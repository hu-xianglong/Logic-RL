[
  {
    "puzzle_id": "simple_3x3_74",
    "puzzle": {
      "id": "simple_3x3_74",
      "title": "Einstein Puzzle simple_3x3_74 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.012376374999999884
      },
      "clues": [
        "the person who plays baseball is the same person as at least one of the person who likes milk or the person who works as a coach",
        "the person who works as a coach is to the right of the person who likes juice (not necessarily immediately)",
        "the person who likes juice is to the left of the person who plays soccer (not necessarily immediately)",
        "the person who likes juice is to the right of the person who works as a police-officer (not necessarily immediately)"
      ],
      "categories": [
        "Beverage",
        "Job",
        "Sport"
      ],
      "items": {
        "Beverage": [
          "milk",
          "juice",
          "almond-milk"
        ],
        "Job": [
          "police-officer",
          "videographer",
          "coach"
        ],
        "Sport": [
          "baseball",
          "swimming",
          "soccer"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"milk\", \"juice\", \"almond-milk\"], \"Job\": [\"police-officer\", \"videographer\", \"coach\"], \"Sport\": [\"baseball\", \"swimming\", \"soccer\"]}"
    },
    "puzzle_hash": "32f0acb7ae4a38ad64948ef5a3d1072e",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Job\", \"Sport\"]\n    items = {\n        \"Beverage\": [\"milk\", \"juice\", \"almond-milk\"],\n        \"Job\": [\"police-officer\", \"videographer\", \"coach\"],\n        \"Sport\": [\"baseball\", \"swimming\", \"soccer\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays baseball is the same person as at least one of the person who likes milk or the person who works as a coach\n    # baseball == milk or baseball == coach\n    problem.addConstraint(\n        lambda baseball, milk, coach: baseball == milk or baseball == coach,\n        [\"Sport:baseball\", \"Beverage:milk\", \"Job:coach\"]\n    )\n    \n    # Clue 2: the person who works as a coach is to the right of the person who likes juice (not necessarily immediately)\n    problem.addConstraint(\n        lambda coach, juice: coach > juice,\n        [\"Job:coach\", \"Beverage:juice\"]\n    )\n    \n    # Clue 3: the person who likes juice is to the left of the person who plays soccer (not necessarily immediately)\n    problem.addConstraint(\n        lambda juice, soccer: juice < soccer,\n        [\"Beverage:juice\", \"Sport:soccer\"]\n    )\n    \n    # Clue 4: the person who likes juice is to the right of the person who works as a police-officer (not necessarily immediately)\n    problem.addConstraint(\n        lambda police, juice: juice > police,\n        [\"Job:police-officer\", \"Beverage:juice\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['milk', 'juice', 'almond-milk'], 'Job': ['police-officer', 'videographer', 'coach'], 'Sport': ['baseball', 'swimming', 'soccer']}\n",
    "success": true,
    "execution_time": 0.00268,
    "timestamp": "20250918_093558",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['milk', 'juice', 'almond-milk'], 'Job': ['police-officer', 'videographer', 'coach'], 'Sport': ['baseball', 'swimming', 'soccer']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_63",
    "puzzle": {
      "id": "simple_3x3_63",
      "title": "Einstein Puzzle simple_3x3_63 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.008190375000000083
      },
      "clues": [
        "the person who works as a manager is at the same position as or to the left of the person who plays weightlifting",
        "the person who plays basketball is adjacent to the person who works as a analyst (either immediately left or right)",
        "the japanese person is at the same position as or to the left of the person who plays cricket",
        "the japanese person is directly between the british person and the person who works as a journalist",
        "the person who works as a journalist and the person who plays weightlifting are at positions with different parity (one at odd, one at even position)"
      ],
      "categories": [
        "Job",
        "Nationality",
        "Sport"
      ],
      "items": {
        "Job": [
          "manager",
          "analyst",
          "journalist"
        ],
        "Nationality": [
          "british",
          "japanese",
          "thai"
        ],
        "Sport": [
          "basketball",
          "weightlifting",
          "cricket"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"manager\", \"analyst\", \"journalist\"], \"Nationality\": [\"british\", \"japanese\", \"thai\"], \"Sport\": [\"basketball\", \"weightlifting\", \"cricket\"]}"
    },
    "puzzle_hash": "3301ac574b0aa8680f74bfff6915d03e",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Nationality\", \"Sport\"]\n    items = {\n        \"Job\": [\"manager\", \"analyst\", \"journalist\"],\n        \"Nationality\": [\"british\", \"japanese\", \"thai\"],\n        \"Sport\": [\"basketball\", \"weightlifting\", \"cricket\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: manager is at the same position as or to the left of weightlifting\n    problem.addConstraint(lambda m, w: m <= w, [\"Job:manager\", \"Sport:weightlifting\"])\n    \n    # Clue 2: basketball is adjacent to analyst (immediately left or right)\n    problem.addConstraint(lambda b, a: abs(b - a) == 1, [\"Sport:basketball\", \"Job:analyst\"])\n    \n    # Clue 3: japanese is at the same position as or to the left of cricket\n    problem.addConstraint(lambda j, c: j <= c, [\"Nationality:japanese\", \"Sport:cricket\"])\n    \n    # Clue 4: japanese is directly between british and journalist\n    # That means japanese position is one more than british and one less than journalist OR vice versa\n    problem.addConstraint(\n        lambda j, b, jo: (j == b + 1 and j == jo - 1) or (j == jo + 1 and j == b - 1),\n        [\"Nationality:japanese\", \"Nationality:british\", \"Job:journalist\"]\n    )\n    \n    # Clue 5: journalist and weightlifting are at positions with different parity\n    problem.addConstraint(lambda jo, w: (jo % 2) != (w % 2), [\"Job:journalist\", \"Sport:weightlifting\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['manager', 'analyst', 'journalist'], 'Nationality': ['british', 'japanese', 'thai'], 'Sport': ['basketball', 'weightlifting', 'cricket']}\n",
    "success": true,
    "execution_time": 0.00302,
    "timestamp": "20250918_093401",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['manager', 'analyst', 'journalist'], 'Nationality': ['british', 'japanese', 'thai'], 'Sport': ['basketball', 'weightlifting', 'cricket']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_65",
    "puzzle": {
      "id": "simple_3x3_65",
      "title": "Einstein Puzzle simple_3x3_65 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.011371457999999945
      },
      "clues": [
        "the person who enjoys sudoku is at the same position as or to the left of the turkish person",
        "the person who enjoys dancing is somewhere between the person who likes satire movies and the german person (not necessarily immediately adjacent)",
        "the turkish person is the same person as the person who enjoys puzzles or the person who likes comedy movies is the same person as the turkish person or both",
        "the german person is to the right of the person who likes comedy movies (not necessarily immediately)"
      ],
      "categories": [
        "Hobby",
        "Movie",
        "Nationality"
      ],
      "items": {
        "Hobby": [
          "sudoku",
          "dancing",
          "puzzles"
        ],
        "Movie": [
          "satire",
          "comedy",
          "documentary"
        ],
        "Nationality": [
          "brazilian",
          "turkish",
          "german"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"sudoku\", \"dancing\", \"puzzles\"], \"Movie\": [\"satire\", \"comedy\", \"documentary\"], \"Nationality\": [\"brazilian\", \"turkish\", \"german\"]}"
    },
    "puzzle_hash": "e6a991fbafa2b153c09a810165096670",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Movie\", \"Nationality\"]\n    items = {\n        \"Hobby\": [\"sudoku\", \"dancing\", \"puzzles\"],\n        \"Movie\": [\"satire\", \"comedy\", \"documentary\"],\n        \"Nationality\": [\"brazilian\", \"turkish\", \"german\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys sudoku is at the same position as or to the left of the turkish person\n    problem.addConstraint(lambda sudoku_pos, turkish_pos: sudoku_pos <= turkish_pos,\n                          [\"Hobby:sudoku\", \"Nationality:turkish\"])\n    \n    # Clue 2: the person who enjoys dancing is somewhere between the person who likes satire movies and the german person (not necessarily immediately adjacent)\n    # This means dancing_pos is strictly between satire_pos and german_pos or vice versa\n    def dancing_between(satire_pos, dancing_pos, german_pos):\n        low = min(satire_pos, german_pos)\n        high = max(satire_pos, german_pos)\n        return low < dancing_pos < high\n    problem.addConstraint(dancing_between, [\"Movie:satire\", \"Hobby:dancing\", \"Nationality:german\"])\n    \n    # Clue 3: the turkish person is the same person as the person who enjoys puzzles or the person who likes comedy movies is the same person as the turkish person or both\n    # This means turkish_pos == puzzles_pos or turkish_pos == comedy_pos or both\n    def clue3(turkish_pos, puzzles_pos, comedy_pos):\n        return turkish_pos == puzzles_pos or turkish_pos == comedy_pos\n    problem.addConstraint(clue3, [\"Nationality:turkish\", \"Hobby:puzzles\", \"Movie:comedy\"])\n    \n    # Clue 4: the german person is to the right of the person who likes comedy movies (not necessarily immediately)\n    problem.addConstraint(lambda german_pos, comedy_pos: german_pos > comedy_pos,\n                          [\"Nationality:german\", \"Movie:comedy\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['sudoku', 'dancing', 'puzzles'], 'Movie': ['satire', 'comedy', 'documentary'], 'Nationality': ['brazilian', 'turkish', 'german']}\n",
    "success": true,
    "execution_time": 0.003023,
    "timestamp": "20250918_093421",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['sudoku', 'dancing', 'puzzles'], 'Movie': ['satire', 'comedy', 'documentary'], 'Nationality': ['brazilian', 'turkish', 'german']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_66",
    "puzzle": {
      "id": "simple_3x3_66",
      "title": "Einstein Puzzle simple_3x3_66 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.014741000000000115
      },
      "clues": [
        "the australian person is a different person than at least one of the person who works as a analyst or the person who likes 7up",
        "the person who works as a videographer is at the same position as or to the right of the australian person",
        "the colombian person is the same person as the person who works as a videographer or the person who likes tea is the same person as the colombian person, but not both",
        "the colombian person is somewhere between the australian person and the person who works as a dancer (not necessarily immediately adjacent)",
        "the person who likes cola and the spanish person are at positions with different parity (one at odd, one at even position)"
      ],
      "categories": [
        "Beverage",
        "Job",
        "Nationality"
      ],
      "items": {
        "Beverage": [
          "tea",
          "cola",
          "7up"
        ],
        "Job": [
          "analyst",
          "videographer",
          "dancer"
        ],
        "Nationality": [
          "australian",
          "colombian",
          "spanish"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"tea\", \"cola\", \"7up\"], \"Job\": [\"analyst\", \"videographer\", \"dancer\"], \"Nationality\": [\"australian\", \"colombian\", \"spanish\"]}"
    },
    "puzzle_hash": "75f30c828c46bd1432d19525d9e80c97",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Job\", \"Nationality\"]\n    items = {\n        \"Beverage\": [\"tea\", \"cola\", \"7up\"],\n        \"Job\": [\"analyst\", \"videographer\", \"dancer\"],\n        \"Nationality\": [\"australian\", \"colombian\", \"spanish\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1:\n    # the australian person is a different person than at least one of the person who works as a analyst or the person who likes 7up\n    # That means: australian != analyst OR australian != 7up\n    # We model this as a constraint that enforces at least one difference\n    def clue1(aus, ana, sev):\n        return aus != ana or aus != sev\n    problem.addConstraint(clue1, [\"Nationality:australian\", \"Job:analyst\", \"Beverage:7up\"])\n    \n    # Clue 2:\n    # the person who works as a videographer is at the same position as or to the right of the australian person\n    problem.addConstraint(lambda vid, aus: vid >= aus, [\"Job:videographer\", \"Nationality:australian\"])\n    \n    # Clue 3:\n    # the colombian person is the same person as the person who works as a videographer or the person who likes tea is the same person as the colombian person, but not both\n    # XOR condition: (colombian == videographer) != (tea == colombian)\n    def clue3(col, vid, tea):\n        return (col == vid) != (tea == col)\n    problem.addConstraint(clue3, [\"Nationality:colombian\", \"Job:videographer\", \"Beverage:tea\"])\n    \n    # Clue 4:\n    # the colombian person is somewhere between the australian person and the person who works as a dancer (not necessarily immediately adjacent)\n    # So colombian position is strictly between australian and dancer positions\n    def clue4(col, aus, dan):\n        return (aus < col < dan) or (dan < col < aus)\n    problem.addConstraint(clue4, [\"Nationality:colombian\", \"Nationality:australian\", \"Job:dancer\"])\n    \n    # Clue 5:\n    # the person who likes cola and the spanish person are at positions with different parity (one at odd, one at even position)\n    problem.addConstraint(lambda cola, spa: (cola % 2) != (spa % 2), [\"Beverage:cola\", \"Nationality:spanish\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['tea', 'cola', '7up'], 'Job': ['analyst', 'videographer', 'dancer'], 'Nationality': ['australian', 'colombian', 'spanish']}\n",
    "success": true,
    "execution_time": 0.003028,
    "timestamp": "20250918_093436",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['tea', 'cola', '7up'], 'Job': ['analyst', 'videographer', 'dancer'], 'Nationality': ['australian', 'colombian', 'spanish']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_35",
    "puzzle": {
      "id": "simple_3x3_35",
      "title": "Einstein Puzzle simple_3x3_35 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.030195042000000005
      },
      "clues": [
        "the person who likes romance movies is to the left of the person who enjoys video-games (not necessarily immediately)",
        "the person who uses subway for transportation is to the left of the person who uses bike for transportation (not necessarily immediately)",
        "the person who likes animation movies is the same person as the person who enjoys cooking or the person who uses bike for transportation is the same person as the person who likes animation movies, but not both",
        "the person who likes romance movies is at the same position as or to the right of the person who uses bike for transportation"
      ],
      "categories": [
        "Hobby",
        "Movie",
        "Transport"
      ],
      "items": {
        "Hobby": [
          "cooking",
          "traveling",
          "video-games"
        ],
        "Movie": [
          "animation",
          "romance",
          "horror"
        ],
        "Transport": [
          "subway",
          "bike",
          "van"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"cooking\", \"traveling\", \"video-games\"], \"Movie\": [\"animation\", \"romance\", \"horror\"], \"Transport\": [\"subway\", \"bike\", \"van\"]}"
    },
    "puzzle_hash": "60863c11cbbebada1a020e2094cbc717",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Movie\", \"Transport\"]\n    items = {\n        \"Hobby\": [\"cooking\", \"traveling\", \"video-games\"],\n        \"Movie\": [\"animation\", \"romance\", \"horror\"],\n        \"Transport\": [\"subway\", \"bike\", \"van\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes romance movies is to the left of the person who enjoys video-games (not necessarily immediately)\n    problem.addConstraint(lambda romance_pos, videogames_pos: romance_pos < videogames_pos,\n                          [\"Movie:romance\", \"Hobby:video-games\"])\n    \n    # Clue 2: the person who uses subway for transportation is to the left of the person who uses bike for transportation (not necessarily immediately)\n    problem.addConstraint(lambda subway_pos, bike_pos: subway_pos < bike_pos,\n                          [\"Transport:subway\", \"Transport:bike\"])\n    \n    # Clue 3: the person who likes animation movies is the same person as the person who enjoys cooking or the person who uses bike for transportation is the same person as the person who likes animation movies, but not both\n    # This means exactly one of these is true:\n    # (Movie:animation == Hobby:cooking) XOR (Transport:bike == Movie:animation)\n    def clue3(animation_pos, cooking_pos, bike_pos):\n        first = (animation_pos == cooking_pos)\n        second = (bike_pos == animation_pos)\n        return (first != second)\n    problem.addConstraint(clue3, [\"Movie:animation\", \"Hobby:cooking\", \"Transport:bike\"])\n    \n    # Clue 4: the person who likes romance movies is at the same position as or to the right of the person who uses bike for transportation\n    problem.addConstraint(lambda romance_pos, bike_pos: romance_pos >= bike_pos,\n                          [\"Movie:romance\", \"Transport:bike\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['cooking', 'traveling', 'video-games'], 'Movie': ['animation', 'romance', 'horror'], 'Transport': ['subway', 'bike', 'van']}\n",
    "success": true,
    "execution_time": 0.0028,
    "timestamp": "20250918_092929",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['cooking', 'traveling', 'video-games'], 'Movie': ['animation', 'romance', 'horror'], 'Transport': ['subway', 'bike', 'van']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_27",
    "puzzle": {
      "id": "simple_3x3_27",
      "title": "Einstein Puzzle simple_3x3_27 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.014838916999999952
      },
      "clues": [
        "the person who enjoys fishing is directly between the person who has hedgehog as a pet and the person who plays water-polo",
        "the person who plays badminton is to the right of the person who enjoys magic-tricks (not necessarily immediately)",
        "the person who plays water-polo is a different person than the person who enjoys magic-tricks",
        "the person who enjoys fishing and the person who has goldfish as a pet are at positions with different parity (one at odd, one at even position)"
      ],
      "categories": [
        "Hobby",
        "Pet",
        "Sport"
      ],
      "items": {
        "Hobby": [
          "magic-tricks",
          "fishing",
          "reading"
        ],
        "Pet": [
          "hedgehog",
          "frog",
          "goldfish"
        ],
        "Sport": [
          "ice-hockey",
          "badminton",
          "water-polo"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"magic-tricks\", \"fishing\", \"reading\"], \"Pet\": [\"hedgehog\", \"frog\", \"goldfish\"], \"Sport\": [\"ice-hockey\", \"badminton\", \"water-polo\"]}"
    },
    "puzzle_hash": "7fe830fa4643a41eb6634e48bfa26367",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Pet\", \"Sport\"]\n    items = {\n        \"Hobby\": [\"magic-tricks\", \"fishing\", \"reading\"],\n        \"Pet\": [\"hedgehog\", \"frog\", \"goldfish\"],\n        \"Sport\": [\"ice-hockey\", \"badminton\", \"water-polo\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys fishing is directly between the person who has hedgehog as a pet and the person who plays water-polo\n    problem.addConstraint(\n        lambda fishing, hedgehog, waterpolo: (fishing == hedgehog + 1 and fishing == waterpolo - 1) or (fishing == waterpolo + 1 and fishing == hedgehog - 1),\n        [\"Hobby:fishing\", \"Pet:hedgehog\", \"Sport:water-polo\"]\n    )\n    \n    # Clue 2: the person who plays badminton is to the right of the person who enjoys magic-tricks (not necessarily immediately)\n    problem.addConstraint(\n        lambda badminton, magic: badminton > magic,\n        [\"Sport:badminton\", \"Hobby:magic-tricks\"]\n    )\n    \n    # Clue 3: the person who plays water-polo is a different person than the person who enjoys magic-tricks\n    problem.addConstraint(\n        lambda waterpolo, magic: waterpolo != magic,\n        [\"Sport:water-polo\", \"Hobby:magic-tricks\"]\n    )\n    \n    # Clue 4: the person who enjoys fishing and the person who has goldfish as a pet are at positions with different parity (one at odd, one at even position)\n    problem.addConstraint(\n        lambda fishing, goldfish: (fishing % 2) != (goldfish % 2),\n        [\"Hobby:fishing\", \"Pet:goldfish\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['magic-tricks', 'fishing', 'reading'], 'Pet': ['hedgehog', 'frog', 'goldfish'], 'Sport': ['ice-hockey', 'badminton', 'water-polo']}\n",
    "success": true,
    "execution_time": 0.002842,
    "timestamp": "20250918_092801",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['magic-tricks', 'fishing', 'reading'], 'Pet': ['hedgehog', 'frog', 'goldfish'], 'Sport': ['ice-hockey', 'badminton', 'water-polo']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_2",
    "puzzle": {
      "id": "simple_3x3_2",
      "title": "Einstein Puzzle simple_3x3_2 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.021511416999999998
      },
      "clues": [
        "the person who likes funk music and the person who likes thriller movies are at positions with the same parity (both at odd or both at even positions)",
        "the person who likes action movies is to the right of the person who likes crime movies (not necessarily immediately)",
        "the person who has frog as a pet and the person who likes indie music are at positions with the same parity (both at odd or both at even positions)",
        "the person who likes funk music is directly between the person who likes action movies and the person who likes jazz music",
        "the person who likes action movies is at the same position as or to the left of the person who has ferret as a pet"
      ],
      "categories": [
        "Movie",
        "Music",
        "Pet"
      ],
      "items": {
        "Movie": [
          "crime",
          "thriller",
          "action"
        ],
        "Music": [
          "jazz",
          "funk",
          "indie"
        ],
        "Pet": [
          "frog",
          "rat",
          "ferret"
        ]
      },
      "ground_truth_solution": "{\"Movie\": [\"crime\", \"thriller\", \"action\"], \"Music\": [\"jazz\", \"funk\", \"indie\"], \"Pet\": [\"frog\", \"rat\", \"ferret\"]}"
    },
    "puzzle_hash": "6f681e9e549916c369d06af7871930a7",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Music\", \"Pet\"]\n    items = {\n        \"Movie\": [\"crime\", \"thriller\", \"action\"],\n        \"Music\": [\"jazz\", \"funk\", \"indie\"],\n        \"Pet\": [\"frog\", \"rat\", \"ferret\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: funk music and thriller movies same parity\n    problem.addConstraint(\n        lambda funk, thriller: funk % 2 == thriller % 2,\n        [\"Music:funk\", \"Movie:thriller\"]\n    )\n    \n    # Clue 2: action movies to the right of crime movies\n    problem.addConstraint(\n        lambda action, crime: action > crime,\n        [\"Movie:action\", \"Movie:crime\"]\n    )\n    \n    # Clue 3: frog pet and indie music same parity\n    problem.addConstraint(\n        lambda frog, indie: frog % 2 == indie % 2,\n        [\"Pet:frog\", \"Music:indie\"]\n    )\n    \n    # Clue 4: funk music directly between action movies and jazz music\n    problem.addConstraint(\n        lambda funk, action, jazz: (funk == action + 1 and funk == jazz - 1) or (funk == jazz + 1 and funk == action - 1),\n        [\"Music:funk\", \"Movie:action\", \"Music:jazz\"]\n    )\n    \n    # Clue 5: action movies same position or to the left of ferret pet\n    problem.addConstraint(\n        lambda action, ferret: action <= ferret,\n        [\"Movie:action\", \"Pet:ferret\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Movie': ['crime', 'thriller', 'action'], 'Music': ['jazz', 'funk', 'indie'], 'Pet': ['frog', 'rat', 'ferret']}\n",
    "success": true,
    "execution_time": 0.002686,
    "timestamp": "20250918_092331",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Movie': ['crime', 'thriller', 'action'], 'Music': ['jazz', 'funk', 'indie'], 'Pet': ['frog', 'rat', 'ferret']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_71",
    "puzzle": {
      "id": "simple_3x3_71",
      "title": "Einstein Puzzle simple_3x3_71 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.023846582999999866
      },
      "clues": [
        "the british person is at the same position as or to the left of the person who works as a musician",
        "the person who enjoys magic-tricks is at the same position as or to the right of the australian person",
        "the person who works as a teacher is the same person as at least one of the person who enjoys magic-tricks or the turkish person",
        "the australian person is at the same position as or to the right of the person who enjoys chess",
        "the person who works as a entrepreneur is the same person as the person who enjoys drawing or the person who enjoys drawing is the same person as the british person or both",
        "the person who works as a musician is directly between the turkish person and the british person"
      ],
      "categories": [
        "Hobby",
        "Job",
        "Nationality"
      ],
      "items": {
        "Hobby": [
          "drawing",
          "chess",
          "magic-tricks"
        ],
        "Job": [
          "entrepreneur",
          "musician",
          "teacher"
        ],
        "Nationality": [
          "british",
          "australian",
          "turkish"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"drawing\", \"chess\", \"magic-tricks\"], \"Job\": [\"entrepreneur\", \"musician\", \"teacher\"], \"Nationality\": [\"british\", \"australian\", \"turkish\"]}"
    },
    "puzzle_hash": "ffd3b63a5b763f04c950c7dba97c8d72",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Job\", \"Nationality\"]\n    items = {\n        \"Hobby\": [\"drawing\", \"chess\", \"magic-tricks\"],\n        \"Job\": [\"entrepreneur\", \"musician\", \"teacher\"],\n        \"Nationality\": [\"british\", \"australian\", \"turkish\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the british person is at the same position as or to the left of the person who works as a musician\n    problem.addConstraint(lambda british, musician: british <= musician,\n                          [\"Nationality:british\", \"Job:musician\"])\n    \n    # Clue 2: the person who enjoys magic-tricks is at the same position as or to the right of the australian person\n    problem.addConstraint(lambda magic, australian: magic >= australian,\n                          [\"Hobby:magic-tricks\", \"Nationality:australian\"])\n    \n    # Clue 3: the person who works as a teacher is the same person as at least one of the person who enjoys magic-tricks or the turkish person\n    # teacher == magic-tricks or teacher == turkish\n    def teacher_magic_turkish_constraint(teacher, magic, turkish):\n        return teacher == magic or teacher == turkish\n    problem.addConstraint(teacher_magic_turkish_constraint,\n                          [\"Job:teacher\", \"Hobby:magic-tricks\", \"Nationality:turkish\"])\n    \n    # Clue 4: the australian person is at the same position as or to the right of the person who enjoys chess\n    problem.addConstraint(lambda australian, chess: australian >= chess,\n                          [\"Nationality:australian\", \"Hobby:chess\"])\n    \n    # Clue 5: the person who works as a entrepreneur is the same person as the person who enjoys drawing or the person who enjoys drawing is the same person as the british person or both\n    # entrepreneur == drawing or drawing == british or both\n    def entrepreneur_drawing_british_constraint(entrepreneur, drawing, british):\n        return entrepreneur == drawing or drawing == british\n    problem.addConstraint(entrepreneur_drawing_british_constraint,\n                          [\"Job:entrepreneur\", \"Hobby:drawing\", \"Nationality:british\"])\n    \n    # Clue 6: the person who works as a musician is directly between the turkish person and the british person\n    # musician is between turkish and british: musician == turkish +1 and musician == british -1 or musician == turkish -1 and musician == british +1\n    def musician_between_turkish_british(musician, turkish, british):\n        return (musician == turkish + 1 and musician == british - 1) or (musician == turkish - 1 and musician == british + 1)\n    problem.addConstraint(musician_between_turkish_british,\n                          [\"Job:musician\", \"Nationality:turkish\", \"Nationality:british\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['drawing', 'chess', 'magic-tricks'], 'Job': ['entrepreneur', 'musician', 'teacher'], 'Nationality': ['british', 'australian', 'turkish']}\n",
    "success": true,
    "execution_time": 0.002942,
    "timestamp": "20250918_093530",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['drawing', 'chess', 'magic-tricks'], 'Job': ['entrepreneur', 'musician', 'teacher'], 'Nationality': ['british', 'australian', 'turkish']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_16",
    "puzzle": {
      "id": "simple_3x3_16",
      "title": "Einstein Puzzle simple_3x3_16 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.014278958000000008
      },
      "clues": [
        "the person who works as a engineer is somewhere between the person who works as a teacher and the american person (not necessarily immediately adjacent)",
        "the british person is to the right of the spanish person (not necessarily immediately)",
        "the spanish person and the person who works as a teacher are at positions with different parity (one at odd, one at even position)",
        "the person who likes blues music is somewhere between the person who likes electronic music and the person who likes funk music (not necessarily immediately adjacent)",
        "the person who likes funk music is to the left of the person who likes blues music (not necessarily immediately)"
      ],
      "categories": [
        "Job",
        "Music",
        "Nationality"
      ],
      "items": {
        "Job": [
          "project-manager",
          "engineer",
          "teacher"
        ],
        "Music": [
          "funk",
          "blues",
          "electronic"
        ],
        "Nationality": [
          "american",
          "spanish",
          "british"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"project-manager\", \"engineer\", \"teacher\"], \"Music\": [\"funk\", \"blues\", \"electronic\"], \"Nationality\": [\"american\", \"spanish\", \"british\"]}"
    },
    "puzzle_hash": "073ebd898eb4d0f19f5adf73f7b08627",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Music\", \"Nationality\"]\n    items = {\n        \"Job\": [\"project-manager\", \"engineer\", \"teacher\"],\n        \"Music\": [\"funk\", \"blues\", \"electronic\"],\n        \"Nationality\": [\"american\", \"spanish\", \"british\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who works as a engineer is somewhere between the person who works as a teacher and the american person (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda engineer, teacher, american:\n            (teacher < engineer < american) or (american < engineer < teacher),\n        [\"Job:engineer\", \"Job:teacher\", \"Nationality:american\"]\n    )\n    \n    # Clue 2: the british person is to the right of the spanish person (not necessarily immediately)\n    problem.addConstraint(\n        lambda british, spanish: british > spanish,\n        [\"Nationality:british\", \"Nationality:spanish\"]\n    )\n    \n    # Clue 3: the spanish person and the person who works as a teacher are at positions with different parity (one at odd, one at even position)\n    problem.addConstraint(\n        lambda spanish, teacher: (spanish % 2) != (teacher % 2),\n        [\"Nationality:spanish\", \"Job:teacher\"]\n    )\n    \n    # Clue 4: the person who likes blues music is somewhere between the person who likes electronic music and the person who likes funk music (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda blues, electronic, funk:\n            (electronic < blues < funk) or (funk < blues < electronic),\n        [\"Music:blues\", \"Music:electronic\", \"Music:funk\"]\n    )\n    \n    # Clue 5: the person who likes funk music is to the left of the person who likes blues music (not necessarily immediately)\n    problem.addConstraint(\n        lambda funk, blues: funk < blues,\n        [\"Music:funk\", \"Music:blues\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['project-manager', 'engineer', 'teacher'], 'Music': ['funk', 'blues', 'electronic'], 'Nationality': ['american', 'spanish', 'british']}\n",
    "success": true,
    "execution_time": 0.002957,
    "timestamp": "20250918_092610",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['project-manager', 'engineer', 'teacher'], 'Music': ['funk', 'blues', 'electronic'], 'Nationality': ['american', 'spanish', 'british']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_64",
    "puzzle": {
      "id": "simple_3x3_64",
      "title": "Einstein Puzzle simple_3x3_64 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.013353583000000002
      },
      "clues": [
        "the person who likes sprite is to the right of the person who plays soccer (not necessarily immediately)",
        "the person who likes milk is the same person as the person who plays surfing or the person who likes apple is the same person as the person who likes milk, but not both",
        "the person who likes apple is adjacent to the person who likes blueberry (either immediately left or right)",
        "the person who likes sprite is to the left of the person who likes apple (not necessarily immediately)"
      ],
      "categories": [
        "Beverage",
        "Food",
        "Sport"
      ],
      "items": {
        "Beverage": [
          "almond-milk",
          "sprite",
          "milk"
        ],
        "Food": [
          "nectarine",
          "blueberry",
          "apple"
        ],
        "Sport": [
          "soccer",
          "surfing",
          "golf"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"almond-milk\", \"sprite\", \"milk\"], \"Food\": [\"nectarine\", \"blueberry\", \"apple\"], \"Sport\": [\"soccer\", \"surfing\", \"golf\"]}"
    },
    "puzzle_hash": "a97497da19141c5bc24ce4520168bc11",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Food\", \"Sport\"]\n    items = {\n        \"Beverage\": [\"almond-milk\", \"sprite\", \"milk\"],\n        \"Food\": [\"nectarine\", \"blueberry\", \"apple\"],\n        \"Sport\": [\"soccer\", \"surfing\", \"golf\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes sprite is to the right of the person who plays soccer (not necessarily immediately)\n    problem.addConstraint(lambda sprite, soccer: sprite > soccer, [\"Beverage:sprite\", \"Sport:soccer\"])\n    \n    # Clue 2: the person who likes milk is the same person as the person who plays surfing or the person who likes apple is the same person as the person who likes milk, but not both\n    # (milk == surfing) XOR (apple == milk)\n    def clue2(milk, surfing, apple):\n        return (milk == surfing) != (apple == milk)\n    problem.addConstraint(clue2, [\"Beverage:milk\", \"Sport:surfing\", \"Food:apple\"])\n    \n    # Clue 3: the person who likes apple is adjacent to the person who likes blueberry (either immediately left or right)\n    problem.addConstraint(lambda apple, blueberry: abs(apple - blueberry) == 1, [\"Food:apple\", \"Food:blueberry\"])\n    \n    # Clue 4: the person who likes sprite is to the left of the person who likes apple (not necessarily immediately)\n    problem.addConstraint(lambda sprite, apple: sprite < apple, [\"Beverage:sprite\", \"Food:apple\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['almond-milk', 'sprite', 'milk'], 'Food': ['nectarine', 'blueberry', 'apple'], 'Sport': ['soccer', 'surfing', 'golf']}\n",
    "success": true,
    "execution_time": 0.002861,
    "timestamp": "20250918_093409",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['almond-milk', 'sprite', 'milk'], 'Food': ['nectarine', 'blueberry', 'apple'], 'Sport': ['soccer', 'surfing', 'golf']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_20",
    "puzzle": {
      "id": "simple_3x3_20",
      "title": "Einstein Puzzle simple_3x3_20 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.018228291000000008
      },
      "clues": [
        "the person who works as a coach is to the left of the person who likes water (not necessarily immediately)",
        "the person who uses motorbike for transportation is to the right of the person who likes sprite (not necessarily immediately)",
        "the person who works as a videographer is somewhere between the person who uses van for transportation and the person who uses motorbike for transportation (not necessarily immediately adjacent)",
        "the person who uses van for transportation is adjacent to the person who likes milk (either immediately left or right)"
      ],
      "categories": [
        "Beverage",
        "Job",
        "Transport"
      ],
      "items": {
        "Beverage": [
          "sprite",
          "milk",
          "water"
        ],
        "Job": [
          "coach",
          "videographer",
          "firefighter"
        ],
        "Transport": [
          "van",
          "taxi",
          "motorbike"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"sprite\", \"milk\", \"water\"], \"Job\": [\"coach\", \"videographer\", \"firefighter\"], \"Transport\": [\"van\", \"taxi\", \"motorbike\"]}"
    },
    "puzzle_hash": "9b06a8c293ba30638e0f421bdfc53d1d",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Job\", \"Transport\"]\n    items = {\n        \"Beverage\": [\"sprite\", \"milk\", \"water\"],\n        \"Job\": [\"coach\", \"videographer\", \"firefighter\"],\n        \"Transport\": [\"van\", \"taxi\", \"motorbike\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: coach is to the left of water (not necessarily immediately)\n    problem.addConstraint(lambda coach, water: coach < water, [\"Job:coach\", \"Beverage:water\"])\n    \n    # Clue 2: motorbike is to the right of sprite (not necessarily immediately)\n    problem.addConstraint(lambda sprite, motorbike: sprite < motorbike, [\"Beverage:sprite\", \"Transport:motorbike\"])\n    \n    # Clue 3: videographer is somewhere between van and motorbike (not necessarily adjacent)\n    # means videographer position is strictly between van and motorbike positions\n    def between(videographer, van, motorbike):\n        return (van < videographer < motorbike) or (motorbike < videographer < van)\n    problem.addConstraint(between, [\"Job:videographer\", \"Transport:van\", \"Transport:motorbike\"])\n    \n    # Clue 4: van is adjacent to milk (immediately left or right)\n    problem.addConstraint(lambda van, milk: abs(van - milk) == 1, [\"Transport:van\", \"Beverage:milk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['sprite', 'milk', 'water'], 'Job': ['coach', 'videographer', 'firefighter'], 'Transport': ['van', 'taxi', 'motorbike']}\n",
    "success": true,
    "execution_time": 0.002808,
    "timestamp": "20250918_092651",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['sprite', 'milk', 'water'], 'Job': ['coach', 'videographer', 'firefighter'], 'Transport': ['van', 'taxi', 'motorbike']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_11",
    "puzzle": {
      "id": "simple_3x3_11",
      "title": "Einstein Puzzle simple_3x3_11 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.02000358400000002
      },
      "clues": [
        "the canadian person is at the same position as or to the right of the person who likes soy-milk",
        "the person who uses van for transportation is to the left of the person who uses bus for transportation (not necessarily immediately)",
        "the colombian person is the same person as the person who likes soy-milk or the person who likes soy-milk is the same person as the person who uses bus for transportation, but not both",
        "the person who uses bus for transportation is somewhere between the person who likes soy-milk and the egyptian person (not necessarily immediately adjacent)",
        "the person who likes mirinda and the colombian person are at positions with different parity (one at odd, one at even position)"
      ],
      "categories": [
        "Beverage",
        "Nationality",
        "Transport"
      ],
      "items": {
        "Beverage": [
          "soy-milk",
          "mirinda",
          "milk"
        ],
        "Nationality": [
          "colombian",
          "canadian",
          "egyptian"
        ],
        "Transport": [
          "van",
          "bus",
          "boat"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"soy-milk\", \"mirinda\", \"milk\"], \"Nationality\": [\"colombian\", \"canadian\", \"egyptian\"], \"Transport\": [\"van\", \"bus\", \"boat\"]}"
    },
    "puzzle_hash": "e63152ff19d86545025c3d5b6503636a",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Nationality\", \"Transport\"]\n    items = {\n        \"Beverage\": [\"soy-milk\", \"mirinda\", \"milk\"],\n        \"Nationality\": [\"colombian\", \"canadian\", \"egyptian\"],\n        \"Transport\": [\"van\", \"bus\", \"boat\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the canadian person is at the same position as or to the right of the person who likes soy-milk\n    problem.addConstraint(lambda c, s: c >= s, [\"Nationality:canadian\", \"Beverage:soy-milk\"])\n    \n    # Clue 2: the person who uses van for transportation is to the left of the person who uses bus for transportation (not necessarily immediately)\n    problem.addConstraint(lambda v, b: v < b, [\"Transport:van\", \"Transport:bus\"])\n    \n    # Clue 3: the colombian person is the same person as the person who likes soy-milk or the person who likes soy-milk is the same person as the person who uses bus for transportation, but not both\n    # (X == Y) XOR (Y == Z)\n    def clue3(col, soy, bus):\n        return (col == soy) != (soy == bus)\n    problem.addConstraint(clue3, [\"Nationality:colombian\", \"Beverage:soy-milk\", \"Transport:bus\"])\n    \n    # Clue 4: the person who uses bus for transportation is somewhere between the person who likes soy-milk and the egyptian person (not necessarily immediately adjacent)\n    # bus position is strictly between soy-milk and egyptian positions\n    def clue4(bus, soy, egy):\n        return (soy < bus < egy) or (egy < bus < soy)\n    problem.addConstraint(clue4, [\"Transport:bus\", \"Beverage:soy-milk\", \"Nationality:egyptian\"])\n    \n    # Clue 5: the person who likes mirinda and the colombian person are at positions with different parity (one at odd, one at even position)\n    problem.addConstraint(lambda m, c: (m % 2) != (c % 2), [\"Beverage:mirinda\", \"Nationality:colombian\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['soy-milk', 'mirinda', 'milk'], 'Nationality': ['colombian', 'canadian', 'egyptian'], 'Transport': ['van', 'bus', 'boat']}\n",
    "success": true,
    "execution_time": 0.002764,
    "timestamp": "20250918_092514",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['soy-milk', 'mirinda', 'milk'], 'Nationality': ['colombian', 'canadian', 'egyptian'], 'Transport': ['van', 'bus', 'boat']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_56",
    "puzzle": {
      "id": "simple_3x3_56",
      "title": "Einstein Puzzle simple_3x3_56 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.009337624999999905
      },
      "clues": [
        "the person who likes techno music is to the left of the person who likes scientific movies (not necessarily immediately)",
        "the person who likes house music is directly between the person who likes satire movies and the person who likes jazz music",
        "the person who likes satire movies and the german person are at positions with the same parity (both at odd or both at even positions)",
        "the person who likes scientific movies is directly between the turkish person and the person who likes satire movies"
      ],
      "categories": [
        "Movie",
        "Music",
        "Nationality"
      ],
      "items": {
        "Movie": [
          "satire",
          "scientific",
          "action"
        ],
        "Music": [
          "techno",
          "house",
          "jazz"
        ],
        "Nationality": [
          "german",
          "malaysian",
          "turkish"
        ]
      },
      "ground_truth_solution": "{\"Movie\": [\"satire\", \"scientific\", \"action\"], \"Music\": [\"techno\", \"house\", \"jazz\"], \"Nationality\": [\"german\", \"malaysian\", \"turkish\"]}"
    },
    "puzzle_hash": "4c9c566cf2d211da98f2ae57cdf94ab0",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Music\", \"Nationality\"]\n    items = {\n        \"Movie\": [\"satire\", \"scientific\", \"action\"],\n        \"Music\": [\"techno\", \"house\", \"jazz\"],\n        \"Nationality\": [\"german\", \"malaysian\", \"turkish\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes techno music is to the left of the person who likes scientific movies (not necessarily immediately)\n    problem.addConstraint(lambda techno, scientific: techno < scientific, [\"Music:techno\", \"Movie:scientific\"])\n    \n    # Clue 2: the person who likes house music is directly between the person who likes satire movies and the person who likes jazz music\n    problem.addConstraint(\n        lambda house, satire, jazz: (house == satire + 1 and house == jazz - 1) or (house == jazz + 1 and house == satire - 1),\n        [\"Music:house\", \"Movie:satire\", \"Music:jazz\"]\n    )\n    \n    # Clue 3: the person who likes satire movies and the german person are at positions with the same parity (both at odd or both at even positions)\n    problem.addConstraint(lambda satire, german: satire % 2 == german % 2, [\"Movie:satire\", \"Nationality:german\"])\n    \n    # Clue 4: the person who likes scientific movies is directly between the turkish person and the person who likes satire movies\n    problem.addConstraint(\n        lambda scientific, turkish, satire: (scientific == turkish + 1 and scientific == satire - 1) or (scientific == satire + 1 and scientific == turkish - 1),\n        [\"Movie:scientific\", \"Nationality:turkish\", \"Movie:satire\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Movie': ['satire', 'scientific', 'action'], 'Music': ['techno', 'house', 'jazz'], 'Nationality': ['german', 'malaysian', 'turkish']}\n",
    "success": true,
    "execution_time": 0.002912,
    "timestamp": "20250918_093249",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Movie': ['satire', 'scientific', 'action'], 'Music': ['techno', 'house', 'jazz'], 'Nationality': ['german', 'malaysian', 'turkish']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_77",
    "puzzle": {
      "id": "simple_3x3_77",
      "title": "Einstein Puzzle simple_3x3_77 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.02993237500000001
      },
      "clues": [
        "the person who plays rugby is at the same position as or to the left of the person who plays swimming",
        "the person who likes tea is a different person than the person who uses bus for transportation or the person who plays parkour is a different person than the person who likes tea or both",
        "the person who plays rugby and the person who likes sprite are at positions with the same parity (both at odd or both at even positions)",
        "the person who uses car for transportation is somewhere between the person who likes milk and the person who likes tea (not necessarily immediately adjacent)",
        "the person who plays rugby is to the left of the person who likes milk (not necessarily immediately)"
      ],
      "categories": [
        "Beverage",
        "Sport",
        "Transport"
      ],
      "items": {
        "Beverage": [
          "tea",
          "sprite",
          "milk"
        ],
        "Sport": [
          "parkour",
          "rugby",
          "swimming"
        ],
        "Transport": [
          "skateboard",
          "car",
          "bus"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"tea\", \"sprite\", \"milk\"], \"Sport\": [\"parkour\", \"rugby\", \"swimming\"], \"Transport\": [\"skateboard\", \"car\", \"bus\"]}"
    },
    "puzzle_hash": "b49dd2f8b4c16439e7cf54795d1a750e",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Sport\", \"Transport\"]\n    items = {\n        \"Beverage\": [\"tea\", \"sprite\", \"milk\"],\n        \"Sport\": [\"parkour\", \"rugby\", \"swimming\"],\n        \"Transport\": [\"skateboard\", \"car\", \"bus\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays rugby is at the same position as or to the left of the person who plays swimming\n    problem.addConstraint(lambda rugby, swimming: rugby <= swimming,\n                          [\"Sport:rugby\", \"Sport:swimming\"])\n    \n    # Clue 2: the person who likes tea is a different person than the person who uses bus for transportation or the person who plays parkour is a different person than the person who likes tea or both\n    # This means: (tea != bus) OR (parkour != tea)\n    # To model OR, we use a custom constraint that returns True if either condition is True\n    def clue2(tea, bus, parkour):\n        return (tea != bus) or (parkour != tea)\n    problem.addConstraint(clue2, [\"Beverage:tea\", \"Transport:bus\", \"Sport:parkour\"])\n    \n    # Clue 3: the person who plays rugby and the person who likes sprite are at positions with the same parity (both at odd or both at even positions)\n    problem.addConstraint(lambda rugby, sprite: rugby % 2 == sprite % 2,\n                          [\"Sport:rugby\", \"Beverage:sprite\"])\n    \n    # Clue 4: the person who uses car for transportation is somewhere between the person who likes milk and the person who likes tea (not necessarily immediately adjacent)\n    # So car position is strictly between milk and tea positions\n    def clue4(car, milk, tea):\n        return (milk < car < tea) or (tea < car < milk)\n    problem.addConstraint(clue4, [\"Transport:car\", \"Beverage:milk\", \"Beverage:tea\"])\n    \n    # Clue 5: the person who plays rugby is to the left of the person who likes milk (not necessarily immediately)\n    problem.addConstraint(lambda rugby, milk: rugby < milk,\n                          [\"Sport:rugby\", \"Beverage:milk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['tea', 'sprite', 'milk'], 'Sport': ['parkour', 'rugby', 'swimming'], 'Transport': ['skateboard', 'car', 'bus']}\n",
    "success": true,
    "execution_time": 0.002136,
    "timestamp": "20250918_093630",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['tea', 'sprite', 'milk'], 'Sport': ['parkour', 'rugby', 'swimming'], 'Transport': ['skateboard', 'car', 'bus']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_54",
    "puzzle": {
      "id": "simple_3x3_54",
      "title": "Einstein Puzzle simple_3x3_54 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.02118262500000001
      },
      "clues": [
        "the person who plays golf is a different person than the german person",
        "the person who plays golf is to the right of the person who plays skiing (not necessarily immediately)",
        "the german person is at the same position as or to the right of the chinese person",
        "the chinese person is directly between the person who likes pomegranate and the person who likes pumpkin",
        "the person who likes pumpkin is a different person than the australian person"
      ],
      "categories": [
        "Food",
        "Nationality",
        "Sport"
      ],
      "items": {
        "Food": [
          "pomegranate",
          "pear",
          "pumpkin"
        ],
        "Nationality": [
          "australian",
          "chinese",
          "german"
        ],
        "Sport": [
          "skiing",
          "golf",
          "biathlon"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"pomegranate\", \"pear\", \"pumpkin\"], \"Nationality\": [\"australian\", \"chinese\", \"german\"], \"Sport\": [\"skiing\", \"golf\", \"biathlon\"]}"
    },
    "puzzle_hash": "141eb9fce813d79d68980c134c9867c1",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Nationality\", \"Sport\"]\n    items = {\n        \"Food\": [\"pomegranate\", \"pear\", \"pumpkin\"],\n        \"Nationality\": [\"australian\", \"chinese\", \"german\"],\n        \"Sport\": [\"skiing\", \"golf\", \"biathlon\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays golf is a different person than the german person\n    problem.addConstraint(lambda golf, german: golf != german,\n                          [\"Sport:golf\", \"Nationality:german\"])\n    \n    # Clue 2: the person who plays golf is to the right of the person who plays skiing (not necessarily immediately)\n    problem.addConstraint(lambda golf, skiing: golf > skiing,\n                          [\"Sport:golf\", \"Sport:skiing\"])\n    \n    # Clue 3: the german person is at the same position as or to the right of the chinese person\n    problem.addConstraint(lambda german, chinese: german >= chinese,\n                          [\"Nationality:german\", \"Nationality:chinese\"])\n    \n    # Clue 4: the chinese person is directly between the person who likes pomegranate and the person who likes pumpkin\n    problem.addConstraint(lambda chinese, pomegranate, pumpkin:\n                          (chinese == pomegranate + 1 and chinese == pumpkin - 1) or\n                          (chinese == pumpkin + 1 and chinese == pomegranate - 1),\n                          [\"Nationality:chinese\", \"Food:pomegranate\", \"Food:pumpkin\"])\n    \n    # Clue 5: the person who likes pumpkin is a different person than the australian person\n    problem.addConstraint(lambda pumpkin, australian: pumpkin != australian,\n                          [\"Food:pumpkin\", \"Nationality:australian\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['pomegranate', 'pear', 'pumpkin'], 'Nationality': ['australian', 'chinese', 'german'], 'Sport': ['skiing', 'golf', 'biathlon']}\n",
    "success": true,
    "execution_time": 0.002847,
    "timestamp": "20250918_093230",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['pomegranate', 'pear', 'pumpkin'], 'Nationality': ['australian', 'chinese', 'german'], 'Sport': ['skiing', 'golf', 'biathlon']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_93",
    "puzzle": {
      "id": "simple_3x3_93",
      "title": "Einstein Puzzle simple_3x3_93 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.03446883300000003
      },
      "clues": [
        "the person who likes punk music is somewhere between the person who plays surfing and the person who uses scooter for transportation (not necessarily immediately adjacent)",
        "the person who plays surfing is adjacent to the person who uses boat for transportation (either immediately left or right)",
        "the person who likes soul music is the same person as at least one of the person who uses scooter for transportation or the person who plays weightlifting",
        "the person who uses boat for transportation is to the left of the person who plays weightlifting (not necessarily immediately)"
      ],
      "categories": [
        "Music",
        "Sport",
        "Transport"
      ],
      "items": {
        "Music": [
          "gospel",
          "punk",
          "soul"
        ],
        "Sport": [
          "surfing",
          "baseball",
          "weightlifting"
        ],
        "Transport": [
          "ship",
          "boat",
          "scooter"
        ]
      },
      "ground_truth_solution": "{\"Music\": [\"gospel\", \"punk\", \"soul\"], \"Sport\": [\"surfing\", \"baseball\", \"weightlifting\"], \"Transport\": [\"ship\", \"boat\", \"scooter\"]}"
    },
    "puzzle_hash": "52f8992a0327db6f9ffd1668df388d97",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Music\", \"Sport\", \"Transport\"]\n    items = {\n        \"Music\": [\"gospel\", \"punk\", \"soul\"],\n        \"Sport\": [\"surfing\", \"baseball\", \"weightlifting\"],\n        \"Transport\": [\"ship\", \"boat\", \"scooter\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes punk music is somewhere between the person who plays surfing and the person who uses scooter for transportation (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda punk, surfing, scooter: (surfing < punk < scooter) or (scooter < punk < surfing),\n        [\"Music:punk\", \"Sport:surfing\", \"Transport:scooter\"]\n    )\n    \n    # Clue 2: the person who plays surfing is adjacent to the person who uses boat for transportation (either immediately left or right)\n    problem.addConstraint(\n        lambda surfing, boat: abs(surfing - boat) == 1,\n        [\"Sport:surfing\", \"Transport:boat\"]\n    )\n    \n    # Clue 3: the person who likes soul music is the same person as at least one of the person who uses scooter for transportation or the person who plays weightlifting\n    problem.addConstraint(\n        lambda soul, scooter, weightlifting: soul == scooter or soul == weightlifting,\n        [\"Music:soul\", \"Transport:scooter\", \"Sport:weightlifting\"]\n    )\n    \n    # Clue 4: the person who uses boat for transportation is to the left of the person who plays weightlifting (not necessarily immediately)\n    problem.addConstraint(\n        lambda boat, weightlifting: boat < weightlifting,\n        [\"Transport:boat\", \"Sport:weightlifting\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Music': ['gospel', 'punk', 'soul'], 'Sport': ['surfing', 'baseball', 'weightlifting'], 'Transport': ['ship', 'boat', 'scooter']}\n",
    "success": true,
    "execution_time": 0.00185,
    "timestamp": "20250918_093919",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Music': ['gospel', 'punk', 'soul'], 'Sport': ['surfing', 'baseball', 'weightlifting'], 'Transport': ['ship', 'boat', 'scooter']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_52",
    "puzzle": {
      "id": "simple_3x3_52",
      "title": "Einstein Puzzle simple_3x3_52 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.018299999999999983
      },
      "clues": [
        "the pakistani person is to the left of the russian person (not necessarily immediately)",
        "the russian person is to the left of the person who likes soul music (not necessarily immediately)",
        "the person who likes house music is somewhere between the person who likes coffee and the person who likes mirinda (not necessarily immediately adjacent)",
        "the person who likes reggae music is the same person as the person who likes mirinda or the pakistani person is the same person as the person who likes reggae music, but not both"
      ],
      "categories": [
        "Beverage",
        "Music",
        "Nationality"
      ],
      "items": {
        "Beverage": [
          "coffee",
          "lemonade",
          "mirinda"
        ],
        "Music": [
          "reggae",
          "house",
          "soul"
        ],
        "Nationality": [
          "pakistani",
          "russian",
          "mexican"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"coffee\", \"lemonade\", \"mirinda\"], \"Music\": [\"reggae\", \"house\", \"soul\"], \"Nationality\": [\"pakistani\", \"russian\", \"mexican\"]}"
    },
    "puzzle_hash": "d110b3aa8526e6900cf39e5728683889",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Music\", \"Nationality\"]\n    items = {\n        \"Beverage\": [\"coffee\", \"lemonade\", \"mirinda\"],\n        \"Music\": [\"reggae\", \"house\", \"soul\"],\n        \"Nationality\": [\"pakistani\", \"russian\", \"mexican\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the pakistani person is to the left of the russian person (not necessarily immediately)\n    problem.addConstraint(lambda pak, rus: pak < rus, [\"Nationality:pakistani\", \"Nationality:russian\"])\n    \n    # Clue 2: the russian person is to the left of the person who likes soul music (not necessarily immediately)\n    problem.addConstraint(lambda rus, soul: rus < soul, [\"Nationality:russian\", \"Music:soul\"])\n    \n    # Clue 3: the person who likes house music is somewhere between the person who likes coffee and the person who likes mirinda\n    # This means house position is strictly between coffee and mirinda positions\n    def house_between(cof, hou, mir):\n        return (cof < hou < mir) or (mir < hou < cof)\n    problem.addConstraint(house_between, [\"Beverage:coffee\", \"Music:house\", \"Beverage:mirinda\"])\n    \n    # Clue 4: The person who likes reggae music is the same person as the person who likes mirinda or the pakistani person is the same person as the person who likes reggae music, but not both\n    # This is an exclusive or (XOR) between (Music:reggae == Beverage:mirinda) and (Nationality:pakistani == Music:reggae)\n    def xor_constraint(reggae, mirinda, pakistani):\n        cond1 = (reggae == mirinda)\n        cond2 = (pakistani == reggae)\n        return (cond1 != cond2)\n    problem.addConstraint(xor_constraint, [\"Music:reggae\", \"Beverage:mirinda\", \"Nationality:pakistani\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['coffee', 'lemonade', 'mirinda'], 'Music': ['reggae', 'house', 'soul'], 'Nationality': ['pakistani', 'russian', 'mexican']}\n",
    "success": true,
    "execution_time": 0.003005,
    "timestamp": "20250918_093209",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['coffee', 'lemonade', 'mirinda'], 'Music': ['reggae', 'house', 'soul'], 'Nationality': ['pakistani', 'russian', 'mexican']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_44",
    "puzzle": {
      "id": "simple_3x3_44",
      "title": "Einstein Puzzle simple_3x3_44 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.018216082999999994
      },
      "clues": [
        "the person who likes musical movies is to the right of the person who likes epic movies (not necessarily immediately)",
        "the person who uses car for transportation and the person who likes grapefruit are at positions with the same parity (both at odd or both at even positions)",
        "the person who uses car for transportation is at the same position as or to the left of the person who likes epic movies",
        "the person who likes mystery movies is a different person than the person who uses ship for transportation",
        "the person who likes musical movies is to the left of the person who likes watermelon (not necessarily immediately)"
      ],
      "categories": [
        "Food",
        "Movie",
        "Transport"
      ],
      "items": {
        "Food": [
          "grapefruit",
          "apricot",
          "watermelon"
        ],
        "Movie": [
          "epic",
          "musical",
          "mystery"
        ],
        "Transport": [
          "car",
          "ship",
          "train"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"grapefruit\", \"apricot\", \"watermelon\"], \"Movie\": [\"epic\", \"musical\", \"mystery\"], \"Transport\": [\"car\", \"ship\", \"train\"]}"
    },
    "puzzle_hash": "9cbb00c5c35f6b97e0c4ef3ddafd44bc",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Movie\", \"Transport\"]\n    items = {\n        \"Food\": [\"grapefruit\", \"apricot\", \"watermelon\"],\n        \"Movie\": [\"epic\", \"musical\", \"mystery\"],\n        \"Transport\": [\"car\", \"ship\", \"train\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: musical movies is to the right of epic movies (not necessarily immediately)\n    problem.addConstraint(lambda musical, epic: musical > epic,\n                          [\"Movie:musical\", \"Movie:epic\"])\n    \n    # Clue 2: car and grapefruit are at positions with the same parity\n    problem.addConstraint(lambda car, grapefruit: car % 2 == grapefruit % 2,\n                          [\"Transport:car\", \"Food:grapefruit\"])\n    \n    # Clue 3: car is at the same position as or to the left of epic\n    problem.addConstraint(lambda car, epic: car <= epic,\n                          [\"Transport:car\", \"Movie:epic\"])\n    \n    # Clue 4: mystery and ship are different persons\n    problem.addConstraint(lambda mystery, ship: mystery != ship,\n                          [\"Movie:mystery\", \"Transport:ship\"])\n    \n    # Clue 5: musical is to the left of watermelon (not necessarily immediately)\n    problem.addConstraint(lambda musical, watermelon: musical < watermelon,\n                          [\"Movie:musical\", \"Food:watermelon\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['grapefruit', 'apricot', 'watermelon'], 'Movie': ['epic', 'musical', 'mystery'], 'Transport': ['car', 'ship', 'train']}\n",
    "success": true,
    "execution_time": 0.002455,
    "timestamp": "20250918_093051",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['grapefruit', 'apricot', 'watermelon'], 'Movie': ['epic', 'musical', 'mystery'], 'Transport': ['car', 'ship', 'train']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_80",
    "puzzle": {
      "id": "simple_3x3_80",
      "title": "Einstein Puzzle simple_3x3_80 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.05599041700000007
      },
      "clues": [
        "the person who likes artichoke is to the left of the person who likes cucumber (not necessarily immediately)",
        "the person who has frog as a pet is a different person than at least one of the person who likes artichoke or the person who likes spy movies",
        "the person who likes family movies is at an even-numbered position",
        "the person who has goat as a pet is at the same position as or to the left of the person who has goldfish as a pet",
        "the person who likes spy movies is to the left of the person who has goat as a pet (not necessarily immediately)"
      ],
      "categories": [
        "Food",
        "Movie",
        "Pet"
      ],
      "items": {
        "Food": [
          "eggplant",
          "artichoke",
          "cucumber"
        ],
        "Movie": [
          "spy",
          "family",
          "horror"
        ],
        "Pet": [
          "frog",
          "goat",
          "goldfish"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"eggplant\", \"artichoke\", \"cucumber\"], \"Movie\": [\"spy\", \"family\", \"horror\"], \"Pet\": [\"frog\", \"goat\", \"goldfish\"]}"
    },
    "puzzle_hash": "9b92e61b630f0b53e9c0f8bc0b1d5900",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Movie\", \"Pet\"]\n    items = {\n        \"Food\": [\"eggplant\", \"artichoke\", \"cucumber\"],\n        \"Movie\": [\"spy\", \"family\", \"horror\"],\n        \"Pet\": [\"frog\", \"goat\", \"goldfish\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes artichoke is to the left of the person who likes cucumber (not necessarily immediately)\n    problem.addConstraint(lambda a, c: a < c, [\"Food:artichoke\", \"Food:cucumber\"])\n    \n    # Clue 2: the person who has frog as a pet is a different person than at least one of the person who likes artichoke or the person who likes spy movies\n    # This means frog != artichoke OR frog != spy\n    # We implement this by adding a constraint that frog != artichoke OR frog != spy\n    # python-constraint does not support OR directly, so we add two constraints:\n    # frog != artichoke OR frog != spy means frog == artichoke == spy is not allowed\n    # So we forbid frog == artichoke == spy\n    def clue2(frog, artichoke, spy):\n        return not (frog == artichoke == spy)\n    problem.addConstraint(clue2, [\"Pet:frog\", \"Food:artichoke\", \"Movie:spy\"])\n    \n    # Clue 3: the person who likes family movies is at an even-numbered position\n    problem.addConstraint(lambda f: f % 2 == 0, [\"Movie:family\"])\n    \n    # Clue 4: the person who has goat as a pet is at the same position as or to the left of the person who has goldfish as a pet\n    problem.addConstraint(lambda goat, goldfish: goat <= goldfish, [\"Pet:goat\", \"Pet:goldfish\"])\n    \n    # Clue 5: the person who likes spy movies is to the left of the person who has goat as a pet (not necessarily immediately)\n    problem.addConstraint(lambda spy, goat: spy < goat, [\"Movie:spy\", \"Pet:goat\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['eggplant', 'artichoke', 'cucumber'], 'Movie': ['spy', 'horror', 'family'], 'Pet': ['frog', 'goat', 'goldfish']}\n",
    "success": true,
    "execution_time": 0.002302,
    "timestamp": "20250918_093700",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['eggplant', 'artichoke', 'cucumber'], 'Movie': ['spy', 'family', 'horror'], 'Pet': ['frog', 'goat', 'goldfish']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_31",
    "puzzle": {
      "id": "simple_3x3_31",
      "title": "Einstein Puzzle simple_3x3_31 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.017896833
      },
      "clues": [
        "the person who enjoys rock-climbing is at the same position as or to the right of the person who likes sprite",
        "the person who likes hip-hop music is at an end position (either leftmost or rightmost)",
        "the person who enjoys gardening is directly between the person who enjoys chess and the person who likes metal music",
        "the person who enjoys chess is adjacent to the person who likes mirinda (either immediately left or right)",
        "the person who likes mirinda is to the left of the person who likes sprite (not necessarily immediately)"
      ],
      "categories": [
        "Beverage",
        "Hobby",
        "Music"
      ],
      "items": {
        "Beverage": [
          "juice",
          "mirinda",
          "sprite"
        ],
        "Hobby": [
          "chess",
          "gardening",
          "rock-climbing"
        ],
        "Music": [
          "hip-hop",
          "salsa",
          "metal"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"juice\", \"mirinda\", \"sprite\"], \"Hobby\": [\"chess\", \"gardening\", \"rock-climbing\"], \"Music\": [\"hip-hop\", \"salsa\", \"metal\"]}"
    },
    "puzzle_hash": "88d9608786969b0d10184ca497d0e97e",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Hobby\", \"Music\"]\n    items = {\n        \"Beverage\": [\"juice\", \"mirinda\", \"sprite\"],\n        \"Hobby\": [\"chess\", \"gardening\", \"rock-climbing\"],\n        \"Music\": [\"hip-hop\", \"salsa\", \"metal\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys rock-climbing is at the same position as or to the right of the person who likes sprite\n    problem.addConstraint(lambda rc, sp: rc >= sp, [\"Hobby:rock-climbing\", \"Beverage:sprite\"])\n    \n    # Clue 2: the person who likes hip-hop music is at an end position (either leftmost or rightmost)\n    problem.addConstraint(lambda hh: hh == 0 or hh == num_positions - 1, [\"Music:hip-hop\"])\n    \n    # Clue 3: the person who enjoys gardening is directly between the person who enjoys chess and the person who likes metal music\n    # directly between means gardening position is one more than one and one less than the other\n    problem.addConstraint(lambda g, c, m: (g == c + 1 and g == m - 1) or (g == m + 1 and g == c - 1),\n                          [\"Hobby:gardening\", \"Hobby:chess\", \"Music:metal\"])\n    \n    # Clue 4: the person who enjoys chess is adjacent to the person who likes mirinda (either immediately left or right)\n    problem.addConstraint(lambda c, mi: abs(c - mi) == 1, [\"Hobby:chess\", \"Beverage:mirinda\"])\n    \n    # Clue 5: the person who likes mirinda is to the left of the person who likes sprite (not necessarily immediately)\n    problem.addConstraint(lambda mi, sp: mi < sp, [\"Beverage:mirinda\", \"Beverage:sprite\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['juice', 'mirinda', 'sprite'], 'Hobby': ['chess', 'gardening', 'rock-climbing'], 'Music': ['hip-hop', 'salsa', 'metal']}\n",
    "success": true,
    "execution_time": 0.002881,
    "timestamp": "20250918_092848",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['juice', 'mirinda', 'sprite'], 'Hobby': ['chess', 'gardening', 'rock-climbing'], 'Music': ['hip-hop', 'salsa', 'metal']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_59",
    "puzzle": {
      "id": "simple_3x3_59",
      "title": "Einstein Puzzle simple_3x3_59 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.022836917000000012
      },
      "clues": [
        "the person who likes banana is at the same position as or to the right of the person who likes tea",
        "the person who uses skateboard for transportation is adjacent to the person who likes banana (either immediately left or right)",
        "the person who likes almond-milk is at the same position as or to the right of the person who uses skateboard for transportation",
        "the person who uses airplane for transportation is directly between the person who uses subway for transportation and the person who likes cherry",
        "the person who likes iced-tea is adjacent to the person who likes almond-milk (either immediately left or right)",
        "the person who uses subway for transportation is at the same position as or to the left of the person who likes tea"
      ],
      "categories": [
        "Beverage",
        "Food",
        "Transport"
      ],
      "items": {
        "Beverage": [
          "tea",
          "iced-tea",
          "almond-milk"
        ],
        "Food": [
          "raspberry",
          "banana",
          "cherry"
        ],
        "Transport": [
          "subway",
          "airplane",
          "skateboard"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"tea\", \"iced-tea\", \"almond-milk\"], \"Food\": [\"raspberry\", \"banana\", \"cherry\"], \"Transport\": [\"subway\", \"airplane\", \"skateboard\"]}"
    },
    "puzzle_hash": "f007b48cb6f4862c3c3fb6c952862197",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Beverage\", \"Food\", \"Transport\"]\n    items = {\n        \"Beverage\": [\"tea\", \"iced-tea\", \"almond-milk\"],\n        \"Food\": [\"raspberry\", \"banana\", \"cherry\"],\n        \"Transport\": [\"subway\", \"airplane\", \"skateboard\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes banana is at the same position as or to the right of the person who likes tea\n    problem.addConstraint(lambda banana, tea: banana >= tea,\n                          [\"Food:banana\", \"Beverage:tea\"])\n    \n    # Clue 2: the person who uses skateboard for transportation is adjacent to the person who likes banana\n    problem.addConstraint(lambda skateboard, banana: abs(skateboard - banana) == 1,\n                          [\"Transport:skateboard\", \"Food:banana\"])\n    \n    # Clue 3: the person who likes almond-milk is at the same position as or to the right of the person who uses skateboard\n    problem.addConstraint(lambda almond_milk, skateboard: almond_milk >= skateboard,\n                          [\"Beverage:almond-milk\", \"Transport:skateboard\"])\n    \n    # Clue 4: the person who uses airplane is directly between the person who uses subway and the person who likes cherry\n    problem.addConstraint(lambda airplane, subway, cherry:\n                          (airplane == subway + 1 and airplane == cherry - 1) or\n                          (airplane == cherry + 1 and airplane == subway - 1),\n                          [\"Transport:airplane\", \"Transport:subway\", \"Food:cherry\"])\n    \n    # Clue 5: the person who likes iced-tea is adjacent to the person who likes almond-milk\n    problem.addConstraint(lambda iced_tea, almond_milk: abs(iced_tea - almond_milk) == 1,\n                          [\"Beverage:iced-tea\", \"Beverage:almond-milk\"])\n    \n    # Clue 6: the person who uses subway is at the same position as or to the left of the person who likes tea\n    problem.addConstraint(lambda subway, tea: subway <= tea,\n                          [\"Transport:subway\", \"Beverage:tea\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['tea', 'iced-tea', 'almond-milk'], 'Food': ['raspberry', 'banana', 'cherry'], 'Transport': ['subway', 'airplane', 'skateboard']}\n",
    "success": true,
    "execution_time": 0.003089,
    "timestamp": "20250918_093325",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['tea', 'iced-tea', 'almond-milk'], 'Food': ['raspberry', 'banana', 'cherry'], 'Transport': ['subway', 'airplane', 'skateboard']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_78",
    "puzzle": {
      "id": "simple_3x3_78",
      "title": "Einstein Puzzle simple_3x3_78 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.029035875000000155
      },
      "clues": [
        "the person who has hamster as a pet is somewhere between the person who likes milk and the person who uses quad-bike for transportation (not necessarily immediately adjacent)",
        "the person who uses bike for transportation is at the same position as or to the left of the person who likes lemonade",
        "the person who has hamster as a pet is a different person than the person who likes hot-chocolate",
        "the person who likes lemonade is at the same position as or to the right of the person who uses quad-bike for transportation",
        "the person who has frog as a pet is at the same position as or to the right of the person who uses bike for transportation"
      ],
      "categories": [
        "Beverage",
        "Pet",
        "Transport"
      ],
      "items": {
        "Beverage": [
          "hot-chocolate",
          "lemonade",
          "milk"
        ],
        "Pet": [
          "goldfish",
          "hamster",
          "frog"
        ],
        "Transport": [
          "quad-bike",
          "bike",
          "car"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"hot-chocolate\", \"lemonade\", \"milk\"], \"Pet\": [\"goldfish\", \"hamster\", \"frog\"], \"Transport\": [\"quad-bike\", \"bike\", \"car\"]}"
    },
    "puzzle_hash": "94cbcaf729da58c68faadb10a97f527d",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Pet\", \"Transport\"]\n    items = {\n        \"Beverage\": [\"hot-chocolate\", \"lemonade\", \"milk\"],\n        \"Pet\": [\"goldfish\", \"hamster\", \"frog\"],\n        \"Transport\": [\"quad-bike\", \"bike\", \"car\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: hamster is somewhere between milk and quad-bike (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda hamster, milk, quad: (milk < hamster < quad) or (quad < hamster < milk),\n        [\"Pet:hamster\", \"Beverage:milk\", \"Transport:quad-bike\"]\n    )\n    \n    # Clue 2: bike is at the same position as or to the left of lemonade\n    problem.addConstraint(\n        lambda bike, lemonade: bike <= lemonade,\n        [\"Transport:bike\", \"Beverage:lemonade\"]\n    )\n    \n    # Clue 3: hamster is a different person than hot-chocolate\n    problem.addConstraint(\n        lambda hamster, hot_chocolate: hamster != hot_chocolate,\n        [\"Pet:hamster\", \"Beverage:hot-chocolate\"]\n    )\n    \n    # Clue 4: lemonade is at the same position as or to the right of quad-bike\n    problem.addConstraint(\n        lambda lemonade, quad: lemonade >= quad,\n        [\"Beverage:lemonade\", \"Transport:quad-bike\"]\n    )\n    \n    # Clue 5: frog is at the same position as or to the right of bike\n    problem.addConstraint(\n        lambda frog, bike: frog >= bike,\n        [\"Pet:frog\", \"Transport:bike\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['hot-chocolate', 'lemonade', 'milk'], 'Pet': ['goldfish', 'hamster', 'frog'], 'Transport': ['quad-bike', 'bike', 'car']}\n",
    "success": true,
    "execution_time": 0.002966,
    "timestamp": "20250918_093640",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['hot-chocolate', 'lemonade', 'milk'], 'Pet': ['goldfish', 'hamster', 'frog'], 'Transport': ['quad-bike', 'bike', 'car']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_48",
    "puzzle": {
      "id": "simple_3x3_48",
      "title": "Einstein Puzzle simple_3x3_48 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.02207729199999997
      },
      "clues": [
        "the person who has hamster as a pet is the same person as the malaysian person or the person who plays cycling is the same person as the person who has hamster as a pet or both",
        "the person who plays biathlon is to the right of the person who has fish as a pet (not necessarily immediately)",
        "the malaysian person is directly between the chinese person and the person who plays snowboarding",
        "the mexican person is at the same position as or to the right of the person who has hamster as a pet"
      ],
      "categories": [
        "Nationality",
        "Pet",
        "Sport"
      ],
      "items": {
        "Nationality": [
          "chinese",
          "malaysian",
          "mexican"
        ],
        "Pet": [
          "fish",
          "hamster",
          "goldfish"
        ],
        "Sport": [
          "cycling",
          "biathlon",
          "snowboarding"
        ]
      },
      "ground_truth_solution": "{\"Nationality\": [\"chinese\", \"malaysian\", \"mexican\"], \"Pet\": [\"fish\", \"hamster\", \"goldfish\"], \"Sport\": [\"cycling\", \"biathlon\", \"snowboarding\"]}"
    },
    "puzzle_hash": "bc65a0c022e8993fc63ffe2c9029a2fa",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Nationality\", \"Pet\", \"Sport\"]\n    items = {\n        \"Nationality\": [\"chinese\", \"malaysian\", \"mexican\"],\n        \"Pet\": [\"fish\", \"hamster\", \"goldfish\"],\n        \"Sport\": [\"cycling\", \"biathlon\", \"snowboarding\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1:\n    # the person who has hamster as a pet is the same person as the malaysian person or\n    # the person who plays cycling is the same person as the person who has hamster as a pet or both\n    # This means:\n    # Pet:hamster == Nationality:malaysian OR Sport:cycling == Pet:hamster\n    # We can write this as:\n    # (hamster == malaysian) or (cycling == hamster)\n    def clue1(hamster, malaysian, cycling):\n        return hamster == malaysian or cycling == hamster\n    problem.addConstraint(clue1, [\"Pet:hamster\", \"Nationality:malaysian\", \"Sport:cycling\"])\n    \n    # Clue 2:\n    # the person who plays biathlon is to the right of the person who has fish as a pet (not necessarily immediately)\n    # biathlon > fish\n    problem.addConstraint(lambda biathlon, fish: biathlon > fish, [\"Sport:biathlon\", \"Pet:fish\"])\n    \n    # Clue 3:\n    # the malaysian person is directly between the chinese person and the person who plays snowboarding\n    # malaysian is between chinese and snowboarding means:\n    # (malaysian == chinese + 1 and malaysian == snowboarding - 1) or (malaysian == snowboarding + 1 and malaysian == chinese - 1)\n    problem.addConstraint(\n        lambda malaysian, chinese, snowboarding: (malaysian == chinese + 1 and malaysian == snowboarding - 1) or (malaysian == snowboarding + 1 and malaysian == chinese - 1),\n        [\"Nationality:malaysian\", \"Nationality:chinese\", \"Sport:snowboarding\"]\n    )\n    \n    # Clue 4:\n    # the mexican person is at the same position as or to the right of the person who has hamster as a pet\n    # mexican >= hamster\n    problem.addConstraint(lambda mexican, hamster: mexican >= hamster, [\"Nationality:mexican\", \"Pet:hamster\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Nationality': ['chinese', 'malaysian', 'mexican'], 'Pet': ['fish', 'hamster', 'goldfish'], 'Sport': ['cycling', 'biathlon', 'snowboarding']}\n",
    "success": true,
    "execution_time": 0.002983,
    "timestamp": "20250918_093134",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Nationality': ['chinese', 'malaysian', 'mexican'], 'Pet': ['fish', 'hamster', 'goldfish'], 'Sport': ['cycling', 'biathlon', 'snowboarding']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_33",
    "puzzle": {
      "id": "simple_3x3_33",
      "title": "Einstein Puzzle simple_3x3_33 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.01049991700000008
      },
      "clues": [
        "the person who likes radish is to the right of the person who has goldfish as a pet (not necessarily immediately)",
        "the person who has goldfish as a pet is a different person than the person who likes iced-tea",
        "the person who likes grapefruit is to the right of the person who has guinea-pig as a pet (not necessarily immediately)",
        "the person who has goldfish as a pet is somewhere between the person who likes radish and the person who likes water (not necessarily immediately adjacent)"
      ],
      "categories": [
        "Beverage",
        "Food",
        "Pet"
      ],
      "items": {
        "Beverage": [
          "water",
          "tea",
          "iced-tea"
        ],
        "Food": [
          "pepper",
          "grapefruit",
          "radish"
        ],
        "Pet": [
          "guinea-pig",
          "goldfish",
          "cat"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"water\", \"tea\", \"iced-tea\"], \"Food\": [\"pepper\", \"grapefruit\", \"radish\"], \"Pet\": [\"guinea-pig\", \"goldfish\", \"cat\"]}"
    },
    "puzzle_hash": "28e53c1c2420ad93d9004cbebb520b1d",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Food\", \"Pet\"]\n    items = {\n        \"Beverage\": [\"water\", \"tea\", \"iced-tea\"],\n        \"Food\": [\"pepper\", \"grapefruit\", \"radish\"],\n        \"Pet\": [\"guinea-pig\", \"goldfish\", \"cat\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes radish is to the right of the person who has goldfish as a pet (not necessarily immediately)\n    problem.addConstraint(lambda radish, goldfish: radish > goldfish,\n                          [\"Food:radish\", \"Pet:goldfish\"])\n    \n    # Clue 2: the person who has goldfish as a pet is a different person than the person who likes iced-tea\n    problem.addConstraint(lambda goldfish, iced_tea: goldfish != iced_tea,\n                          [\"Pet:goldfish\", \"Beverage:iced-tea\"])\n    \n    # Clue 3: the person who likes grapefruit is to the right of the person who has guinea-pig as a pet (not necessarily immediately)\n    problem.addConstraint(lambda grapefruit, guinea_pig: grapefruit > guinea_pig,\n                          [\"Food:grapefruit\", \"Pet:guinea-pig\"])\n    \n    # Clue 4: the person who has goldfish as a pet is somewhere between the person who likes radish and the person who likes water (not necessarily immediately adjacent)\n    # That means goldfish position is strictly between radish and water positions\n    def goldfish_between(radish, goldfish, water):\n        return (radish < goldfish < water) or (water < goldfish < radish)\n    problem.addConstraint(goldfish_between,\n                          [\"Food:radish\", \"Pet:goldfish\", \"Beverage:water\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['water', 'tea', 'iced-tea'], 'Food': ['pepper', 'grapefruit', 'radish'], 'Pet': ['guinea-pig', 'goldfish', 'cat']}\n",
    "success": true,
    "execution_time": 0.002744,
    "timestamp": "20250918_092906",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['water', 'tea', 'iced-tea'], 'Food': ['pepper', 'grapefruit', 'radish'], 'Pet': ['guinea-pig', 'goldfish', 'cat']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_83",
    "puzzle": {
      "id": "simple_3x3_83",
      "title": "Einstein Puzzle simple_3x3_83 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.011001791999999844
      },
      "clues": [
        "the person who uses quad-bike for transportation is to the left of the person who likes corn (not necessarily immediately)",
        "the person who likes lime is to the right of the person who likes hip-hop music (not necessarily immediately)",
        "the person who uses taxi for transportation is directly between the person who likes gospel music and the person who likes soul music",
        "the person who likes soul music is at the same position as or to the left of the person who likes peas"
      ],
      "categories": [
        "Food",
        "Music",
        "Transport"
      ],
      "items": {
        "Food": [
          "peas",
          "corn",
          "lime"
        ],
        "Music": [
          "soul",
          "hip-hop",
          "gospel"
        ],
        "Transport": [
          "quad-bike",
          "taxi",
          "bus"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"peas\", \"corn\", \"lime\"], \"Music\": [\"soul\", \"hip-hop\", \"gospel\"], \"Transport\": [\"quad-bike\", \"taxi\", \"bus\"]}"
    },
    "puzzle_hash": "5291324054113f31bbbaaf70f1986049",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Music\", \"Transport\"]\n    items = {\n        \"Food\": [\"peas\", \"corn\", \"lime\"],\n        \"Music\": [\"soul\", \"hip-hop\", \"gospel\"],\n        \"Transport\": [\"quad-bike\", \"taxi\", \"bus\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses quad-bike for transportation is to the left of the person who likes corn (not necessarily immediately)\n    problem.addConstraint(lambda q, c: q < c, [\"Transport:quad-bike\", \"Food:corn\"])\n    \n    # Clue 2: the person who likes lime is to the right of the person who likes hip-hop music (not necessarily immediately)\n    problem.addConstraint(lambda l, h: l > h, [\"Food:lime\", \"Music:hip-hop\"])\n    \n    # Clue 3: the person who uses taxi for transportation is directly between the person who likes gospel music and the person who likes soul music\n    # \"directly between\" means taxi position is one more than one music and one less than the other music\n    problem.addConstraint(lambda t, g, s: (t == g + 1 and t == s - 1) or (t == s + 1 and t == g - 1),\n                          [\"Transport:taxi\", \"Music:gospel\", \"Music:soul\"])\n    \n    # Clue 4: the person who likes soul music is at the same position as or to the left of the person who likes peas\n    problem.addConstraint(lambda s, p: s <= p, [\"Music:soul\", \"Food:peas\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['peas', 'corn', 'lime'], 'Music': ['soul', 'hip-hop', 'gospel'], 'Transport': ['quad-bike', 'taxi', 'bus']}\n",
    "success": true,
    "execution_time": 0.001973,
    "timestamp": "20250918_093735",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['peas', 'corn', 'lime'], 'Music': ['soul', 'hip-hop', 'gospel'], 'Transport': ['quad-bike', 'taxi', 'bus']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_70",
    "puzzle": {
      "id": "simple_3x3_70",
      "title": "Einstein Puzzle simple_3x3_70 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.020956167000000026
      },
      "clues": [
        "the person who likes d&b music is the same person as the person who likes zombie movies or the person who likes zombie movies is the same person as the person who enjoys traveling, but not both",
        "the person who enjoys traveling is at an end position (either leftmost or rightmost)",
        "the person who likes salsa music is to the left of the person who enjoys drawing (not necessarily immediately)",
        "the person who enjoys magic-tricks is to the left of the person who enjoys traveling (not necessarily immediately)",
        "the person who likes adventure movies is at an odd-numbered position",
        "the person who likes zombie movies is adjacent to the person who likes adventure movies (either immediately left or right)",
        "the person who likes funk music is to the right of the person who likes adventure movies (not necessarily immediately)"
      ],
      "categories": [
        "Hobby",
        "Movie",
        "Music"
      ],
      "items": {
        "Hobby": [
          "magic-tricks",
          "drawing",
          "traveling"
        ],
        "Movie": [
          "adventure",
          "zombie",
          "mystery"
        ],
        "Music": [
          "salsa",
          "d&b",
          "funk"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"magic-tricks\", \"drawing\", \"traveling\"], \"Movie\": [\"adventure\", \"zombie\", \"mystery\"], \"Music\": [\"salsa\", \"d&b\", \"funk\"]}"
    },
    "puzzle_hash": "bd9d0f3390cc8dcdc36a1ab31ee3df1a",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Movie\", \"Music\"]\n    items = {\n        \"Hobby\": [\"magic-tricks\", \"drawing\", \"traveling\"],\n        \"Movie\": [\"adventure\", \"zombie\", \"mystery\"],\n        \"Music\": [\"salsa\", \"d&b\", \"funk\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1:\n    # the person who likes d&b music is the same person as the person who likes zombie movies\n    # or the person who likes zombie movies is the same person as the person who enjoys traveling, but not both\n    # XOR condition:\n    def clue1(dnb, zombie, traveling):\n        return (dnb == zombie) != (zombie == traveling)\n    problem.addConstraint(clue1, [\"Music:d&b\", \"Movie:zombie\", \"Hobby:traveling\"])\n    \n    # Clue 2:\n    # the person who enjoys traveling is at an end position (either leftmost or rightmost)\n    problem.addConstraint(lambda x: x == 0 or x == num_positions - 1, [\"Hobby:traveling\"])\n    \n    # Clue 3:\n    # the person who likes salsa music is to the left of the person who enjoys drawing (not necessarily immediately)\n    problem.addConstraint(lambda salsa, drawing: salsa < drawing, [\"Music:salsa\", \"Hobby:drawing\"])\n    \n    # Clue 4:\n    # the person who enjoys magic-tricks is to the left of the person who enjoys traveling (not necessarily immediately)\n    problem.addConstraint(lambda magic, traveling: magic < traveling, [\"Hobby:magic-tricks\", \"Hobby:traveling\"])\n    \n    # Clue 5:\n    # the person who likes adventure movies is at an odd-numbered position\n    problem.addConstraint(lambda x: x % 2 == 0, [\"Movie:adventure\"])  # positions 0,1,2; odd-numbered means 1-based odd, so 1 or 3\n    # positions are 0-indexed, so odd-numbered positions are 0 and 2? No, 1-based odd positions are 1 and 3, so 0 and 2 in 0-indexed\n    # But clue says \"at an odd-numbered position\", so positions 1 or 3 (1-based), which is 0 or 2 (0-based)\n    # So x == 0 or x == 2\n    # So x % 2 == 0 is correct\n    \n    # Clue 6:\n    # the person who likes zombie movies is adjacent to the person who likes adventure movies (either immediately left or right)\n    problem.addConstraint(lambda zombie, adventure: abs(zombie - adventure) == 1, [\"Movie:zombie\", \"Movie:adventure\"])\n    \n    # Clue 7:\n    # the person who likes funk music is to the right of the person who likes adventure movies (not necessarily immediately)\n    problem.addConstraint(lambda funk, adventure: funk > adventure, [\"Music:funk\", \"Movie:adventure\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['magic-tricks', 'drawing', 'traveling'], 'Movie': ['adventure', 'zombie', 'mystery'], 'Music': ['salsa', 'd&b', 'funk']}\n",
    "success": true,
    "execution_time": 0.00328,
    "timestamp": "20250918_093518",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['magic-tricks', 'drawing', 'traveling'], 'Movie': ['adventure', 'zombie', 'mystery'], 'Music': ['salsa', 'd&b', 'funk']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_95",
    "puzzle": {
      "id": "simple_3x3_95",
      "title": "Einstein Puzzle simple_3x3_95 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.017025040999999907
      },
      "clues": [
        "the person who likes thriller movies is at the same position as or to the right of the person who likes superhero movies",
        "the person who likes orange is directly between the person who likes drama movies and the person who likes iced-tea",
        "the person who likes thriller movies and the person who likes soy-milk are at positions with different parity (one at odd, one at even position)",
        "the person who likes drama movies is adjacent to the person who likes thriller movies (either immediately left or right)",
        "the person who likes soy-milk is at the same position as or to the left of the person who likes cherry"
      ],
      "categories": [
        "Beverage",
        "Food",
        "Movie"
      ],
      "items": {
        "Beverage": [
          "iced-tea",
          "juice",
          "soy-milk"
        ],
        "Food": [
          "nectarine",
          "orange",
          "cherry"
        ],
        "Movie": [
          "superhero",
          "thriller",
          "drama"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"iced-tea\", \"juice\", \"soy-milk\"], \"Food\": [\"nectarine\", \"orange\", \"cherry\"], \"Movie\": [\"superhero\", \"thriller\", \"drama\"]}"
    },
    "puzzle_hash": "d97aa9a8e967093e6e20773003691302",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Food\", \"Movie\"]\n    items = {\n        \"Beverage\": [\"iced-tea\", \"juice\", \"soy-milk\"],\n        \"Food\": [\"nectarine\", \"orange\", \"cherry\"],\n        \"Movie\": [\"superhero\", \"thriller\", \"drama\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes thriller movies is at the same position as or to the right of the person who likes superhero movies\n    problem.addConstraint(lambda thriller, superhero: thriller >= superhero,\n                          [\"Movie:thriller\", \"Movie:superhero\"])\n    \n    # Clue 2: the person who likes orange is directly between the person who likes drama movies and the person who likes iced-tea\n    # \"directly between\" means orange position is exactly one between drama and iced-tea\n    # So orange == drama +1 and orange == iced-tea -1 or orange == iced-tea +1 and orange == drama -1\n    problem.addConstraint(lambda orange, drama, iced_tea: (orange == drama + 1 and orange == iced_tea - 1) or (orange == iced_tea + 1 and orange == drama - 1),\n                          [\"Food:orange\", \"Movie:drama\", \"Beverage:iced-tea\"])\n    \n    # Clue 3: the person who likes thriller movies and the person who likes soy-milk are at positions with different parity\n    problem.addConstraint(lambda thriller, soy_milk: (thriller % 2) != (soy_milk % 2),\n                          [\"Movie:thriller\", \"Beverage:soy-milk\"])\n    \n    # Clue 4: the person who likes drama movies is adjacent to the person who likes thriller movies\n    problem.addConstraint(lambda drama, thriller: abs(drama - thriller) == 1,\n                          [\"Movie:drama\", \"Movie:thriller\"])\n    \n    # Clue 5: the person who likes soy-milk is at the same position as or to the left of the person who likes cherry\n    problem.addConstraint(lambda soy_milk, cherry: soy_milk <= cherry,\n                          [\"Beverage:soy-milk\", \"Food:cherry\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['iced-tea', 'juice', 'soy-milk'], 'Food': ['nectarine', 'orange', 'cherry'], 'Movie': ['superhero', 'thriller', 'drama']}\n",
    "success": true,
    "execution_time": 0.002888,
    "timestamp": "20250918_093941",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['iced-tea', 'juice', 'soy-milk'], 'Food': ['nectarine', 'orange', 'cherry'], 'Movie': ['superhero', 'thriller', 'drama']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_9",
    "puzzle": {
      "id": "simple_3x3_9",
      "title": "Einstein Puzzle simple_3x3_9 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.024863125000000014
      },
      "clues": [
        "the person who enjoys skydiving is a different person than the russian person",
        "the french person is to the right of the person who enjoys skydiving (not necessarily immediately)",
        "the person who likes fantasy movies is to the right of the person who likes family movies (not necessarily immediately)",
        "the person who likes family movies is directly between the person who likes drama movies and the person who likes fantasy movies",
        "the person who enjoys traveling is to the right of the french person (not necessarily immediately)"
      ],
      "categories": [
        "Hobby",
        "Movie",
        "Nationality"
      ],
      "items": {
        "Hobby": [
          "skydiving",
          "drawing",
          "traveling"
        ],
        "Movie": [
          "drama",
          "family",
          "fantasy"
        ],
        "Nationality": [
          "mexican",
          "french",
          "russian"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"skydiving\", \"drawing\", \"traveling\"], \"Movie\": [\"drama\", \"family\", \"fantasy\"], \"Nationality\": [\"mexican\", \"french\", \"russian\"]}"
    },
    "puzzle_hash": "740e0252dc474637604b40b8ceef5a98",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Movie\", \"Nationality\"]\n    items = {\n        \"Hobby\": [\"skydiving\", \"drawing\", \"traveling\"],\n        \"Movie\": [\"drama\", \"family\", \"fantasy\"],\n        \"Nationality\": [\"mexican\", \"french\", \"russian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys skydiving is a different person than the russian person\n    problem.addConstraint(lambda x, y: x != y, [\"Hobby:skydiving\", \"Nationality:russian\"])\n    \n    # Clue 2: the french person is to the right of the person who enjoys skydiving (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x > y, [\"Nationality:french\", \"Hobby:skydiving\"])\n    \n    # Clue 3: the person who likes fantasy movies is to the right of the person who likes family movies (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x > y, [\"Movie:fantasy\", \"Movie:family\"])\n    \n    # Clue 4: the person who likes family movies is directly between the person who likes drama movies and the person who likes fantasy movies\n    # family is between drama and fantasy means family position is between drama and fantasy positions\n    # So family is exactly one position away from drama and fantasy, and drama and fantasy are on opposite sides\n    problem.addConstraint(lambda f, d, fa: (f == d + 1 and f == fa - 1) or (f == d - 1 and f == fa + 1),\n                          [\"Movie:family\", \"Movie:drama\", \"Movie:fantasy\"])\n    \n    # Clue 5: the person who enjoys traveling is to the right of the french person (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x > y, [\"Hobby:traveling\", \"Nationality:french\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['skydiving', 'drawing', 'traveling'], 'Movie': ['drama', 'family', 'fantasy'], 'Nationality': ['mexican', 'french', 'russian']}\n",
    "success": true,
    "execution_time": 0.002844,
    "timestamp": "20250918_092446",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['skydiving', 'drawing', 'traveling'], 'Movie': ['drama', 'family', 'fantasy'], 'Nationality': ['mexican', 'french', 'russian']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_40",
    "puzzle": {
      "id": "simple_3x3_40",
      "title": "Einstein Puzzle simple_3x3_40 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.033651333000000005
      },
      "clues": [
        "the person who works as a mechanic is the same person as the person who likes spinach or the person who enjoys rock-climbing is the same person as the person who works as a mechanic, but not both",
        "the person who likes grapefruit is the same person as the person who works as a dressmaker or the person who enjoys sudoku is the same person as the person who likes grapefruit, but not both",
        "the person who likes grapefruit is to the left of the person who likes spinach (not necessarily immediately)",
        "the person who likes spinach is to the left of the person who works as a dressmaker (not necessarily immediately)"
      ],
      "categories": [
        "Food",
        "Hobby",
        "Job"
      ],
      "items": {
        "Food": [
          "grapefruit",
          "spinach",
          "potato"
        ],
        "Hobby": [
          "sudoku",
          "reading",
          "rock-climbing"
        ],
        "Job": [
          "teacher",
          "mechanic",
          "dressmaker"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"grapefruit\", \"spinach\", \"potato\"], \"Hobby\": [\"sudoku\", \"reading\", \"rock-climbing\"], \"Job\": [\"teacher\", \"mechanic\", \"dressmaker\"]}"
    },
    "puzzle_hash": "7ff932ff7e51660553c4ce5e39af3cb4",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Hobby\", \"Job\"]\n    items = {\n        \"Food\": [\"grapefruit\", \"spinach\", \"potato\"],\n        \"Hobby\": [\"sudoku\", \"reading\", \"rock-climbing\"],\n        \"Job\": [\"teacher\", \"mechanic\", \"dressmaker\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1:\n    # the person who works as a mechanic is the same person as the person who likes spinach\n    # or the person who enjoys rock-climbing is the same person as the person who works as a mechanic, but not both\n    # This is an XOR between (mechanic == spinach) and (rock-climbing == mechanic)\n    def clue1(mechanic, spinach, rock_climbing):\n        return (mechanic == spinach) != (rock_climbing == mechanic)\n    problem.addConstraint(clue1, [\"Job:mechanic\", \"Food:spinach\", \"Hobby:rock-climbing\"])\n    \n    # Clue 2:\n    # the person who likes grapefruit is the same person as the person who works as a dressmaker\n    # or the person who enjoys sudoku is the same person as the person who likes grapefruit, but not both\n    # XOR between (grapefruit == dressmaker) and (sudoku == grapefruit)\n    def clue2(grapefruit, dressmaker, sudoku):\n        return (grapefruit == dressmaker) != (sudoku == grapefruit)\n    problem.addConstraint(clue2, [\"Food:grapefruit\", \"Job:dressmaker\", \"Hobby:sudoku\"])\n    \n    # Clue 3:\n    # the person who likes grapefruit is to the left of the person who likes spinach (not necessarily immediately)\n    problem.addConstraint(lambda grapefruit, spinach: grapefruit < spinach, [\"Food:grapefruit\", \"Food:spinach\"])\n    \n    # Clue 4:\n    # the person who likes spinach is to the left of the person who works as a dressmaker (not necessarily immediately)\n    problem.addConstraint(lambda spinach, dressmaker: spinach < dressmaker, [\"Food:spinach\", \"Job:dressmaker\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['grapefruit', 'spinach', 'potato'], 'Hobby': ['sudoku', 'reading', 'rock-climbing'], 'Job': ['teacher', 'mechanic', 'dressmaker']}\n",
    "success": true,
    "execution_time": 0.002683,
    "timestamp": "20250918_093013",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['grapefruit', 'spinach', 'potato'], 'Hobby': ['sudoku', 'reading', 'rock-climbing'], 'Job': ['teacher', 'mechanic', 'dressmaker']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_87",
    "puzzle": {
      "id": "simple_3x3_87",
      "title": "Einstein Puzzle simple_3x3_87 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.025498374999999962
      },
      "clues": [
        "the person who plays golf is the same person as the person who works as a scientist or the person who works as a scientist is the same person as the person who likes epic movies, but not both",
        "the person who likes epic movies is to the left of the person who likes satire movies (not necessarily immediately)",
        "the person who works as a scientist is somewhere between the person who works as a accountant and the person who plays volleyball (not necessarily immediately adjacent)",
        "the person who plays rowing and the person who likes satire movies are at positions with the same parity (both at odd or both at even positions)",
        "the person who plays volleyball is to the left of the person who works as a accountant (not necessarily immediately)"
      ],
      "categories": [
        "Job",
        "Movie",
        "Sport"
      ],
      "items": {
        "Job": [
          "nurse",
          "scientist",
          "accountant"
        ],
        "Movie": [
          "epic",
          "adventure",
          "satire"
        ],
        "Sport": [
          "volleyball",
          "golf",
          "rowing"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"nurse\", \"scientist\", \"accountant\"], \"Movie\": [\"epic\", \"adventure\", \"satire\"], \"Sport\": [\"volleyball\", \"golf\", \"rowing\"]}"
    },
    "puzzle_hash": "408572d01c6cdfc5b5b78dc528e47591",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Movie\", \"Sport\"]\n    items = {\n        \"Job\": [\"nurse\", \"scientist\", \"accountant\"],\n        \"Movie\": [\"epic\", \"adventure\", \"satire\"],\n        \"Sport\": [\"volleyball\", \"golf\", \"rowing\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1:\n    # the person who plays golf is the same person as the person who works as a scientist\n    # or the person who works as a scientist is the same person as the person who likes epic movies, but not both\n    # XOR condition:\n    # (Golf == Scientist) XOR (Scientist == Epic)\n    problem.addConstraint(\n        lambda golf, scientist, epic: (golf == scientist) != (scientist == epic),\n        [\"Sport:golf\", \"Job:scientist\", \"Movie:epic\"]\n    )\n    \n    # Clue 2:\n    # the person who likes epic movies is to the left of the person who likes satire movies (not necessarily immediately)\n    problem.addConstraint(\n        lambda epic, satire: epic < satire,\n        [\"Movie:epic\", \"Movie:satire\"]\n    )\n    \n    # Clue 3:\n    # the person who works as a scientist is somewhere between the person who works as an accountant and the person who plays volleyball\n    # scientist position is strictly between accountant and volleyball\n    problem.addConstraint(\n        lambda scientist, accountant, volleyball:\n            (accountant < scientist < volleyball) or (volleyball < scientist < accountant),\n        [\"Job:scientist\", \"Job:accountant\", \"Sport:volleyball\"]\n    )\n    \n    # Clue 4:\n    # the person who plays rowing and the person who likes satire movies are at positions with the same parity\n    problem.addConstraint(\n        lambda rowing, satire: rowing % 2 == satire % 2,\n        [\"Sport:rowing\", \"Movie:satire\"]\n    )\n    \n    # Clue 5:\n    # the person who plays volleyball is to the left of the person who works as an accountant (not necessarily immediately)\n    problem.addConstraint(\n        lambda volleyball, accountant: volleyball < accountant,\n        [\"Sport:volleyball\", \"Job:accountant\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['nurse', 'scientist', 'accountant'], 'Movie': ['epic', 'adventure', 'satire'], 'Sport': ['volleyball', 'golf', 'rowing']}\n",
    "success": true,
    "execution_time": 0.00273,
    "timestamp": "20250918_093815",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['nurse', 'scientist', 'accountant'], 'Movie': ['epic', 'adventure', 'satire'], 'Sport': ['volleyball', 'golf', 'rowing']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_82",
    "puzzle": {
      "id": "simple_3x3_82",
      "title": "Einstein Puzzle simple_3x3_82 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.03876754200000021
      },
      "clues": [
        "the person who likes scientific movies is to the left of the person who likes garlic (not necessarily immediately)",
        "the person who likes jazz music is a different person than the person who likes fantasy movies or the person who likes lemon is a different person than the person who likes jazz music or both",
        "the person who likes potato is at the same position as or to the left of the person who likes reggae music",
        "the person who likes potato is at the same position as or to the right of the person who likes jazz music",
        "the person who likes lemon is at the same position as or to the right of the person who likes fantasy movies",
        "the person who likes lemon is to the left of the person who likes scientific movies (not necessarily immediately)"
      ],
      "categories": [
        "Food",
        "Movie",
        "Music"
      ],
      "items": {
        "Food": [
          "lemon",
          "potato",
          "garlic"
        ],
        "Movie": [
          "fantasy",
          "scientific",
          "adventure"
        ],
        "Music": [
          "r&b",
          "jazz",
          "reggae"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"lemon\", \"potato\", \"garlic\"], \"Movie\": [\"fantasy\", \"scientific\", \"adventure\"], \"Music\": [\"r&b\", \"jazz\", \"reggae\"]}"
    },
    "puzzle_hash": "586b8470d5098f5cd049a0246717d4fc",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Movie\", \"Music\"]\n    items = {\n        \"Food\": [\"lemon\", \"potato\", \"garlic\"],\n        \"Movie\": [\"fantasy\", \"scientific\", \"adventure\"],\n        \"Music\": [\"r&b\", \"jazz\", \"reggae\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes scientific movies is to the left of the person who likes garlic (not necessarily immediately)\n    problem.addConstraint(lambda sci, gar: sci < gar, [\"Movie:scientific\", \"Food:garlic\"])\n    \n    # Clue 2: the person who likes jazz music is a different person than the person who likes fantasy movies or the person who likes lemon is a different person than the person who likes jazz music or both\n    # This means: jazz != fantasy OR lemon != jazz\n    # So the only forbidden case is jazz == fantasy AND lemon == jazz\n    # So we forbid jazz == fantasy == lemon\n    def clue2(jazz, fantasy, lemon):\n        return not (jazz == fantasy == lemon)\n    problem.addConstraint(clue2, [\"Music:jazz\", \"Movie:fantasy\", \"Food:lemon\"])\n    \n    # Clue 3: the person who likes potato is at the same position as or to the left of the person who likes reggae music\n    problem.addConstraint(lambda pot, reg: pot <= reg, [\"Food:potato\", \"Music:reggae\"])\n    \n    # Clue 4: the person who likes potato is at the same position as or to the right of the person who likes jazz music\n    problem.addConstraint(lambda pot, jazz: pot >= jazz, [\"Food:potato\", \"Music:jazz\"])\n    \n    # Clue 5: the person who likes lemon is at the same position as or to the right of the person who likes fantasy movies\n    problem.addConstraint(lambda lemon, fantasy: lemon >= fantasy, [\"Food:lemon\", \"Movie:fantasy\"])\n    \n    # Clue 6: the person who likes lemon is to the left of the person who likes scientific movies (not necessarily immediately)\n    problem.addConstraint(lambda lemon, sci: lemon < sci, [\"Food:lemon\", \"Movie:scientific\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['lemon', 'potato', 'garlic'], 'Movie': ['fantasy', 'scientific', 'adventure'], 'Music': ['r&b', 'jazz', 'reggae']}\n",
    "success": true,
    "execution_time": 0.002873,
    "timestamp": "20250918_093726",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['lemon', 'potato', 'garlic'], 'Movie': ['fantasy', 'scientific', 'adventure'], 'Music': ['r&b', 'jazz', 'reggae']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_50",
    "puzzle": {
      "id": "simple_3x3_50",
      "title": "Einstein Puzzle simple_3x3_50 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.01268304099999995
      },
      "clues": [
        "the person who uses snowmobile for transportation is somewhere between the person who plays lacrosse and the person who uses jet-ski for transportation (not necessarily immediately adjacent)",
        "the person who plays skiing is somewhere between the person who plays parkour and the person who likes disaster movies (not necessarily immediately adjacent)",
        "the person who uses jet-ski for transportation is at the same position as or to the right of the person who uses snowmobile for transportation",
        "the person who likes animation movies and the person who plays lacrosse are at positions with different parity (one at odd, one at even position)"
      ],
      "categories": [
        "Movie",
        "Sport",
        "Transport"
      ],
      "items": {
        "Movie": [
          "disaster",
          "animation",
          "family"
        ],
        "Sport": [
          "lacrosse",
          "skiing",
          "parkour"
        ],
        "Transport": [
          "subway",
          "snowmobile",
          "jet-ski"
        ]
      },
      "ground_truth_solution": "{\"Movie\": [\"disaster\", \"animation\", \"family\"], \"Sport\": [\"lacrosse\", \"skiing\", \"parkour\"], \"Transport\": [\"subway\", \"snowmobile\", \"jet-ski\"]}"
    },
    "puzzle_hash": "ea60c8fcef68328f0ccdcb10e2e1f345",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Sport\", \"Transport\"]\n    items = {\n        \"Movie\": [\"disaster\", \"animation\", \"family\"],\n        \"Sport\": [\"lacrosse\", \"skiing\", \"parkour\"],\n        \"Transport\": [\"subway\", \"snowmobile\", \"jet-ski\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1:\n    # the person who uses snowmobile for transportation is somewhere between the person who plays lacrosse and the person who uses jet-ski for transportation (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda snowmobile, lacrosse, jetski:\n        (lacrosse < snowmobile < jetski) or (jetski < snowmobile < lacrosse),\n        [\"Transport:snowmobile\", \"Sport:lacrosse\", \"Transport:jet-ski\"]\n    )\n    \n    # Clue 2:\n    # the person who plays skiing is somewhere between the person who plays parkour and the person who likes disaster movies (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda skiing, parkour, disaster:\n        (parkour < skiing < disaster) or (disaster < skiing < parkour),\n        [\"Sport:skiing\", \"Sport:parkour\", \"Movie:disaster\"]\n    )\n    \n    # Clue 3:\n    # the person who uses jet-ski for transportation is at the same position as or to the right of the person who uses snowmobile for transportation\n    problem.addConstraint(\n        lambda jetski, snowmobile: jetski >= snowmobile,\n        [\"Transport:jet-ski\", \"Transport:snowmobile\"]\n    )\n    \n    # Clue 4:\n    # the person who likes animation movies and the person who plays lacrosse are at positions with different parity (one at odd, one at even position)\n    problem.addConstraint(\n        lambda animation, lacrosse: (animation % 2) != (lacrosse % 2),\n        [\"Movie:animation\", \"Sport:lacrosse\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Movie': ['disaster', 'animation', 'family'], 'Sport': ['lacrosse', 'skiing', 'parkour'], 'Transport': ['subway', 'snowmobile', 'jet-ski']}\n",
    "success": true,
    "execution_time": 0.002777,
    "timestamp": "20250918_093151",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Movie': ['disaster', 'animation', 'family'], 'Sport': ['lacrosse', 'skiing', 'parkour'], 'Transport': ['subway', 'snowmobile', 'jet-ski']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_47",
    "puzzle": {
      "id": "simple_3x3_47",
      "title": "Einstein Puzzle simple_3x3_47 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.03740699999999997
      },
      "clues": [
        "the person who likes carrot is a different person than the person who likes comedy movies",
        "the person who likes watermelon is to the right of the person who likes carrot (not necessarily immediately)",
        "the person who likes martial-arts movies is to the right of the person who works as a entrepreneur (not necessarily immediately)",
        "the person who likes superhero movies is at the same position as or to the right of the person who works as a electrician",
        "the person who likes superhero movies is to the left of the person who works as a entrepreneur (not necessarily immediately)",
        "the person who works as a electrician and the person who likes watermelon are at positions with the same parity (both at odd or both at even positions)"
      ],
      "categories": [
        "Food",
        "Job",
        "Movie"
      ],
      "items": {
        "Food": [
          "carrot",
          "peach",
          "watermelon"
        ],
        "Job": [
          "electrician",
          "entrepreneur",
          "lawyer"
        ],
        "Movie": [
          "superhero",
          "comedy",
          "martial-arts"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"carrot\", \"peach\", \"watermelon\"], \"Job\": [\"electrician\", \"entrepreneur\", \"lawyer\"], \"Movie\": [\"superhero\", \"comedy\", \"martial-arts\"]}"
    },
    "puzzle_hash": "c1cfb2412f133332098d724a0d7edaa2",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Job\", \"Movie\"]\n    items = {\n        \"Food\": [\"carrot\", \"peach\", \"watermelon\"],\n        \"Job\": [\"electrician\", \"entrepreneur\", \"lawyer\"],\n        \"Movie\": [\"superhero\", \"comedy\", \"martial-arts\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes carrot is a different person than the person who likes comedy movies\n    problem.addConstraint(lambda x, y: x != y, [\"Food:carrot\", \"Movie:comedy\"])\n    \n    # Clue 2: the person who likes watermelon is to the right of the person who likes carrot (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x > y, [\"Food:watermelon\", \"Food:carrot\"])\n    \n    # Clue 3: the person who likes martial-arts movies is to the right of the person who works as a entrepreneur (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x > y, [\"Movie:martial-arts\", \"Job:entrepreneur\"])\n    \n    # Clue 4: the person who likes superhero movies is at the same position as or to the right of the person who works as a electrician\n    problem.addConstraint(lambda x, y: x >= y, [\"Movie:superhero\", \"Job:electrician\"])\n    \n    # Clue 5: the person who likes superhero movies is to the left of the person who works as a entrepreneur (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x < y, [\"Movie:superhero\", \"Job:entrepreneur\"])\n    \n    # Clue 6: the person who works as a electrician and the person who likes watermelon are at positions with the same parity (both at odd or both at even positions)\n    problem.addConstraint(lambda x, y: x % 2 == y % 2, [\"Job:electrician\", \"Food:watermelon\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['carrot', 'peach', 'watermelon'], 'Job': ['electrician', 'entrepreneur', 'lawyer'], 'Movie': ['superhero', 'comedy', 'martial-arts']}\n",
    "success": true,
    "execution_time": 0.002905,
    "timestamp": "20250918_093123",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['carrot', 'peach', 'watermelon'], 'Job': ['electrician', 'entrepreneur', 'lawyer'], 'Movie': ['superhero', 'comedy', 'martial-arts']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_45",
    "puzzle": {
      "id": "simple_3x3_45",
      "title": "Einstein Puzzle simple_3x3_45 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.024786207999999976
      },
      "clues": [
        "the person who works as a chef is to the right of the person who enjoys card-games (not necessarily immediately)",
        "the person who likes soul music is to the left of the person who likes r&b music (not necessarily immediately)",
        "the person who works as a entrepreneur and the person who likes r&b music are at positions with the same parity (both at odd or both at even positions)",
        "the person who works as a project-manager is to the left of the person who works as a entrepreneur (not necessarily immediately)",
        "the person who works as a project-manager and the person who enjoys collecting are at positions with different parity (one at odd, one at even position)",
        "the person who works as a entrepreneur and the person who likes folk music are at positions with the same parity (both at odd or both at even positions)"
      ],
      "categories": [
        "Hobby",
        "Job",
        "Music"
      ],
      "items": {
        "Hobby": [
          "card-games",
          "collecting",
          "rock-climbing"
        ],
        "Job": [
          "project-manager",
          "chef",
          "entrepreneur"
        ],
        "Music": [
          "folk",
          "soul",
          "r&b"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"card-games\", \"collecting\", \"rock-climbing\"], \"Job\": [\"project-manager\", \"chef\", \"entrepreneur\"], \"Music\": [\"folk\", \"soul\", \"r&b\"]}"
    },
    "puzzle_hash": "683a18a4926f3e4bd80fe1f729b21b2c",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Job\", \"Music\"]\n    items = {\n        \"Hobby\": [\"card-games\", \"collecting\", \"rock-climbing\"],\n        \"Job\": [\"project-manager\", \"chef\", \"entrepreneur\"],\n        \"Music\": [\"folk\", \"soul\", \"r&b\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: chef is to the right of card-games (not necessarily immediately)\n    problem.addConstraint(lambda chef, card_games: chef > card_games,\n                          [\"Job:chef\", \"Hobby:card-games\"])\n    \n    # Clue 2: soul music is to the left of r&b music (not necessarily immediately)\n    problem.addConstraint(lambda soul, rnb: soul < rnb,\n                          [\"Music:soul\", \"Music:r&b\"])\n    \n    # Clue 3: entrepreneur and r&b music are at positions with the same parity\n    problem.addConstraint(lambda entrepreneur, rnb: entrepreneur % 2 == rnb % 2,\n                          [\"Job:entrepreneur\", \"Music:r&b\"])\n    \n    # Clue 4: project-manager is to the left of entrepreneur (not necessarily immediately)\n    problem.addConstraint(lambda pm, entrepreneur: pm < entrepreneur,\n                          [\"Job:project-manager\", \"Job:entrepreneur\"])\n    \n    # Clue 5: project-manager and collecting are at positions with different parity\n    problem.addConstraint(lambda pm, collecting: (pm % 2) != (collecting % 2),\n                          [\"Job:project-manager\", \"Hobby:collecting\"])\n    \n    # Clue 6: entrepreneur and folk music are at positions with the same parity\n    problem.addConstraint(lambda entrepreneur, folk: entrepreneur % 2 == folk % 2,\n                          [\"Job:entrepreneur\", \"Music:folk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['card-games', 'collecting', 'rock-climbing'], 'Job': ['project-manager', 'chef', 'entrepreneur'], 'Music': ['folk', 'soul', 'r&b']}\n",
    "success": true,
    "execution_time": 0.002939,
    "timestamp": "20250918_093104",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['card-games', 'collecting', 'rock-climbing'], 'Job': ['project-manager', 'chef', 'entrepreneur'], 'Music': ['folk', 'soul', 'r&b']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_99",
    "puzzle": {
      "id": "simple_3x3_99",
      "title": "Einstein Puzzle simple_3x3_99 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.04483249999999983
      },
      "clues": [
        "the person who likes electronic music is to the right of the person who works as a videographer (not necessarily immediately)",
        "the person who has turtle as a pet is adjacent to the person who likes metal music (either immediately left or right)",
        "the person who likes metal music is to the left of the person who has rat as a pet (not necessarily immediately)",
        "the person who works as a accountant is directly between the person who likes trance music and the person who likes electronic music"
      ],
      "categories": [
        "Job",
        "Music",
        "Pet"
      ],
      "items": {
        "Job": [
          "videographer",
          "accountant",
          "musician"
        ],
        "Music": [
          "trance",
          "metal",
          "electronic"
        ],
        "Pet": [
          "turtle",
          "rabbit",
          "rat"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"videographer\", \"accountant\", \"musician\"], \"Music\": [\"trance\", \"metal\", \"electronic\"], \"Pet\": [\"turtle\", \"rabbit\", \"rat\"]}"
    },
    "puzzle_hash": "93d2b4fa1f1f1aac06623ace5f42f29c",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Music\", \"Pet\"]\n    items = {\n        \"Job\": [\"videographer\", \"accountant\", \"musician\"],\n        \"Music\": [\"trance\", \"metal\", \"electronic\"],\n        \"Pet\": [\"turtle\", \"rabbit\", \"rat\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: electronic music is to the right of videographer (not necessarily immediately)\n    problem.addConstraint(lambda e, v: e > v, [\"Music:electronic\", \"Job:videographer\"])\n    \n    # Clue 2: turtle pet is adjacent to metal music (immediately left or right)\n    problem.addConstraint(lambda t, m: abs(t - m) == 1, [\"Pet:turtle\", \"Music:metal\"])\n    \n    # Clue 3: metal music is to the left of rat pet (not necessarily immediately)\n    problem.addConstraint(lambda m, r: m < r, [\"Music:metal\", \"Pet:rat\"])\n    \n    # Clue 4: accountant is directly between trance and electronic music\n    # accountant position is between trance and electronic positions\n    problem.addConstraint(lambda a, t, e: (a == t + 1 and a == e - 1) or (a == e + 1 and a == t - 1),\n                          [\"Job:accountant\", \"Music:trance\", \"Music:electronic\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['videographer', 'accountant', 'musician'], 'Music': ['trance', 'metal', 'electronic'], 'Pet': ['turtle', 'rabbit', 'rat']}\n",
    "success": true,
    "execution_time": 0.002861,
    "timestamp": "20250918_094014",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['videographer', 'accountant', 'musician'], 'Music': ['trance', 'metal', 'electronic'], 'Pet': ['turtle', 'rabbit', 'rat']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_53",
    "puzzle": {
      "id": "simple_3x3_53",
      "title": "Einstein Puzzle simple_3x3_53 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.014016042000000173
      },
      "clues": [
        "the person who works as a journalist is at the same position as or to the left of the person who likes scientific movies",
        "the person who works as a accountant is at the same position as or to the left of the italian person",
        "the person who works as a journalist is adjacent to the italian person (either immediately left or right)",
        "the italian person is somewhere between the brazilian person and the person who works as a accountant (not necessarily immediately adjacent)",
        "the person who likes adventure movies and the person who works as a accountant are at positions with different parity (one at odd, one at even position)"
      ],
      "categories": [
        "Job",
        "Movie",
        "Nationality"
      ],
      "items": {
        "Job": [
          "accountant",
          "designer",
          "journalist"
        ],
        "Movie": [
          "fantasy",
          "adventure",
          "scientific"
        ],
        "Nationality": [
          "pakistani",
          "italian",
          "brazilian"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"accountant\", \"designer\", \"journalist\"], \"Movie\": [\"fantasy\", \"adventure\", \"scientific\"], \"Nationality\": [\"pakistani\", \"italian\", \"brazilian\"]}"
    },
    "puzzle_hash": "3590d043c3d1a8a0ab2fa036287baadc",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Movie\", \"Nationality\"]\n    items = {\n        \"Job\": [\"accountant\", \"designer\", \"journalist\"],\n        \"Movie\": [\"fantasy\", \"adventure\", \"scientific\"],\n        \"Nationality\": [\"pakistani\", \"italian\", \"brazilian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: journalist is at the same position as or to the left of scientific\n    problem.addConstraint(\n        lambda j, s: j <= s,\n        [\"Job:journalist\", \"Movie:scientific\"]\n    )\n    \n    # Clue 2: accountant is at the same position as or to the left of italian\n    problem.addConstraint(\n        lambda a, i: a <= i,\n        [\"Job:accountant\", \"Nationality:italian\"]\n    )\n    \n    # Clue 3: journalist is adjacent to italian (immediately left or right)\n    problem.addConstraint(\n        lambda j, i: abs(j - i) == 1,\n        [\"Job:journalist\", \"Nationality:italian\"]\n    )\n    \n    # Clue 4: italian is somewhere between brazilian and accountant (not necessarily immediately)\n    # Means italian position is strictly between brazilian and accountant positions\n    # So italian is greater than min(brazilian, accountant) and less than max(brazilian, accountant)\n    def italian_between(b, i, a):\n        return (b < i < a) or (a < i < b)\n    problem.addConstraint(\n        italian_between,\n        [\"Nationality:brazilian\", \"Nationality:italian\", \"Job:accountant\"]\n    )\n    \n    # Clue 5: adventure movie and accountant have different parity positions\n    problem.addConstraint(\n        lambda adv, acc: (adv % 2) != (acc % 2),\n        [\"Movie:adventure\", \"Job:accountant\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['accountant', 'designer', 'journalist'], 'Movie': ['fantasy', 'adventure', 'scientific'], 'Nationality': ['pakistani', 'italian', 'brazilian']}\n",
    "success": true,
    "execution_time": 0.002872,
    "timestamp": "20250918_093218",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['accountant', 'designer', 'journalist'], 'Movie': ['fantasy', 'adventure', 'scientific'], 'Nationality': ['pakistani', 'italian', 'brazilian']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_100",
    "puzzle": {
      "id": "simple_3x3_100",
      "title": "Einstein Puzzle simple_3x3_100 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.017991917000000024
      },
      "clues": [
        "the person who enjoys filmmaking is to the left of the person who likes 7up (not necessarily immediately)",
        "the person who enjoys dancing and the person who has lizard as a pet are at positions with the same parity (both at odd or both at even positions)",
        "the person who has lizard as a pet is directly between the person who likes water and the person who has pony as a pet",
        "the person who likes 7up is to the left of the person who likes iced-tea (not necessarily immediately)"
      ],
      "categories": [
        "Beverage",
        "Hobby",
        "Pet"
      ],
      "items": {
        "Beverage": [
          "water",
          "7up",
          "iced-tea"
        ],
        "Hobby": [
          "filmmaking",
          "dancing",
          "traveling"
        ],
        "Pet": [
          "mouse",
          "lizard",
          "pony"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"water\", \"7up\", \"iced-tea\"], \"Hobby\": [\"filmmaking\", \"dancing\", \"traveling\"], \"Pet\": [\"mouse\", \"lizard\", \"pony\"]}"
    },
    "puzzle_hash": "68c1b48a4cf60650d42e7f8815ba3cce",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Hobby\", \"Pet\"]\n    items = {\n        \"Beverage\": [\"water\", \"7up\", \"iced-tea\"],\n        \"Hobby\": [\"filmmaking\", \"dancing\", \"traveling\"],\n        \"Pet\": [\"mouse\", \"lizard\", \"pony\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys filmmaking is to the left of the person who likes 7up (not necessarily immediately)\n    problem.addConstraint(lambda filmmaking, sevenup: filmmaking < sevenup,\n                          [\"Hobby:filmmaking\", \"Beverage:7up\"])\n    \n    # Clue 2: the person who enjoys dancing and the person who has lizard as a pet are at positions with the same parity\n    problem.addConstraint(lambda dancing, lizard: dancing % 2 == lizard % 2,\n                          [\"Hobby:dancing\", \"Pet:lizard\"])\n    \n    # Clue 3: the person who has lizard as a pet is directly between the person who likes water and the person who has pony as a pet\n    problem.addConstraint(lambda lizard, water, pony: (lizard == water + 1 and lizard == pony - 1) or (lizard == pony + 1 and lizard == water - 1),\n                          [\"Pet:lizard\", \"Beverage:water\", \"Pet:pony\"])\n    \n    # Clue 4: the person who likes 7up is to the left of the person who likes iced-tea (not necessarily immediately)\n    problem.addConstraint(lambda sevenup, iced_tea: sevenup < iced_tea,\n                          [\"Beverage:7up\", \"Beverage:iced-tea\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['water', '7up', 'iced-tea'], 'Hobby': ['filmmaking', 'dancing', 'traveling'], 'Pet': ['mouse', 'lizard', 'pony']}\n",
    "success": true,
    "execution_time": 0.002743,
    "timestamp": "20250918_094024",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['water', '7up', 'iced-tea'], 'Hobby': ['filmmaking', 'dancing', 'traveling'], 'Pet': ['mouse', 'lizard', 'pony']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_13",
    "puzzle": {
      "id": "simple_3x3_13",
      "title": "Einstein Puzzle simple_3x3_13 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.015321917000000018
      },
      "clues": [
        "the person who uses scooter for transportation is at the same position as or to the right of the person who uses boat for transportation",
        "the person who plays skateboarding is somewhere between the person who plays basketball and the person who works as a coach (not necessarily immediately adjacent)",
        "the person who uses boat for transportation is to the right of the person who plays cycling (not necessarily immediately)",
        "the person who works as a manager is to the right of the person who uses boat for transportation (not necessarily immediately)"
      ],
      "categories": [
        "Job",
        "Sport",
        "Transport"
      ],
      "items": {
        "Job": [
          "coach",
          "musician",
          "manager"
        ],
        "Sport": [
          "cycling",
          "skateboarding",
          "basketball"
        ],
        "Transport": [
          "tram",
          "boat",
          "scooter"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"coach\", \"musician\", \"manager\"], \"Sport\": [\"cycling\", \"skateboarding\", \"basketball\"], \"Transport\": [\"tram\", \"boat\", \"scooter\"]}"
    },
    "puzzle_hash": "b1f3ab94bbb7f8915dcfc3edeb4d4ed9",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Sport\", \"Transport\"]\n    items = {\n        \"Job\": [\"coach\", \"musician\", \"manager\"],\n        \"Sport\": [\"cycling\", \"skateboarding\", \"basketball\"],\n        \"Transport\": [\"tram\", \"boat\", \"scooter\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses scooter for transportation is at the same position as or to the right of the person who uses boat for transportation\n    problem.addConstraint(lambda scooter, boat: scooter >= boat, [\"Transport:scooter\", \"Transport:boat\"])\n    \n    # Clue 2: the person who plays skateboarding is somewhere between the person who plays basketball and the person who works as a coach (not necessarily immediately adjacent)\n    # This means skateboarding position is strictly between basketball and coach positions\n    def skateboarding_between(basketball, coach, skateboarding):\n        return (basketball < skateboarding < coach) or (coach < skateboarding < basketball)\n    problem.addConstraint(skateboarding_between, [\"Sport:basketball\", \"Job:coach\", \"Sport:skateboarding\"])\n    \n    # Clue 3: the person who uses boat for transportation is to the right of the person who plays cycling (not necessarily immediately)\n    problem.addConstraint(lambda boat, cycling: boat > cycling, [\"Transport:boat\", \"Sport:cycling\"])\n    \n    # Clue 4: the person who works as a manager is to the right of the person who uses boat for transportation (not necessarily immediately)\n    problem.addConstraint(lambda manager, boat: manager > boat, [\"Job:manager\", \"Transport:boat\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['coach', 'musician', 'manager'], 'Sport': ['cycling', 'skateboarding', 'basketball'], 'Transport': ['tram', 'boat', 'scooter']}\n",
    "success": true,
    "execution_time": 0.003217,
    "timestamp": "20250918_092540",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['coach', 'musician', 'manager'], 'Sport': ['cycling', 'skateboarding', 'basketball'], 'Transport': ['tram', 'boat', 'scooter']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_39",
    "puzzle": {
      "id": "simple_3x3_39",
      "title": "Einstein Puzzle simple_3x3_39 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.0055840830000000174
      },
      "clues": [
        "the person who works as a musician is to the left of the person who likes documentary movies (not necessarily immediately)",
        "the person who likes nectarine is to the left of the person who likes papaya (not necessarily immediately)",
        "the person who likes thriller movies and the person who works as a musician are at positions with the same parity (both at odd or both at even positions)",
        "the person who likes zucchini is somewhere between the person who likes documentary movies and the person who works as a doctor (not necessarily immediately adjacent)"
      ],
      "categories": [
        "Food",
        "Job",
        "Movie"
      ],
      "items": {
        "Food": [
          "nectarine",
          "zucchini",
          "papaya"
        ],
        "Job": [
          "doctor",
          "musician",
          "analyst"
        ],
        "Movie": [
          "animation",
          "thriller",
          "documentary"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"nectarine\", \"zucchini\", \"papaya\"], \"Job\": [\"doctor\", \"musician\", \"analyst\"], \"Movie\": [\"animation\", \"thriller\", \"documentary\"]}"
    },
    "puzzle_hash": "51bccee203c741b9692ff527a7265e50",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Job\", \"Movie\"]\n    items = {\n        \"Food\": [\"nectarine\", \"zucchini\", \"papaya\"],\n        \"Job\": [\"doctor\", \"musician\", \"analyst\"],\n        \"Movie\": [\"animation\", \"thriller\", \"documentary\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: musician is to the left of documentary\n    problem.addConstraint(lambda m, d: m < d, [\"Job:musician\", \"Movie:documentary\"])\n    \n    # Clue 2: nectarine is to the left of papaya\n    problem.addConstraint(lambda n, p: n < p, [\"Food:nectarine\", \"Food:papaya\"])\n    \n    # Clue 3: thriller and musician have same parity\n    problem.addConstraint(lambda t, m: t % 2 == m % 2, [\"Movie:thriller\", \"Job:musician\"])\n    \n    # Clue 4: zucchini is between documentary and doctor (not necessarily adjacent)\n    # So zucchini position is strictly between documentary and doctor positions\n    def zucchini_between(doc, docr, zuc):\n        return (doc < zuc < docr) or (docr < zuc < doc)\n    problem.addConstraint(zucchini_between, [\"Movie:documentary\", \"Job:doctor\", \"Food:zucchini\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['nectarine', 'zucchini', 'papaya'], 'Job': ['doctor', 'musician', 'analyst'], 'Movie': ['animation', 'thriller', 'documentary']}\n",
    "success": true,
    "execution_time": 0.002925,
    "timestamp": "20250918_093002",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['nectarine', 'zucchini', 'papaya'], 'Job': ['doctor', 'musician', 'analyst'], 'Movie': ['animation', 'thriller', 'documentary']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_24",
    "puzzle": {
      "id": "simple_3x3_24",
      "title": "Einstein Puzzle simple_3x3_24 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.008799374999999998
      },
      "clues": [
        "the person who likes action movies is directly between the person who enjoys card-games and the person who enjoys skydiving",
        "the person who plays volleyball is to the right of the person who plays badminton (not necessarily immediately)",
        "the person who plays tennis is somewhere between the person who enjoys skydiving and the person who plays badminton (not necessarily immediately adjacent)",
        "the person who plays tennis is to the right of the person who likes romance movies (not necessarily immediately)"
      ],
      "categories": [
        "Hobby",
        "Movie",
        "Sport"
      ],
      "items": {
        "Hobby": [
          "card-games",
          "traveling",
          "skydiving"
        ],
        "Movie": [
          "romance",
          "action",
          "comedy"
        ],
        "Sport": [
          "badminton",
          "tennis",
          "volleyball"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"card-games\", \"traveling\", \"skydiving\"], \"Movie\": [\"romance\", \"action\", \"comedy\"], \"Sport\": [\"badminton\", \"tennis\", \"volleyball\"]}"
    },
    "puzzle_hash": "915761fb0015710ef8d93b0290bc02bf",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Movie\", \"Sport\"]\n    items = {\n        \"Hobby\": [\"card-games\", \"traveling\", \"skydiving\"],\n        \"Movie\": [\"romance\", \"action\", \"comedy\"],\n        \"Sport\": [\"badminton\", \"tennis\", \"volleyball\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes action movies is directly between the person who enjoys card-games and the person who enjoys skydiving\n    problem.addConstraint(\n        lambda action, card, skydiving: (action == card + 1 and action == skydiving - 1) or (action == skydiving + 1 and action == card - 1),\n        [\"Movie:action\", \"Hobby:card-games\", \"Hobby:skydiving\"]\n    )\n    \n    # Clue 2: the person who plays volleyball is to the right of the person who plays badminton (not necessarily immediately)\n    problem.addConstraint(\n        lambda volleyball, badminton: volleyball > badminton,\n        [\"Sport:volleyball\", \"Sport:badminton\"]\n    )\n    \n    # Clue 3: the person who plays tennis is somewhere between the person who enjoys skydiving and the person who plays badminton (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda tennis, skydiving, badminton: (skydiving < tennis < badminton) or (badminton < tennis < skydiving),\n        [\"Sport:tennis\", \"Hobby:skydiving\", \"Sport:badminton\"]\n    )\n    \n    # Clue 4: the person who plays tennis is to the right of the person who likes romance movies (not necessarily immediately)\n    problem.addConstraint(\n        lambda tennis, romance: tennis > romance,\n        [\"Sport:tennis\", \"Movie:romance\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['card-games', 'traveling', 'skydiving'], 'Movie': ['romance', 'action', 'comedy'], 'Sport': ['badminton', 'tennis', 'volleyball']}\n",
    "success": true,
    "execution_time": 0.002957,
    "timestamp": "20250918_092732",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['card-games', 'traveling', 'skydiving'], 'Movie': ['romance', 'action', 'comedy'], 'Sport': ['badminton', 'tennis', 'volleyball']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_42",
    "puzzle": {
      "id": "simple_3x3_42",
      "title": "Einstein Puzzle simple_3x3_42 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.012682583000000025
      },
      "clues": [
        "the person who likes reggae music is somewhere between the person who works as a architect and the person who likes d&b music (not necessarily immediately adjacent)",
        "the malaysian person is adjacent to the person who works as a architect (either immediately left or right)",
        "the australian person is at the same position as or to the right of the person who works as a analyst",
        "the person who likes reggae music is to the left of the person who likes d&b music (not necessarily immediately)",
        "the person who likes salsa music is adjacent to the person who works as a social-worker (either immediately left or right)"
      ],
      "categories": [
        "Job",
        "Music",
        "Nationality"
      ],
      "items": {
        "Job": [
          "architect",
          "social-worker",
          "analyst"
        ],
        "Music": [
          "salsa",
          "reggae",
          "d&b"
        ],
        "Nationality": [
          "french",
          "malaysian",
          "australian"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"architect\", \"social-worker\", \"analyst\"], \"Music\": [\"salsa\", \"reggae\", \"d&b\"], \"Nationality\": [\"french\", \"malaysian\", \"australian\"]}"
    },
    "puzzle_hash": "ed6f665c39681cf16118037d72746b62",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Music\", \"Nationality\"]\n    items = {\n        \"Job\": [\"architect\", \"social-worker\", \"analyst\"],\n        \"Music\": [\"salsa\", \"reggae\", \"d&b\"],\n        \"Nationality\": [\"french\", \"malaysian\", \"australian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes reggae music is somewhere between the person who works as an architect and the person who likes d&b music (not necessarily immediately adjacent)\n    # This means reggae position is strictly between architect and d&b positions\n    problem.addConstraint(\n        lambda reggae, architect, dnb: (architect < reggae < dnb) or (dnb < reggae < architect),\n        [\"Music:reggae\", \"Job:architect\", \"Music:d&b\"]\n    )\n    \n    # Clue 2: the malaysian person is adjacent to the person who works as an architect (either immediately left or right)\n    problem.addConstraint(\n        lambda malaysian, architect: abs(malaysian - architect) == 1,\n        [\"Nationality:malaysian\", \"Job:architect\"]\n    )\n    \n    # Clue 3: the australian person is at the same position as or to the right of the person who works as an analyst\n    problem.addConstraint(\n        lambda australian, analyst: australian >= analyst,\n        [\"Nationality:australian\", \"Job:analyst\"]\n    )\n    \n    # Clue 4: the person who likes reggae music is to the left of the person who likes d&b music (not necessarily immediately)\n    problem.addConstraint(\n        lambda reggae, dnb: reggae < dnb,\n        [\"Music:reggae\", \"Music:d&b\"]\n    )\n    \n    # Clue 5: the person who likes salsa music is adjacent to the person who works as a social-worker (either immediately left or right)\n    problem.addConstraint(\n        lambda salsa, social_worker: abs(salsa - social_worker) == 1,\n        [\"Music:salsa\", \"Job:social-worker\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['architect', 'social-worker', 'analyst'], 'Music': ['salsa', 'reggae', 'd&b'], 'Nationality': ['french', 'malaysian', 'australian']}\n",
    "success": true,
    "execution_time": 0.001651,
    "timestamp": "20250918_093034",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['architect', 'social-worker', 'analyst'], 'Music': ['salsa', 'reggae', 'd&b'], 'Nationality': ['french', 'malaysian', 'australian']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_43",
    "puzzle": {
      "id": "simple_3x3_43",
      "title": "Einstein Puzzle simple_3x3_43 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.019283041999999972
      },
      "clues": [
        "the person who has guinea-pig as a pet is directly between the person who likes pumpkin and the person who uses helicopter for transportation",
        "the person who has chinchilla as a pet is to the left of the person who has cat as a pet (not necessarily immediately)",
        "the person who likes pear is to the right of the person who likes grapefruit (not necessarily immediately)",
        "the person who likes pumpkin is to the left of the person who uses train for transportation (not necessarily immediately)"
      ],
      "categories": [
        "Food",
        "Pet",
        "Transport"
      ],
      "items": {
        "Food": [
          "pumpkin",
          "grapefruit",
          "pear"
        ],
        "Pet": [
          "chinchilla",
          "guinea-pig",
          "cat"
        ],
        "Transport": [
          "motorbike",
          "train",
          "helicopter"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"pumpkin\", \"grapefruit\", \"pear\"], \"Pet\": [\"chinchilla\", \"guinea-pig\", \"cat\"], \"Transport\": [\"motorbike\", \"train\", \"helicopter\"]}"
    },
    "puzzle_hash": "99c26a711a0740d8e7fde703263a0c44",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Pet\", \"Transport\"]\n    items = {\n        \"Food\": [\"pumpkin\", \"grapefruit\", \"pear\"],\n        \"Pet\": [\"chinchilla\", \"guinea-pig\", \"cat\"],\n        \"Transport\": [\"motorbike\", \"train\", \"helicopter\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who has guinea-pig as a pet is directly between the person who likes pumpkin and the person who uses helicopter for transportation\n    problem.addConstraint(\n        lambda guinea_pig, pumpkin, helicopter: (guinea_pig == pumpkin + 1 and guinea_pig == helicopter - 1) or (guinea_pig == helicopter + 1 and guinea_pig == pumpkin - 1),\n        [\"Pet:guinea-pig\", \"Food:pumpkin\", \"Transport:helicopter\"]\n    )\n    \n    # Clue 2: the person who has chinchilla as a pet is to the left of the person who has cat as a pet (not necessarily immediately)\n    problem.addConstraint(\n        lambda chinchilla, cat: chinchilla < cat,\n        [\"Pet:chinchilla\", \"Pet:cat\"]\n    )\n    \n    # Clue 3: the person who likes pear is to the right of the person who likes grapefruit (not necessarily immediately)\n    problem.addConstraint(\n        lambda pear, grapefruit: pear > grapefruit,\n        [\"Food:pear\", \"Food:grapefruit\"]\n    )\n    \n    # Clue 4: the person who likes pumpkin is to the left of the person who uses train for transportation (not necessarily immediately)\n    problem.addConstraint(\n        lambda pumpkin, train: pumpkin < train,\n        [\"Food:pumpkin\", \"Transport:train\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['pumpkin', 'grapefruit', 'pear'], 'Pet': ['chinchilla', 'guinea-pig', 'cat'], 'Transport': ['motorbike', 'train', 'helicopter']}\n",
    "success": true,
    "execution_time": 0.00283,
    "timestamp": "20250918_093043",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['pumpkin', 'grapefruit', 'pear'], 'Pet': ['chinchilla', 'guinea-pig', 'cat'], 'Transport': ['motorbike', 'train', 'helicopter']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_19",
    "puzzle": {
      "id": "simple_3x3_19",
      "title": "Einstein Puzzle simple_3x3_19 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.014170542000000008
      },
      "clues": [
        "the person who likes papaya is directly between the person who works as a social-worker and the person who works as a mechanic",
        "the person who has horse as a pet is to the right of the person who has ferret as a pet (not necessarily immediately)",
        "the person who works as a social-worker is a different person than the person who likes tomato",
        "the person who has snake as a pet is the same person as the person who likes pineapple or the person who works as a social-worker is the same person as the person who has snake as a pet or both",
        "the person who works as a coach is at the same position as or to the right of the person who likes tomato"
      ],
      "categories": [
        "Food",
        "Job",
        "Pet"
      ],
      "items": {
        "Food": [
          "tomato",
          "papaya",
          "pineapple"
        ],
        "Job": [
          "mechanic",
          "coach",
          "social-worker"
        ],
        "Pet": [
          "ferret",
          "horse",
          "snake"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"tomato\", \"papaya\", \"pineapple\"], \"Job\": [\"mechanic\", \"coach\", \"social-worker\"], \"Pet\": [\"ferret\", \"horse\", \"snake\"]}"
    },
    "puzzle_hash": "223ba0242598199abb794cb43c1a8fcd",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Job\", \"Pet\"]\n    items = {\n        \"Food\": [\"tomato\", \"papaya\", \"pineapple\"],\n        \"Job\": [\"mechanic\", \"coach\", \"social-worker\"],\n        \"Pet\": [\"ferret\", \"horse\", \"snake\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes papaya is directly between the person who works as a social-worker and the person who works as a mechanic\n    problem.addConstraint(\n        lambda papaya, social_worker, mechanic: (papaya == social_worker + 1 and papaya == mechanic - 1) or (papaya == mechanic + 1 and papaya == social_worker - 1),\n        [\"Food:papaya\", \"Job:social-worker\", \"Job:mechanic\"]\n    )\n    \n    # Clue 2: the person who has horse as a pet is to the right of the person who has ferret as a pet (not necessarily immediately)\n    problem.addConstraint(\n        lambda horse, ferret: horse > ferret,\n        [\"Pet:horse\", \"Pet:ferret\"]\n    )\n    \n    # Clue 3: the person who works as a social-worker is a different person than the person who likes tomato\n    problem.addConstraint(\n        lambda social_worker, tomato: social_worker != tomato,\n        [\"Job:social-worker\", \"Food:tomato\"]\n    )\n    \n    # Clue 4: the person who has snake as a pet is the same person as the person who likes pineapple or the person who works as a social-worker is the same person as the person who has snake as a pet or both\n    problem.addConstraint(\n        lambda snake, pineapple, social_worker: (snake == pineapple) or (social_worker == snake),\n        [\"Pet:snake\", \"Food:pineapple\", \"Job:social-worker\"]\n    )\n    \n    # Clue 5: the person who works as a coach is at the same position as or to the right of the person who likes tomato\n    problem.addConstraint(\n        lambda coach, tomato: coach >= tomato,\n        [\"Job:coach\", \"Food:tomato\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['tomato', 'papaya', 'pineapple'], 'Job': ['mechanic', 'coach', 'social-worker'], 'Pet': ['ferret', 'horse', 'snake']}\n",
    "success": true,
    "execution_time": 0.002886,
    "timestamp": "20250918_092641",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['tomato', 'papaya', 'pineapple'], 'Job': ['mechanic', 'coach', 'social-worker'], 'Pet': ['ferret', 'horse', 'snake']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_67",
    "puzzle": {
      "id": "simple_3x3_67",
      "title": "Einstein Puzzle simple_3x3_67 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.01569166700000002
      },
      "clues": [
        "the person who uses van for transportation is to the right of the person who likes trance music (not necessarily immediately)",
        "the person who uses tram for transportation is at an even-numbered position",
        "the person who likes superhero movies is adjacent to the person who likes drama movies (either immediately left or right)",
        "the person who uses motorbike for transportation and the person who likes funk music are at positions with the same parity (both at odd or both at even positions)",
        "the person who likes trance music is a different person than the person who likes drama movies",
        "the person who likes funk music is to the left of the person who likes drama movies (not necessarily immediately)"
      ],
      "categories": [
        "Movie",
        "Music",
        "Transport"
      ],
      "items": {
        "Movie": [
          "mystery",
          "superhero",
          "drama"
        ],
        "Music": [
          "funk",
          "trance",
          "folk"
        ],
        "Transport": [
          "motorbike",
          "tram",
          "van"
        ]
      },
      "ground_truth_solution": "{\"Movie\": [\"mystery\", \"superhero\", \"drama\"], \"Music\": [\"funk\", \"trance\", \"folk\"], \"Transport\": [\"motorbike\", \"tram\", \"van\"]}"
    },
    "puzzle_hash": "18a78310c67302a242a0f9423de84bfa",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Music\", \"Transport\"]\n    items = {\n        \"Movie\": [\"mystery\", \"superhero\", \"drama\"],\n        \"Music\": [\"funk\", \"trance\", \"folk\"],\n        \"Transport\": [\"motorbike\", \"tram\", \"van\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses van for transportation is to the right of the person who likes trance music (not necessarily immediately)\n    problem.addConstraint(lambda van, trance: van > trance, [\"Transport:van\", \"Music:trance\"])\n    \n    # Clue 2: the person who uses tram for transportation is at an even-numbered position\n    problem.addConstraint(lambda tram: tram % 2 == 0, [\"Transport:tram\"])\n    \n    # Clue 3: the person who likes superhero movies is adjacent to the person who likes drama movies (either immediately left or right)\n    problem.addConstraint(lambda superhero, drama: abs(superhero - drama) == 1, [\"Movie:superhero\", \"Movie:drama\"])\n    \n    # Clue 4: the person who uses motorbike for transportation and the person who likes funk music are at positions with the same parity (both at odd or both at even positions)\n    problem.addConstraint(lambda motorbike, funk: motorbike % 2 == funk % 2, [\"Transport:motorbike\", \"Music:funk\"])\n    \n    # Clue 5: the person who likes trance music is a different person than the person who likes drama movies\n    problem.addConstraint(lambda trance, drama: trance != drama, [\"Music:trance\", \"Movie:drama\"])\n    \n    # Clue 6: the person who likes funk music is to the left of the person who likes drama movies (not necessarily immediately)\n    problem.addConstraint(lambda funk, drama: funk < drama, [\"Music:funk\", \"Movie:drama\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Movie': ['mystery', 'superhero', 'drama'], 'Music': ['trance', 'funk', 'folk'], 'Transport': ['tram', 'motorbike', 'van']}\n",
    "success": true,
    "execution_time": 0.002809,
    "timestamp": "20250918_093443",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Movie': ['mystery', 'superhero', 'drama'], 'Music': ['funk', 'trance', 'folk'], 'Transport': ['motorbike', 'tram', 'van']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_76",
    "puzzle": {
      "id": "simple_3x3_76",
      "title": "Einstein Puzzle simple_3x3_76 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.020647708000000042
      },
      "clues": [
        "the person who uses snowmobile for transportation is adjacent to the person who works as a police-officer (either immediately left or right)",
        "the person who works as a paramedic is to the left of the person who works as a police-officer (not necessarily immediately)",
        "the person who works as a paramedic and the person who likes action movies are at positions with the same parity (both at odd or both at even positions)",
        "the person who likes satire movies is adjacent to the person who works as a entrepreneur (either immediately left or right)",
        "the person who likes action movies is to the right of the person who uses snowmobile for transportation (not necessarily immediately)",
        "the person who uses bus for transportation is adjacent to the person who likes satire movies (either immediately left or right)"
      ],
      "categories": [
        "Job",
        "Movie",
        "Transport"
      ],
      "items": {
        "Job": [
          "paramedic",
          "police-officer",
          "entrepreneur"
        ],
        "Movie": [
          "family",
          "satire",
          "action"
        ],
        "Transport": [
          "snowmobile",
          "boat",
          "bus"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"paramedic\", \"police-officer\", \"entrepreneur\"], \"Movie\": [\"family\", \"satire\", \"action\"], \"Transport\": [\"snowmobile\", \"boat\", \"bus\"]}"
    },
    "puzzle_hash": "ddcc72276521d8e5a485015f75b9db0c",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Movie\", \"Transport\"]\n    items = {\n        \"Job\": [\"paramedic\", \"police-officer\", \"entrepreneur\"],\n        \"Movie\": [\"family\", \"satire\", \"action\"],\n        \"Transport\": [\"snowmobile\", \"boat\", \"bus\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: snowmobile adjacent to police-officer\n    problem.addConstraint(lambda x, y: abs(x - y) == 1, [\"Transport:snowmobile\", \"Job:police-officer\"])\n    \n    # Clue 2: paramedic is to the left of police-officer (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x < y, [\"Job:paramedic\", \"Job:police-officer\"])\n    \n    # Clue 3: paramedic and action movies have same parity\n    problem.addConstraint(lambda x, y: x % 2 == y % 2, [\"Job:paramedic\", \"Movie:action\"])\n    \n    # Clue 4: satire movies adjacent to entrepreneur\n    problem.addConstraint(lambda x, y: abs(x - y) == 1, [\"Movie:satire\", \"Job:entrepreneur\"])\n    \n    # Clue 5: action movies is to the right of snowmobile (not necessarily immediately)\n    problem.addConstraint(lambda x, y: y < x, [\"Transport:snowmobile\", \"Movie:action\"])\n    \n    # Clue 6: bus adjacent to satire movies\n    problem.addConstraint(lambda x, y: abs(x - y) == 1, [\"Transport:bus\", \"Movie:satire\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['paramedic', 'police-officer', 'entrepreneur'], 'Movie': ['action', 'satire', 'family'], 'Transport': ['bus', 'boat', 'snowmobile']}\n",
    "success": true,
    "execution_time": 0.002915,
    "timestamp": "20250918_093617",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['paramedic', 'police-officer', 'entrepreneur'], 'Movie': ['family', 'satire', 'action'], 'Transport': ['snowmobile', 'boat', 'bus']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_60",
    "puzzle": {
      "id": "simple_3x3_60",
      "title": "Einstein Puzzle simple_3x3_60 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.02075379200000005
      },
      "clues": [
        "the person who likes sprite is at an odd-numbered position",
        "the person who likes cola and the person who likes jazz music are at positions with the same parity (both at odd or both at even positions)",
        "the person who works as a accountant is at the same position as or to the right of the person who likes jazz music",
        "the person who likes salsa music is somewhere between the person who likes funk music and the person who works as a software-developer (not necessarily immediately adjacent)",
        "the person who likes funk music and the person who works as a lawyer are at positions with the same parity (both at odd or both at even positions)",
        "the person who likes sprite is at the same position as or to the left of the person who likes hot-chocolate"
      ],
      "categories": [
        "Beverage",
        "Job",
        "Music"
      ],
      "items": {
        "Beverage": [
          "sprite",
          "hot-chocolate",
          "cola"
        ],
        "Job": [
          "software-developer",
          "accountant",
          "lawyer"
        ],
        "Music": [
          "jazz",
          "salsa",
          "funk"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"sprite\", \"hot-chocolate\", \"cola\"], \"Job\": [\"software-developer\", \"accountant\", \"lawyer\"], \"Music\": [\"jazz\", \"salsa\", \"funk\"]}"
    },
    "puzzle_hash": "796abd463c4aa5a749c280253d3ea81a",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Job\", \"Music\"]\n    items = {\n        \"Beverage\": [\"sprite\", \"hot-chocolate\", \"cola\"],\n        \"Job\": [\"software-developer\", \"accountant\", \"lawyer\"],\n        \"Music\": [\"jazz\", \"salsa\", \"funk\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes sprite is at an odd-numbered position\n    problem.addConstraint(lambda x: x % 2 == 0, [\"Beverage:sprite\"])  # positions 0,2 are odd-numbered in puzzle? No, puzzle says 1-indexed, so odd positions are 1 and 3, zero-indexed 0 and 2\n    \n    # Clue 2: the person who likes cola and the person who likes jazz music are at positions with the same parity\n    problem.addConstraint(lambda x, y: x % 2 == y % 2, [\"Beverage:cola\", \"Music:jazz\"])\n    \n    # Clue 3: the person who works as an accountant is at the same position as or to the right of the person who likes jazz music\n    problem.addConstraint(lambda x, y: x >= y, [\"Job:accountant\", \"Music:jazz\"])\n    \n    # Clue 4: the person who likes salsa music is somewhere between the person who likes funk music and the person who works as a software-developer (not necessarily immediately adjacent)\n    problem.addConstraint(lambda salsa, funk, software: (funk < salsa < software) or (software < salsa < funk), [\"Music:salsa\", \"Music:funk\", \"Job:software-developer\"])\n    \n    # Clue 5: the person who likes funk music and the person who works as a lawyer are at positions with the same parity\n    problem.addConstraint(lambda x, y: x % 2 == y % 2, [\"Music:funk\", \"Job:lawyer\"])\n    \n    # Clue 6: the person who likes sprite is at the same position as or to the left of the person who likes hot-chocolate\n    problem.addConstraint(lambda x, y: x <= y, [\"Beverage:sprite\", \"Beverage:hot-chocolate\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['sprite', 'hot-chocolate', 'cola'], 'Job': ['software-developer', 'accountant', 'lawyer'], 'Music': ['jazz', 'salsa', 'funk']}\n",
    "success": true,
    "execution_time": 0.003293,
    "timestamp": "20250918_093333",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['sprite', 'hot-chocolate', 'cola'], 'Job': ['software-developer', 'accountant', 'lawyer'], 'Music': ['jazz', 'salsa', 'funk']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_8",
    "puzzle": {
      "id": "simple_3x3_8",
      "title": "Einstein Puzzle simple_3x3_8 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.009880917000000017
      },
      "clues": [
        "the person who likes artichoke is somewhere between the person who likes garlic and the person who likes cucumber (not necessarily immediately adjacent)",
        "the person who enjoys gardening and the person who likes animation movies are at positions with different parity (one at odd, one at even position)",
        "the person who likes cucumber is at the same position as or to the left of the person who likes drama movies",
        "the person who enjoys cooking is at the same position as or to the left of the person who enjoys gardening",
        "the person who likes cucumber is to the right of the person who enjoys gardening (not necessarily immediately)"
      ],
      "categories": [
        "Food",
        "Hobby",
        "Movie"
      ],
      "items": {
        "Food": [
          "garlic",
          "artichoke",
          "cucumber"
        ],
        "Hobby": [
          "cooking",
          "gardening",
          "writing"
        ],
        "Movie": [
          "animation",
          "disaster",
          "drama"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"garlic\", \"artichoke\", \"cucumber\"], \"Hobby\": [\"cooking\", \"gardening\", \"writing\"], \"Movie\": [\"animation\", \"disaster\", \"drama\"]}"
    },
    "puzzle_hash": "5eb89590a26cbf61b99d8cfd12319549",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Hobby\", \"Movie\"]\n    items = {\n        \"Food\": [\"garlic\", \"artichoke\", \"cucumber\"],\n        \"Hobby\": [\"cooking\", \"gardening\", \"writing\"],\n        \"Movie\": [\"animation\", \"disaster\", \"drama\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes artichoke is somewhere between the person who likes garlic and the person who likes cucumber (not necessarily immediately adjacent)\n    # This means position of artichoke is strictly between garlic and cucumber\n    problem.addConstraint(\n        lambda art, gar, cuc: (gar < art < cuc) or (cuc < art < gar),\n        [\"Food:artichoke\", \"Food:garlic\", \"Food:cucumber\"]\n    )\n    \n    # Clue 2: the person who enjoys gardening and the person who likes animation movies are at positions with different parity (one at odd, one at even position)\n    problem.addConstraint(\n        lambda gar, ani: (gar % 2) != (ani % 2),\n        [\"Hobby:gardening\", \"Movie:animation\"]\n    )\n    \n    # Clue 3: the person who likes cucumber is at the same position as or to the left of the person who likes drama movies\n    problem.addConstraint(\n        lambda cuc, dra: cuc <= dra,\n        [\"Food:cucumber\", \"Movie:drama\"]\n    )\n    \n    # Clue 4: the person who enjoys cooking is at the same position as or to the left of the person who enjoys gardening\n    problem.addConstraint(\n        lambda cook, gar: cook <= gar,\n        [\"Hobby:cooking\", \"Hobby:gardening\"]\n    )\n    \n    # Clue 5: the person who likes cucumber is to the right of the person who enjoys gardening (not necessarily immediately)\n    problem.addConstraint(\n        lambda gar, cuc: gar < cuc,\n        [\"Hobby:gardening\", \"Food:cucumber\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['garlic', 'artichoke', 'cucumber'], 'Hobby': ['cooking', 'gardening', 'writing'], 'Movie': ['animation', 'disaster', 'drama']}\n",
    "success": true,
    "execution_time": 0.002722,
    "timestamp": "20250918_092435",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['garlic', 'artichoke', 'cucumber'], 'Hobby': ['cooking', 'gardening', 'writing'], 'Movie': ['animation', 'disaster', 'drama']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_37",
    "puzzle": {
      "id": "simple_3x3_37",
      "title": "Einstein Puzzle simple_3x3_37 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.009652374999999935
      },
      "clues": [
        "the person who likes action movies is at the same position as or to the right of the polish person",
        "the person who has mouse as a pet is somewhere between the person who has bird as a pet and the american person (not necessarily immediately adjacent)",
        "the polish person is a different person than the person who likes action movies",
        "the american person is to the left of the person who likes fantasy movies (not necessarily immediately)"
      ],
      "categories": [
        "Movie",
        "Nationality",
        "Pet"
      ],
      "items": {
        "Movie": [
          "horror",
          "fantasy",
          "action"
        ],
        "Nationality": [
          "american",
          "polish",
          "brazilian"
        ],
        "Pet": [
          "guinea-pig",
          "mouse",
          "bird"
        ]
      },
      "ground_truth_solution": "{\"Movie\": [\"horror\", \"fantasy\", \"action\"], \"Nationality\": [\"american\", \"polish\", \"brazilian\"], \"Pet\": [\"guinea-pig\", \"mouse\", \"bird\"]}"
    },
    "puzzle_hash": "12b2f02d58c565778bd169f3c1630eaa",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Nationality\", \"Pet\"]\n    items = {\n        \"Movie\": [\"horror\", \"fantasy\", \"action\"],\n        \"Nationality\": [\"american\", \"polish\", \"brazilian\"],\n        \"Pet\": [\"guinea-pig\", \"mouse\", \"bird\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes action movies is at the same position as or to the right of the polish person\n    problem.addConstraint(lambda action_pos, polish_pos: action_pos >= polish_pos,\n                          [\"Movie:action\", \"Nationality:polish\"])\n    \n    # Clue 2: the person who has mouse as a pet is somewhere between the person who has bird as a pet and the american person (not necessarily immediately adjacent)\n    # This means mouse_pos is strictly between bird_pos and american_pos\n    def mouse_between(bird_pos, mouse_pos, american_pos):\n        return (bird_pos < mouse_pos < american_pos) or (american_pos < mouse_pos < bird_pos)\n    problem.addConstraint(mouse_between, [\"Pet:bird\", \"Pet:mouse\", \"Nationality:american\"])\n    \n    # Clue 3: the polish person is a different person than the person who likes action movies\n    problem.addConstraint(lambda polish_pos, action_pos: polish_pos != action_pos,\n                          [\"Nationality:polish\", \"Movie:action\"])\n    \n    # Clue 4: the american person is to the left of the person who likes fantasy movies (not necessarily immediately)\n    problem.addConstraint(lambda american_pos, fantasy_pos: american_pos < fantasy_pos,\n                          [\"Nationality:american\", \"Movie:fantasy\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Movie': ['horror', 'fantasy', 'action'], 'Nationality': ['american', 'polish', 'brazilian'], 'Pet': ['guinea-pig', 'mouse', 'bird']}\n",
    "success": true,
    "execution_time": 0.002757,
    "timestamp": "20250918_092945",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Movie': ['horror', 'fantasy', 'action'], 'Nationality': ['american', 'polish', 'brazilian'], 'Pet': ['guinea-pig', 'mouse', 'bird']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_81",
    "puzzle": {
      "id": "simple_3x3_81",
      "title": "Einstein Puzzle simple_3x3_81 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.02496712500000009
      },
      "clues": [
        "the person who plays biathlon is to the right of the person who likes scientific movies (not necessarily immediately)",
        "the person who enjoys cooking is adjacent to the person who likes time-travel movies (either immediately left or right)",
        "the person who likes zombie movies is to the left of the person who likes time-travel movies (not necessarily immediately)",
        "the person who enjoys gardening is to the left of the person who plays water-polo (not necessarily immediately)",
        "the person who plays water-polo is adjacent to the person who enjoys cooking (either immediately left or right)"
      ],
      "categories": [
        "Hobby",
        "Movie",
        "Sport"
      ],
      "items": {
        "Hobby": [
          "gardening",
          "cooking",
          "filmmaking"
        ],
        "Movie": [
          "scientific",
          "zombie",
          "time-travel"
        ],
        "Sport": [
          "snowboarding",
          "biathlon",
          "water-polo"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"gardening\", \"cooking\", \"filmmaking\"], \"Movie\": [\"scientific\", \"zombie\", \"time-travel\"], \"Sport\": [\"snowboarding\", \"biathlon\", \"water-polo\"]}"
    },
    "puzzle_hash": "43a8e6562f4f91ffec3b7fcf4fba4f30",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Movie\", \"Sport\"]\n    items = {\n        \"Hobby\": [\"gardening\", \"cooking\", \"filmmaking\"],\n        \"Movie\": [\"scientific\", \"zombie\", \"time-travel\"],\n        \"Sport\": [\"snowboarding\", \"biathlon\", \"water-polo\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays biathlon is to the right of the person who likes scientific movies (not necessarily immediately)\n    problem.addConstraint(lambda biathlon, scientific: biathlon > scientific,\n                          [\"Sport:biathlon\", \"Movie:scientific\"])\n    \n    # Clue 2: the person who enjoys cooking is adjacent to the person who likes time-travel movies (either immediately left or right)\n    problem.addConstraint(lambda cooking, time_travel: abs(cooking - time_travel) == 1,\n                          [\"Hobby:cooking\", \"Movie:time-travel\"])\n    \n    # Clue 3: the person who likes zombie movies is to the left of the person who likes time-travel movies (not necessarily immediately)\n    problem.addConstraint(lambda zombie, time_travel: zombie < time_travel,\n                          [\"Movie:zombie\", \"Movie:time-travel\"])\n    \n    # Clue 4: the person who enjoys gardening is to the left of the person who plays water-polo (not necessarily immediately)\n    problem.addConstraint(lambda gardening, water_polo: gardening < water_polo,\n                          [\"Hobby:gardening\", \"Sport:water-polo\"])\n    \n    # Clue 5: the person who plays water-polo is adjacent to the person who enjoys cooking (either immediately left or right)\n    problem.addConstraint(lambda water_polo, cooking: abs(water_polo - cooking) == 1,\n                          [\"Sport:water-polo\", \"Hobby:cooking\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['gardening', 'cooking', 'filmmaking'], 'Movie': ['scientific', 'zombie', 'time-travel'], 'Sport': ['snowboarding', 'biathlon', 'water-polo']}\n",
    "success": true,
    "execution_time": 0.00302,
    "timestamp": "20250918_093711",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['gardening', 'cooking', 'filmmaking'], 'Movie': ['scientific', 'zombie', 'time-travel'], 'Sport': ['snowboarding', 'biathlon', 'water-polo']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_49",
    "puzzle": {
      "id": "simple_3x3_49",
      "title": "Einstein Puzzle simple_3x3_49 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.022310457999999977
      },
      "clues": [
        "the person who likes grapes is directly between the person who works as a analyst and the person who works as a paramedic",
        "the person who works as a analyst and the person who has rat as a pet are at positions with different parity (one at odd, one at even position)",
        "the person who likes asparagus is at the same position as or to the right of the person who has goldfish as a pet",
        "the person who has goldfish as a pet is to the right of the person who works as a paramedic (not necessarily immediately)"
      ],
      "categories": [
        "Food",
        "Job",
        "Pet"
      ],
      "items": {
        "Food": [
          "zucchini",
          "grapes",
          "asparagus"
        ],
        "Job": [
          "paramedic",
          "pilot",
          "analyst"
        ],
        "Pet": [
          "rabbit",
          "rat",
          "goldfish"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"zucchini\", \"grapes\", \"asparagus\"], \"Job\": [\"paramedic\", \"pilot\", \"analyst\"], \"Pet\": [\"rabbit\", \"rat\", \"goldfish\"]}"
    },
    "puzzle_hash": "54fc376d699ae4faf9c0eee78be586bc",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Job\", \"Pet\"]\n    items = {\n        \"Food\": [\"zucchini\", \"grapes\", \"asparagus\"],\n        \"Job\": [\"paramedic\", \"pilot\", \"analyst\"],\n        \"Pet\": [\"rabbit\", \"rat\", \"goldfish\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes grapes is directly between the person who works as a analyst and the person who works as a paramedic\n    problem.addConstraint(\n        lambda grapes, analyst, paramedic: (grapes == analyst + 1 and grapes == paramedic - 1) or (grapes == paramedic + 1 and grapes == analyst - 1),\n        [\"Food:grapes\", \"Job:analyst\", \"Job:paramedic\"]\n    )\n    \n    # Clue 2: the person who works as a analyst and the person who has rat as a pet are at positions with different parity (one at odd, one at even position)\n    problem.addConstraint(\n        lambda analyst, rat: (analyst % 2) != (rat % 2),\n        [\"Job:analyst\", \"Pet:rat\"]\n    )\n    \n    # Clue 3: the person who likes asparagus is at the same position as or to the right of the person who has goldfish as a pet\n    problem.addConstraint(\n        lambda asparagus, goldfish: asparagus >= goldfish,\n        [\"Food:asparagus\", \"Pet:goldfish\"]\n    )\n    \n    # Clue 4: the person who has goldfish as a pet is to the right of the person who works as a paramedic (not necessarily immediately)\n    problem.addConstraint(\n        lambda goldfish, paramedic: goldfish > paramedic,\n        [\"Pet:goldfish\", \"Job:paramedic\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['zucchini', 'grapes', 'asparagus'], 'Job': ['paramedic', 'pilot', 'analyst'], 'Pet': ['rabbit', 'rat', 'goldfish']}\n",
    "success": true,
    "execution_time": 0.001506,
    "timestamp": "20250918_093143",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['zucchini', 'grapes', 'asparagus'], 'Job': ['paramedic', 'pilot', 'analyst'], 'Pet': ['rabbit', 'rat', 'goldfish']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_3",
    "puzzle": {
      "id": "simple_3x3_3",
      "title": "Einstein Puzzle simple_3x3_3 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.023872500000000005
      },
      "clues": [
        "the person who likes mirinda is to the left of the person who likes juice (not necessarily immediately)",
        "the person who likes mirinda is to the right of the person who uses airplane for transportation (not necessarily immediately)",
        "the thai person is a different person than the person who likes soy-milk",
        "the thai person is to the left of the spanish person (not necessarily immediately)",
        "the person who uses airplane for transportation is adjacent to the person who uses taxi for transportation (either immediately left or right)"
      ],
      "categories": [
        "Beverage",
        "Nationality",
        "Transport"
      ],
      "items": {
        "Beverage": [
          "soy-milk",
          "mirinda",
          "juice"
        ],
        "Nationality": [
          "german",
          "thai",
          "spanish"
        ],
        "Transport": [
          "airplane",
          "taxi",
          "roller"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"soy-milk\", \"mirinda\", \"juice\"], \"Nationality\": [\"german\", \"thai\", \"spanish\"], \"Transport\": [\"airplane\", \"taxi\", \"roller\"]}"
    },
    "puzzle_hash": "c03583d7fd2759c4ba1c9f8237d021b9",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Nationality\", \"Transport\"]\n    items = {\n        \"Beverage\": [\"soy-milk\", \"mirinda\", \"juice\"],\n        \"Nationality\": [\"german\", \"thai\", \"spanish\"],\n        \"Transport\": [\"airplane\", \"taxi\", \"roller\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes mirinda is to the left of the person who likes juice (not necessarily immediately)\n    problem.addConstraint(lambda mirinda, juice: mirinda < juice,\n                          [\"Beverage:mirinda\", \"Beverage:juice\"])\n    \n    # Clue 2: the person who likes mirinda is to the right of the person who uses airplane for transportation (not necessarily immediately)\n    problem.addConstraint(lambda mirinda, airplane: mirinda > airplane,\n                          [\"Beverage:mirinda\", \"Transport:airplane\"])\n    \n    # Clue 3: the thai person is a different person than the person who likes soy-milk\n    problem.addConstraint(lambda thai, soy_milk: thai != soy_milk,\n                          [\"Nationality:thai\", \"Beverage:soy-milk\"])\n    \n    # Clue 4: the thai person is to the left of the spanish person (not necessarily immediately)\n    problem.addConstraint(lambda thai, spanish: thai < spanish,\n                          [\"Nationality:thai\", \"Nationality:spanish\"])\n    \n    # Clue 5: the person who uses airplane for transportation is adjacent to the person who uses taxi for transportation\n    problem.addConstraint(lambda airplane, taxi: abs(airplane - taxi) == 1,\n                          [\"Transport:airplane\", \"Transport:taxi\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['soy-milk', 'mirinda', 'juice'], 'Nationality': ['german', 'thai', 'spanish'], 'Transport': ['airplane', 'taxi', 'roller']}\n",
    "success": true,
    "execution_time": 0.002804,
    "timestamp": "20250918_092340",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['soy-milk', 'mirinda', 'juice'], 'Nationality': ['german', 'thai', 'spanish'], 'Transport': ['airplane', 'taxi', 'roller']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_17",
    "puzzle": {
      "id": "simple_3x3_17",
      "title": "Einstein Puzzle simple_3x3_17 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.025870583999999974
      },
      "clues": [
        "the person who plays baseball is somewhere between the person who plays rugby and the person who likes lemonade (not necessarily immediately adjacent)",
        "the person who has hamster as a pet is to the left of the person who has goldfish as a pet (not necessarily immediately)",
        "the person who plays baseball is adjacent to the person who likes mirinda (either immediately left or right)",
        "the person who likes water is the same person as the person who has goldfish as a pet or the person who plays rugby is the same person as the person who likes water or both",
        "the person who likes water is at the same position as or to the left of the person who likes mirinda"
      ],
      "categories": [
        "Beverage",
        "Pet",
        "Sport"
      ],
      "items": {
        "Beverage": [
          "lemonade",
          "water",
          "mirinda"
        ],
        "Pet": [
          "hamster",
          "goldfish",
          "dog"
        ],
        "Sport": [
          "cycling",
          "baseball",
          "rugby"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"lemonade\", \"water\", \"mirinda\"], \"Pet\": [\"hamster\", \"goldfish\", \"dog\"], \"Sport\": [\"cycling\", \"baseball\", \"rugby\"]}"
    },
    "puzzle_hash": "b50ed03a909b7b7fd5649aef1b7405b6",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Pet\", \"Sport\"]\n    items = {\n        \"Beverage\": [\"lemonade\", \"water\", \"mirinda\"],\n        \"Pet\": [\"hamster\", \"goldfish\", \"dog\"],\n        \"Sport\": [\"cycling\", \"baseball\", \"rugby\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays baseball is somewhere between the person who plays rugby and the person who likes lemonade (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda baseball, rugby, lemonade: (rugby < baseball < lemonade) or (lemonade < baseball < rugby),\n        [\"Sport:baseball\", \"Sport:rugby\", \"Beverage:lemonade\"]\n    )\n    \n    # Clue 2: the person who has hamster as a pet is to the left of the person who has goldfish as a pet (not necessarily immediately)\n    problem.addConstraint(\n        lambda hamster, goldfish: hamster < goldfish,\n        [\"Pet:hamster\", \"Pet:goldfish\"]\n    )\n    \n    # Clue 3: the person who plays baseball is adjacent to the person who likes mirinda (either immediately left or right)\n    problem.addConstraint(\n        lambda baseball, mirinda: abs(baseball - mirinda) == 1,\n        [\"Sport:baseball\", \"Beverage:mirinda\"]\n    )\n    \n    # Clue 4: the person who likes water is the same person as the person who has goldfish as a pet or the person who plays rugby is the same person as the person who likes water or both\n    problem.addConstraint(\n        lambda water, goldfish, rugby: (water == goldfish) or (rugby == water),\n        [\"Beverage:water\", \"Pet:goldfish\", \"Sport:rugby\"]\n    )\n    \n    # Clue 5: the person who likes water is at the same position as or to the left of the person who likes mirinda\n    problem.addConstraint(\n        lambda water, mirinda: water <= mirinda,\n        [\"Beverage:water\", \"Beverage:mirinda\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['lemonade', 'water', 'mirinda'], 'Pet': ['hamster', 'goldfish', 'dog'], 'Sport': ['cycling', 'baseball', 'rugby']}\n",
    "success": true,
    "execution_time": 0.001688,
    "timestamp": "20250918_092619",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['lemonade', 'water', 'mirinda'], 'Pet': ['hamster', 'goldfish', 'dog'], 'Sport': ['cycling', 'baseball', 'rugby']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_41",
    "puzzle": {
      "id": "simple_3x3_41",
      "title": "Einstein Puzzle simple_3x3_41 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.01759095799999999
      },
      "clues": [
        "the person who likes dubstep music is at an odd-numbered position",
        "the person who enjoys baking is to the right of the person who enjoys magic-tricks (not necessarily immediately)",
        "the person who enjoys cooking is directly between the italian person and the person who likes gospel music",
        "the italian person is at the same position as or to the left of the person who enjoys magic-tricks",
        "the person who likes gospel music is the same person as the mexican person or the mexican person is the same person as the person who enjoys baking or both"
      ],
      "categories": [
        "Hobby",
        "Music",
        "Nationality"
      ],
      "items": {
        "Hobby": [
          "magic-tricks",
          "cooking",
          "baking"
        ],
        "Music": [
          "dubstep",
          "jazz",
          "gospel"
        ],
        "Nationality": [
          "italian",
          "russian",
          "mexican"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"magic-tricks\", \"cooking\", \"baking\"], \"Music\": [\"dubstep\", \"jazz\", \"gospel\"], \"Nationality\": [\"italian\", \"russian\", \"mexican\"]}"
    },
    "puzzle_hash": "8d8b3c4e718a0490bc2fa948fd78936a",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Music\", \"Nationality\"]\n    items = {\n        \"Hobby\": [\"magic-tricks\", \"cooking\", \"baking\"],\n        \"Music\": [\"dubstep\", \"jazz\", \"gospel\"],\n        \"Nationality\": [\"italian\", \"russian\", \"mexican\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes dubstep music is at an odd-numbered position\n    problem.addConstraint(lambda x: x % 2 == 0, [\"Music:dubstep\"])  # positions 0,2 are odd-numbered in 1-based indexing\n    \n    # Clue 2: the person who enjoys baking is to the right of the person who enjoys magic-tricks (not necessarily immediately)\n    problem.addConstraint(lambda baking, magic: baking > magic, [\"Hobby:baking\", \"Hobby:magic-tricks\"])\n    \n    # Clue 3: the person who enjoys cooking is directly between the italian person and the person who likes gospel music\n    # i.e. cooking is between italian and gospel, so cooking position is one more than min(italian,gospel) and one less than max(italian,gospel)\n    def cooking_between(cooking, italian, gospel):\n        return (cooking == italian + 1 and cooking == gospel - 1) or (cooking == gospel + 1 and cooking == italian - 1)\n    problem.addConstraint(cooking_between, [\"Hobby:cooking\", \"Nationality:italian\", \"Music:gospel\"])\n    \n    # Clue 4: the italian person is at the same position as or to the left of the person who enjoys magic-tricks\n    problem.addConstraint(lambda italian, magic: italian <= magic, [\"Nationality:italian\", \"Hobby:magic-tricks\"])\n    \n    # Clue 5: the person who likes gospel music is the same person as the mexican person or the mexican person is the same person as the person who enjoys baking or both\n    # i.e. gospel == mexican or mexican == baking\n    def gospel_mexican_baking(gospel, mexican, baking):\n        return gospel == mexican or mexican == baking\n    problem.addConstraint(gospel_mexican_baking, [\"Music:gospel\", \"Nationality:mexican\", \"Hobby:baking\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['magic-tricks', 'cooking', 'baking'], 'Music': ['dubstep', 'jazz', 'gospel'], 'Nationality': ['italian', 'russian', 'mexican']}\n",
    "success": true,
    "execution_time": 0.003008,
    "timestamp": "20250918_093023",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['magic-tricks', 'cooking', 'baking'], 'Music': ['dubstep', 'jazz', 'gospel'], 'Nationality': ['italian', 'russian', 'mexican']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_69",
    "puzzle": {
      "id": "simple_3x3_69",
      "title": "Einstein Puzzle simple_3x3_69 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.023864541000000017
      },
      "clues": [
        "the person who plays lacrosse is at the same position as or to the left of the person who likes family movies",
        "the person who plays ice-hockey is the same person as at least one of the person who likes spy movies or the person who has goldfish as a pet",
        "the person who has goldfish as a pet is directly between the person who has cat as a pet and the person who likes spy movies",
        "the person who plays lacrosse and the person who has hedgehog as a pet are at positions with different parity (one at odd, one at even position)",
        "the person who likes scientific movies is to the right of the person who likes family movies (not necessarily immediately)"
      ],
      "categories": [
        "Movie",
        "Pet",
        "Sport"
      ],
      "items": {
        "Movie": [
          "spy",
          "family",
          "scientific"
        ],
        "Pet": [
          "hedgehog",
          "goldfish",
          "cat"
        ],
        "Sport": [
          "ice-hockey",
          "lacrosse",
          "biathlon"
        ]
      },
      "ground_truth_solution": "{\"Movie\": [\"spy\", \"family\", \"scientific\"], \"Pet\": [\"hedgehog\", \"goldfish\", \"cat\"], \"Sport\": [\"ice-hockey\", \"lacrosse\", \"biathlon\"]}"
    },
    "puzzle_hash": "fb1b8e7b6cfc5199f4a8d1a51f59a12c",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Pet\", \"Sport\"]\n    items = {\n        \"Movie\": [\"spy\", \"family\", \"scientific\"],\n        \"Pet\": [\"hedgehog\", \"goldfish\", \"cat\"],\n        \"Sport\": [\"ice-hockey\", \"lacrosse\", \"biathlon\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays lacrosse is at the same position as or to the left of the person who likes family movies\n    problem.addConstraint(\n        lambda lacrosse, family: lacrosse <= family,\n        [\"Sport:lacrosse\", \"Movie:family\"]\n    )\n    \n    # Clue 2: the person who plays ice-hockey is the same person as at least one of the person who likes spy movies or the person who has goldfish as a pet\n    # This means ice-hockey position == spy position or ice-hockey position == goldfish position\n    def clue2(ice_hockey, spy, goldfish):\n        return ice_hockey == spy or ice_hockey == goldfish\n    problem.addConstraint(\n        clue2,\n        [\"Sport:ice-hockey\", \"Movie:spy\", \"Pet:goldfish\"]\n    )\n    \n    # Clue 3: the person who has goldfish as a pet is directly between the person who has cat as a pet and the person who likes spy movies\n    # That means goldfish position is exactly one position between cat and spy\n    def clue3(goldfish, cat, spy):\n        return (goldfish == cat + 1 and goldfish == spy - 1) or (goldfish == spy + 1 and goldfish == cat - 1)\n    problem.addConstraint(\n        clue3,\n        [\"Pet:goldfish\", \"Pet:cat\", \"Movie:spy\"]\n    )\n    \n    # Clue 4: the person who plays lacrosse and the person who has hedgehog as a pet are at positions with different parity\n    problem.addConstraint(\n        lambda lacrosse, hedgehog: (lacrosse % 2) != (hedgehog % 2),\n        [\"Sport:lacrosse\", \"Pet:hedgehog\"]\n    )\n    \n    # Clue 5: the person who likes scientific movies is to the right of the person who likes family movies (not necessarily immediately)\n    problem.addConstraint(\n        lambda scientific, family: scientific > family,\n        [\"Movie:scientific\", \"Movie:family\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Movie': ['spy', 'family', 'scientific'], 'Pet': ['hedgehog', 'goldfish', 'cat'], 'Sport': ['ice-hockey', 'lacrosse', 'biathlon']}\n",
    "success": true,
    "execution_time": 0.001877,
    "timestamp": "20250918_093506",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Movie': ['spy', 'family', 'scientific'], 'Pet': ['hedgehog', 'goldfish', 'cat'], 'Sport': ['ice-hockey', 'lacrosse', 'biathlon']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_23",
    "puzzle": {
      "id": "simple_3x3_23",
      "title": "Einstein Puzzle simple_3x3_23 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.017421709000000007
      },
      "clues": [
        "the argentine person is to the right of the person who likes strawberry (not necessarily immediately)",
        "the person who likes orange is to the left of the person who likes lime (not necessarily immediately)",
        "the person who has horse as a pet is at the same position as or to the right of the argentine person",
        "the person who has ferret as a pet is directly between the french person and the person who has rabbit as a pet"
      ],
      "categories": [
        "Food",
        "Nationality",
        "Pet"
      ],
      "items": {
        "Food": [
          "strawberry",
          "orange",
          "lime"
        ],
        "Nationality": [
          "mexican",
          "argentine",
          "french"
        ],
        "Pet": [
          "rabbit",
          "ferret",
          "horse"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"strawberry\", \"orange\", \"lime\"], \"Nationality\": [\"mexican\", \"argentine\", \"french\"], \"Pet\": [\"rabbit\", \"ferret\", \"horse\"]}"
    },
    "puzzle_hash": "9dc1bf6cf66bede95db885892efb9f21",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Food\", \"Nationality\", \"Pet\"]\n    items = {\n        \"Food\": [\"strawberry\", \"orange\", \"lime\"],\n        \"Nationality\": [\"mexican\", \"argentine\", \"french\"],\n        \"Pet\": [\"rabbit\", \"ferret\", \"horse\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the argentine person is to the right of the person who likes strawberry (not necessarily immediately)\n    problem.addConstraint(lambda arg, straw: arg > straw,\n                          [\"Nationality:argentine\", \"Food:strawberry\"])\n    \n    # Clue 2: the person who likes orange is to the left of the person who likes lime (not necessarily immediately)\n    problem.addConstraint(lambda orange, lime: orange < lime,\n                          [\"Food:orange\", \"Food:lime\"])\n    \n    # Clue 3: the person who has horse as a pet is at the same position as or to the right of the argentine person\n    problem.addConstraint(lambda horse, arg: horse >= arg,\n                          [\"Pet:horse\", \"Nationality:argentine\"])\n    \n    # Clue 4: the person who has ferret as a pet is directly between the french person and the person who has rabbit as a pet\n    problem.addConstraint(lambda ferret, french, rabbit: (ferret == french + 1 and ferret == rabbit - 1) or (ferret == rabbit + 1 and ferret == french - 1),\n                          [\"Pet:ferret\", \"Nationality:french\", \"Pet:rabbit\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['strawberry', 'orange', 'lime'], 'Nationality': ['mexican', 'argentine', 'french'], 'Pet': ['rabbit', 'ferret', 'horse']}\n",
    "success": true,
    "execution_time": 0.002964,
    "timestamp": "20250918_092719",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['strawberry', 'orange', 'lime'], 'Nationality': ['mexican', 'argentine', 'french'], 'Pet': ['rabbit', 'ferret', 'horse']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_62",
    "puzzle": {
      "id": "simple_3x3_62",
      "title": "Einstein Puzzle simple_3x3_62 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.015207417000000056
      },
      "clues": [
        "the person who works as a librarian is at an even-numbered position",
        "the person who likes pineapple is the same person as at least one of the person who works as a librarian or the person who enjoys video-games",
        "the person who likes peach is the same person as exactly one of the person who enjoys filmmaking or the person who works as a writer",
        "the person who enjoys woodworking and the person who likes avocado are at positions with different parity (one at odd, one at even position)",
        "the person who likes pineapple is to the right of the person who works as a librarian (not necessarily immediately)"
      ],
      "categories": [
        "Food",
        "Hobby",
        "Job"
      ],
      "items": {
        "Food": [
          "peach",
          "avocado",
          "pineapple"
        ],
        "Hobby": [
          "woodworking",
          "filmmaking",
          "video-games"
        ],
        "Job": [
          "writer",
          "librarian",
          "police-officer"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"peach\", \"avocado\", \"pineapple\"], \"Hobby\": [\"woodworking\", \"filmmaking\", \"video-games\"], \"Job\": [\"writer\", \"librarian\", \"police-officer\"]}"
    },
    "puzzle_hash": "63b65152a51121b43da18362be04ea97",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Food\", \"Hobby\", \"Job\"]\n    items = {\n        \"Food\": [\"peach\", \"avocado\", \"pineapple\"],\n        \"Hobby\": [\"woodworking\", \"filmmaking\", \"video-games\"],\n        \"Job\": [\"writer\", \"librarian\", \"police-officer\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who works as a librarian is at an even-numbered position\n    problem.addConstraint(lambda x: x % 2 == 0, [\"Job:librarian\"])\n    \n    # Clue 2: the person who likes pineapple is the same person as at least one of the person who works as a librarian or the person who enjoys video-games\n    # pineapple == librarian or pineapple == video-games\n    problem.addConstraint(lambda pineapple, librarian, videogames: pineapple == librarian or pineapple == videogames,\n                          [\"Food:pineapple\", \"Job:librarian\", \"Hobby:video-games\"])\n    \n    # Clue 3: the person who likes peach is the same person as exactly one of the person who enjoys filmmaking or the person who works as a writer\n    # peach == filmmaking xor peach == writer\n    def exactly_one(peach, filmmaking, writer):\n        return (peach == filmmaking) != (peach == writer)\n    problem.addConstraint(exactly_one, [\"Food:peach\", \"Hobby:filmmaking\", \"Job:writer\"])\n    \n    # Clue 4: the person who enjoys woodworking and the person who likes avocado are at positions with different parity\n    problem.addConstraint(lambda woodworking, avocado: (woodworking % 2) != (avocado % 2),\n                          [\"Hobby:woodworking\", \"Food:avocado\"])\n    \n    # Clue 5: the person who likes pineapple is to the right of the person who works as a librarian (not necessarily immediately)\n    problem.addConstraint(lambda pineapple, librarian: pineapple > librarian,\n                          [\"Food:pineapple\", \"Job:librarian\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['avocado', 'peach', 'pineapple'], 'Hobby': ['filmmaking', 'woodworking', 'video-games'], 'Job': ['librarian', 'writer', 'police-officer']}\n",
    "success": true,
    "execution_time": 0.002795,
    "timestamp": "20250918_093352",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['peach', 'avocado', 'pineapple'], 'Hobby': ['woodworking', 'filmmaking', 'video-games'], 'Job': ['writer', 'librarian', 'police-officer']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_25",
    "puzzle": {
      "id": "simple_3x3_25",
      "title": "Einstein Puzzle simple_3x3_25 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.0052514999999999645
      },
      "clues": [
        "the person who uses bike for transportation is somewhere between the person who plays surfing and the person who uses skateboard for transportation (not necessarily immediately adjacent)",
        "the person who uses bike for transportation is to the right of the nigerian person (not necessarily immediately)",
        "the american person is somewhere between the person who plays surfing and the person who plays volleyball (not necessarily immediately adjacent)",
        "the american person is somewhere between the pakistani person and the person who uses car for transportation (not necessarily immediately adjacent)"
      ],
      "categories": [
        "Nationality",
        "Sport",
        "Transport"
      ],
      "items": {
        "Nationality": [
          "nigerian",
          "american",
          "pakistani"
        ],
        "Sport": [
          "surfing",
          "climbing",
          "volleyball"
        ],
        "Transport": [
          "car",
          "bike",
          "skateboard"
        ]
      },
      "ground_truth_solution": "{\"Nationality\": [\"nigerian\", \"american\", \"pakistani\"], \"Sport\": [\"surfing\", \"climbing\", \"volleyball\"], \"Transport\": [\"car\", \"bike\", \"skateboard\"]}"
    },
    "puzzle_hash": "99e8fcaa06eb3f9a717792827fe03b25",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Nationality\", \"Sport\", \"Transport\"]\n    items = {\n        \"Nationality\": [\"nigerian\", \"american\", \"pakistani\"],\n        \"Sport\": [\"surfing\", \"climbing\", \"volleyball\"],\n        \"Transport\": [\"car\", \"bike\", \"skateboard\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: bike is somewhere between surfing and skateboard (not necessarily immediately)\n    problem.addConstraint(\n        lambda bike, surfing, skateboard: (surfing < bike < skateboard) or (skateboard < bike < surfing),\n        [\"Transport:bike\", \"Sport:surfing\", \"Transport:skateboard\"]\n    )\n    \n    # Clue 2: bike is to the right of nigerian (not necessarily immediately)\n    problem.addConstraint(\n        lambda bike, nigerian: bike > nigerian,\n        [\"Transport:bike\", \"Nationality:nigerian\"]\n    )\n    \n    # Clue 3: american is somewhere between surfing and volleyball (not necessarily immediately)\n    problem.addConstraint(\n        lambda american, surfing, volleyball: (surfing < american < volleyball) or (volleyball < american < surfing),\n        [\"Nationality:american\", \"Sport:surfing\", \"Sport:volleyball\"]\n    )\n    \n    # Clue 4: american is somewhere between pakistani and car (not necessarily immediately)\n    problem.addConstraint(\n        lambda american, pakistani, car: (pakistani < american < car) or (car < american < pakistani),\n        [\"Nationality:american\", \"Nationality:pakistani\", \"Transport:car\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Nationality': ['nigerian', 'american', 'pakistani'], 'Sport': ['surfing', 'climbing', 'volleyball'], 'Transport': ['car', 'bike', 'skateboard']}\n",
    "success": true,
    "execution_time": 0.002387,
    "timestamp": "20250918_092741",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Nationality': ['nigerian', 'american', 'pakistani'], 'Sport': ['surfing', 'climbing', 'volleyball'], 'Transport': ['car', 'bike', 'skateboard']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_6",
    "puzzle": {
      "id": "simple_3x3_6",
      "title": "Einstein Puzzle simple_3x3_6 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.016552042000000017
      },
      "clues": [
        "the person who has goat as a pet is to the left of the spanish person (not necessarily immediately)",
        "the person who works as a entrepreneur is somewhere between the person who works as a chef and the person who has goldfish as a pet (not necessarily immediately adjacent)",
        "the person who works as a pilot is to the left of the malaysian person (not necessarily immediately)"
      ],
      "categories": [
        "Job",
        "Nationality",
        "Pet"
      ],
      "items": {
        "Job": [
          "pilot",
          "entrepreneur",
          "chef"
        ],
        "Nationality": [
          "egyptian",
          "malaysian",
          "spanish"
        ],
        "Pet": [
          "goldfish",
          "goat",
          "ferret"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"pilot\", \"entrepreneur\", \"chef\"], \"Nationality\": [\"egyptian\", \"malaysian\", \"spanish\"], \"Pet\": [\"goldfish\", \"goat\", \"ferret\"]}"
    },
    "puzzle_hash": "4b027b9892f92b7018da3e632d34331a",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Nationality\", \"Pet\"]\n    items = {\n        \"Job\": [\"pilot\", \"entrepreneur\", \"chef\"],\n        \"Nationality\": [\"egyptian\", \"malaysian\", \"spanish\"],\n        \"Pet\": [\"goldfish\", \"goat\", \"ferret\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who has goat as a pet is to the left of the spanish person (not necessarily immediately)\n    problem.addConstraint(lambda goat_pos, spanish_pos: goat_pos < spanish_pos,\n                          [\"Pet:goat\", \"Nationality:spanish\"])\n    \n    # Clue 2: the person who works as an entrepreneur is somewhere between the person who works as a chef and the person who has goldfish as a pet (not necessarily immediately)\n    # entrepreneur_pos is between chef_pos and goldfish_pos means entrepreneur_pos is strictly between chef_pos and goldfish_pos\n    def entrepreneur_between(entrepreneur_pos, chef_pos, goldfish_pos):\n        return (chef_pos < entrepreneur_pos < goldfish_pos) or (goldfish_pos < entrepreneur_pos < chef_pos)\n    problem.addConstraint(entrepreneur_between,\n                          [\"Job:entrepreneur\", \"Job:chef\", \"Pet:goldfish\"])\n    \n    # Clue 3: the person who works as a pilot is to the left of the malaysian person (not necessarily immediately)\n    problem.addConstraint(lambda pilot_pos, malaysian_pos: pilot_pos < malaysian_pos,\n                          [\"Job:pilot\", \"Nationality:malaysian\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['pilot', 'entrepreneur', 'chef'], 'Nationality': ['egyptian', 'malaysian', 'spanish'], 'Pet': ['goldfish', 'goat', 'ferret']}\n",
    "success": true,
    "execution_time": 0.002671,
    "timestamp": "20250918_092413",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['pilot', 'entrepreneur', 'chef'], 'Nationality': ['egyptian', 'malaysian', 'spanish'], 'Pet': ['goldfish', 'goat', 'ferret']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_7",
    "puzzle": {
      "id": "simple_3x3_7",
      "title": "Einstein Puzzle simple_3x3_7 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.017128667000000014
      },
      "clues": [
        "the person who likes ambient music is to the left of the person who likes drama movies (not necessarily immediately)",
        "the person who likes cauliflower is a different person than the person who likes spy movies",
        "the person who likes drama movies is to the left of the person who likes western movies (not necessarily immediately)",
        "the person who likes country music and the person who likes cauliflower are at positions with the same parity (both at odd or both at even positions)",
        "the person who likes onion is to the right of the person who likes cauliflower (not necessarily immediately)"
      ],
      "categories": [
        "Food",
        "Movie",
        "Music"
      ],
      "items": {
        "Food": [
          "plum",
          "cauliflower",
          "onion"
        ],
        "Movie": [
          "spy",
          "drama",
          "western"
        ],
        "Music": [
          "ambient",
          "country",
          "folk"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"plum\", \"cauliflower\", \"onion\"], \"Movie\": [\"spy\", \"drama\", \"western\"], \"Music\": [\"ambient\", \"country\", \"folk\"]}"
    },
    "puzzle_hash": "c0b032a0e6d77c8756cda4a6494cfeea",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Movie\", \"Music\"]\n    items = {\n        \"Food\": [\"plum\", \"cauliflower\", \"onion\"],\n        \"Movie\": [\"spy\", \"drama\", \"western\"],\n        \"Music\": [\"ambient\", \"country\", \"folk\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: ambient music is to the left of drama movies\n    problem.addConstraint(lambda ambient, drama: ambient < drama, [\"Music:ambient\", \"Movie:drama\"])\n    \n    # Clue 2: cauliflower is a different person than spy movies\n    problem.addConstraint(lambda cauliflower, spy: cauliflower != spy, [\"Food:cauliflower\", \"Movie:spy\"])\n    \n    # Clue 3: drama movies is to the left of western movies\n    problem.addConstraint(lambda drama, western: drama < western, [\"Movie:drama\", \"Movie:western\"])\n    \n    # Clue 4: country music and cauliflower have same parity positions\n    problem.addConstraint(lambda country, cauliflower: country % 2 == cauliflower % 2, [\"Music:country\", \"Food:cauliflower\"])\n    \n    # Clue 5: onion is to the right of cauliflower\n    problem.addConstraint(lambda onion, cauliflower: onion > cauliflower, [\"Food:onion\", \"Food:cauliflower\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['plum', 'cauliflower', 'onion'], 'Movie': ['spy', 'drama', 'western'], 'Music': ['ambient', 'country', 'folk']}\n",
    "success": true,
    "execution_time": 0.00283,
    "timestamp": "20250918_092424",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['plum', 'cauliflower', 'onion'], 'Movie': ['spy', 'drama', 'western'], 'Music': ['ambient', 'country', 'folk']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_22",
    "puzzle": {
      "id": "simple_3x3_22",
      "title": "Einstein Puzzle simple_3x3_22 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.03630041700000003
      },
      "clues": [
        "the person who likes funk music is a different person than the person who plays volleyball",
        "the person who likes techno music is at the same position as or to the right of the person who likes salsa music",
        "the person who likes salsa music is at the same position as or to the left of the person who plays tennis",
        "the person who works as a doctor is somewhere between the person who plays tennis and the person who plays cycling (not necessarily immediately adjacent)",
        "the person who works as a dancer is to the right of the person who works as a videographer (not necessarily immediately)",
        "the person who likes techno music is adjacent to the person who plays volleyball (either immediately left or right)"
      ],
      "categories": [
        "Job",
        "Music",
        "Sport"
      ],
      "items": {
        "Job": [
          "videographer",
          "doctor",
          "dancer"
        ],
        "Music": [
          "funk",
          "salsa",
          "techno"
        ],
        "Sport": [
          "cycling",
          "volleyball",
          "tennis"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"videographer\", \"doctor\", \"dancer\"], \"Music\": [\"funk\", \"salsa\", \"techno\"], \"Sport\": [\"cycling\", \"volleyball\", \"tennis\"]}"
    },
    "puzzle_hash": "db7bbb834b380caed18fe2be38c11d2c",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Music\", \"Sport\"]\n    items = {\n        \"Job\": [\"videographer\", \"doctor\", \"dancer\"],\n        \"Music\": [\"funk\", \"salsa\", \"techno\"],\n        \"Sport\": [\"cycling\", \"volleyball\", \"tennis\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes funk music is a different person than the person who plays volleyball\n    problem.addConstraint(lambda funk, volleyball: funk != volleyball,\n                          [\"Music:funk\", \"Sport:volleyball\"])\n    \n    # Clue 2: the person who likes techno music is at the same position as or to the right of the person who likes salsa music\n    problem.addConstraint(lambda techno, salsa: techno >= salsa,\n                          [\"Music:techno\", \"Music:salsa\"])\n    \n    # Clue 3: the person who likes salsa music is at the same position as or to the left of the person who plays tennis\n    problem.addConstraint(lambda salsa, tennis: salsa <= tennis,\n                          [\"Music:salsa\", \"Sport:tennis\"])\n    \n    # Clue 4: the person who works as a doctor is somewhere between the person who plays tennis and the person who plays cycling (not necessarily immediately adjacent)\n    # This means doctor position is strictly between tennis and cycling positions\n    def doctor_between(doctor, tennis, cycling):\n        return (tennis < doctor < cycling) or (cycling < doctor < tennis)\n    problem.addConstraint(doctor_between,\n                          [\"Job:doctor\", \"Sport:tennis\", \"Sport:cycling\"])\n    \n    # Clue 5: the person who works as a dancer is to the right of the person who works as a videographer (not necessarily immediately)\n    problem.addConstraint(lambda dancer, videographer: dancer > videographer,\n                          [\"Job:dancer\", \"Job:videographer\"])\n    \n    # Clue 6: the person who likes techno music is adjacent to the person who plays volleyball (either immediately left or right)\n    problem.addConstraint(lambda techno, volleyball: abs(techno - volleyball) == 1,\n                          [\"Music:techno\", \"Sport:volleyball\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['videographer', 'doctor', 'dancer'], 'Music': ['funk', 'salsa', 'techno'], 'Sport': ['cycling', 'volleyball', 'tennis']}\n",
    "success": true,
    "execution_time": 0.002618,
    "timestamp": "20250918_092711",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['videographer', 'doctor', 'dancer'], 'Music': ['funk', 'salsa', 'techno'], 'Sport': ['cycling', 'volleyball', 'tennis']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_51",
    "puzzle": {
      "id": "simple_3x3_51",
      "title": "Einstein Puzzle simple_3x3_51 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.013059374999999984
      },
      "clues": [
        "the british person is to the right of the person who enjoys dancing (not necessarily immediately)",
        "the person who enjoys filmmaking is to the left of the person who enjoys dancing (not necessarily immediately)",
        "the person who enjoys dancing is to the right of the person who has dog as a pet (not necessarily immediately)",
        "the person who has lizard as a pet is to the left of the person who has rat as a pet (not necessarily immediately)",
        "the german person is a different person than the person who enjoys dancing"
      ],
      "categories": [
        "Hobby",
        "Nationality",
        "Pet"
      ],
      "items": {
        "Hobby": [
          "filmmaking",
          "dancing",
          "magic-tricks"
        ],
        "Nationality": [
          "german",
          "egyptian",
          "british"
        ],
        "Pet": [
          "dog",
          "lizard",
          "rat"
        ]
      },
      "ground_truth_solution": "{\"Hobby\": [\"filmmaking\", \"dancing\", \"magic-tricks\"], \"Nationality\": [\"german\", \"egyptian\", \"british\"], \"Pet\": [\"dog\", \"lizard\", \"rat\"]}"
    },
    "puzzle_hash": "e570ec7ee7512603663ea8e48e752a3b",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Nationality\", \"Pet\"]\n    items = {\n        \"Hobby\": [\"filmmaking\", \"dancing\", \"magic-tricks\"],\n        \"Nationality\": [\"german\", \"egyptian\", \"british\"],\n        \"Pet\": [\"dog\", \"lizard\", \"rat\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the british person is to the right of the person who enjoys dancing (not necessarily immediately)\n    problem.addConstraint(lambda british, dancing: british > dancing, [\"Nationality:british\", \"Hobby:dancing\"])\n    \n    # Clue 2: the person who enjoys filmmaking is to the left of the person who enjoys dancing (not necessarily immediately)\n    problem.addConstraint(lambda filmmaking, dancing: filmmaking < dancing, [\"Hobby:filmmaking\", \"Hobby:dancing\"])\n    \n    # Clue 3: the person who enjoys dancing is to the right of the person who has dog as a pet (not necessarily immediately)\n    problem.addConstraint(lambda dancing, dog: dancing > dog, [\"Hobby:dancing\", \"Pet:dog\"])\n    \n    # Clue 4: the person who has lizard as a pet is to the left of the person who has rat as a pet (not necessarily immediately)\n    problem.addConstraint(lambda lizard, rat: lizard < rat, [\"Pet:lizard\", \"Pet:rat\"])\n    \n    # Clue 5: the german person is a different person than the person who enjoys dancing\n    problem.addConstraint(lambda german, dancing: german != dancing, [\"Nationality:german\", \"Hobby:dancing\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Hobby': ['filmmaking', 'dancing', 'magic-tricks'], 'Nationality': ['german', 'egyptian', 'british'], 'Pet': ['dog', 'lizard', 'rat']}\n",
    "success": true,
    "execution_time": 0.002241,
    "timestamp": "20250918_093200",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Hobby': ['filmmaking', 'dancing', 'magic-tricks'], 'Nationality': ['german', 'egyptian', 'british'], 'Pet': ['dog', 'lizard', 'rat']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_92",
    "puzzle": {
      "id": "simple_3x3_92",
      "title": "Einstein Puzzle simple_3x3_92 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.018036000000000163
      },
      "clues": [
        "the person who likes cauliflower and the person who likes funk music are at positions with different parity (one at odd, one at even position)",
        "the person who enjoys filmmaking is a different person than the person who likes tomato",
        "the person who likes pear is at the same position as or to the left of the person who likes ambient music",
        "the person who enjoys woodworking is somewhere between the person who likes trance music and the person who enjoys puzzles (not necessarily immediately adjacent)",
        "the person who likes ambient music and the person who enjoys filmmaking are at positions with different parity (one at odd, one at even position)"
      ],
      "categories": [
        "Food",
        "Hobby",
        "Music"
      ],
      "items": {
        "Food": [
          "pear",
          "cauliflower",
          "tomato"
        ],
        "Hobby": [
          "filmmaking",
          "woodworking",
          "puzzles"
        ],
        "Music": [
          "trance",
          "ambient",
          "funk"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"pear\", \"cauliflower\", \"tomato\"], \"Hobby\": [\"filmmaking\", \"woodworking\", \"puzzles\"], \"Music\": [\"trance\", \"ambient\", \"funk\"]}"
    },
    "puzzle_hash": "46e0672e2b7dc1a51290e0a5ac060231",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Hobby\", \"Music\"]\n    items = {\n        \"Food\": [\"pear\", \"cauliflower\", \"tomato\"],\n        \"Hobby\": [\"filmmaking\", \"woodworking\", \"puzzles\"],\n        \"Music\": [\"trance\", \"ambient\", \"funk\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: cauliflower and funk music are at positions with different parity\n    problem.addConstraint(lambda x, y: (x % 2) != (y % 2), [\"Food:cauliflower\", \"Music:funk\"])\n    \n    # Clue 2: filmmaking and tomato are different persons\n    problem.addConstraint(lambda x, y: x != y, [\"Hobby:filmmaking\", \"Food:tomato\"])\n    \n    # Clue 3: pear is at the same position as or to the left of ambient music\n    problem.addConstraint(lambda x, y: x <= y, [\"Food:pear\", \"Music:ambient\"])\n    \n    # Clue 4: woodworking is somewhere between trance music and puzzles (not necessarily immediately)\n    # So woodworking position is strictly between trance and puzzles positions\n    problem.addConstraint(lambda x, y, z: (y < x < z) or (z < x < y), [\"Hobby:woodworking\", \"Music:trance\", \"Hobby:puzzles\"])\n    \n    # Clue 5: ambient music and filmmaking are at positions with different parity\n    problem.addConstraint(lambda x, y: (x % 2) != (y % 2), [\"Music:ambient\", \"Hobby:filmmaking\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['pear', 'cauliflower', 'tomato'], 'Hobby': ['filmmaking', 'woodworking', 'puzzles'], 'Music': ['trance', 'ambient', 'funk']}\n",
    "success": true,
    "execution_time": 0.003206,
    "timestamp": "20250918_093907",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['pear', 'cauliflower', 'tomato'], 'Hobby': ['filmmaking', 'woodworking', 'puzzles'], 'Music': ['trance', 'ambient', 'funk']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_10",
    "puzzle": {
      "id": "simple_3x3_10",
      "title": "Einstein Puzzle simple_3x3_10 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.01378175000000001
      },
      "clues": [
        "the person who likes almond-milk is to the right of the person who likes coffee (not necessarily immediately)",
        "the person who likes coffee is at the same position as or to the right of the person who likes blueberry",
        "the person who likes soy-milk is to the right of the person who likes almond-milk (not necessarily immediately)",
        "the person who likes strawberry is a different person than the pakistani person",
        "the pakistani person is directly between the french person and the person who likes soy-milk"
      ],
      "categories": [
        "Beverage",
        "Food",
        "Nationality"
      ],
      "items": {
        "Beverage": [
          "coffee",
          "almond-milk",
          "soy-milk"
        ],
        "Food": [
          "blueberry",
          "apple",
          "strawberry"
        ],
        "Nationality": [
          "french",
          "pakistani",
          "russian"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"coffee\", \"almond-milk\", \"soy-milk\"], \"Food\": [\"blueberry\", \"apple\", \"strawberry\"], \"Nationality\": [\"french\", \"pakistani\", \"russian\"]}"
    },
    "puzzle_hash": "40c33231a95589c8a0b89797b1d5dbc2",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Beverage\", \"Food\", \"Nationality\"]\n    items = {\n        \"Beverage\": [\"coffee\", \"almond-milk\", \"soy-milk\"],\n        \"Food\": [\"blueberry\", \"apple\", \"strawberry\"],\n        \"Nationality\": [\"french\", \"pakistani\", \"russian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes almond-milk is to the right of the person who likes coffee (not necessarily immediately)\n    problem.addConstraint(lambda almond, coffee: almond > coffee, [\"Beverage:almond-milk\", \"Beverage:coffee\"])\n    \n    # Clue 2: the person who likes coffee is at the same position as or to the right of the person who likes blueberry\n    problem.addConstraint(lambda coffee, blueberry: coffee >= blueberry, [\"Beverage:coffee\", \"Food:blueberry\"])\n    \n    # Clue 3: the person who likes soy-milk is to the right of the person who likes almond-milk (not necessarily immediately)\n    problem.addConstraint(lambda soy, almond: soy > almond, [\"Beverage:soy-milk\", \"Beverage:almond-milk\"])\n    \n    # Clue 4: the person who likes strawberry is a different person than the pakistani person\n    problem.addConstraint(lambda strawberry, pakistani: strawberry != pakistani, [\"Food:strawberry\", \"Nationality:pakistani\"])\n    \n    # Clue 5: the pakistani person is directly between the french person and the person who likes soy-milk\n    # That means pakistani is at position x, french and soy-milk are at positions x-1 and x+1 in some order\n    def between_constraint(pakistani, french, soy):\n        return (pakistani == french + 1 and pakistani == soy - 1) or (pakistani == soy + 1 and pakistani == french - 1)\n    problem.addConstraint(between_constraint, [\"Nationality:pakistani\", \"Nationality:french\", \"Beverage:soy-milk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['coffee', 'almond-milk', 'soy-milk'], 'Food': ['blueberry', 'apple', 'strawberry'], 'Nationality': ['french', 'pakistani', 'russian']}\n",
    "success": true,
    "execution_time": 0.001516,
    "timestamp": "20250918_092459",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['coffee', 'almond-milk', 'soy-milk'], 'Food': ['blueberry', 'apple', 'strawberry'], 'Nationality': ['french', 'pakistani', 'russian']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_72",
    "puzzle": {
      "id": "simple_3x3_72",
      "title": "Einstein Puzzle simple_3x3_72 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.01649179200000006
      },
      "clues": [
        "the person who uses boat for transportation is to the right of the person who plays skateboarding (not necessarily immediately)",
        "the person who plays lacrosse is at the same position as or to the left of the person who likes spinach",
        "the person who uses boat for transportation is adjacent to the person who plays handball (either immediately left or right)",
        "the person who uses helicopter for transportation is somewhere between the person who likes radish and the person who uses boat for transportation (not necessarily immediately adjacent)"
      ],
      "categories": [
        "Food",
        "Sport",
        "Transport"
      ],
      "items": {
        "Food": [
          "radish",
          "pineapple",
          "spinach"
        ],
        "Sport": [
          "skateboarding",
          "handball",
          "lacrosse"
        ],
        "Transport": [
          "ship",
          "helicopter",
          "boat"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"radish\", \"pineapple\", \"spinach\"], \"Sport\": [\"skateboarding\", \"handball\", \"lacrosse\"], \"Transport\": [\"ship\", \"helicopter\", \"boat\"]}"
    },
    "puzzle_hash": "f463d55acffd89eac9aed4ec0a477d77",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Sport\", \"Transport\"]\n    items = {\n        \"Food\": [\"radish\", \"pineapple\", \"spinach\"],\n        \"Sport\": [\"skateboarding\", \"handball\", \"lacrosse\"],\n        \"Transport\": [\"ship\", \"helicopter\", \"boat\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses boat for transportation is to the right of the person who plays skateboarding (not necessarily immediately)\n    problem.addConstraint(lambda boat, skateboarding: boat > skateboarding, [\"Transport:boat\", \"Sport:skateboarding\"])\n    \n    # Clue 2: the person who plays lacrosse is at the same position as or to the left of the person who likes spinach\n    problem.addConstraint(lambda lacrosse, spinach: lacrosse <= spinach, [\"Sport:lacrosse\", \"Food:spinach\"])\n    \n    # Clue 3: the person who uses boat for transportation is adjacent to the person who plays handball (either immediately left or right)\n    problem.addConstraint(lambda boat, handball: abs(boat - handball) == 1, [\"Transport:boat\", \"Sport:handball\"])\n    \n    # Clue 4: the person who uses helicopter for transportation is somewhere between the person who likes radish and the person who uses boat for transportation (not necessarily immediately adjacent)\n    # That means helicopter position is strictly between radish and boat positions\n    problem.addConstraint(lambda helicopter, radish, boat: (radish < helicopter < boat) or (boat < helicopter < radish), [\"Transport:helicopter\", \"Food:radish\", \"Transport:boat\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['radish', 'pineapple', 'spinach'], 'Sport': ['skateboarding', 'handball', 'lacrosse'], 'Transport': ['ship', 'helicopter', 'boat']}\n",
    "success": true,
    "execution_time": 0.002852,
    "timestamp": "20250918_093539",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['radish', 'pineapple', 'spinach'], 'Sport': ['skateboarding', 'handball', 'lacrosse'], 'Transport': ['ship', 'helicopter', 'boat']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_46",
    "puzzle": {
      "id": "simple_3x3_46",
      "title": "Einstein Puzzle simple_3x3_46 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.02709962499999996
      },
      "clues": [
        "the person who likes cranberry is at the same position as or to the right of the person who likes family movies",
        "the person who likes zucchini is at the same position as or to the left of the person who likes family movies",
        "the person who likes comedy movies and the person who likes cranberry are at positions with the same parity (both at odd or both at even positions)",
        "the person who likes comedy movies is directly between the person who likes zucchini and the person who likes hip-hop music",
        "the person who likes animation movies and the person who likes country music are at positions with different parity (one at odd, one at even position)"
      ],
      "categories": [
        "Food",
        "Movie",
        "Music"
      ],
      "items": {
        "Food": [
          "zucchini",
          "cranberry",
          "spinach"
        ],
        "Movie": [
          "family",
          "comedy",
          "animation"
        ],
        "Music": [
          "salsa",
          "country",
          "hip-hop"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"zucchini\", \"cranberry\", \"spinach\"], \"Movie\": [\"family\", \"comedy\", \"animation\"], \"Music\": [\"salsa\", \"country\", \"hip-hop\"]}"
    },
    "puzzle_hash": "71372fafabde92b9717ea7fa7fd6e0e7",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Food\", \"Movie\", \"Music\"]\n    items = {\n        \"Food\": [\"zucchini\", \"cranberry\", \"spinach\"],\n        \"Movie\": [\"family\", \"comedy\", \"animation\"],\n        \"Music\": [\"salsa\", \"country\", \"hip-hop\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: cranberry is at the same position as or to the right of family movies\n    problem.addConstraint(lambda cranberry, family: cranberry >= family,\n                          [\"Food:cranberry\", \"Movie:family\"])\n    \n    # Clue 2: zucchini is at the same position as or to the left of family movies\n    problem.addConstraint(lambda zucchini, family: zucchini <= family,\n                          [\"Food:zucchini\", \"Movie:family\"])\n    \n    # Clue 3: comedy movies and cranberry have same parity positions\n    problem.addConstraint(lambda comedy, cranberry: comedy % 2 == cranberry % 2,\n                          [\"Movie:comedy\", \"Food:cranberry\"])\n    \n    # Clue 4: comedy movies is directly between zucchini and hip-hop music\n    # i.e. comedy is at position one more than one and one less than the other\n    problem.addConstraint(lambda comedy, zucchini, hiphop:\n                          (comedy == zucchini + 1 and comedy == hiphop - 1) or\n                          (comedy == hiphop + 1 and comedy == zucchini - 1),\n                          [\"Movie:comedy\", \"Food:zucchini\", \"Music:hip-hop\"])\n    \n    # Clue 5: animation movies and country music are at positions with different parity\n    problem.addConstraint(lambda animation, country: (animation % 2) != (country % 2),\n                          [\"Movie:animation\", \"Music:country\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['zucchini', 'cranberry', 'spinach'], 'Movie': ['family', 'comedy', 'animation'], 'Music': ['salsa', 'country', 'hip-hop']}\n",
    "success": true,
    "execution_time": 0.002842,
    "timestamp": "20250918_093113",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['zucchini', 'cranberry', 'spinach'], 'Movie': ['family', 'comedy', 'animation'], 'Music': ['salsa', 'country', 'hip-hop']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_86",
    "puzzle": {
      "id": "simple_3x3_86",
      "title": "Einstein Puzzle simple_3x3_86 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.03188925000000009
      },
      "clues": [
        "the person who has rat as a pet is at the same position as or to the left of the person who has fish as a pet",
        "the person who likes sports movies is at the same position as or to the left of the person who likes crime movies",
        "the person who uses motorbike for transportation is at an odd-numbered position",
        "the person who uses ship for transportation is to the right of the person who likes crime movies (not necessarily immediately)",
        "the person who likes crime movies is somewhere between the person who has mouse as a pet and the person who has fish as a pet (not necessarily immediately adjacent)"
      ],
      "categories": [
        "Movie",
        "Pet",
        "Transport"
      ],
      "items": {
        "Movie": [
          "sports",
          "crime",
          "fantasy"
        ],
        "Pet": [
          "mouse",
          "rat",
          "fish"
        ],
        "Transport": [
          "motorbike",
          "jet-ski",
          "ship"
        ]
      },
      "ground_truth_solution": "{\"Movie\": [\"sports\", \"crime\", \"fantasy\"], \"Pet\": [\"mouse\", \"rat\", \"fish\"], \"Transport\": [\"motorbike\", \"jet-ski\", \"ship\"]}"
    },
    "puzzle_hash": "4b2df658850e93caad24eca65f47e402",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Pet\", \"Transport\"]\n    items = {\n        \"Movie\": [\"sports\", \"crime\", \"fantasy\"],\n        \"Pet\": [\"mouse\", \"rat\", \"fish\"],\n        \"Transport\": [\"motorbike\", \"jet-ski\", \"ship\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who has rat as a pet is at the same position as or to the left of the person who has fish as a pet\n    problem.addConstraint(lambda rat_pos, fish_pos: rat_pos <= fish_pos, [\"Pet:rat\", \"Pet:fish\"])\n    \n    # Clue 2: the person who likes sports movies is at the same position as or to the left of the person who likes crime movies\n    problem.addConstraint(lambda sports_pos, crime_pos: sports_pos <= crime_pos, [\"Movie:sports\", \"Movie:crime\"])\n    \n    # Clue 3: the person who uses motorbike for transportation is at an odd-numbered position\n    problem.addConstraint(lambda motorbike_pos: motorbike_pos % 2 == 1, [\"Transport:motorbike\"])\n    \n    # Clue 4: the person who uses ship for transportation is to the right of the person who likes crime movies (not necessarily immediately)\n    problem.addConstraint(lambda ship_pos, crime_pos: ship_pos > crime_pos, [\"Transport:ship\", \"Movie:crime\"])\n    \n    # Clue 5: the person who likes crime movies is somewhere between the person who has mouse as a pet and the person who has fish as a pet (not necessarily immediately adjacent)\n    # This means crime_pos is strictly between mouse_pos and fish_pos\n    def between(crime_pos, mouse_pos, fish_pos):\n        return (mouse_pos < crime_pos < fish_pos) or (fish_pos < crime_pos < mouse_pos)\n    problem.addConstraint(between, [\"Movie:crime\", \"Pet:mouse\", \"Pet:fish\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Movie': ['sports', 'crime', 'fantasy'], 'Pet': ['mouse', 'rat', 'fish'], 'Transport': ['jet-ski', 'motorbike', 'ship']}\n",
    "success": true,
    "execution_time": 0.00287,
    "timestamp": "20250918_093805",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Movie': ['sports', 'crime', 'fantasy'], 'Pet': ['mouse', 'rat', 'fish'], 'Transport': ['motorbike', 'jet-ski', 'ship']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_21",
    "puzzle": {
      "id": "simple_3x3_21",
      "title": "Einstein Puzzle simple_3x3_21 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.013241707999999963
      },
      "clues": [
        "the person who likes techno music and the person who likes juice are at positions with the same parity (both at odd or both at even positions)",
        "the person who likes juice is directly between the person who works as a security-guard and the person who likes gospel music",
        "the person who works as a musician is somewhere between the person who works as a security-guard and the person who likes tea (not necessarily immediately adjacent)",
        "the person who likes techno music is at the same position as or to the left of the person who likes house music"
      ],
      "categories": [
        "Beverage",
        "Job",
        "Music"
      ],
      "items": {
        "Beverage": [
          "tea",
          "juice",
          "milk"
        ],
        "Job": [
          "firefighter",
          "musician",
          "security-guard"
        ],
        "Music": [
          "gospel",
          "techno",
          "house"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"tea\", \"juice\", \"milk\"], \"Job\": [\"firefighter\", \"musician\", \"security-guard\"], \"Music\": [\"gospel\", \"techno\", \"house\"]}"
    },
    "puzzle_hash": "edf08fe86a114fb2baa163b8d9a71016",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Job\", \"Music\"]\n    items = {\n        \"Beverage\": [\"tea\", \"juice\", \"milk\"],\n        \"Job\": [\"firefighter\", \"musician\", \"security-guard\"],\n        \"Music\": [\"gospel\", \"techno\", \"house\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes techno music and the person who likes juice are at positions with the same parity\n    problem.addConstraint(lambda techno, juice: techno % 2 == juice % 2,\n                          [\"Music:techno\", \"Beverage:juice\"])\n    \n    # Clue 2: the person who likes juice is directly between the person who works as a security-guard and the person who likes gospel music\n    # Directly between means juice position is one more than one and one less than the other\n    problem.addConstraint(lambda juice, security, gospel:\n                          (juice == security + 1 and juice == gospel - 1) or\n                          (juice == gospel + 1 and juice == security - 1),\n                          [\"Beverage:juice\", \"Job:security-guard\", \"Music:gospel\"])\n    \n    # Clue 3: the person who works as a musician is somewhere between the person who works as a security-guard and the person who likes tea (not necessarily immediately)\n    # musician position is strictly between security and tea positions\n    problem.addConstraint(lambda musician, security, tea:\n                          (security < musician < tea) or (tea < musician < security),\n                          [\"Job:musician\", \"Job:security-guard\", \"Beverage:tea\"])\n    \n    # Clue 4: the person who likes techno music is at the same position as or to the left of the person who likes house music\n    problem.addConstraint(lambda techno, house: techno <= house,\n                          [\"Music:techno\", \"Music:house\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['tea', 'juice', 'milk'], 'Job': ['firefighter', 'musician', 'security-guard'], 'Music': ['gospel', 'techno', 'house']}\n",
    "success": true,
    "execution_time": 0.001804,
    "timestamp": "20250918_092700",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['tea', 'juice', 'milk'], 'Job': ['firefighter', 'musician', 'security-guard'], 'Music': ['gospel', 'techno', 'house']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_1",
    "puzzle": {
      "id": "simple_3x3_1",
      "title": "Einstein Puzzle simple_3x3_1 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.030972958999999998
      },
      "clues": [
        "the person who likes funk music and the person who likes eggplant are at positions with different parity (one at odd, one at even position)",
        "the person who likes asparagus is to the right of the person who likes folk music (not necessarily immediately)",
        "the person who uses van for transportation is a different person than the person who likes funk music",
        "the person who uses van for transportation is at the same position as or to the right of the person who uses boat for transportation",
        "the person who likes folk music is somewhere between the person who uses bus for transportation and the person who uses van for transportation (not necessarily immediately adjacent)"
      ],
      "categories": [
        "Food",
        "Music",
        "Transport"
      ],
      "items": {
        "Food": [
          "lettuce",
          "eggplant",
          "asparagus"
        ],
        "Music": [
          "funk",
          "folk",
          "gospel"
        ],
        "Transport": [
          "bus",
          "boat",
          "van"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"lettuce\", \"eggplant\", \"asparagus\"], \"Music\": [\"funk\", \"folk\", \"gospel\"], \"Transport\": [\"bus\", \"boat\", \"van\"]}"
    },
    "puzzle_hash": "0d42cc58c761cfbe7c2b32297321d576",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Music\", \"Transport\"]\n    items = {\n        \"Food\": [\"lettuce\", \"eggplant\", \"asparagus\"],\n        \"Music\": [\"funk\", \"folk\", \"gospel\"],\n        \"Transport\": [\"bus\", \"boat\", \"van\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: funk music and eggplant are at positions with different parity\n    problem.addConstraint(\n        lambda funk_pos, eggplant_pos: (funk_pos % 2) != (eggplant_pos % 2),\n        [\"Music:funk\", \"Food:eggplant\"]\n    )\n    \n    # Clue 2: asparagus is to the right of folk music (not necessarily immediately)\n    problem.addConstraint(\n        lambda asparagus_pos, folk_pos: asparagus_pos > folk_pos,\n        [\"Food:asparagus\", \"Music:folk\"]\n    )\n    \n    # Clue 3: van user is different person than funk music liker\n    problem.addConstraint(\n        lambda van_pos, funk_pos: van_pos != funk_pos,\n        [\"Transport:van\", \"Music:funk\"]\n    )\n    \n    # Clue 4: van user is at same position as or to the right of boat user\n    problem.addConstraint(\n        lambda van_pos, boat_pos: van_pos >= boat_pos,\n        [\"Transport:van\", \"Transport:boat\"]\n    )\n    \n    # Clue 5: folk music liker is somewhere between bus user and van user (not necessarily immediately adjacent)\n    # This means folk_pos is strictly between bus_pos and van_pos\n    # So folk_pos > min(bus_pos, van_pos) and folk_pos < max(bus_pos, van_pos)\n    problem.addConstraint(\n        lambda folk_pos, bus_pos, van_pos: (min(bus_pos, van_pos) < folk_pos < max(bus_pos, van_pos)),\n        [\"Music:folk\", \"Transport:bus\", \"Transport:van\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['lettuce', 'eggplant', 'asparagus'], 'Music': ['funk', 'folk', 'gospel'], 'Transport': ['bus', 'boat', 'van']}\n",
    "success": true,
    "execution_time": 0.001733,
    "timestamp": "20250918_092311",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['lettuce', 'eggplant', 'asparagus'], 'Music': ['funk', 'folk', 'gospel'], 'Transport': ['bus', 'boat', 'van']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_97",
    "puzzle": {
      "id": "simple_3x3_97",
      "title": "Einstein Puzzle simple_3x3_97 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.011078042000000066
      },
      "clues": [
        "the person who has lizard as a pet is at the same position as or to the right of the person who likes comedy movies",
        "the person who likes animation movies is to the right of the person who works as a firefighter (not necessarily immediately)",
        "the person who has guinea-pig as a pet is somewhere between the person who works as a designer and the person who likes animation movies (not necessarily immediately adjacent)",
        "the person who has lizard as a pet is at the same position as or to the left of the person who works as a designer"
      ],
      "categories": [
        "Job",
        "Movie",
        "Pet"
      ],
      "items": {
        "Job": [
          "designer",
          "firefighter",
          "videographer"
        ],
        "Movie": [
          "comedy",
          "satire",
          "animation"
        ],
        "Pet": [
          "lizard",
          "guinea-pig",
          "rabbit"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"designer\", \"firefighter\", \"videographer\"], \"Movie\": [\"comedy\", \"satire\", \"animation\"], \"Pet\": [\"lizard\", \"guinea-pig\", \"rabbit\"]}"
    },
    "puzzle_hash": "1a76b833645f895c0b5be8b28f9d69a4",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Movie\", \"Pet\"]\n    items = {\n        \"Job\": [\"designer\", \"firefighter\", \"videographer\"],\n        \"Movie\": [\"comedy\", \"satire\", \"animation\"],\n        \"Pet\": [\"lizard\", \"guinea-pig\", \"rabbit\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who has lizard as a pet is at the same position as or to the right of the person who likes comedy movies\n    problem.addConstraint(lambda lizard_pos, comedy_pos: lizard_pos >= comedy_pos,\n                          [\"Pet:lizard\", \"Movie:comedy\"])\n    \n    # Clue 2: the person who likes animation movies is to the right of the person who works as a firefighter (not necessarily immediately)\n    problem.addConstraint(lambda animation_pos, firefighter_pos: animation_pos > firefighter_pos,\n                          [\"Movie:animation\", \"Job:firefighter\"])\n    \n    # Clue 3: the person who has guinea-pig as a pet is somewhere between the person who works as a designer and the person who likes animation movies (not necessarily immediately adjacent)\n    # This means guinea-pig position is strictly between designer and animation positions\n    def between(guinea_pig_pos, designer_pos, animation_pos):\n        low = min(designer_pos, animation_pos)\n        high = max(designer_pos, animation_pos)\n        return low < guinea_pig_pos < high\n    problem.addConstraint(between, [\"Pet:guinea-pig\", \"Job:designer\", \"Movie:animation\"])\n    \n    # Clue 4: the person who has lizard as a pet is at the same position as or to the left of the person who works as a designer\n    problem.addConstraint(lambda lizard_pos, designer_pos: lizard_pos <= designer_pos,\n                          [\"Pet:lizard\", \"Job:designer\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['designer', 'firefighter', 'videographer'], 'Movie': ['comedy', 'satire', 'animation'], 'Pet': ['lizard', 'guinea-pig', 'rabbit']}\n",
    "success": true,
    "execution_time": 0.002986,
    "timestamp": "20250918_093958",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['designer', 'firefighter', 'videographer'], 'Movie': ['comedy', 'satire', 'animation'], 'Pet': ['lizard', 'guinea-pig', 'rabbit']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_61",
    "puzzle": {
      "id": "simple_3x3_61",
      "title": "Einstein Puzzle simple_3x3_61 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.01348912499999999
      },
      "clues": [
        "the person who likes hip-hop music is to the left of the person who likes artichoke (not necessarily immediately)",
        "the person who likes hip-hop music is at the same position as or to the right of the person who likes tea",
        "the person who likes artichoke is somewhere between the person who likes r&b music and the person who likes potato (not necessarily immediately adjacent)",
        "the person who likes coffee is at an end position (either leftmost or rightmost)"
      ],
      "categories": [
        "Beverage",
        "Food",
        "Music"
      ],
      "items": {
        "Beverage": [
          "tea",
          "hot-chocolate",
          "coffee"
        ],
        "Food": [
          "potato",
          "artichoke",
          "pomegranate"
        ],
        "Music": [
          "hip-hop",
          "techno",
          "r&b"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"tea\", \"hot-chocolate\", \"coffee\"], \"Food\": [\"potato\", \"artichoke\", \"pomegranate\"], \"Music\": [\"hip-hop\", \"techno\", \"r&b\"]}"
    },
    "puzzle_hash": "3119216026f29aff5548131b5dc65e09",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Food\", \"Music\"]\n    items = {\n        \"Beverage\": [\"tea\", \"hot-chocolate\", \"coffee\"],\n        \"Food\": [\"potato\", \"artichoke\", \"pomegranate\"],\n        \"Music\": [\"hip-hop\", \"techno\", \"r&b\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes hip-hop music is to the left of the person who likes artichoke (not necessarily immediately)\n    problem.addConstraint(lambda hiphop, artichoke: hiphop < artichoke,\n                          [\"Music:hip-hop\", \"Food:artichoke\"])\n    \n    # Clue 2: the person who likes hip-hop music is at the same position as or to the right of the person who likes tea\n    problem.addConstraint(lambda hiphop, tea: hiphop >= tea,\n                          [\"Music:hip-hop\", \"Beverage:tea\"])\n    \n    # Clue 3: the person who likes artichoke is somewhere between the person who likes r&b music and the person who likes potato (not necessarily immediately adjacent)\n    # This means artichoke position is strictly between r&b and potato positions\n    def between(artichoke, rnb, potato):\n        return (rnb < artichoke < potato) or (potato < artichoke < rnb)\n    problem.addConstraint(between, [\"Food:artichoke\", \"Music:r&b\", \"Food:potato\"])\n    \n    # Clue 4: the person who likes coffee is at an end position (either leftmost or rightmost)\n    problem.addConstraint(lambda coffee: coffee == 0 or coffee == num_positions - 1,\n                          [\"Beverage:coffee\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['tea', 'hot-chocolate', 'coffee'], 'Food': ['potato', 'artichoke', 'pomegranate'], 'Music': ['hip-hop', 'techno', 'r&b']}\n",
    "success": true,
    "execution_time": 0.002859,
    "timestamp": "20250918_093343",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['tea', 'hot-chocolate', 'coffee'], 'Food': ['potato', 'artichoke', 'pomegranate'], 'Music': ['hip-hop', 'techno', 'r&b']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_94",
    "puzzle": {
      "id": "simple_3x3_94",
      "title": "Einstein Puzzle simple_3x3_94 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.00915887500000001
      },
      "clues": [
        "the person who likes drama movies is to the right of the person who has horse as a pet (not necessarily immediately)",
        "the person who likes nectarine is adjacent to the person who has guinea-pig as a pet (either immediately left or right)",
        "the person who has guinea-pig as a pet is at the same position as or to the left of the person who likes kiwi",
        "the person who likes spinach is directly between the person who likes western movies and the person who likes adventure movies",
        "the person who has guinea-pig as a pet is at the same position as or to the left of the person who likes adventure movies"
      ],
      "categories": [
        "Food",
        "Movie",
        "Pet"
      ],
      "items": {
        "Food": [
          "nectarine",
          "spinach",
          "kiwi"
        ],
        "Movie": [
          "western",
          "drama",
          "adventure"
        ],
        "Pet": [
          "horse",
          "guinea-pig",
          "lizard"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"nectarine\", \"spinach\", \"kiwi\"], \"Movie\": [\"western\", \"drama\", \"adventure\"], \"Pet\": [\"horse\", \"guinea-pig\", \"lizard\"]}"
    },
    "puzzle_hash": "5d76515fd667af87181656a67284e51d",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Movie\", \"Pet\"]\n    items = {\n        \"Food\": [\"nectarine\", \"spinach\", \"kiwi\"],\n        \"Movie\": [\"western\", \"drama\", \"adventure\"],\n        \"Pet\": [\"horse\", \"guinea-pig\", \"lizard\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: drama movie is to the right of horse pet (not necessarily immediately)\n    problem.addConstraint(lambda drama_pos, horse_pos: drama_pos > horse_pos,\n                          [\"Movie:drama\", \"Pet:horse\"])\n    \n    # Clue 2: nectarine is adjacent to guinea-pig (immediately left or right)\n    problem.addConstraint(lambda nectarine_pos, guinea_pos: abs(nectarine_pos - guinea_pos) == 1,\n                          [\"Food:nectarine\", \"Pet:guinea-pig\"])\n    \n    # Clue 3: guinea-pig is at the same position as or to the left of kiwi\n    problem.addConstraint(lambda guinea_pos, kiwi_pos: guinea_pos <= kiwi_pos,\n                          [\"Pet:guinea-pig\", \"Food:kiwi\"])\n    \n    # Clue 4: spinach is directly between western and adventure movies\n    # That means spinach position is exactly between western and adventure\n    # So spinach_pos == western_pos +1 and spinach_pos == adventure_pos -1 or vice versa\n    problem.addConstraint(lambda spinach_pos, western_pos, adventure_pos:\n                          (spinach_pos == western_pos + 1 and spinach_pos == adventure_pos - 1) or\n                          (spinach_pos == adventure_pos + 1 and spinach_pos == western_pos - 1),\n                          [\"Food:spinach\", \"Movie:western\", \"Movie:adventure\"])\n    \n    # Clue 5: guinea-pig is at the same position as or to the left of adventure movie\n    problem.addConstraint(lambda guinea_pos, adventure_pos: guinea_pos <= adventure_pos,\n                          [\"Pet:guinea-pig\", \"Movie:adventure\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['nectarine', 'spinach', 'kiwi'], 'Movie': ['western', 'drama', 'adventure'], 'Pet': ['horse', 'guinea-pig', 'lizard']}\n",
    "success": true,
    "execution_time": 0.003289,
    "timestamp": "20250918_093930",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['nectarine', 'spinach', 'kiwi'], 'Movie': ['western', 'drama', 'adventure'], 'Pet': ['horse', 'guinea-pig', 'lizard']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_57",
    "puzzle": {
      "id": "simple_3x3_57",
      "title": "Einstein Puzzle simple_3x3_57 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.020269916999999804
      },
      "clues": [
        "the person who uses airplane for transportation is to the right of the person who uses snowmobile for transportation (not necessarily immediately)",
        "the person who uses quad-bike for transportation is at the same position as or to the right of the spanish person",
        "the person who likes zucchini is a different person than the person who uses airplane for transportation",
        "the person who uses snowmobile for transportation is at the same position as or to the right of the turkish person",
        "the pakistani person is directly between the person who uses quad-bike for transportation and the person who likes lettuce"
      ],
      "categories": [
        "Food",
        "Nationality",
        "Transport"
      ],
      "items": {
        "Food": [
          "lettuce",
          "garlic",
          "zucchini"
        ],
        "Nationality": [
          "turkish",
          "pakistani",
          "spanish"
        ],
        "Transport": [
          "snowmobile",
          "airplane",
          "quad-bike"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"lettuce\", \"garlic\", \"zucchini\"], \"Nationality\": [\"turkish\", \"pakistani\", \"spanish\"], \"Transport\": [\"snowmobile\", \"airplane\", \"quad-bike\"]}"
    },
    "puzzle_hash": "f0c7c79bb900322642c3a5d8ae3a2932",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Nationality\", \"Transport\"]\n    items = {\n        \"Food\": [\"lettuce\", \"garlic\", \"zucchini\"],\n        \"Nationality\": [\"turkish\", \"pakistani\", \"spanish\"],\n        \"Transport\": [\"snowmobile\", \"airplane\", \"quad-bike\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: airplane is to the right of snowmobile (not necessarily immediately)\n    problem.addConstraint(\n        lambda airplane, snowmobile: airplane > snowmobile,\n        [\"Transport:airplane\", \"Transport:snowmobile\"]\n    )\n    \n    # Clue 2: quad-bike is at the same position as or to the right of spanish\n    problem.addConstraint(\n        lambda quad, spanish: quad >= spanish,\n        [\"Transport:quad-bike\", \"Nationality:spanish\"]\n    )\n    \n    # Clue 3: zucchini and airplane are different persons\n    problem.addConstraint(\n        lambda zucchini, airplane: zucchini != airplane,\n        [\"Food:zucchini\", \"Transport:airplane\"]\n    )\n    \n    # Clue 4: snowmobile is at the same position as or to the right of turkish\n    problem.addConstraint(\n        lambda snowmobile, turkish: snowmobile >= turkish,\n        [\"Transport:snowmobile\", \"Nationality:turkish\"]\n    )\n    \n    # Clue 5: pakistani is directly between quad-bike and lettuce\n    # That means pakistani is at position x, quad-bike at y, lettuce at z\n    # and x is directly between y and z:\n    # (x == y + 1 and x == z - 1) or (x == z + 1 and x == y - 1)\n    problem.addConstraint(\n        lambda pakistani, quad, lettuce: (pakistani == quad + 1 and pakistani == lettuce - 1) or (pakistani == lettuce + 1 and pakistani == quad - 1),\n        [\"Nationality:pakistani\", \"Transport:quad-bike\", \"Food:lettuce\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['lettuce', 'garlic', 'zucchini'], 'Nationality': ['turkish', 'pakistani', 'spanish'], 'Transport': ['snowmobile', 'airplane', 'quad-bike']}\n",
    "success": true,
    "execution_time": 0.002845,
    "timestamp": "20250918_093259",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['lettuce', 'garlic', 'zucchini'], 'Nationality': ['turkish', 'pakistani', 'spanish'], 'Transport': ['snowmobile', 'airplane', 'quad-bike']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_90",
    "puzzle": {
      "id": "simple_3x3_90",
      "title": "Einstein Puzzle simple_3x3_90 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.014580833000000126
      },
      "clues": [
        "the person who enjoys reading is to the right of the person who likes cabbage (not necessarily immediately)",
        "the person who likes spinach is directly between the person who likes watermelon and the person who likes cabbage",
        "the person who enjoys magic-tricks is at the same position as or to the left of the person who likes satire movies",
        "the person who enjoys magic-tricks is directly between the person who likes romance movies and the person who likes satire movies"
      ],
      "categories": [
        "Food",
        "Hobby",
        "Movie"
      ],
      "items": {
        "Food": [
          "cabbage",
          "spinach",
          "watermelon"
        ],
        "Hobby": [
          "gardening",
          "magic-tricks",
          "reading"
        ],
        "Movie": [
          "romance",
          "family",
          "satire"
        ]
      },
      "ground_truth_solution": "{\"Food\": [\"cabbage\", \"spinach\", \"watermelon\"], \"Hobby\": [\"gardening\", \"magic-tricks\", \"reading\"], \"Movie\": [\"romance\", \"family\", \"satire\"]}"
    },
    "puzzle_hash": "3961653cebffd959ef836b386bc06aff",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Hobby\", \"Movie\"]\n    items = {\n        \"Food\": [\"cabbage\", \"spinach\", \"watermelon\"],\n        \"Hobby\": [\"gardening\", \"magic-tricks\", \"reading\"],\n        \"Movie\": [\"romance\", \"family\", \"satire\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys reading is to the right of the person who likes cabbage (not necessarily immediately)\n    problem.addConstraint(lambda reading, cabbage: reading > cabbage, [\"Hobby:reading\", \"Food:cabbage\"])\n    \n    # Clue 2: the person who likes spinach is directly between the person who likes watermelon and the person who likes cabbage\n    # That means spinach position is between watermelon and cabbage positions, directly adjacent on both sides\n    problem.addConstraint(\n        lambda spinach, watermelon, cabbage: (spinach == watermelon + 1 and spinach == cabbage - 1) or (spinach == cabbage + 1 and spinach == watermelon - 1),\n        [\"Food:spinach\", \"Food:watermelon\", \"Food:cabbage\"]\n    )\n    \n    # Clue 3: the person who enjoys magic-tricks is at the same position as or to the left of the person who likes satire movies\n    problem.addConstraint(lambda magic, satire: magic <= satire, [\"Hobby:magic-tricks\", \"Movie:satire\"])\n    \n    # Clue 4: the person who enjoys magic-tricks is directly between the person who likes romance movies and the person who likes satire movies\n    problem.addConstraint(\n        lambda magic, romance, satire: (magic == romance + 1 and magic == satire - 1) or (magic == satire + 1 and magic == romance - 1),\n        [\"Hobby:magic-tricks\", \"Movie:romance\", \"Movie:satire\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Food': ['cabbage', 'spinach', 'watermelon'], 'Hobby': ['gardening', 'magic-tricks', 'reading'], 'Movie': ['romance', 'family', 'satire']}\n",
    "success": true,
    "execution_time": 0.002914,
    "timestamp": "20250918_093842",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Food': ['cabbage', 'spinach', 'watermelon'], 'Hobby': ['gardening', 'magic-tricks', 'reading'], 'Movie': ['romance', 'family', 'satire']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_26",
    "puzzle": {
      "id": "simple_3x3_26",
      "title": "Einstein Puzzle simple_3x3_26 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.016723040999999994
      },
      "clues": [
        "the person who uses bike for transportation is somewhere between the person who works as a photographer and the person who uses snowmobile for transportation (not necessarily immediately adjacent)",
        "the person who uses airplane for transportation is to the right of the person who uses snowmobile for transportation (not necessarily immediately)",
        "the russian person is somewhere between the indonesian person and the person who uses airplane for transportation (not necessarily immediately adjacent)",
        "the person who uses airplane for transportation is adjacent to the person who works as a pilot (either immediately left or right)"
      ],
      "categories": [
        "Job",
        "Nationality",
        "Transport"
      ],
      "items": {
        "Job": [
          "lawyer",
          "pilot",
          "photographer"
        ],
        "Nationality": [
          "indonesian",
          "russian",
          "american"
        ],
        "Transport": [
          "snowmobile",
          "bike",
          "airplane"
        ]
      },
      "ground_truth_solution": "{\"Job\": [\"lawyer\", \"pilot\", \"photographer\"], \"Nationality\": [\"indonesian\", \"russian\", \"american\"], \"Transport\": [\"snowmobile\", \"bike\", \"airplane\"]}"
    },
    "puzzle_hash": "d9d14d4194b043cdc16116d53764220f",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Job\", \"Nationality\", \"Transport\"]\n    items = {\n        \"Job\": [\"lawyer\", \"pilot\", \"photographer\"],\n        \"Nationality\": [\"indonesian\", \"russian\", \"american\"],\n        \"Transport\": [\"snowmobile\", \"bike\", \"airplane\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1:\n    # the person who uses bike for transportation is somewhere between the person who works as a photographer and the person who uses snowmobile for transportation (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda bike, photographer, snowmobile: (photographer < bike < snowmobile) or (snowmobile < bike < photographer),\n        [\"Transport:bike\", \"Job:photographer\", \"Transport:snowmobile\"]\n    )\n    \n    # Clue 2:\n    # the person who uses airplane for transportation is to the right of the person who uses snowmobile for transportation (not necessarily immediately)\n    problem.addConstraint(\n        lambda airplane, snowmobile: airplane > snowmobile,\n        [\"Transport:airplane\", \"Transport:snowmobile\"]\n    )\n    \n    # Clue 3:\n    # the russian person is somewhere between the indonesian person and the person who uses airplane for transportation (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda russian, indonesian, airplane: (indonesian < russian < airplane) or (airplane < russian < indonesian),\n        [\"Nationality:russian\", \"Nationality:indonesian\", \"Transport:airplane\"]\n    )\n    \n    # Clue 4:\n    # the person who uses airplane for transportation is adjacent to the person who works as a pilot (either immediately left or right)\n    problem.addConstraint(\n        lambda airplane, pilot: abs(airplane - pilot) == 1,\n        [\"Transport:airplane\", \"Job:pilot\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Job': ['lawyer', 'pilot', 'photographer'], 'Nationality': ['indonesian', 'russian', 'american'], 'Transport': ['snowmobile', 'bike', 'airplane']}\n",
    "success": true,
    "execution_time": 0.002799,
    "timestamp": "20250918_092751",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Job': ['lawyer', 'pilot', 'photographer'], 'Nationality': ['indonesian', 'russian', 'american'], 'Transport': ['snowmobile', 'bike', 'airplane']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_75",
    "puzzle": {
      "id": "simple_3x3_75",
      "title": "Einstein Puzzle simple_3x3_75 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.008006374999999899
      },
      "clues": [
        "the person who likes mirinda is to the right of the person who works as a software-developer (not necessarily immediately)",
        "the person who works as a software-developer is at an end position (either leftmost or rightmost)",
        "the person who works as a entrepreneur is the same person as at least one of the person who likes martial-arts movies or the person who likes hot-chocolate",
        "the person who likes sprite is directly between the person who likes superhero movies and the person who works as a police-officer"
      ],
      "categories": [
        "Beverage",
        "Job",
        "Movie"
      ],
      "items": {
        "Beverage": [
          "hot-chocolate",
          "sprite",
          "mirinda"
        ],
        "Job": [
          "software-developer",
          "entrepreneur",
          "police-officer"
        ],
        "Movie": [
          "superhero",
          "martial-arts",
          "spy"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"hot-chocolate\", \"sprite\", \"mirinda\"], \"Job\": [\"software-developer\", \"entrepreneur\", \"police-officer\"], \"Movie\": [\"superhero\", \"martial-arts\", \"spy\"]}"
    },
    "puzzle_hash": "5a1b7ef97b5176ca9372a4cb690b26f6",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Job\", \"Movie\"]\n    items = {\n        \"Beverage\": [\"hot-chocolate\", \"sprite\", \"mirinda\"],\n        \"Job\": [\"software-developer\", \"entrepreneur\", \"police-officer\"],\n        \"Movie\": [\"superhero\", \"martial-arts\", \"spy\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes mirinda is to the right of the person who works as a software-developer (not necessarily immediately)\n    problem.addConstraint(lambda mirinda, sd: sd < mirinda,\n                          [\"Beverage:mirinda\", \"Job:software-developer\"])\n    \n    # Clue 2: the person who works as a software-developer is at an end position (either leftmost or rightmost)\n    problem.addConstraint(lambda sd: sd == 0 or sd == num_positions - 1,\n                          [\"Job:software-developer\"])\n    \n    # Clue 3: the person who works as a entrepreneur is the same person as at least one of the person who likes martial-arts movies or the person who likes hot-chocolate\n    # This means entrepreneur position equals martial-arts or entrepreneur position equals hot-chocolate\n    def entrepreneur_constraint(entrepreneur, martial_arts, hot_chocolate):\n        return entrepreneur == martial_arts or entrepreneur == hot_chocolate\n    problem.addConstraint(entrepreneur_constraint,\n                          [\"Job:entrepreneur\", \"Movie:martial-arts\", \"Beverage:hot-chocolate\"])\n    \n    # Clue 4: the person who likes sprite is directly between the person who likes superhero movies and the person who works as a police-officer\n    # \"directly between\" means sprite position is exactly one more than one and one less than the other\n    problem.addConstraint(lambda sprite, superhero, police: (sprite == superhero + 1 and sprite == police - 1) or (sprite == police + 1 and sprite == superhero - 1),\n                          [\"Beverage:sprite\", \"Movie:superhero\", \"Job:police-officer\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['hot-chocolate', 'sprite', 'mirinda'], 'Job': ['software-developer', 'entrepreneur', 'police-officer'], 'Movie': ['superhero', 'martial-arts', 'spy']}\n",
    "success": true,
    "execution_time": 0.002838,
    "timestamp": "20250918_093608",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['hot-chocolate', 'sprite', 'mirinda'], 'Job': ['software-developer', 'entrepreneur', 'police-officer'], 'Movie': ['superhero', 'martial-arts', 'spy']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  },
  {
    "puzzle_id": "simple_3x3_84",
    "puzzle": {
      "id": "simple_3x3_84",
      "title": "Einstein Puzzle simple_3x3_84 (3x3, level 15)",
      "problem": "You are given an Einstein logic puzzle with 3 houses and 3 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
      "source": "generated_simple",
      "metadata": {
        "n_attributes": 3,
        "m_objects": 3,
        "difficulty_level": 15,
        "generation_time": 0.01028862499999983
      },
      "clues": [
        "the person who likes salsa music is to the right of the person who likes soul music (not necessarily immediately)",
        "the person who likes salsa music is to the left of the person who likes coffee (not necessarily immediately)",
        "the person who likes water is at the same position as or to the right of the person who likes salsa music",
        "the person who likes salsa music and the person who works as a analyst are at positions with the same parity (both at odd or both at even positions)",
        "the person who works as a doctor is at the same position as or to the left of the person who likes water"
      ],
      "categories": [
        "Beverage",
        "Job",
        "Music"
      ],
      "items": {
        "Beverage": [
          "milk",
          "water",
          "coffee"
        ],
        "Job": [
          "doctor",
          "analyst",
          "freelancer"
        ],
        "Music": [
          "soul",
          "salsa",
          "house"
        ]
      },
      "ground_truth_solution": "{\"Beverage\": [\"milk\", \"water\", \"coffee\"], \"Job\": [\"doctor\", \"analyst\", \"freelancer\"], \"Music\": [\"soul\", \"salsa\", \"house\"]}"
    },
    "puzzle_hash": "bb4732f6801f1d1d8986375201e6968c",
    "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Job\", \"Music\"]\n    items = {\n        \"Beverage\": [\"milk\", \"water\", \"coffee\"],\n        \"Job\": [\"doctor\", \"analyst\", \"freelancer\"],\n        \"Music\": [\"soul\", \"salsa\", \"house\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes salsa music is to the right of the person who likes soul music (not necessarily immediately)\n    problem.addConstraint(lambda salsa, soul: salsa > soul, [\"Music:salsa\", \"Music:soul\"])\n    \n    # Clue 2: the person who likes salsa music is to the left of the person who likes coffee (not necessarily immediately)\n    problem.addConstraint(lambda salsa, coffee: salsa < coffee, [\"Music:salsa\", \"Beverage:coffee\"])\n    \n    # Clue 3: the person who likes water is at the same position as or to the right of the person who likes salsa music\n    problem.addConstraint(lambda water, salsa: water >= salsa, [\"Beverage:water\", \"Music:salsa\"])\n    \n    # Clue 4: the person who likes salsa music and the person who works as an analyst are at positions with the same parity\n    problem.addConstraint(lambda salsa, analyst: salsa % 2 == analyst % 2, [\"Music:salsa\", \"Job:analyst\"])\n    \n    # Clue 5: the person who works as a doctor is at the same position as or to the left of the person who likes water\n    problem.addConstraint(lambda doctor, water: doctor <= water, [\"Job:doctor\", \"Beverage:water\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
    "execution_result": "{'Beverage': ['milk', 'water', 'coffee'], 'Job': ['doctor', 'analyst', 'freelancer'], 'Music': ['soul', 'salsa', 'house']}\n",
    "success": true,
    "execution_time": 0.002918,
    "timestamp": "20250918_093743",
    "verification": {
      "verified": true,
      "is_correct": true,
      "ground_truth": "{'Beverage': ['milk', 'water', 'coffee'], 'Job': ['doctor', 'analyst', 'freelancer'], 'Music': ['soul', 'salsa', 'house']}",
      "verification_time": null,
      "verification_method": null,
      "verification_notes": null,
      "feedback": null
    },
    "additional_metadata": {
      "timestamp": "20250918_092300"
    }
  }
]