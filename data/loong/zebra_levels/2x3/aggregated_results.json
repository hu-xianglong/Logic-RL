{
  "results": [
    {
      "puzzle_id": "simple_2x3_1",
      "puzzle": {
        "id": "simple_2x3_1",
        "title": "Einstein Puzzle simple_2x3_1 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005543209
        },
        "clues": [
          "the person who likes cola is directly between the person who likes nectarine and the person who likes hot-chocolate",
          "the person who likes mango is adjacent to the person who likes nectarine (either immediately left or right)",
          "the person who likes nectarine is immediately to the left of the person who likes cola"
        ],
        "categories": [
          "Beverage",
          "Food"
        ],
        "items": {
          "Beverage": [
            "almond-milk",
            "cola",
            "hot-chocolate"
          ],
          "Food": [
            "nectarine",
            "mango",
            "pear"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"almond-milk\", \"cola\", \"hot-chocolate\"], \"Food\": [\"nectarine\", \"mango\", \"pear\"]}"
      },
      "puzzle_hash": "26db36b19d2c42b48fbc9a7bae2f0502",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Food\"]\n    items = {\n        \"Beverage\": [\"almond-milk\", \"cola\", \"hot-chocolate\"],\n        \"Food\": [\"nectarine\", \"mango\", \"pear\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes cola is directly between the person who likes nectarine and the person who likes hot-chocolate\n    problem.addConstraint(\n        lambda cola, nectarine, hot_chocolate: (cola == nectarine + 1 and cola == hot_chocolate - 1) or (cola == hot_chocolate + 1 and cola == nectarine - 1),\n        [\"Beverage:cola\", \"Food:nectarine\", \"Beverage:hot-chocolate\"]\n    )\n    \n    # Clue 2: the person who likes mango is adjacent to the person who likes nectarine (either immediately left or right)\n    problem.addConstraint(\n        lambda mango, nectarine: abs(mango - nectarine) == 1,\n        [\"Food:mango\", \"Food:nectarine\"]\n    )\n    \n    # Clue 3: the person who likes nectarine is immediately to the left of the person who likes cola\n    problem.addConstraint(\n        lambda nectarine, cola: nectarine == cola - 1,\n        [\"Food:nectarine\", \"Beverage:cola\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['almond-milk', 'cola', 'hot-chocolate'], 'Food': ['nectarine', 'mango', 'pear']}\n",
      "success": true,
      "execution_time": 0.001898,
      "timestamp": "20250918_084356",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['almond-milk', 'cola', 'hot-chocolate'], 'Food': ['nectarine', 'mango', 'pear']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_2",
      "puzzle": {
        "id": "simple_2x3_2",
        "title": "Einstein Puzzle simple_2x3_2 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0032811249999999993
        },
        "clues": [
          "the person who likes rock music is at the same position as or to the left of the person who plays ice-hockey",
          "the person who plays skateboarding is somewhere between the person who plays skiing and the person who likes soul music (not necessarily immediately adjacent)",
          "the person who likes rock music and the person who plays skiing are at positions with different parity (one at odd, one at even position)"
        ],
        "categories": [
          "Music",
          "Sport"
        ],
        "items": {
          "Music": [
            "pop",
            "rock",
            "soul"
          ],
          "Sport": [
            "skiing",
            "skateboarding",
            "ice-hockey"
          ]
        },
        "ground_truth_solution": "{\"Music\": [\"pop\", \"rock\", \"soul\"], \"Sport\": [\"skiing\", \"skateboarding\", \"ice-hockey\"]}"
      },
      "puzzle_hash": "b2e5b1db52122da5d87cf19dd8fb3950",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Music\", \"Sport\"]\n    items = {\n        \"Music\": [\"pop\", \"rock\", \"soul\"],\n        \"Sport\": [\"skiing\", \"skateboarding\", \"ice-hockey\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes rock music is at the same position as or to the left of the person who plays ice-hockey\n    problem.addConstraint(lambda rock_pos, ice_pos: rock_pos <= ice_pos,\n                          [\"Music:rock\", \"Sport:ice-hockey\"])\n    \n    # Clue 2: the person who plays skateboarding is somewhere between the person who plays skiing and the person who likes soul music (not necessarily immediately adjacent)\n    # This means skateboarding position is strictly between skiing and soul positions\n    problem.addConstraint(lambda skate_pos, skiing_pos, soul_pos:\n                          (skiing_pos < skate_pos < soul_pos) or (soul_pos < skate_pos < skiing_pos),\n                          [\"Sport:skateboarding\", \"Sport:skiing\", \"Music:soul\"])\n    \n    # Clue 3: the person who likes rock music and the person who plays skiing are at positions with different parity\n    problem.addConstraint(lambda rock_pos, skiing_pos: (rock_pos % 2) != (skiing_pos % 2),\n                          [\"Music:rock\", \"Sport:skiing\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['pop', 'rock', 'soul'], 'Sport': ['skiing', 'skateboarding', 'ice-hockey']}\n",
      "success": true,
      "execution_time": 0.002895,
      "timestamp": "20250918_084404",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['pop', 'rock', 'soul'], 'Sport': ['skiing', 'skateboarding', 'ice-hockey']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_3",
      "puzzle": {
        "id": "simple_2x3_3",
        "title": "Einstein Puzzle simple_2x3_3 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.009324792000000002
        },
        "clues": [
          "the colombian person is the same person as the person who enjoys collecting",
          "the person who enjoys collecting is immediately to the right of the person who enjoys puzzles",
          "the person who enjoys puzzles is to the right of the american person (not necessarily immediately)"
        ],
        "categories": [
          "Hobby",
          "Nationality"
        ],
        "items": {
          "Hobby": [
            "board-games",
            "puzzles",
            "collecting"
          ],
          "Nationality": [
            "american",
            "chinese",
            "colombian"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"board-games\", \"puzzles\", \"collecting\"], \"Nationality\": [\"american\", \"chinese\", \"colombian\"]}"
      },
      "puzzle_hash": "e32acb01c27d3b868fdfe60ad7d98f51",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Nationality\"]\n    items = {\n        \"Hobby\": [\"board-games\", \"puzzles\", \"collecting\"],\n        \"Nationality\": [\"american\", \"chinese\", \"colombian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the colombian person is the same person as the person who enjoys collecting\n    problem.addConstraint(lambda c, col: c == col, [\"Hobby:collecting\", \"Nationality:colombian\"])\n    \n    # Clue 2: the person who enjoys collecting is immediately to the right of the person who enjoys puzzles\n    problem.addConstraint(lambda c, p: c == p + 1, [\"Hobby:collecting\", \"Hobby:puzzles\"])\n    \n    # Clue 3: the person who enjoys puzzles is to the right of the american person (not necessarily immediately)\n    problem.addConstraint(lambda p, a: p > a, [\"Hobby:puzzles\", \"Nationality:american\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['board-games', 'puzzles', 'collecting'], 'Nationality': ['american', 'chinese', 'colombian']}\n",
      "success": true,
      "execution_time": 0.002628,
      "timestamp": "20250918_084414",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['board-games', 'puzzles', 'collecting'], 'Nationality': ['american', 'chinese', 'colombian']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_4",
      "puzzle": {
        "id": "simple_2x3_4",
        "title": "Einstein Puzzle simple_2x3_4 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0033662910000000004
        },
        "clues": [
          "the person who has fish as a pet is directly between the person who plays handball and the person who has bird as a pet",
          "the person who has bird as a pet is to the right of the person who plays climbing (not necessarily immediately)"
        ],
        "categories": [
          "Pet",
          "Sport"
        ],
        "items": {
          "Pet": [
            "cat",
            "fish",
            "bird"
          ],
          "Sport": [
            "handball",
            "climbing",
            "basketball"
          ]
        },
        "ground_truth_solution": "{\"Pet\": [\"cat\", \"fish\", \"bird\"], \"Sport\": [\"handball\", \"climbing\", \"basketball\"]}"
      },
      "puzzle_hash": "abd521ba4ddd07559913d658895b66f6",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Pet\", \"Sport\"]\n    items = {\n        \"Pet\": [\"cat\", \"fish\", \"bird\"],\n        \"Sport\": [\"handball\", \"climbing\", \"basketball\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who has fish as a pet is directly between the person who plays handball and the person who has bird as a pet\n    problem.addConstraint(\n        lambda fish, handball, bird: (fish == handball + 1 and fish == bird - 1) or (fish == bird + 1 and fish == handball - 1),\n        [\"Pet:fish\", \"Sport:handball\", \"Pet:bird\"]\n    )\n    \n    # Clue 2: the person who has bird as a pet is to the right of the person who plays climbing (not necessarily immediately)\n    problem.addConstraint(\n        lambda bird, climbing: bird > climbing,\n        [\"Pet:bird\", \"Sport:climbing\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Pet': ['cat', 'fish', 'bird'], 'Sport': ['handball', 'climbing', 'basketball']}\n",
      "success": true,
      "execution_time": 0.002334,
      "timestamp": "20250918_084421",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Pet': ['cat', 'fish', 'bird'], 'Sport': ['handball', 'climbing', 'basketball']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_5",
      "puzzle": {
        "id": "simple_2x3_5",
        "title": "Einstein Puzzle simple_2x3_5 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003984667000000004
        },
        "clues": [
          "the person who uses car for transportation is at an even-numbered position",
          "the person who uses snowmobile for transportation is adjacent to the person who likes mystery movies (either immediately left or right)",
          "the person who uses car for transportation is at the same position as or to the left of the person who uses bike for transportation",
          "the person who likes epic movies is to the right of the person who likes adventure movies (not necessarily immediately)"
        ],
        "categories": [
          "Movie",
          "Transport"
        ],
        "items": {
          "Movie": [
            "adventure",
            "mystery",
            "epic"
          ],
          "Transport": [
            "snowmobile",
            "car",
            "bike"
          ]
        },
        "ground_truth_solution": "{\"Movie\": [\"adventure\", \"mystery\", \"epic\"], \"Transport\": [\"snowmobile\", \"car\", \"bike\"]}"
      },
      "puzzle_hash": "07f81c635a82716e0e86b52798d53586",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Transport\"]\n    items = {\n        \"Movie\": [\"adventure\", \"mystery\", \"epic\"],\n        \"Transport\": [\"snowmobile\", \"car\", \"bike\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses car for transportation is at an even-numbered position\n    problem.addConstraint(lambda x: x % 2 == 0, [\"Transport:car\"])\n    \n    # Clue 2: the person who uses snowmobile for transportation is adjacent to the person who likes mystery movies\n    problem.addConstraint(lambda x, y: abs(x - y) == 1, [\"Transport:snowmobile\", \"Movie:mystery\"])\n    \n    # Clue 3: the person who uses car for transportation is at the same position as or to the left of the person who uses bike for transportation\n    problem.addConstraint(lambda x, y: x <= y, [\"Transport:car\", \"Transport:bike\"])\n    \n    # Clue 4: the person who likes epic movies is to the right of the person who likes adventure movies (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x > y, [\"Movie:epic\", \"Movie:adventure\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "",
      "success": false,
      "execution_time": 0.019028,
      "timestamp": "20250918_084429",
      "verification": {
        "verified": true,
        "is_correct": false,
        "ground_truth": "{'Movie': ['adventure', 'mystery', 'epic'], 'Transport': ['snowmobile', 'car', 'bike']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_6",
      "puzzle": {
        "id": "simple_2x3_6",
        "title": "Einstein Puzzle simple_2x3_6 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.008782790999999998
        },
        "clues": [
          "the person who enjoys singing is immediately to the left of the person who plays soccer",
          "the person who enjoys board-games is a different person than the person who plays soccer",
          "the person who plays cricket is to the right of the person who plays baseball (not necessarily immediately)",
          "the person who plays baseball is adjacent to the person who plays soccer (either immediately left or right)"
        ],
        "categories": [
          "Hobby",
          "Sport"
        ],
        "items": {
          "Hobby": [
            "singing",
            "magic-tricks",
            "board-games"
          ],
          "Sport": [
            "baseball",
            "soccer",
            "cricket"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"singing\", \"magic-tricks\", \"board-games\"], \"Sport\": [\"baseball\", \"soccer\", \"cricket\"]}"
      },
      "puzzle_hash": "de2a16ac7ddc0e9fc0ec40a9612c2f46",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Sport\"]\n    items = {\n        \"Hobby\": [\"singing\", \"magic-tricks\", \"board-games\"],\n        \"Sport\": [\"baseball\", \"soccer\", \"cricket\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys singing is immediately to the left of the person who plays soccer\n    problem.addConstraint(lambda singing, soccer: singing == soccer - 1,\n                          [\"Hobby:singing\", \"Sport:soccer\"])\n    \n    # Clue 2: the person who enjoys board-games is a different person than the person who plays soccer\n    problem.addConstraint(lambda board_games, soccer: board_games != soccer,\n                          [\"Hobby:board-games\", \"Sport:soccer\"])\n    \n    # Clue 3: the person who plays cricket is to the right of the person who plays baseball (not necessarily immediately)\n    problem.addConstraint(lambda baseball, cricket: baseball < cricket,\n                          [\"Sport:baseball\", \"Sport:cricket\"])\n    \n    # Clue 4: the person who plays baseball is adjacent to the person who plays soccer (either immediately left or right)\n    problem.addConstraint(lambda baseball, soccer: abs(baseball - soccer) == 1,\n                          [\"Sport:baseball\", \"Sport:soccer\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['singing', 'magic-tricks', 'board-games'], 'Sport': ['baseball', 'soccer', 'cricket']}\n",
      "success": true,
      "execution_time": 0.001425,
      "timestamp": "20250918_084437",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['singing', 'magic-tricks', 'board-games'], 'Sport': ['baseball', 'soccer', 'cricket']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_7",
      "puzzle": {
        "id": "simple_2x3_7",
        "title": "Einstein Puzzle simple_2x3_7 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005541249999999998
        },
        "clues": [
          "the person who plays tennis is at the same position as or to the left of the person who likes milk",
          "the person who plays baseball is at an even-numbered position",
          "the person who plays tennis is to the right of the person who likes tea (not necessarily immediately)",
          "the person who likes milk is adjacent to the person who likes tea (either immediately left or right)"
        ],
        "categories": [
          "Beverage",
          "Sport"
        ],
        "items": {
          "Beverage": [
            "soy-milk",
            "tea",
            "milk"
          ],
          "Sport": [
            "handball",
            "baseball",
            "tennis"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"soy-milk\", \"tea\", \"milk\"], \"Sport\": [\"handball\", \"baseball\", \"tennis\"]}"
      },
      "puzzle_hash": "a7cd117767125df97dfc9fddf8c16179",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Sport\"]\n    items = {\n        \"Beverage\": [\"soy-milk\", \"tea\", \"milk\"],\n        \"Sport\": [\"handball\", \"baseball\", \"tennis\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays tennis is at the same position as or to the left of the person who likes milk\n    problem.addConstraint(lambda tennis, milk: tennis <= milk, [\"Sport:tennis\", \"Beverage:milk\"])\n    \n    # Clue 2: the person who plays baseball is at an even-numbered position\n    problem.addConstraint(lambda baseball: baseball % 2 == 0, [\"Sport:baseball\"])\n    \n    # Clue 3: the person who plays tennis is to the right of the person who likes tea (not necessarily immediately)\n    problem.addConstraint(lambda tennis, tea: tennis > tea, [\"Sport:tennis\", \"Beverage:tea\"])\n    \n    # Clue 4: the person who likes milk is adjacent to the person who likes tea (either immediately left or right)\n    problem.addConstraint(lambda milk, tea: abs(milk - tea) == 1, [\"Beverage:milk\", \"Beverage:tea\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "",
      "success": false,
      "execution_time": 0.012886,
      "timestamp": "20250918_084446",
      "verification": {
        "verified": true,
        "is_correct": false,
        "ground_truth": "{'Beverage': ['soy-milk', 'tea', 'milk'], 'Sport': ['handball', 'baseball', 'tennis']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_8",
      "puzzle": {
        "id": "simple_2x3_8",
        "title": "Einstein Puzzle simple_2x3_8 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004502666000000002
        },
        "clues": [
          "the person who likes pineapple is somewhere between the person who likes raspberry and the person who plays swimming (not necessarily immediately adjacent)",
          "the person who plays rowing and the person who likes pineapple are at positions with the same parity (both at odd or both at even positions)",
          "the person who plays rowing is at the same position as or to the right of the person who likes plum"
        ],
        "categories": [
          "Food",
          "Sport"
        ],
        "items": {
          "Food": [
            "plum",
            "pineapple",
            "raspberry"
          ],
          "Sport": [
            "swimming",
            "rowing",
            "biathlon"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"plum\", \"pineapple\", \"raspberry\"], \"Sport\": [\"swimming\", \"rowing\", \"biathlon\"]}"
      },
      "puzzle_hash": "4b89bc32b1d5b39eb1173e5e2aec942d",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Sport\"]\n    items = {\n        \"Food\": [\"plum\", \"pineapple\", \"raspberry\"],\n        \"Sport\": [\"swimming\", \"rowing\", \"biathlon\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes pineapple is somewhere between the person who likes raspberry and the person who plays swimming (not necessarily immediately adjacent)\n    # This means pineapple position is strictly between raspberry and swimming positions\n    problem.addConstraint(\n        lambda pineapple, raspberry, swimming: (raspberry < pineapple < swimming) or (swimming < pineapple < raspberry),\n        [\"Food:pineapple\", \"Food:raspberry\", \"Sport:swimming\"]\n    )\n    \n    # Clue 2: the person who plays rowing and the person who likes pineapple are at positions with the same parity\n    problem.addConstraint(\n        lambda rowing, pineapple: (rowing % 2) == (pineapple % 2),\n        [\"Sport:rowing\", \"Food:pineapple\"]\n    )\n    \n    # Clue 3: the person who plays rowing is at the same position as or to the right of the person who likes plum\n    problem.addConstraint(\n        lambda rowing, plum: rowing >= plum,\n        [\"Sport:rowing\", \"Food:plum\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['plum', 'pineapple', 'raspberry'], 'Sport': ['swimming', 'rowing', 'biathlon']}\n",
      "success": true,
      "execution_time": 0.001594,
      "timestamp": "20250918_084454",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['plum', 'pineapple', 'raspberry'], 'Sport': ['swimming', 'rowing', 'biathlon']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_9",
      "puzzle": {
        "id": "simple_2x3_9",
        "title": "Einstein Puzzle simple_2x3_9 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004230959000000006
        },
        "clues": [
          "the person who plays cricket is adjacent to the person who plays weightlifting (either immediately left or right)",
          "the person who likes electronic music is directly between the person who likes funk music and the person who plays cricket",
          "the person who likes gospel music is to the left of the person who plays weightlifting (not necessarily immediately)"
        ],
        "categories": [
          "Music",
          "Sport"
        ],
        "items": {
          "Music": [
            "gospel",
            "electronic",
            "funk"
          ],
          "Sport": [
            "cricket",
            "weightlifting",
            "water-polo"
          ]
        },
        "ground_truth_solution": "{\"Music\": [\"gospel\", \"electronic\", \"funk\"], \"Sport\": [\"cricket\", \"weightlifting\", \"water-polo\"]}"
      },
      "puzzle_hash": "67077a032f139835f137461f92da5483",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Music\", \"Sport\"]\n    items = {\n        \"Music\": [\"gospel\", \"electronic\", \"funk\"],\n        \"Sport\": [\"cricket\", \"weightlifting\", \"water-polo\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays cricket is adjacent to the person who plays weightlifting\n    problem.addConstraint(lambda cricket, weightlifting: abs(cricket - weightlifting) == 1,\n                          [\"Sport:cricket\", \"Sport:weightlifting\"])\n    \n    # Clue 2: the person who likes electronic music is directly between the person who likes funk music and the person who plays cricket\n    problem.addConstraint(\n        lambda electronic, funk, cricket: (electronic == funk + 1 and electronic == cricket - 1) or (electronic == funk - 1 and electronic == cricket + 1),\n        [\"Music:electronic\", \"Music:funk\", \"Sport:cricket\"]\n    )\n    \n    # Clue 3: the person who likes gospel music is to the left of the person who plays weightlifting (not necessarily immediately)\n    problem.addConstraint(lambda gospel, weightlifting: gospel < weightlifting,\n                          [\"Music:gospel\", \"Sport:weightlifting\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['gospel', 'electronic', 'funk'], 'Sport': ['cricket', 'weightlifting', 'water-polo']}\n",
      "success": true,
      "execution_time": 0.001585,
      "timestamp": "20250918_084510",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['gospel', 'electronic', 'funk'], 'Sport': ['cricket', 'weightlifting', 'water-polo']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_10",
      "puzzle": {
        "id": "simple_2x3_10",
        "title": "Einstein Puzzle simple_2x3_10 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003999749999999996
        },
        "clues": [
          "the person who likes corn is immediately to the right of the person who likes cranberry",
          "the person who likes zucchini is to the left of the argentine person (not necessarily immediately)",
          "the thai person is immediately to the right of the person who likes zucchini"
        ],
        "categories": [
          "Food",
          "Nationality"
        ],
        "items": {
          "Food": [
            "zucchini",
            "cranberry",
            "corn"
          ],
          "Nationality": [
            "polish",
            "thai",
            "argentine"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"zucchini\", \"cranberry\", \"corn\"], \"Nationality\": [\"polish\", \"thai\", \"argentine\"]}"
      },
      "puzzle_hash": "b70ee2f96df97340a944196e327b9349",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Nationality\"]\n    items = {\n        \"Food\": [\"zucchini\", \"cranberry\", \"corn\"],\n        \"Nationality\": [\"polish\", \"thai\", \"argentine\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes corn is immediately to the right of the person who likes cranberry\n    problem.addConstraint(lambda corn, cranberry: corn == cranberry + 1,\n                          [\"Food:corn\", \"Food:cranberry\"])\n    \n    # Clue 2: the person who likes zucchini is to the left of the argentine person (not necessarily immediately)\n    problem.addConstraint(lambda zucchini, argentine: zucchini < argentine,\n                          [\"Food:zucchini\", \"Nationality:argentine\"])\n    \n    # Clue 3: the thai person is immediately to the right of the person who likes zucchini\n    problem.addConstraint(lambda thai, zucchini: thai == zucchini + 1,\n                          [\"Nationality:thai\", \"Food:zucchini\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['zucchini', 'cranberry', 'corn'], 'Nationality': ['polish', 'thai', 'argentine']}\n",
      "success": true,
      "execution_time": 0.001831,
      "timestamp": "20250918_084521",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['zucchini', 'cranberry', 'corn'], 'Nationality': ['polish', 'thai', 'argentine']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_11",
      "puzzle": {
        "id": "simple_2x3_11",
        "title": "Einstein Puzzle simple_2x3_11 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0026604579999999906
        },
        "clues": [
          "the person who enjoys magic-tricks is at the same position as or to the left of the person who enjoys writing",
          "the person who likes fantasy movies is immediately to the left of the person who enjoys magic-tricks",
          "the person who enjoys magic-tricks is to the left of the person who likes scientific movies (not necessarily immediately)"
        ],
        "categories": [
          "Hobby",
          "Movie"
        ],
        "items": {
          "Hobby": [
            "woodworking",
            "magic-tricks",
            "writing"
          ],
          "Movie": [
            "fantasy",
            "family",
            "scientific"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"woodworking\", \"magic-tricks\", \"writing\"], \"Movie\": [\"fantasy\", \"family\", \"scientific\"]}"
      },
      "puzzle_hash": "0767d4c454a01b0b5d3f105a5416c93d",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Movie\"]\n    items = {\n        \"Hobby\": [\"woodworking\", \"magic-tricks\", \"writing\"],\n        \"Movie\": [\"fantasy\", \"family\", \"scientific\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys magic-tricks is at the same position as or to the left of the person who enjoys writing\n    problem.addConstraint(lambda x, y: x <= y, [\"Hobby:magic-tricks\", \"Hobby:writing\"])\n    \n    # Clue 2: the person who likes fantasy movies is immediately to the left of the person who enjoys magic-tricks\n    problem.addConstraint(lambda x, y: x == y - 1, [\"Movie:fantasy\", \"Hobby:magic-tricks\"])\n    \n    # Clue 3: the person who enjoys magic-tricks is to the left of the person who likes scientific movies (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x < y, [\"Hobby:magic-tricks\", \"Movie:scientific\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['woodworking', 'magic-tricks', 'writing'], 'Movie': ['fantasy', 'family', 'scientific']}\n",
      "success": true,
      "execution_time": 0.002776,
      "timestamp": "20250918_084530",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['woodworking', 'magic-tricks', 'writing'], 'Movie': ['fantasy', 'family', 'scientific']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_12",
      "puzzle": {
        "id": "simple_2x3_12",
        "title": "Einstein Puzzle simple_2x3_12 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006812625000000003
        },
        "clues": [
          "the person who plays parkour is immediately to the left of the person who plays handball",
          "the person who plays handball is to the left of the person who uses car for transportation (not necessarily immediately)",
          "the person who uses van for transportation is immediately to the left of the person who plays handball"
        ],
        "categories": [
          "Sport",
          "Transport"
        ],
        "items": {
          "Sport": [
            "parkour",
            "handball",
            "lacrosse"
          ],
          "Transport": [
            "van",
            "helicopter",
            "car"
          ]
        },
        "ground_truth_solution": "{\"Sport\": [\"parkour\", \"handball\", \"lacrosse\"], \"Transport\": [\"van\", \"helicopter\", \"car\"]}"
      },
      "puzzle_hash": "df511fd762bc7f12a6bafaff72072e6e",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Sport\", \"Transport\"]\n    items = {\n        \"Sport\": [\"parkour\", \"handball\", \"lacrosse\"],\n        \"Transport\": [\"van\", \"helicopter\", \"car\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays parkour is immediately to the left of the person who plays handball\n    problem.addConstraint(lambda parkour, handball: parkour == handball - 1,\n                          [\"Sport:parkour\", \"Sport:handball\"])\n    \n    # Clue 2: the person who plays handball is to the left of the person who uses car for transportation (not necessarily immediately)\n    problem.addConstraint(lambda handball, car: handball < car,\n                          [\"Sport:handball\", \"Transport:car\"])\n    \n    # Clue 3: the person who uses van for transportation is immediately to the left of the person who plays handball\n    problem.addConstraint(lambda van, handball: van == handball - 1,\n                          [\"Transport:van\", \"Sport:handball\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['parkour', 'handball', 'lacrosse'], 'Transport': ['van', 'helicopter', 'car']}\n",
      "success": true,
      "execution_time": 0.002913,
      "timestamp": "20250918_084538",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Sport': ['parkour', 'handball', 'lacrosse'], 'Transport': ['van', 'helicopter', 'car']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_13",
      "puzzle": {
        "id": "simple_2x3_13",
        "title": "Einstein Puzzle simple_2x3_13 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005471625000000008
        },
        "clues": [
          "the person who likes house music is immediately to the right of the person who likes ambient music",
          "the person who works as a fisherman is to the left of the person who likes ambient music (not necessarily immediately)",
          "the person who works as a engineer is immediately to the left of the person who works as a pilot"
        ],
        "categories": [
          "Job",
          "Music"
        ],
        "items": {
          "Job": [
            "fisherman",
            "engineer",
            "pilot"
          ],
          "Music": [
            "disco",
            "ambient",
            "house"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"fisherman\", \"engineer\", \"pilot\"], \"Music\": [\"disco\", \"ambient\", \"house\"]}"
      },
      "puzzle_hash": "ebb18dd350adf9a9fa458e8f0b61086f",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Music\"]\n    items = {\n        \"Job\": [\"fisherman\", \"engineer\", \"pilot\"],\n        \"Music\": [\"disco\", \"ambient\", \"house\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes house music is immediately to the right of the person who likes ambient music\n    problem.addConstraint(lambda house, ambient: house == ambient + 1,\n                          [\"Music:house\", \"Music:ambient\"])\n    \n    # Clue 2: the person who works as a fisherman is to the left of the person who likes ambient music (not necessarily immediately)\n    problem.addConstraint(lambda fisherman, ambient: fisherman < ambient,\n                          [\"Job:fisherman\", \"Music:ambient\"])\n    \n    # Clue 3: the person who works as an engineer is immediately to the left of the person who works as a pilot\n    problem.addConstraint(lambda engineer, pilot: engineer == pilot - 1,\n                          [\"Job:engineer\", \"Job:pilot\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['fisherman', 'engineer', 'pilot'], 'Music': ['disco', 'ambient', 'house']}\n",
      "success": true,
      "execution_time": 0.001393,
      "timestamp": "20250918_084546",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['fisherman', 'engineer', 'pilot'], 'Music': ['disco', 'ambient', 'house']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_14",
      "puzzle": {
        "id": "simple_2x3_14",
        "title": "Einstein Puzzle simple_2x3_14 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004800082999999997
        },
        "clues": [
          "the person who works as a police-officer is at the same position as or to the right of the brazilian person",
          "the person who works as a police-officer is directly between the brazilian person and the mexican person",
          "the person who works as a chef is immediately to the right of the person who works as a police-officer"
        ],
        "categories": [
          "Job",
          "Nationality"
        ],
        "items": {
          "Job": [
            "musician",
            "police-officer",
            "chef"
          ],
          "Nationality": [
            "brazilian",
            "chinese",
            "mexican"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"musician\", \"police-officer\", \"chef\"], \"Nationality\": [\"brazilian\", \"chinese\", \"mexican\"]}"
      },
      "puzzle_hash": "c65ba45633f9ca26d64ce409392f4998",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Nationality\"]\n    items = {\n        \"Job\": [\"musician\", \"police-officer\", \"chef\"],\n        \"Nationality\": [\"brazilian\", \"chinese\", \"mexican\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: police-officer is at the same position as or to the right of brazilian\n    problem.addConstraint(\n        lambda po, br: po >= br,\n        [\"Job:police-officer\", \"Nationality:brazilian\"]\n    )\n    \n    # Clue 2: police-officer is directly between brazilian and mexican\n    # That means police-officer is position between brazilian and mexican\n    # So police-officer is one position away from each, and brazilian and mexican are on opposite sides\n    def between(po, br, mx):\n        return (po == br + 1 and po == mx - 1) or (po == mx + 1 and po == br - 1)\n    problem.addConstraint(\n        between,\n        [\"Job:police-officer\", \"Nationality:brazilian\", \"Nationality:mexican\"]\n    )\n    \n    # Clue 3: chef is immediately to the right of police-officer\n    problem.addConstraint(\n        lambda ch, po: ch == po + 1,\n        [\"Job:chef\", \"Job:police-officer\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['musician', 'police-officer', 'chef'], 'Nationality': ['brazilian', 'chinese', 'mexican']}\n",
      "success": true,
      "execution_time": 0.00295,
      "timestamp": "20250918_084553",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['musician', 'police-officer', 'chef'], 'Nationality': ['brazilian', 'chinese', 'mexican']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_15",
      "puzzle": {
        "id": "simple_2x3_15",
        "title": "Einstein Puzzle simple_2x3_15 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003922666000000005
        },
        "clues": [
          "the american person is immediately to the left of the person who plays lacrosse",
          "the spanish person is immediately to the right of the american person",
          "the spanish person is to the left of the person who plays basketball (not necessarily immediately)"
        ],
        "categories": [
          "Nationality",
          "Sport"
        ],
        "items": {
          "Nationality": [
            "american",
            "spanish",
            "australian"
          ],
          "Sport": [
            "rugby",
            "lacrosse",
            "basketball"
          ]
        },
        "ground_truth_solution": "{\"Nationality\": [\"american\", \"spanish\", \"australian\"], \"Sport\": [\"rugby\", \"lacrosse\", \"basketball\"]}"
      },
      "puzzle_hash": "12c14af36c5b98743ac062aad9d31c1f",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Nationality\", \"Sport\"]\n    items = {\n        \"Nationality\": [\"american\", \"spanish\", \"australian\"],\n        \"Sport\": [\"rugby\", \"lacrosse\", \"basketball\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the american person is immediately to the left of the person who plays lacrosse\n    problem.addConstraint(lambda american, lacrosse: american == lacrosse - 1,\n                          [\"Nationality:american\", \"Sport:lacrosse\"])\n    \n    # Clue 2: the spanish person is immediately to the right of the american person\n    problem.addConstraint(lambda spanish, american: spanish == american + 1,\n                          [\"Nationality:spanish\", \"Nationality:american\"])\n    \n    # Clue 3: the spanish person is to the left of the person who plays basketball (not necessarily immediately)\n    problem.addConstraint(lambda spanish, basketball: spanish < basketball,\n                          [\"Nationality:spanish\", \"Sport:basketball\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['american', 'spanish', 'australian'], 'Sport': ['rugby', 'lacrosse', 'basketball']}\n",
      "success": true,
      "execution_time": 0.003133,
      "timestamp": "20250918_084601",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['american', 'spanish', 'australian'], 'Sport': ['rugby', 'lacrosse', 'basketball']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_16",
      "puzzle": {
        "id": "simple_2x3_16",
        "title": "Einstein Puzzle simple_2x3_16 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.002070709000000004
        },
        "clues": [
          "the person who uses scooter for transportation is somewhere between the person who likes fantasy movies and the person who uses car for transportation (not necessarily immediately adjacent)",
          "the person who likes superhero movies is to the left of the person who uses car for transportation (not necessarily immediately)"
        ],
        "categories": [
          "Movie",
          "Transport"
        ],
        "items": {
          "Movie": [
            "fantasy",
            "superhero",
            "crime"
          ],
          "Transport": [
            "helicopter",
            "scooter",
            "car"
          ]
        },
        "ground_truth_solution": "{\"Movie\": [\"fantasy\", \"superhero\", \"crime\"], \"Transport\": [\"helicopter\", \"scooter\", \"car\"]}"
      },
      "puzzle_hash": "a3fd66d0e13cf8622f9ad3e0b5dc36b3",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Transport\"]\n    items = {\n        \"Movie\": [\"fantasy\", \"superhero\", \"crime\"],\n        \"Transport\": [\"helicopter\", \"scooter\", \"car\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1:\n    # the person who uses scooter for transportation is somewhere between the person who likes fantasy movies and the person who uses car for transportation (not necessarily immediately adjacent)\n    # This means scooter position is strictly between fantasy and car positions\n    problem.addConstraint(\n        lambda scooter, fantasy, car: (fantasy < scooter < car) or (car < scooter < fantasy),\n        [\"Transport:scooter\", \"Movie:fantasy\", \"Transport:car\"]\n    )\n    \n    # Clue 2:\n    # the person who likes superhero movies is to the left of the person who uses car for transportation (not necessarily immediately)\n    problem.addConstraint(\n        lambda superhero, car: superhero < car,\n        [\"Movie:superhero\", \"Transport:car\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['fantasy', 'superhero', 'crime'], 'Transport': ['helicopter', 'scooter', 'car']}\n",
      "success": true,
      "execution_time": 0.002947,
      "timestamp": "20250918_084608",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['fantasy', 'superhero', 'crime'], 'Transport': ['helicopter', 'scooter', 'car']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_17",
      "puzzle": {
        "id": "simple_2x3_17",
        "title": "Einstein Puzzle simple_2x3_17 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004173499999999997
        },
        "clues": [
          "the person who likes rock music is directly between the person who likes hip-hop music and the polish person",
          "the russian person is to the right of the person who likes rock music (not necessarily immediately)"
        ],
        "categories": [
          "Music",
          "Nationality"
        ],
        "items": {
          "Music": [
            "soul",
            "rock",
            "hip-hop"
          ],
          "Nationality": [
            "polish",
            "indian",
            "russian"
          ]
        },
        "ground_truth_solution": "{\"Music\": [\"soul\", \"rock\", \"hip-hop\"], \"Nationality\": [\"polish\", \"indian\", \"russian\"]}"
      },
      "puzzle_hash": "75a12966133aa32ab1d88c8a39843de5",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Music\", \"Nationality\"]\n    items = {\n        \"Music\": [\"soul\", \"rock\", \"hip-hop\"],\n        \"Nationality\": [\"polish\", \"indian\", \"russian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes rock music is directly between the person who likes hip-hop music and the polish person\n    problem.addConstraint(\n        lambda rock, hiphop, polish: (rock == hiphop + 1 and rock == polish - 1) or (rock == polish + 1 and rock == hiphop - 1),\n        [\"Music:rock\", \"Music:hip-hop\", \"Nationality:polish\"]\n    )\n    \n    # Clue 2: the russian person is to the right of the person who likes rock music (not necessarily immediately)\n    problem.addConstraint(\n        lambda rock, russian: rock < russian,\n        [\"Music:rock\", \"Nationality:russian\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['soul', 'rock', 'hip-hop'], 'Nationality': ['polish', 'indian', 'russian']}\n",
      "success": true,
      "execution_time": 0.002797,
      "timestamp": "20250918_084616",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['soul', 'rock', 'hip-hop'], 'Nationality': ['polish', 'indian', 'russian']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_18",
      "puzzle": {
        "id": "simple_2x3_18",
        "title": "Einstein Puzzle simple_2x3_18 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004270958000000005
        },
        "clues": [
          "the person who likes r&b music is at position 1 (the leftmost position)",
          "the person who likes tea is to the right of the person who likes hot-chocolate (not necessarily immediately)",
          "the person who likes tea is immediately to the left of the person who likes coffee",
          "the person who likes d&b music is immediately to the right of the person who likes reggae music"
        ],
        "categories": [
          "Beverage",
          "Music"
        ],
        "items": {
          "Beverage": [
            "hot-chocolate",
            "tea",
            "coffee"
          ],
          "Music": [
            "r&b",
            "reggae",
            "d&b"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"hot-chocolate\", \"tea\", \"coffee\"], \"Music\": [\"r&b\", \"reggae\", \"d&b\"]}"
      },
      "puzzle_hash": "3ee01172c6c3fce76583eb285974cef7",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Music\"]\n    items = {\n        \"Beverage\": [\"hot-chocolate\", \"tea\", \"coffee\"],\n        \"Music\": [\"r&b\", \"reggae\", \"d&b\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes r&b music is at position 1 (0-indexed)\n    problem.addConstraint(lambda x: x == 0, [\"Music:r&b\"])\n    \n    # Clue 2: the person who likes tea is to the right of the person who likes hot-chocolate (not necessarily immediately)\n    problem.addConstraint(lambda tea, hot_choc: tea > hot_choc, [\"Beverage:tea\", \"Beverage:hot-chocolate\"])\n    \n    # Clue 3: the person who likes tea is immediately to the left of the person who likes coffee\n    problem.addConstraint(lambda tea, coffee: tea == coffee - 1, [\"Beverage:tea\", \"Beverage:coffee\"])\n    \n    # Clue 4: the person who likes d&b music is immediately to the right of the person who likes reggae music\n    problem.addConstraint(lambda reggae, dnb: dnb == reggae + 1, [\"Music:reggae\", \"Music:d&b\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['hot-chocolate', 'tea', 'coffee'], 'Music': ['r&b', 'reggae', 'd&b']}\n",
      "success": true,
      "execution_time": 0.002873,
      "timestamp": "20250918_084627",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['hot-chocolate', 'tea', 'coffee'], 'Music': ['r&b', 'reggae', 'd&b']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_19",
      "puzzle": {
        "id": "simple_2x3_19",
        "title": "Einstein Puzzle simple_2x3_19 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005164083
        },
        "clues": [
          "the person who enjoys hiking is to the left of the person who likes 7up (not necessarily immediately)",
          "the person who likes tea is to the left of the person who enjoys hiking (not necessarily immediately)",
          "the person who enjoys gardening is to the left of the person who enjoys fishing (not necessarily immediately)"
        ],
        "categories": [
          "Beverage",
          "Hobby"
        ],
        "items": {
          "Beverage": [
            "tea",
            "milk",
            "7up"
          ],
          "Hobby": [
            "gardening",
            "hiking",
            "fishing"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"tea\", \"milk\", \"7up\"], \"Hobby\": [\"gardening\", \"hiking\", \"fishing\"]}"
      },
      "puzzle_hash": "4254fe7af47b6c47bb494429f1e42785",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Hobby\"]\n    items = {\n        \"Beverage\": [\"tea\", \"milk\", \"7up\"],\n        \"Hobby\": [\"gardening\", \"hiking\", \"fishing\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: hiking is to the left of 7up\n    problem.addConstraint(lambda hiking, sevenup: hiking < sevenup, [\"Hobby:hiking\", \"Beverage:7up\"])\n    # Clue 2: tea is to the left of hiking\n    problem.addConstraint(lambda tea, hiking: tea < hiking, [\"Beverage:tea\", \"Hobby:hiking\"])\n    # Clue 3: gardening is to the left of fishing\n    problem.addConstraint(lambda gardening, fishing: gardening < fishing, [\"Hobby:gardening\", \"Hobby:fishing\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['tea', 'milk', '7up'], 'Hobby': ['gardening', 'hiking', 'fishing']}\n",
      "success": true,
      "execution_time": 0.002943,
      "timestamp": "20250918_084633",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['tea', 'milk', '7up'], 'Hobby': ['gardening', 'hiking', 'fishing']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_20",
      "puzzle": {
        "id": "simple_2x3_20",
        "title": "Einstein Puzzle simple_2x3_20 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006949749999999991
        },
        "clues": [
          "the japanese person is to the right of the person who has bird as a pet (not necessarily immediately)",
          "the italian person is at position 1 (the leftmost position)",
          "the japanese person is immediately to the right of the person who has hedgehog as a pet"
        ],
        "categories": [
          "Nationality",
          "Pet"
        ],
        "items": {
          "Nationality": [
            "italian",
            "thai",
            "japanese"
          ],
          "Pet": [
            "bird",
            "hedgehog",
            "rat"
          ]
        },
        "ground_truth_solution": "{\"Nationality\": [\"italian\", \"thai\", \"japanese\"], \"Pet\": [\"bird\", \"hedgehog\", \"rat\"]}"
      },
      "puzzle_hash": "a84e8e225fd04c0002822441c2a51712",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Nationality\", \"Pet\"]\n    items = {\n        \"Nationality\": [\"italian\", \"thai\", \"japanese\"],\n        \"Pet\": [\"bird\", \"hedgehog\", \"rat\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the japanese person is to the right of the person who has bird as a pet (not necessarily immediately)\n    problem.addConstraint(lambda jap, bird: jap > bird, [\"Nationality:japanese\", \"Pet:bird\"])\n    \n    # Clue 2: the italian person is at position 1 (leftmost position, index 0)\n    problem.addConstraint(lambda italian: italian == 0, [\"Nationality:italian\"])\n    \n    # Clue 3: the japanese person is immediately to the right of the person who has hedgehog as a pet\n    problem.addConstraint(lambda jap, hedgehog: jap == hedgehog + 1, [\"Nationality:japanese\", \"Pet:hedgehog\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['italian', 'thai', 'japanese'], 'Pet': ['bird', 'hedgehog', 'rat']}\n",
      "success": true,
      "execution_time": 0.003087,
      "timestamp": "20250918_084641",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['italian', 'thai', 'japanese'], 'Pet': ['bird', 'hedgehog', 'rat']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_21",
      "puzzle": {
        "id": "simple_2x3_21",
        "title": "Einstein Puzzle simple_2x3_21 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005351125000000012
        },
        "clues": [
          "the person who plays soccer is directly between the person who plays tennis and the person who plays biathlon",
          "the person who uses airplane for transportation is at the same position as or to the left of the person who plays soccer",
          "the person who plays biathlon is immediately to the right of the person who uses boat for transportation"
        ],
        "categories": [
          "Sport",
          "Transport"
        ],
        "items": {
          "Sport": [
            "tennis",
            "soccer",
            "biathlon"
          ],
          "Transport": [
            "airplane",
            "boat",
            "taxi"
          ]
        },
        "ground_truth_solution": "{\"Sport\": [\"tennis\", \"soccer\", \"biathlon\"], \"Transport\": [\"airplane\", \"boat\", \"taxi\"]}"
      },
      "puzzle_hash": "5b14fdb0bc9ad77bb44cd23fbbe6b3f7",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Sport\", \"Transport\"]\n    items = {\n        \"Sport\": [\"tennis\", \"soccer\", \"biathlon\"],\n        \"Transport\": [\"airplane\", \"boat\", \"taxi\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays soccer is directly between the person who plays tennis and the person who plays biathlon\n    problem.addConstraint(\n        lambda soccer, tennis, biathlon: (soccer == tennis + 1 and soccer == biathlon - 1) or (soccer == biathlon + 1 and soccer == tennis - 1),\n        [\"Sport:soccer\", \"Sport:tennis\", \"Sport:biathlon\"]\n    )\n    \n    # Clue 2: the person who uses airplane for transportation is at the same position as or to the left of the person who plays soccer\n    problem.addConstraint(\n        lambda airplane, soccer: airplane <= soccer,\n        [\"Transport:airplane\", \"Sport:soccer\"]\n    )\n    \n    # Clue 3: the person who plays biathlon is immediately to the right of the person who uses boat for transportation\n    problem.addConstraint(\n        lambda biathlon, boat: biathlon == boat + 1,\n        [\"Sport:biathlon\", \"Transport:boat\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['tennis', 'soccer', 'biathlon'], 'Transport': ['airplane', 'boat', 'taxi']}\n",
      "success": true,
      "execution_time": 0.002934,
      "timestamp": "20250918_084648",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Sport': ['tennis', 'soccer', 'biathlon'], 'Transport': ['airplane', 'boat', 'taxi']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_22",
      "puzzle": {
        "id": "simple_2x3_22",
        "title": "Einstein Puzzle simple_2x3_22 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006398209000000016
        },
        "clues": [
          "the person who plays climbing is at position 3(the rightmost position)",
          "the person who likes tea and the person who plays climbing are at positions with different parity (one at odd, one at even position)",
          "the person who plays handball is to the right of the person who likes sprite (not necessarily immediately)"
        ],
        "categories": [
          "Beverage",
          "Sport"
        ],
        "items": {
          "Beverage": [
            "sprite",
            "tea",
            "almond-milk"
          ],
          "Sport": [
            "skiing",
            "handball",
            "climbing"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"sprite\", \"tea\", \"almond-milk\"], \"Sport\": [\"skiing\", \"handball\", \"climbing\"]}"
      },
      "puzzle_hash": "3009e688eaf6bf87db4855d2b08d6ba9",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Sport\"]\n    items = {\n        \"Beverage\": [\"sprite\", \"tea\", \"almond-milk\"],\n        \"Sport\": [\"skiing\", \"handball\", \"climbing\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays climbing is at position 3 (index 2)\n    problem.addConstraint(lambda x: x == 2, [\"Sport:climbing\"])\n    \n    # Clue 2: the person who likes tea and the person who plays climbing are at positions with different parity\n    problem.addConstraint(lambda x, y: (x % 2) != (y % 2), [\"Beverage:tea\", \"Sport:climbing\"])\n    \n    # Clue 3: the person who plays handball is to the right of the person who likes sprite\n    problem.addConstraint(lambda x, y: x > y, [\"Sport:handball\", \"Beverage:sprite\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['sprite', 'tea', 'almond-milk'], 'Sport': ['skiing', 'handball', 'climbing']}\n",
      "success": true,
      "execution_time": 0.002935,
      "timestamp": "20250918_084656",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['sprite', 'tea', 'almond-milk'], 'Sport': ['skiing', 'handball', 'climbing']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_23",
      "puzzle": {
        "id": "simple_2x3_23",
        "title": "Einstein Puzzle simple_2x3_23 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004980375000000009
        },
        "clues": [
          "the person who works as a mechanic is directly between the person who plays snowboarding and the person who works as a videographer",
          "the person who plays cricket is at position 1 (the leftmost position)"
        ],
        "categories": [
          "Job",
          "Sport"
        ],
        "items": {
          "Job": [
            "videographer",
            "mechanic",
            "dancer"
          ],
          "Sport": [
            "cricket",
            "rugby",
            "snowboarding"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"videographer\", \"mechanic\", \"dancer\"], \"Sport\": [\"cricket\", \"rugby\", \"snowboarding\"]}"
      },
      "puzzle_hash": "6b5071f634a6637756dc15ff1f1f778c",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Sport\"]\n    items = {\n        \"Job\": [\"videographer\", \"mechanic\", \"dancer\"],\n        \"Sport\": [\"cricket\", \"rugby\", \"snowboarding\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who works as a mechanic is directly between the person who plays snowboarding and the person who works as a videographer\n    problem.addConstraint(\n        lambda mechanic, snowboarding, videographer:\n            (mechanic == snowboarding + 1 and mechanic == videographer - 1) or\n            (mechanic == videographer + 1 and mechanic == snowboarding - 1),\n        [\"Job:mechanic\", \"Sport:snowboarding\", \"Job:videographer\"]\n    )\n    \n    # Clue 2: the person who plays cricket is at position 1 (leftmost position, zero-indexed 0)\n    problem.addConstraint(lambda cricket: cricket == 0, [\"Sport:cricket\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['videographer', 'mechanic', 'dancer'], 'Sport': ['cricket', 'rugby', 'snowboarding']}\n",
      "success": true,
      "execution_time": 0.002805,
      "timestamp": "20250918_084703",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['videographer', 'mechanic', 'dancer'], 'Sport': ['cricket', 'rugby', 'snowboarding']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_24",
      "puzzle": {
        "id": "simple_2x3_24",
        "title": "Einstein Puzzle simple_2x3_24 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003841082999999995
        },
        "clues": [
          "the person who works as a mechanic is to the left of the person who likes country music (not necessarily immediately)",
          "the person who works as a mechanic is at the same position as or to the right of the person who likes pop music",
          "the person who works as a photographer is the same person as the person who likes country music",
          "the person who works as a accountant is to the right of the person who works as a photographer (not necessarily immediately)"
        ],
        "categories": [
          "Job",
          "Music"
        ],
        "items": {
          "Job": [
            "mechanic",
            "photographer",
            "accountant"
          ],
          "Music": [
            "pop",
            "country",
            "hip-hop"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"mechanic\", \"photographer\", \"accountant\"], \"Music\": [\"pop\", \"country\", \"hip-hop\"]}"
      },
      "puzzle_hash": "2169f2d8af4a49f69496046abb4fd49b",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Music\"]\n    items = {\n        \"Job\": [\"mechanic\", \"photographer\", \"accountant\"],\n        \"Music\": [\"pop\", \"country\", \"hip-hop\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: mechanic is to the left of country music (not necessarily immediately)\n    problem.addConstraint(lambda mech, country: mech < country, [\"Job:mechanic\", \"Music:country\"])\n    \n    # Clue 2: mechanic is at the same position as or to the right of pop music\n    problem.addConstraint(lambda mech, pop: mech >= pop, [\"Job:mechanic\", \"Music:pop\"])\n    \n    # Clue 3: photographer is the same person as country music\n    problem.addConstraint(lambda photo, country: photo == country, [\"Job:photographer\", \"Music:country\"])\n    \n    # Clue 4: accountant is to the right of photographer (not necessarily immediately)\n    problem.addConstraint(lambda accountant, photographer: accountant > photographer, [\"Job:accountant\", \"Job:photographer\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['mechanic', 'photographer', 'accountant'], 'Music': ['pop', 'country', 'hip-hop']}\n",
      "success": true,
      "execution_time": 0.002852,
      "timestamp": "20250918_084713",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['mechanic', 'photographer', 'accountant'], 'Music': ['pop', 'country', 'hip-hop']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_25",
      "puzzle": {
        "id": "simple_2x3_25",
        "title": "Einstein Puzzle simple_2x3_25 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004375457999999999
        },
        "clues": [
          "the person who plays skateboarding is adjacent to the person who uses snowmobile for transportation (either immediately left or right)",
          "the person who uses tram for transportation is immediately to the right of the person who plays water-polo",
          "the person who plays skateboarding is to the left of the person who uses airplane for transportation (not necessarily immediately)"
        ],
        "categories": [
          "Sport",
          "Transport"
        ],
        "items": {
          "Sport": [
            "water-polo",
            "skateboarding",
            "cricket"
          ],
          "Transport": [
            "snowmobile",
            "tram",
            "airplane"
          ]
        },
        "ground_truth_solution": "{\"Sport\": [\"water-polo\", \"skateboarding\", \"cricket\"], \"Transport\": [\"snowmobile\", \"tram\", \"airplane\"]}"
      },
      "puzzle_hash": "b2e382243394093513b10eaef6b6a75c",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Sport\", \"Transport\"]\n    items = {\n        \"Sport\": [\"water-polo\", \"skateboarding\", \"cricket\"],\n        \"Transport\": [\"snowmobile\", \"tram\", \"airplane\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays skateboarding is adjacent to the person who uses snowmobile\n    problem.addConstraint(lambda x, y: abs(x - y) == 1, [\"Sport:skateboarding\", \"Transport:snowmobile\"])\n    \n    # Clue 2: the person who uses tram is immediately to the right of the person who plays water-polo\n    problem.addConstraint(lambda x, y: x == y + 1, [\"Transport:tram\", \"Sport:water-polo\"])\n    \n    # Clue 3: the person who plays skateboarding is to the left of the person who uses airplane (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x < y, [\"Sport:skateboarding\", \"Transport:airplane\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['water-polo', 'skateboarding', 'cricket'], 'Transport': ['snowmobile', 'tram', 'airplane']}\n",
      "success": true,
      "execution_time": 0.001351,
      "timestamp": "20250918_084722",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Sport': ['water-polo', 'skateboarding', 'cricket'], 'Transport': ['snowmobile', 'tram', 'airplane']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_26",
      "puzzle": {
        "id": "simple_2x3_26",
        "title": "Einstein Puzzle simple_2x3_26 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00414758300000001
        },
        "clues": [
          "the person who uses bus for transportation is the same person as the person who likes zucchini",
          "the person who uses bus for transportation is immediately to the right of the person who uses motorbike for transportation",
          "the person who uses snowmobile for transportation is at position 1 (the leftmost position)",
          "the person who likes pear is at the same position as or to the left of the person who uses snowmobile for transportation"
        ],
        "categories": [
          "Food",
          "Transport"
        ],
        "items": {
          "Food": [
            "pear",
            "artichoke",
            "zucchini"
          ],
          "Transport": [
            "snowmobile",
            "motorbike",
            "bus"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"pear\", \"artichoke\", \"zucchini\"], \"Transport\": [\"snowmobile\", \"motorbike\", \"bus\"]}"
      },
      "puzzle_hash": "93e7e0610e525e9923ee38d922be03d2",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Transport\"]\n    items = {\n        \"Food\": [\"pear\", \"artichoke\", \"zucchini\"],\n        \"Transport\": [\"snowmobile\", \"motorbike\", \"bus\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses bus for transportation is the same person as the person who likes zucchini\n    problem.addConstraint(lambda bus_pos, zucchini_pos: bus_pos == zucchini_pos,\n                          [\"Transport:bus\", \"Food:zucchini\"])\n    \n    # Clue 2: the person who uses bus for transportation is immediately to the right of the person who uses motorbike for transportation\n    problem.addConstraint(lambda motorbike_pos, bus_pos: bus_pos == motorbike_pos + 1,\n                          [\"Transport:motorbike\", \"Transport:bus\"])\n    \n    # Clue 3: the person who uses snowmobile for transportation is at position 1 (leftmost position, 0-indexed)\n    problem.addConstraint(lambda snowmobile_pos: snowmobile_pos == 0,\n                          [\"Transport:snowmobile\"])\n    \n    # Clue 4: the person who likes pear is at the same position as or to the left of the person who uses snowmobile for transportation\n    problem.addConstraint(lambda pear_pos, snowmobile_pos: pear_pos <= snowmobile_pos,\n                          [\"Food:pear\", \"Transport:snowmobile\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['pear', 'artichoke', 'zucchini'], 'Transport': ['snowmobile', 'motorbike', 'bus']}\n",
      "success": true,
      "execution_time": 0.002718,
      "timestamp": "20250918_084733",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['pear', 'artichoke', 'zucchini'], 'Transport': ['snowmobile', 'motorbike', 'bus']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_27",
      "puzzle": {
        "id": "simple_2x3_27",
        "title": "Einstein Puzzle simple_2x3_27 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004273333000000018
        },
        "clues": [
          "the person who uses taxi for transportation is immediately to the left of the person who uses roller for transportation",
          "the person who likes tomato is somewhere between the person who likes cranberry and the person who uses taxi for transportation (not necessarily immediately adjacent)"
        ],
        "categories": [
          "Food",
          "Transport"
        ],
        "items": {
          "Food": [
            "pineapple",
            "tomato",
            "cranberry"
          ],
          "Transport": [
            "taxi",
            "roller",
            "bike"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"pineapple\", \"tomato\", \"cranberry\"], \"Transport\": [\"taxi\", \"roller\", \"bike\"]}"
      },
      "puzzle_hash": "c13d6bcf2b100efc5ffe0b435245b3fa",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Transport\"]\n    items = {\n        \"Food\": [\"pineapple\", \"tomato\", \"cranberry\"],\n        \"Transport\": [\"taxi\", \"roller\", \"bike\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses taxi for transportation is immediately to the left of the person who uses roller for transportation\n    problem.addConstraint(lambda taxi, roller: taxi == roller - 1, [\"Transport:taxi\", \"Transport:roller\"])\n    \n    # Clue 2: the person who likes tomato is somewhere between the person who likes cranberry and the person who uses taxi for transportation (not necessarily immediately adjacent)\n    # This means tomato's position is strictly between cranberry's and taxi's positions\n    def tomato_between(cranberry, tomato, taxi):\n        return (cranberry < tomato < taxi) or (taxi < tomato < cranberry)\n    problem.addConstraint(tomato_between, [\"Food:cranberry\", \"Food:tomato\", \"Transport:taxi\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['pineapple', 'tomato', 'cranberry'], 'Transport': ['taxi', 'roller', 'bike']}\n",
      "success": true,
      "execution_time": 0.00263,
      "timestamp": "20250918_084747",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['pineapple', 'tomato', 'cranberry'], 'Transport': ['taxi', 'roller', 'bike']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_28",
      "puzzle": {
        "id": "simple_2x3_28",
        "title": "Einstein Puzzle simple_2x3_28 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.008929957999999988
        },
        "clues": [
          "the person who likes action movies is to the right of the person who likes zucchini (not necessarily immediately)",
          "the person who likes zucchini is adjacent to the person who likes garlic (either immediately left or right)",
          "the person who likes satire movies is immediately to the right of the person who likes pomegranate"
        ],
        "categories": [
          "Food",
          "Movie"
        ],
        "items": {
          "Food": [
            "pomegranate",
            "zucchini",
            "garlic"
          ],
          "Movie": [
            "family",
            "satire",
            "action"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"pomegranate\", \"zucchini\", \"garlic\"], \"Movie\": [\"family\", \"satire\", \"action\"]}"
      },
      "puzzle_hash": "9dc54d595eeadf732a636448e2974d6a",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Movie\"]\n    items = {\n        \"Food\": [\"pomegranate\", \"zucchini\", \"garlic\"],\n        \"Movie\": [\"family\", \"satire\", \"action\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes action movies is to the right of the person who likes zucchini (not necessarily immediately)\n    problem.addConstraint(lambda action, zucchini: action > zucchini, [\"Movie:action\", \"Food:zucchini\"])\n    \n    # Clue 2: the person who likes zucchini is adjacent to the person who likes garlic (either immediately left or right)\n    problem.addConstraint(lambda zucchini, garlic: abs(zucchini - garlic) == 1, [\"Food:zucchini\", \"Food:garlic\"])\n    \n    # Clue 3: the person who likes satire movies is immediately to the right of the person who likes pomegranate\n    problem.addConstraint(lambda satire, pomegranate: satire == pomegranate + 1, [\"Movie:satire\", \"Food:pomegranate\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['pomegranate', 'zucchini', 'garlic'], 'Movie': ['family', 'satire', 'action']}\n",
      "success": true,
      "execution_time": 0.001418,
      "timestamp": "20250918_084755",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['pomegranate', 'zucchini', 'garlic'], 'Movie': ['family', 'satire', 'action']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_29",
      "puzzle": {
        "id": "simple_2x3_29",
        "title": "Einstein Puzzle simple_2x3_29 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004396167000000006
        },
        "clues": [
          "the chinese person is at an even-numbered position",
          "the chinese person is immediately to the right of the person who works as a architect",
          "the argentine person is immediately to the right of the person who works as a bartender"
        ],
        "categories": [
          "Job",
          "Nationality"
        ],
        "items": {
          "Job": [
            "architect",
            "bartender",
            "manager"
          ],
          "Nationality": [
            "indian",
            "chinese",
            "argentine"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"architect\", \"bartender\", \"manager\"], \"Nationality\": [\"indian\", \"chinese\", \"argentine\"]}"
      },
      "puzzle_hash": "49c1570113a263874d2c5954dd15642b",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Nationality\"]\n    items = {\n        \"Job\": [\"architect\", \"bartender\", \"manager\"],\n        \"Nationality\": [\"indian\", \"chinese\", \"argentine\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the chinese person is at an even-numbered position\n    problem.addConstraint(lambda x: x % 2 == 0, [\"Nationality:chinese\"])\n    \n    # Clue 2: the chinese person is immediately to the right of the person who works as an architect\n    problem.addConstraint(lambda architect_pos, chinese_pos: chinese_pos == architect_pos + 1, [\"Job:architect\", \"Nationality:chinese\"])\n    \n    # Clue 3: the argentine person is immediately to the right of the person who works as a bartender\n    problem.addConstraint(lambda bartender_pos, argentine_pos: argentine_pos == bartender_pos + 1, [\"Job:bartender\", \"Nationality:argentine\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['bartender', 'architect', 'manager'], 'Nationality': ['indian', 'argentine', 'chinese']}\n",
      "success": true,
      "execution_time": 0.001569,
      "timestamp": "20250918_084804",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['architect', 'bartender', 'manager'], 'Nationality': ['indian', 'chinese', 'argentine']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_30",
      "puzzle": {
        "id": "simple_2x3_30",
        "title": "Einstein Puzzle simple_2x3_30 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004114208000000008
        },
        "clues": [
          "the person who works as a firefighter is at an even-numbered position",
          "the person who works as a firefighter is at the same position as or to the right of the russian person",
          "the person who works as a firefighter is to the left of the person who works as a journalist (not necessarily immediately)",
          "the indonesian person is at an even-numbered position"
        ],
        "categories": [
          "Job",
          "Nationality"
        ],
        "items": {
          "Job": [
            "librarian",
            "firefighter",
            "journalist"
          ],
          "Nationality": [
            "russian",
            "indonesian",
            "japanese"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"librarian\", \"firefighter\", \"journalist\"], \"Nationality\": [\"russian\", \"indonesian\", \"japanese\"]}"
      },
      "puzzle_hash": "d0cd236c1135d56845c8169489cafd9c",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Nationality\"]\n    items = {\n        \"Job\": [\"librarian\", \"firefighter\", \"journalist\"],\n        \"Nationality\": [\"russian\", \"indonesian\", \"japanese\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who works as a firefighter is at an even-numbered position\n    problem.addConstraint(lambda x: x % 2 == 0, [\"Job:firefighter\"])\n    \n    # Clue 2: the person who works as a firefighter is at the same position as or to the right of the russian person\n    problem.addConstraint(lambda f, r: f >= r, [\"Job:firefighter\", \"Nationality:russian\"])\n    \n    # Clue 3: the person who works as a firefighter is to the left of the person who works as a journalist (not necessarily immediately)\n    problem.addConstraint(lambda f, j: f < j, [\"Job:firefighter\", \"Job:journalist\"])\n    \n    # Clue 4: the indonesian person is at an even-numbered position\n    problem.addConstraint(lambda x: x % 2 == 0, [\"Nationality:indonesian\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "",
      "success": false,
      "execution_time": 0.015348,
      "timestamp": "20250918_084813",
      "verification": {
        "verified": true,
        "is_correct": false,
        "ground_truth": "{'Job': ['librarian', 'firefighter', 'journalist'], 'Nationality': ['russian', 'indonesian', 'japanese']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_31",
      "puzzle": {
        "id": "simple_2x3_31",
        "title": "Einstein Puzzle simple_2x3_31 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.008179417000000022
        },
        "clues": [
          "the person who likes pear is immediately to the right of the person who likes cabbage",
          "the person who likes cabbage is to the right of the person who uses subway for transportation (not necessarily immediately)",
          "the person who likes eggplant is adjacent to the person who uses airplane for transportation (either immediately left or right)"
        ],
        "categories": [
          "Food",
          "Transport"
        ],
        "items": {
          "Food": [
            "eggplant",
            "cabbage",
            "pear"
          ],
          "Transport": [
            "subway",
            "airplane",
            "train"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"eggplant\", \"cabbage\", \"pear\"], \"Transport\": [\"subway\", \"airplane\", \"train\"]}"
      },
      "puzzle_hash": "92ca421fb16ea52220b09e1edec2ab8c",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Food\", \"Transport\"]\n    items = {\n        \"Food\": [\"eggplant\", \"cabbage\", \"pear\"],\n        \"Transport\": [\"subway\", \"airplane\", \"train\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes pear is immediately to the right of the person who likes cabbage\n    problem.addConstraint(lambda cabbage_pos, pear_pos: pear_pos == cabbage_pos + 1,\n                          [\"Food:cabbage\", \"Food:pear\"])\n    \n    # Clue 2: the person who likes cabbage is to the right of the person who uses subway for transportation (not necessarily immediately)\n    problem.addConstraint(lambda subway_pos, cabbage_pos: cabbage_pos > subway_pos,\n                          [\"Transport:subway\", \"Food:cabbage\"])\n    \n    # Clue 3: the person who likes eggplant is adjacent to the person who uses airplane for transportation\n    problem.addConstraint(lambda eggplant_pos, airplane_pos: abs(eggplant_pos - airplane_pos) == 1,\n                          [\"Food:eggplant\", \"Transport:airplane\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['eggplant', 'cabbage', 'pear'], 'Transport': ['subway', 'airplane', 'train']}\n",
      "success": true,
      "execution_time": 0.001391,
      "timestamp": "20250918_084822",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['eggplant', 'cabbage', 'pear'], 'Transport': ['subway', 'airplane', 'train']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_32",
      "puzzle": {
        "id": "simple_2x3_32",
        "title": "Einstein Puzzle simple_2x3_32 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.007959833
        },
        "clues": [
          "the indonesian person and the person who uses car for transportation are at positions with different parity (one at odd, one at even position)",
          "the person who uses car for transportation is at the same position as or to the right of the polish person",
          "the person who uses car for transportation is immediately to the left of the person who uses taxi for transportation",
          "the person who uses scooter for transportation is at the same position as or to the right of the person who uses taxi for transportation"
        ],
        "categories": [
          "Nationality",
          "Transport"
        ],
        "items": {
          "Nationality": [
            "polish",
            "indonesian",
            "indian"
          ],
          "Transport": [
            "car",
            "taxi",
            "scooter"
          ]
        },
        "ground_truth_solution": "{\"Nationality\": [\"polish\", \"indonesian\", \"indian\"], \"Transport\": [\"car\", \"taxi\", \"scooter\"]}"
      },
      "puzzle_hash": "0b6c5b01c5de57d6837bb2c17c662ec4",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Nationality\", \"Transport\"]\n    items = {\n        \"Nationality\": [\"polish\", \"indonesian\", \"indian\"],\n        \"Transport\": [\"car\", \"taxi\", \"scooter\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the indonesian person and the person who uses car for transportation are at positions with different parity\n    problem.addConstraint(lambda x, y: (x % 2) != (y % 2), [\"Nationality:indonesian\", \"Transport:car\"])\n    \n    # Clue 2: the person who uses car for transportation is at the same position as or to the right of the polish person\n    problem.addConstraint(lambda x, y: x >= y, [\"Transport:car\", \"Nationality:polish\"])\n    \n    # Clue 3: the person who uses car for transportation is immediately to the left of the person who uses taxi for transportation\n    problem.addConstraint(lambda x, y: x == y - 1, [\"Transport:car\", \"Transport:taxi\"])\n    \n    # Clue 4: the person who uses scooter for transportation is at the same position as or to the right of the person who uses taxi for transportation\n    problem.addConstraint(lambda x, y: x >= y, [\"Transport:scooter\", \"Transport:taxi\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['polish', 'indonesian', 'indian'], 'Transport': ['car', 'taxi', 'scooter']}\n",
      "success": true,
      "execution_time": 0.002212,
      "timestamp": "20250918_084830",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['polish', 'indonesian', 'indian'], 'Transport': ['car', 'taxi', 'scooter']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_33",
      "puzzle": {
        "id": "simple_2x3_33",
        "title": "Einstein Puzzle simple_2x3_33 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005243333000000017
        },
        "clues": [
          "the person who likes d&b music and the person who works as a analyst are at positions with different parity (one at odd, one at even position)",
          "the person who works as a writer is at an even-numbered position",
          "the person who works as a analyst is to the left of the person who likes pop music (not necessarily immediately)"
        ],
        "categories": [
          "Job",
          "Music"
        ],
        "items": {
          "Job": [
            "analyst",
            "writer",
            "freelancer"
          ],
          "Music": [
            "indie",
            "d&b",
            "pop"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"analyst\", \"writer\", \"freelancer\"], \"Music\": [\"indie\", \"d&b\", \"pop\"]}"
      },
      "puzzle_hash": "1a5fb2d6226995b69ce467166322d866",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Music\"]\n    items = {\n        \"Job\": [\"analyst\", \"writer\", \"freelancer\"],\n        \"Music\": [\"indie\", \"d&b\", \"pop\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes d&b music and the person who works as an analyst are at positions with different parity\n    problem.addConstraint(lambda dnb_pos, analyst_pos: (dnb_pos % 2) != (analyst_pos % 2),\n                          [\"Music:d&b\", \"Job:analyst\"])\n    \n    # Clue 2: the person who works as a writer is at an even-numbered position\n    problem.addConstraint(lambda writer_pos: writer_pos % 2 == 0, [\"Job:writer\"])\n    \n    # Clue 3: the person who works as an analyst is to the left of the person who likes pop music (not necessarily immediately)\n    problem.addConstraint(lambda analyst_pos, pop_pos: analyst_pos < pop_pos,\n                          [\"Job:analyst\", \"Music:pop\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "",
      "success": false,
      "execution_time": 0.014838,
      "timestamp": "20250918_084839",
      "verification": {
        "verified": true,
        "is_correct": false,
        "ground_truth": "{'Job': ['analyst', 'writer', 'freelancer'], 'Music': ['indie', 'd&b', 'pop']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_34",
      "puzzle": {
        "id": "simple_2x3_34",
        "title": "Einstein Puzzle simple_2x3_34 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0046002079999999945
        },
        "clues": [
          "the person who likes almond-milk is to the left of the person who uses taxi for transportation (not necessarily immediately)",
          "the person who uses taxi for transportation is immediately to the left of the person who uses helicopter for transportation",
          "the person who likes hot-chocolate is immediately to the left of the person who likes tea"
        ],
        "categories": [
          "Beverage",
          "Transport"
        ],
        "items": {
          "Beverage": [
            "almond-milk",
            "hot-chocolate",
            "tea"
          ],
          "Transport": [
            "jet-ski",
            "taxi",
            "helicopter"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"almond-milk\", \"hot-chocolate\", \"tea\"], \"Transport\": [\"jet-ski\", \"taxi\", \"helicopter\"]}"
      },
      "puzzle_hash": "548e4f80f54b552ef95cd4cd242a4798",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Transport\"]\n    items = {\n        \"Beverage\": [\"almond-milk\", \"hot-chocolate\", \"tea\"],\n        \"Transport\": [\"jet-ski\", \"taxi\", \"helicopter\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes almond-milk is to the left of the person who uses taxi for transportation (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x < y, [\"Beverage:almond-milk\", \"Transport:taxi\"])\n    \n    # Clue 2: the person who uses taxi for transportation is immediately to the left of the person who uses helicopter for transportation\n    problem.addConstraint(lambda x, y: x == y - 1, [\"Transport:taxi\", \"Transport:helicopter\"])\n    \n    # Clue 3: the person who likes hot-chocolate is immediately to the left of the person who likes tea\n    problem.addConstraint(lambda x, y: x == y - 1, [\"Beverage:hot-chocolate\", \"Beverage:tea\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['almond-milk', 'hot-chocolate', 'tea'], 'Transport': ['jet-ski', 'taxi', 'helicopter']}\n",
      "success": true,
      "execution_time": 0.001739,
      "timestamp": "20250918_084847",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['almond-milk', 'hot-chocolate', 'tea'], 'Transport': ['jet-ski', 'taxi', 'helicopter']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_35",
      "puzzle": {
        "id": "simple_2x3_35",
        "title": "Einstein Puzzle simple_2x3_35 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004215292000000009
        },
        "clues": [
          "the person who uses helicopter for transportation is immediately to the left of the person who enjoys collecting",
          "the person who enjoys skydiving is a different person than the person who uses ship for transportation",
          "the person who uses scooter for transportation is somewhere between the person who enjoys magic-tricks and the person who enjoys skydiving (not necessarily immediately adjacent)"
        ],
        "categories": [
          "Hobby",
          "Transport"
        ],
        "items": {
          "Hobby": [
            "skydiving",
            "collecting",
            "magic-tricks"
          ],
          "Transport": [
            "helicopter",
            "scooter",
            "ship"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"skydiving\", \"collecting\", \"magic-tricks\"], \"Transport\": [\"helicopter\", \"scooter\", \"ship\"]}"
      },
      "puzzle_hash": "73de0e729ea82417ae3942f7eaa68fd5",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Transport\"]\n    items = {\n        \"Hobby\": [\"skydiving\", \"collecting\", \"magic-tricks\"],\n        \"Transport\": [\"helicopter\", \"scooter\", \"ship\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: helicopter is immediately to the left of collecting\n    problem.addConstraint(lambda h, c: h == c - 1, [\"Transport:helicopter\", \"Hobby:collecting\"])\n    \n    # Clue 2: skydiving is a different person than ship\n    problem.addConstraint(lambda s, sh: s != sh, [\"Hobby:skydiving\", \"Transport:ship\"])\n    \n    # Clue 3: scooter is somewhere between magic-tricks and skydiving (not necessarily immediately)\n    # means scooter position is strictly between magic-tricks and skydiving positions\n    def between(scooter, magic, sky):\n        return (magic < scooter < sky) or (sky < scooter < magic)\n    problem.addConstraint(between, [\"Transport:scooter\", \"Hobby:magic-tricks\", \"Hobby:skydiving\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['skydiving', 'collecting', 'magic-tricks'], 'Transport': ['helicopter', 'scooter', 'ship']}\n",
      "success": true,
      "execution_time": 0.00173,
      "timestamp": "20250918_084854",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['skydiving', 'collecting', 'magic-tricks'], 'Transport': ['helicopter', 'scooter', 'ship']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_36",
      "puzzle": {
        "id": "simple_2x3_36",
        "title": "Einstein Puzzle simple_2x3_36 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003946959
        },
        "clues": [
          "the person who has fish as a pet is at the same position as or to the left of the person who has pony as a pet",
          "the person who likes sports movies and the person who has pony as a pet are at positions with different parity (one at odd, one at even position)",
          "the person who likes time-travel movies is directly between the person who has fish as a pet and the person who likes family movies"
        ],
        "categories": [
          "Movie",
          "Pet"
        ],
        "items": {
          "Movie": [
            "sports",
            "time-travel",
            "family"
          ],
          "Pet": [
            "fish",
            "pony",
            "lizard"
          ]
        },
        "ground_truth_solution": "{\"Movie\": [\"sports\", \"time-travel\", \"family\"], \"Pet\": [\"fish\", \"pony\", \"lizard\"]}"
      },
      "puzzle_hash": "bfdd4f14b2d63b6b3ed44b54e15dde34",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Pet\"]\n    items = {\n        \"Movie\": [\"sports\", \"time-travel\", \"family\"],\n        \"Pet\": [\"fish\", \"pony\", \"lizard\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: fish is at the same position as or to the left of pony\n    problem.addConstraint(lambda fish_pos, pony_pos: fish_pos <= pony_pos, [\"Pet:fish\", \"Pet:pony\"])\n    \n    # Clue 2: sports movie and pony pet are at positions with different parity\n    problem.addConstraint(lambda sports_pos, pony_pos: (sports_pos % 2) != (pony_pos % 2), [\"Movie:sports\", \"Pet:pony\"])\n    \n    # Clue 3: time-travel movie is directly between fish pet and family movie\n    problem.addConstraint(\n        lambda time_travel_pos, fish_pos, family_pos:\n        (time_travel_pos == fish_pos + 1 and time_travel_pos == family_pos - 1) or\n        (time_travel_pos == family_pos + 1 and time_travel_pos == fish_pos - 1),\n        [\"Movie:time-travel\", \"Pet:fish\", \"Movie:family\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['sports', 'time-travel', 'family'], 'Pet': ['fish', 'pony', 'lizard']}\n",
      "success": true,
      "execution_time": 0.003056,
      "timestamp": "20250918_084902",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['sports', 'time-travel', 'family'], 'Pet': ['fish', 'pony', 'lizard']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_37",
      "puzzle": {
        "id": "simple_2x3_37",
        "title": "Einstein Puzzle simple_2x3_37 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004321167000000015
        },
        "clues": [
          "the argentine person is immediately to the left of the british person",
          "the polish person is a different person than the person who likes cola",
          "the argentine person is at an odd-numbered position",
          "the british person is the same person as the person who likes 7up"
        ],
        "categories": [
          "Beverage",
          "Nationality"
        ],
        "items": {
          "Beverage": [
            "cola",
            "7up",
            "juice"
          ],
          "Nationality": [
            "argentine",
            "british",
            "polish"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"cola\", \"7up\", \"juice\"], \"Nationality\": [\"argentine\", \"british\", \"polish\"]}"
      },
      "puzzle_hash": "8e6f814995cdf6b5473165921b103d4a",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Nationality\"]\n    items = {\n        \"Beverage\": [\"cola\", \"7up\", \"juice\"],\n        \"Nationality\": [\"argentine\", \"british\", \"polish\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the argentine person is immediately to the left of the british person\n    problem.addConstraint(lambda a, b: a == b - 1, [\"Nationality:argentine\", \"Nationality:british\"])\n    \n    # Clue 2: the polish person is a different person than the person who likes cola\n    problem.addConstraint(lambda p, c: p != c, [\"Nationality:polish\", \"Beverage:cola\"])\n    \n    # Clue 3: the argentine person is at an odd-numbered position (0-indexed: positions 0,1,2; odd positions are 1)\n    problem.addConstraint(lambda a: a == 1, [\"Nationality:argentine\"])\n    \n    # Clue 4: the british person is the same person as the person who likes 7up\n    problem.addConstraint(lambda b, s: b == s, [\"Nationality:british\", \"Beverage:7up\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['juice', 'cola', '7up'], 'Nationality': ['polish', 'argentine', 'british']}\n",
      "success": true,
      "execution_time": 0.002119,
      "timestamp": "20250918_084910",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['cola', '7up', 'juice'], 'Nationality': ['argentine', 'british', 'polish']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_38",
      "puzzle": {
        "id": "simple_2x3_38",
        "title": "Einstein Puzzle simple_2x3_38 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00508225000000001
        },
        "clues": [
          "the person who has rat as a pet is at the center position (position 2)",
          "the person who enjoys traveling is to the left of the person who has guinea-pig as a pet (not necessarily immediately)",
          "the person who has rat as a pet and the person who enjoys cooking are at positions with the same parity (both at odd or both at even positions)"
        ],
        "categories": [
          "Hobby",
          "Pet"
        ],
        "items": {
          "Hobby": [
            "traveling",
            "cooking",
            "singing"
          ],
          "Pet": [
            "pony",
            "rat",
            "guinea-pig"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"traveling\", \"cooking\", \"singing\"], \"Pet\": [\"pony\", \"rat\", \"guinea-pig\"]}"
      },
      "puzzle_hash": "bdcd545f80dd21bb1c622b79646f8077",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Hobby\", \"Pet\"]\n    items = {\n        \"Hobby\": [\"traveling\", \"cooking\", \"singing\"],\n        \"Pet\": [\"pony\", \"rat\", \"guinea-pig\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who has rat as a pet is at the center position (position 2)\n    problem.addConstraint(lambda x: x == 1, [\"Pet:rat\"])  # zero-indexed, center is 1\n    \n    # Clue 2: the person who enjoys traveling is to the left of the person who has guinea-pig as a pet (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x < y, [\"Hobby:traveling\", \"Pet:guinea-pig\"])\n    \n    # Clue 3: the person who has rat as a pet and the person who enjoys cooking are at positions with the same parity\n    problem.addConstraint(lambda x, y: x % 2 == y % 2, [\"Pet:rat\", \"Hobby:cooking\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['traveling', 'cooking', 'singing'], 'Pet': ['pony', 'rat', 'guinea-pig']}\n",
      "success": true,
      "execution_time": 0.001842,
      "timestamp": "20250918_084918",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['traveling', 'cooking', 'singing'], 'Pet': ['pony', 'rat', 'guinea-pig']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_39",
      "puzzle": {
        "id": "simple_2x3_39",
        "title": "Einstein Puzzle simple_2x3_39 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004208125000000007
        },
        "clues": [
          "the person who likes sports movies is immediately to the left of the person who plays parkour",
          "the person who plays golf is immediately to the left of the person who plays parkour",
          "the person who likes action movies is to the left of the person who plays golf (not necessarily immediately)"
        ],
        "categories": [
          "Movie",
          "Sport"
        ],
        "items": {
          "Movie": [
            "action",
            "sports",
            "thriller"
          ],
          "Sport": [
            "sailing",
            "golf",
            "parkour"
          ]
        },
        "ground_truth_solution": "{\"Movie\": [\"action\", \"sports\", \"thriller\"], \"Sport\": [\"sailing\", \"golf\", \"parkour\"]}"
      },
      "puzzle_hash": "1557d8e7d082ad72275b54f79018cff6",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Movie\", \"Sport\"]\n    items = {\n        \"Movie\": [\"action\", \"sports\", \"thriller\"],\n        \"Sport\": [\"sailing\", \"golf\", \"parkour\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes sports movies is immediately to the left of the person who plays parkour\n    problem.addConstraint(lambda sports_movie, parkour: sports_movie == parkour - 1,\n                          [\"Movie:sports\", \"Sport:parkour\"])\n    \n    # Clue 2: the person who plays golf is immediately to the left of the person who plays parkour\n    problem.addConstraint(lambda golf, parkour: golf == parkour - 1,\n                          [\"Sport:golf\", \"Sport:parkour\"])\n    \n    # Clue 3: the person who likes action movies is to the left of the person who plays golf (not necessarily immediately)\n    problem.addConstraint(lambda action, golf: action < golf,\n                          [\"Movie:action\", \"Sport:golf\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['action', 'sports', 'thriller'], 'Sport': ['sailing', 'golf', 'parkour']}\n",
      "success": true,
      "execution_time": 0.001905,
      "timestamp": "20250918_084926",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['action', 'sports', 'thriller'], 'Sport': ['sailing', 'golf', 'parkour']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_40",
      "puzzle": {
        "id": "simple_2x3_40",
        "title": "Einstein Puzzle simple_2x3_40 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.007449457999999992
        },
        "clues": [
          "the person who works as a freelancer is at the same position as or to the left of the person who works as a videographer",
          "the person who enjoys chess is immediately to the left of the person who enjoys collecting",
          "the person who works as a videographer is at the same position as or to the left of the person who enjoys chess"
        ],
        "categories": [
          "Hobby",
          "Job"
        ],
        "items": {
          "Hobby": [
            "reading",
            "chess",
            "collecting"
          ],
          "Job": [
            "freelancer",
            "videographer",
            "pilot"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"reading\", \"chess\", \"collecting\"], \"Job\": [\"freelancer\", \"videographer\", \"pilot\"]}"
      },
      "puzzle_hash": "31148fc3aa838dc2606c0c82be0c50ac",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Job\"]\n    items = {\n        \"Hobby\": [\"reading\", \"chess\", \"collecting\"],\n        \"Job\": [\"freelancer\", \"videographer\", \"pilot\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: freelancer is at the same position as or to the left of videographer\n    problem.addConstraint(lambda f, v: f <= v, [\"Job:freelancer\", \"Job:videographer\"])\n    \n    # Clue 2: chess is immediately to the left of collecting\n    problem.addConstraint(lambda c, col: c == col - 1, [\"Hobby:chess\", \"Hobby:collecting\"])\n    \n    # Clue 3: videographer is at the same position as or to the left of chess\n    problem.addConstraint(lambda v, c: v <= c, [\"Job:videographer\", \"Hobby:chess\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['reading', 'chess', 'collecting'], 'Job': ['freelancer', 'videographer', 'pilot']}\n",
      "success": true,
      "execution_time": 0.002236,
      "timestamp": "20250918_084934",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['reading', 'chess', 'collecting'], 'Job': ['freelancer', 'videographer', 'pilot']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_41",
      "puzzle": {
        "id": "simple_2x3_41",
        "title": "Einstein Puzzle simple_2x3_41 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003458249999999996
        },
        "clues": [
          "the person who enjoys magic-tricks is to the right of the person who enjoys card-games (not necessarily immediately)",
          "the person who plays handball is immediately to the left of the person who plays soccer",
          "the person who enjoys card-games is directly between the person who plays ice-hockey and the person who plays soccer"
        ],
        "categories": [
          "Hobby",
          "Sport"
        ],
        "items": {
          "Hobby": [
            "photography",
            "card-games",
            "magic-tricks"
          ],
          "Sport": [
            "ice-hockey",
            "handball",
            "soccer"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"photography\", \"card-games\", \"magic-tricks\"], \"Sport\": [\"ice-hockey\", \"handball\", \"soccer\"]}"
      },
      "puzzle_hash": "cb5f53c31d24a063a7658e3d3ef27da6",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Sport\"]\n    items = {\n        \"Hobby\": [\"photography\", \"card-games\", \"magic-tricks\"],\n        \"Sport\": [\"ice-hockey\", \"handball\", \"soccer\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys magic-tricks is to the right of the person who enjoys card-games (not necessarily immediately)\n    problem.addConstraint(lambda magic, card: magic > card,\n                          [\"Hobby:magic-tricks\", \"Hobby:card-games\"])\n    \n    # Clue 2: the person who plays handball is immediately to the left of the person who plays soccer\n    problem.addConstraint(lambda handball, soccer: handball == soccer - 1,\n                          [\"Sport:handball\", \"Sport:soccer\"])\n    \n    # Clue 3: the person who enjoys card-games is directly between the person who plays ice-hockey and the person who plays soccer\n    # That means card-games position is exactly between ice-hockey and soccer positions\n    # So card-games is at position x, ice-hockey and soccer at positions x-1 and x+1 in any order\n    problem.addConstraint(\n        lambda card, ice, soccer: (card == ice + 1 and card == soccer - 1) or (card == soccer + 1 and card == ice - 1),\n        [\"Hobby:card-games\", \"Sport:ice-hockey\", \"Sport:soccer\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['photography', 'card-games', 'magic-tricks'], 'Sport': ['ice-hockey', 'handball', 'soccer']}\n",
      "success": true,
      "execution_time": 0.002837,
      "timestamp": "20250918_084944",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['photography', 'card-games', 'magic-tricks'], 'Sport': ['ice-hockey', 'handball', 'soccer']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_42",
      "puzzle": {
        "id": "simple_2x3_42",
        "title": "Einstein Puzzle simple_2x3_42 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.007698624999999987
        },
        "clues": [
          "the person who uses subway for transportation is somewhere between the person who enjoys cooking and the person who uses quad-bike for transportation (not necessarily immediately adjacent)",
          "the person who enjoys board-games is to the right of the person who uses quad-bike for transportation (not necessarily immediately)"
        ],
        "categories": [
          "Hobby",
          "Transport"
        ],
        "items": {
          "Hobby": [
            "skydiving",
            "board-games",
            "cooking"
          ],
          "Transport": [
            "quad-bike",
            "subway",
            "ship"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"skydiving\", \"board-games\", \"cooking\"], \"Transport\": [\"quad-bike\", \"subway\", \"ship\"]}"
      },
      "puzzle_hash": "9312ed0bed6929e2f7b23c095faaaa28",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Transport\"]\n    items = {\n        \"Hobby\": [\"skydiving\", \"board-games\", \"cooking\"],\n        \"Transport\": [\"quad-bike\", \"subway\", \"ship\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1:\n    # the person who uses subway for transportation is somewhere between the person who enjoys cooking and the person who uses quad-bike for transportation (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda subway, cooking, quad: (cooking < subway < quad) or (quad < subway < cooking),\n        [\"Transport:subway\", \"Hobby:cooking\", \"Transport:quad-bike\"]\n    )\n    \n    # Clue 2:\n    # the person who enjoys board-games is to the right of the person who uses quad-bike for transportation (not necessarily immediately)\n    problem.addConstraint(\n        lambda board_games, quad: board_games > quad,\n        [\"Hobby:board-games\", \"Transport:quad-bike\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['skydiving', 'board-games', 'cooking'], 'Transport': ['quad-bike', 'subway', 'ship']}\n",
      "success": true,
      "execution_time": 0.002896,
      "timestamp": "20250918_084951",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['skydiving', 'board-games', 'cooking'], 'Transport': ['quad-bike', 'subway', 'ship']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_43",
      "puzzle": {
        "id": "simple_2x3_43",
        "title": "Einstein Puzzle simple_2x3_43 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004014999999999991
        },
        "clues": [
          "the person who enjoys collecting and the person who plays handball are at positions with different parity (one at odd, one at even position)",
          "the person who enjoys hiking is to the right of the person who plays volleyball (not necessarily immediately)",
          "the person who enjoys hiking is to the left of the person who enjoys collecting (not necessarily immediately)"
        ],
        "categories": [
          "Hobby",
          "Sport"
        ],
        "items": {
          "Hobby": [
            "skydiving",
            "hiking",
            "collecting"
          ],
          "Sport": [
            "volleyball",
            "handball",
            "cricket"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"skydiving\", \"hiking\", \"collecting\"], \"Sport\": [\"volleyball\", \"handball\", \"cricket\"]}"
      },
      "puzzle_hash": "0066c8fbef75ee0ef992e4e8431bc397",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Sport\"]\n    items = {\n        \"Hobby\": [\"skydiving\", \"hiking\", \"collecting\"],\n        \"Sport\": [\"volleyball\", \"handball\", \"cricket\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys collecting and the person who plays handball are at positions with different parity\n    problem.addConstraint(lambda c, h: (c % 2) != (h % 2), [\"Hobby:collecting\", \"Sport:handball\"])\n    \n    # Clue 2: the person who enjoys hiking is to the right of the person who plays volleyball (not necessarily immediately)\n    problem.addConstraint(lambda h, v: h > v, [\"Hobby:hiking\", \"Sport:volleyball\"])\n    \n    # Clue 3: the person who enjoys hiking is to the left of the person who enjoys collecting (not necessarily immediately)\n    problem.addConstraint(lambda h, c: h < c, [\"Hobby:hiking\", \"Hobby:collecting\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['skydiving', 'hiking', 'collecting'], 'Sport': ['volleyball', 'handball', 'cricket']}\n",
      "success": true,
      "execution_time": 0.002711,
      "timestamp": "20250918_084959",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['skydiving', 'hiking', 'collecting'], 'Sport': ['volleyball', 'handball', 'cricket']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_44",
      "puzzle": {
        "id": "simple_2x3_44",
        "title": "Einstein Puzzle simple_2x3_44 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005390249999999985
        },
        "clues": [
          "the person who likes fanta is immediately to the left of the person who likes eggplant",
          "the person who likes eggplant is immediately to the right of the person who likes cranberry",
          "the person who likes eggplant is to the left of the person who likes 7up (not necessarily immediately)"
        ],
        "categories": [
          "Beverage",
          "Food"
        ],
        "items": {
          "Beverage": [
            "fanta",
            "almond-milk",
            "7up"
          ],
          "Food": [
            "cranberry",
            "eggplant",
            "avocado"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"fanta\", \"almond-milk\", \"7up\"], \"Food\": [\"cranberry\", \"eggplant\", \"avocado\"]}"
      },
      "puzzle_hash": "6512496c5c48031812e9909071791e3c",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Food\"]\n    items = {\n        \"Beverage\": [\"fanta\", \"almond-milk\", \"7up\"],\n        \"Food\": [\"cranberry\", \"eggplant\", \"avocado\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes fanta is immediately to the left of the person who likes eggplant\n    problem.addConstraint(lambda fanta, eggplant: fanta == eggplant - 1, [\"Beverage:fanta\", \"Food:eggplant\"])\n    \n    # Clue 2: the person who likes eggplant is immediately to the right of the person who likes cranberry\n    problem.addConstraint(lambda eggplant, cranberry: eggplant == cranberry + 1, [\"Food:eggplant\", \"Food:cranberry\"])\n    \n    # Clue 3: the person who likes eggplant is to the left of the person who likes 7up (not necessarily immediately)\n    problem.addConstraint(lambda eggplant, sevenup: eggplant < sevenup, [\"Food:eggplant\", \"Beverage:7up\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['fanta', 'almond-milk', '7up'], 'Food': ['cranberry', 'eggplant', 'avocado']}\n",
      "success": true,
      "execution_time": 0.002957,
      "timestamp": "20250918_085007",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['fanta', 'almond-milk', '7up'], 'Food': ['cranberry', 'eggplant', 'avocado']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_45",
      "puzzle": {
        "id": "simple_2x3_45",
        "title": "Einstein Puzzle simple_2x3_45 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003517958999999987
        },
        "clues": [
          "the person who enjoys skydiving is somewhere between the person who enjoys traveling and the person who likes zucchini (not necessarily immediately adjacent)",
          "the person who likes blueberry is at the same position as or to the left of the person who likes zucchini",
          "the person who enjoys skydiving and the person who likes asparagus are at positions with different parity (one at odd, one at even position)"
        ],
        "categories": [
          "Food",
          "Hobby"
        ],
        "items": {
          "Food": [
            "asparagus",
            "blueberry",
            "zucchini"
          ],
          "Hobby": [
            "traveling",
            "skydiving",
            "writing"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"asparagus\", \"blueberry\", \"zucchini\"], \"Hobby\": [\"traveling\", \"skydiving\", \"writing\"]}"
      },
      "puzzle_hash": "8c2ca8efff853b3ed28c797ebc81c3b8",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Food\", \"Hobby\"]\n    items = {\n        \"Food\": [\"asparagus\", \"blueberry\", \"zucchini\"],\n        \"Hobby\": [\"traveling\", \"skydiving\", \"writing\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys skydiving is somewhere between the person who enjoys traveling and the person who likes zucchini (not necessarily immediately adjacent)\n    # means skydiving position is strictly between traveling and zucchini positions\n    problem.addConstraint(\n        lambda skydiving, traveling, zucchini: (traveling < skydiving < zucchini) or (zucchini < skydiving < traveling),\n        [\"Hobby:skydiving\", \"Hobby:traveling\", \"Food:zucchini\"]\n    )\n    \n    # Clue 2: the person who likes blueberry is at the same position as or to the left of the person who likes zucchini\n    problem.addConstraint(\n        lambda blueberry, zucchini: blueberry <= zucchini,\n        [\"Food:blueberry\", \"Food:zucchini\"]\n    )\n    \n    # Clue 3: the person who enjoys skydiving and the person who likes asparagus are at positions with different parity\n    problem.addConstraint(\n        lambda skydiving, asparagus: (skydiving % 2) != (asparagus % 2),\n        [\"Hobby:skydiving\", \"Food:asparagus\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['asparagus', 'blueberry', 'zucchini'], 'Hobby': ['traveling', 'skydiving', 'writing']}\n",
      "success": true,
      "execution_time": 0.002898,
      "timestamp": "20250918_085014",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['asparagus', 'blueberry', 'zucchini'], 'Hobby': ['traveling', 'skydiving', 'writing']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_46",
      "puzzle": {
        "id": "simple_2x3_46",
        "title": "Einstein Puzzle simple_2x3_46 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0051958750000000165
        },
        "clues": [
          "the person who likes scientific movies is at the same position as or to the left of the person who likes soy-milk",
          "the person who likes tea is immediately to the left of the person who likes scientific movies",
          "the person who likes soy-milk is immediately to the left of the person who likes drama movies"
        ],
        "categories": [
          "Beverage",
          "Movie"
        ],
        "items": {
          "Beverage": [
            "tea",
            "soy-milk",
            "sprite"
          ],
          "Movie": [
            "disaster",
            "scientific",
            "drama"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"tea\", \"soy-milk\", \"sprite\"], \"Movie\": [\"disaster\", \"scientific\", \"drama\"]}"
      },
      "puzzle_hash": "63ea304cc03d601dcf045fbfddb036fb",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Movie\"]\n    items = {\n        \"Beverage\": [\"tea\", \"soy-milk\", \"sprite\"],\n        \"Movie\": [\"disaster\", \"scientific\", \"drama\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes scientific movies is at the same position as or to the left of the person who likes soy-milk\n    problem.addConstraint(lambda sci, soy: sci <= soy, [\"Movie:scientific\", \"Beverage:soy-milk\"])\n    \n    # Clue 2: the person who likes tea is immediately to the left of the person who likes scientific movies\n    problem.addConstraint(lambda tea, sci: tea == sci - 1, [\"Beverage:tea\", \"Movie:scientific\"])\n    \n    # Clue 3: the person who likes soy-milk is immediately to the left of the person who likes drama movies\n    problem.addConstraint(lambda soy, drama: soy == drama - 1, [\"Beverage:soy-milk\", \"Movie:drama\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['tea', 'soy-milk', 'sprite'], 'Movie': ['disaster', 'scientific', 'drama']}\n",
      "success": true,
      "execution_time": 0.002982,
      "timestamp": "20250918_085023",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['tea', 'soy-milk', 'sprite'], 'Movie': ['disaster', 'scientific', 'drama']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_47",
      "puzzle": {
        "id": "simple_2x3_47",
        "title": "Einstein Puzzle simple_2x3_47 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.009476166000000008
        },
        "clues": [
          "the argentine person is at an end position (either leftmost or rightmost)",
          "the argentine person is adjacent to the person who likes apricot (either immediately left or right)",
          "the argentine person is immediately to the right of the thai person",
          "the person who likes apricot is at the same position as or to the left of the person who likes cucumber"
        ],
        "categories": [
          "Food",
          "Nationality"
        ],
        "items": {
          "Food": [
            "kiwi",
            "apricot",
            "cucumber"
          ],
          "Nationality": [
            "indonesian",
            "thai",
            "argentine"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"kiwi\", \"apricot\", \"cucumber\"], \"Nationality\": [\"indonesian\", \"thai\", \"argentine\"]}"
      },
      "puzzle_hash": "d3a3bd734d82ae7c3fb5f04ab56bc1c5",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Nationality\"]\n    items = {\n        \"Food\": [\"kiwi\", \"apricot\", \"cucumber\"],\n        \"Nationality\": [\"indonesian\", \"thai\", \"argentine\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the argentine person is at an end position (0 or 2)\n    problem.addConstraint(lambda x: x == 0 or x == 2, [\"Nationality:argentine\"])\n    \n    # Clue 2: the argentine person is adjacent to the person who likes apricot\n    problem.addConstraint(lambda a, f: abs(a - f) == 1, [\"Nationality:argentine\", \"Food:apricot\"])\n    \n    # Clue 3: the argentine person is immediately to the right of the thai person\n    problem.addConstraint(lambda t, a: a == t + 1, [\"Nationality:thai\", \"Nationality:argentine\"])\n    \n    # Clue 4: the person who likes apricot is at the same position as or to the left of the person who likes cucumber\n    problem.addConstraint(lambda a, c: a <= c, [\"Food:apricot\", \"Food:cucumber\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['kiwi', 'apricot', 'cucumber'], 'Nationality': ['indonesian', 'thai', 'argentine']}\n",
      "success": true,
      "execution_time": 0.002306,
      "timestamp": "20250918_085045",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['kiwi', 'apricot', 'cucumber'], 'Nationality': ['indonesian', 'thai', 'argentine']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_48",
      "puzzle": {
        "id": "simple_2x3_48",
        "title": "Einstein Puzzle simple_2x3_48 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00577704200000001
        },
        "clues": [
          "the person who plays snowboarding is to the right of the person who plays basketball (not necessarily immediately)",
          "the person who likes kale is immediately to the right of the person who likes cucumber",
          "the person who plays basketball is immediately to the left of the person who likes avocado"
        ],
        "categories": [
          "Food",
          "Sport"
        ],
        "items": {
          "Food": [
            "cucumber",
            "kale",
            "avocado"
          ],
          "Sport": [
            "handball",
            "basketball",
            "snowboarding"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"cucumber\", \"kale\", \"avocado\"], \"Sport\": [\"handball\", \"basketball\", \"snowboarding\"]}"
      },
      "puzzle_hash": "e014238678044af8b70c4f1b1bc131d4",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Sport\"]\n    items = {\n        \"Food\": [\"cucumber\", \"kale\", \"avocado\"],\n        \"Sport\": [\"handball\", \"basketball\", \"snowboarding\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays snowboarding is to the right of the person who plays basketball (not necessarily immediately)\n    problem.addConstraint(lambda snow, basket: snow > basket, [\"Sport:snowboarding\", \"Sport:basketball\"])\n    \n    # Clue 2: the person who likes kale is immediately to the right of the person who likes cucumber\n    problem.addConstraint(lambda kale, cucumber: kale == cucumber + 1, [\"Food:kale\", \"Food:cucumber\"])\n    \n    # Clue 3: the person who plays basketball is immediately to the left of the person who likes avocado\n    problem.addConstraint(lambda basket, avocado: basket == avocado - 1, [\"Sport:basketball\", \"Food:avocado\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['cucumber', 'kale', 'avocado'], 'Sport': ['handball', 'basketball', 'snowboarding']}\n",
      "success": true,
      "execution_time": 0.0029,
      "timestamp": "20250918_085052",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['cucumber', 'kale', 'avocado'], 'Sport': ['handball', 'basketball', 'snowboarding']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_49",
      "puzzle": {
        "id": "simple_2x3_49",
        "title": "Einstein Puzzle simple_2x3_49 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.008007916000000004
        },
        "clues": [
          "the person who likes comedy movies is somewhere between the person who enjoys skydiving and the person who likes horror movies (not necessarily immediately adjacent)",
          "the person who enjoys skydiving is to the right of the person who likes horror movies (not necessarily immediately)",
          "the person who likes horror movies and the person who enjoys singing are at positions with the same parity (both at odd or both at even positions)"
        ],
        "categories": [
          "Hobby",
          "Movie"
        ],
        "items": {
          "Hobby": [
            "singing",
            "sudoku",
            "skydiving"
          ],
          "Movie": [
            "horror",
            "comedy",
            "animation"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"singing\", \"sudoku\", \"skydiving\"], \"Movie\": [\"horror\", \"comedy\", \"animation\"]}"
      },
      "puzzle_hash": "43140aee466bc7d613f38376e8bf74a0",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Movie\"]\n    items = {\n        \"Hobby\": [\"singing\", \"sudoku\", \"skydiving\"],\n        \"Movie\": [\"horror\", \"comedy\", \"animation\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes comedy movies is somewhere between the person who enjoys skydiving and the person who likes horror movies (not necessarily immediately adjacent)\n    # Let c = comedy, s = skydiving, h = horror\n    # comedy position is strictly between skydiving and horror positions\n    problem.addConstraint(\n        lambda c, s, h: (s < c < h) or (h < c < s),\n        [\"Movie:comedy\", \"Hobby:skydiving\", \"Movie:horror\"]\n    )\n    \n    # Clue 2: the person who enjoys skydiving is to the right of the person who likes horror movies (not necessarily immediately)\n    problem.addConstraint(\n        lambda s, h: s > h,\n        [\"Hobby:skydiving\", \"Movie:horror\"]\n    )\n    \n    # Clue 3: the person who likes horror movies and the person who enjoys singing are at positions with the same parity\n    problem.addConstraint(\n        lambda h, si: h % 2 == si % 2,\n        [\"Movie:horror\", \"Hobby:singing\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['singing', 'sudoku', 'skydiving'], 'Movie': ['horror', 'comedy', 'animation']}\n",
      "success": true,
      "execution_time": 0.002891,
      "timestamp": "20250918_085100",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['singing', 'sudoku', 'skydiving'], 'Movie': ['horror', 'comedy', 'animation']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_50",
      "puzzle": {
        "id": "simple_2x3_50",
        "title": "Einstein Puzzle simple_2x3_50 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.008479334000000005
        },
        "clues": [
          "the person who likes strawberry is somewhere between the person who likes pomegranate and the person who likes pop music (not necessarily immediately adjacent)",
          "the person who likes pomegranate is immediately to the left of the person who likes funk music"
        ],
        "categories": [
          "Food",
          "Music"
        ],
        "items": {
          "Food": [
            "pomegranate",
            "strawberry",
            "grapefruit"
          ],
          "Music": [
            "folk",
            "funk",
            "pop"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"pomegranate\", \"strawberry\", \"grapefruit\"], \"Music\": [\"folk\", \"funk\", \"pop\"]}"
      },
      "puzzle_hash": "7a242e10c9f145a188b070b20ba6cc1f",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Food\", \"Music\"]\n    items = {\n        \"Food\": [\"pomegranate\", \"strawberry\", \"grapefruit\"],\n        \"Music\": [\"folk\", \"funk\", \"pop\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes strawberry is somewhere between the person who likes pomegranate and the person who likes pop music (not necessarily immediately adjacent)\n    # This means strawberry is strictly between pomegranate and pop, so strawberry's position is greater than min(pomegranate, pop) and less than max(pomegranate, pop)\n    def between(strawberry, pomegranate, pop):\n        return (pomegranate < strawberry < pop) or (pop < strawberry < pomegranate)\n    problem.addConstraint(between, [\"Food:strawberry\", \"Food:pomegranate\", \"Music:pop\"])\n    \n    # Clue 2: the person who likes pomegranate is immediately to the left of the person who likes funk music\n    problem.addConstraint(lambda p, f: p == f - 1, [\"Food:pomegranate\", \"Music:funk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['pomegranate', 'strawberry', 'grapefruit'], 'Music': ['folk', 'funk', 'pop']}\n",
      "success": true,
      "execution_time": 0.002882,
      "timestamp": "20250918_085108",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['pomegranate', 'strawberry', 'grapefruit'], 'Music': ['folk', 'funk', 'pop']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_51",
      "puzzle": {
        "id": "simple_2x3_51",
        "title": "Einstein Puzzle simple_2x3_51 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006287166000000011
        },
        "clues": [
          "the person who plays cycling is to the left of the person who plays sailing (not necessarily immediately)",
          "the person who likes peach is adjacent to the person who likes banana (either immediately left or right)",
          "the person who likes peach is immediately to the right of the person who likes corn",
          "the person who plays tennis is the same person as the person who likes corn"
        ],
        "categories": [
          "Food",
          "Sport"
        ],
        "items": {
          "Food": [
            "corn",
            "peach",
            "banana"
          ],
          "Sport": [
            "tennis",
            "cycling",
            "sailing"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"corn\", \"peach\", \"banana\"], \"Sport\": [\"tennis\", \"cycling\", \"sailing\"]}"
      },
      "puzzle_hash": "7a60d9b97c81fedc0f0aaa3ca1dc2ef0",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Food\", \"Sport\"]\n    items = {\n        \"Food\": [\"corn\", \"peach\", \"banana\"],\n        \"Sport\": [\"tennis\", \"cycling\", \"sailing\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays cycling is to the left of the person who plays sailing (not necessarily immediately)\n    problem.addConstraint(lambda cycling, sailing: cycling < sailing, [\"Sport:cycling\", \"Sport:sailing\"])\n    \n    # Clue 2: the person who likes peach is adjacent to the person who likes banana (either immediately left or right)\n    problem.addConstraint(lambda peach, banana: abs(peach - banana) == 1, [\"Food:peach\", \"Food:banana\"])\n    \n    # Clue 3: the person who likes peach is immediately to the right of the person who likes corn\n    problem.addConstraint(lambda corn, peach: peach == corn + 1, [\"Food:corn\", \"Food:peach\"])\n    \n    # Clue 4: the person who plays tennis is the same person as the person who likes corn\n    problem.addConstraint(lambda tennis, corn: tennis == corn, [\"Sport:tennis\", \"Food:corn\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['corn', 'peach', 'banana'], 'Sport': ['tennis', 'cycling', 'sailing']}\n",
      "success": true,
      "execution_time": 0.002951,
      "timestamp": "20250918_085116",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['corn', 'peach', 'banana'], 'Sport': ['tennis', 'cycling', 'sailing']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_52",
      "puzzle": {
        "id": "simple_2x3_52",
        "title": "Einstein Puzzle simple_2x3_52 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00600974999999998
        },
        "clues": [
          "the dutch person is to the left of the japanese person (not necessarily immediately)",
          "the person who likes apricot is adjacent to the japanese person (either immediately left or right)",
          "the person who likes lemon is somewhere between the dutch person and the person who likes eggplant (not necessarily immediately adjacent)"
        ],
        "categories": [
          "Food",
          "Nationality"
        ],
        "items": {
          "Food": [
            "apricot",
            "lemon",
            "eggplant"
          ],
          "Nationality": [
            "dutch",
            "japanese",
            "spanish"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"apricot\", \"lemon\", \"eggplant\"], \"Nationality\": [\"dutch\", \"japanese\", \"spanish\"]}"
      },
      "puzzle_hash": "f93cc74bd4c238611de9e11f0dc8ef87",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Nationality\"]\n    items = {\n        \"Food\": [\"apricot\", \"lemon\", \"eggplant\"],\n        \"Nationality\": [\"dutch\", \"japanese\", \"spanish\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the dutch person is to the left of the japanese person (not necessarily immediately)\n    problem.addConstraint(lambda dutch, japanese: dutch < japanese,\n                          [\"Nationality:dutch\", \"Nationality:japanese\"])\n    \n    # Clue 2: the person who likes apricot is adjacent to the japanese person (either immediately left or right)\n    problem.addConstraint(lambda apricot, japanese: abs(apricot - japanese) == 1,\n                          [\"Food:apricot\", \"Nationality:japanese\"])\n    \n    # Clue 3: the person who likes lemon is somewhere between the dutch person and the person who likes eggplant (not necessarily immediately adjacent)\n    # This means lemon's position is strictly between dutch and eggplant positions\n    def lemon_between(dutch, lemon, eggplant):\n        return (dutch < lemon < eggplant) or (eggplant < lemon < dutch)\n    problem.addConstraint(lemon_between,\n                          [\"Nationality:dutch\", \"Food:lemon\", \"Food:eggplant\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['apricot', 'lemon', 'eggplant'], 'Nationality': ['dutch', 'japanese', 'spanish']}\n",
      "success": true,
      "execution_time": 0.002623,
      "timestamp": "20250918_085122",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['apricot', 'lemon', 'eggplant'], 'Nationality': ['dutch', 'japanese', 'spanish']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_53",
      "puzzle": {
        "id": "simple_2x3_53",
        "title": "Einstein Puzzle simple_2x3_53 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00494145800000001
        },
        "clues": [
          "the person who enjoys singing is to the left of the person who enjoys card-games (not necessarily immediately)",
          "the person who likes country music is immediately to the right of the person who enjoys board-games",
          "the person who likes hip-hop music is to the right of the person who likes country music (not necessarily immediately)"
        ],
        "categories": [
          "Hobby",
          "Music"
        ],
        "items": {
          "Hobby": [
            "board-games",
            "singing",
            "card-games"
          ],
          "Music": [
            "d&b",
            "country",
            "hip-hop"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"board-games\", \"singing\", \"card-games\"], \"Music\": [\"d&b\", \"country\", \"hip-hop\"]}"
      },
      "puzzle_hash": "0d49ea2eb3b005db2626efd73b9fce02",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Music\"]\n    items = {\n        \"Hobby\": [\"board-games\", \"singing\", \"card-games\"],\n        \"Music\": [\"d&b\", \"country\", \"hip-hop\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys singing is to the left of the person who enjoys card-games (not necessarily immediately)\n    problem.addConstraint(lambda singing, card_games: singing < card_games,\n                          [\"Hobby:singing\", \"Hobby:card-games\"])\n    \n    # Clue 2: the person who likes country music is immediately to the right of the person who enjoys board-games\n    problem.addConstraint(lambda board_games, country: board_games == country - 1,\n                          [\"Hobby:board-games\", \"Music:country\"])\n    \n    # Clue 3: the person who likes hip-hop music is to the right of the person who likes country music (not necessarily immediately)\n    problem.addConstraint(lambda country, hip_hop: country < hip_hop,\n                          [\"Music:country\", \"Music:hip-hop\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['board-games', 'singing', 'card-games'], 'Music': ['d&b', 'country', 'hip-hop']}\n",
      "success": true,
      "execution_time": 0.002015,
      "timestamp": "20250918_085129",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['board-games', 'singing', 'card-games'], 'Music': ['d&b', 'country', 'hip-hop']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_54",
      "puzzle": {
        "id": "simple_2x3_54",
        "title": "Einstein Puzzle simple_2x3_54 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006371707999999976
        },
        "clues": [
          "the person who uses helicopter for transportation is adjacent to the person who uses bike for transportation (either immediately left or right)",
          "the person who likes carrot is at the same position as or to the right of the person who uses helicopter for transportation",
          "the person who uses airplane for transportation is immediately to the left of the person who likes carrot",
          "the person who likes banana is at position 1 (the leftmost position)"
        ],
        "categories": [
          "Food",
          "Transport"
        ],
        "items": {
          "Food": [
            "banana",
            "carrot",
            "cabbage"
          ],
          "Transport": [
            "airplane",
            "helicopter",
            "bike"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"banana\", \"carrot\", \"cabbage\"], \"Transport\": [\"airplane\", \"helicopter\", \"bike\"]}"
      },
      "puzzle_hash": "02dac83182b5e3df6de3ad712b85585d",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Transport\"]\n    items = {\n        \"Food\": [\"banana\", \"carrot\", \"cabbage\"],\n        \"Transport\": [\"airplane\", \"helicopter\", \"bike\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: helicopter adjacent to bike\n    problem.addConstraint(lambda h, b: abs(h - b) == 1, [\"Transport:helicopter\", \"Transport:bike\"])\n    \n    # Clue 2: carrot is at the same position as or to the right of helicopter\n    problem.addConstraint(lambda c, h: c >= h, [\"Food:carrot\", \"Transport:helicopter\"])\n    \n    # Clue 3: airplane immediately to the left of carrot\n    problem.addConstraint(lambda a, c: a == c - 1, [\"Transport:airplane\", \"Food:carrot\"])\n    \n    # Clue 4: banana is at position 1 (leftmost, zero-indexed 0)\n    problem.addConstraint(lambda b: b == 0, [\"Food:banana\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['banana', 'carrot', 'cabbage'], 'Transport': ['airplane', 'helicopter', 'bike']}\n",
      "success": true,
      "execution_time": 0.00242,
      "timestamp": "20250918_085137",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['banana', 'carrot', 'cabbage'], 'Transport': ['airplane', 'helicopter', 'bike']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_55",
      "puzzle": {
        "id": "simple_2x3_55",
        "title": "Einstein Puzzle simple_2x3_55 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005426750000000036
        },
        "clues": [
          "the person who has rat as a pet is adjacent to the person who likes hot-chocolate (either immediately left or right)",
          "the person who likes hot-chocolate is to the right of the person who likes coffee (not necessarily immediately)",
          "the person who has rabbit as a pet is directly between the person who has horse as a pet and the person who likes coffee"
        ],
        "categories": [
          "Beverage",
          "Pet"
        ],
        "items": {
          "Beverage": [
            "coffee",
            "hot-chocolate",
            "fanta"
          ],
          "Pet": [
            "rat",
            "rabbit",
            "horse"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"coffee\", \"hot-chocolate\", \"fanta\"], \"Pet\": [\"rat\", \"rabbit\", \"horse\"]}"
      },
      "puzzle_hash": "8fa445cb69f096ff0e383c62e16062ee",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Pet\"]\n    items = {\n        \"Beverage\": [\"coffee\", \"hot-chocolate\", \"fanta\"],\n        \"Pet\": [\"rat\", \"rabbit\", \"horse\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who has rat as a pet is adjacent to the person who likes hot-chocolate\n    problem.addConstraint(lambda rat_pos, hc_pos: abs(rat_pos - hc_pos) == 1,\n                          [\"Pet:rat\", \"Beverage:hot-chocolate\"])\n    \n    # Clue 2: the person who likes hot-chocolate is to the right of the person who likes coffee\n    problem.addConstraint(lambda coffee_pos, hc_pos: coffee_pos < hc_pos,\n                          [\"Beverage:coffee\", \"Beverage:hot-chocolate\"])\n    \n    # Clue 3: the person who has rabbit as a pet is directly between the person who has horse as a pet and the person who likes coffee\n    # That means rabbit_pos is between horse_pos and coffee_pos, and adjacent to both\n    # So rabbit_pos == horse_pos + 1 and rabbit_pos == coffee_pos - 1\n    # or rabbit_pos == horse_pos - 1 and rabbit_pos == coffee_pos + 1\n    problem.addConstraint(lambda rabbit_pos, horse_pos, coffee_pos:\n                          (rabbit_pos == horse_pos + 1 and rabbit_pos == coffee_pos - 1) or\n                          (rabbit_pos == horse_pos - 1 and rabbit_pos == coffee_pos + 1),\n                          [\"Pet:rabbit\", \"Pet:horse\", \"Beverage:coffee\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['coffee', 'hot-chocolate', 'fanta'], 'Pet': ['rat', 'rabbit', 'horse']}\n",
      "success": true,
      "execution_time": 0.002765,
      "timestamp": "20250918_085147",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['coffee', 'hot-chocolate', 'fanta'], 'Pet': ['rat', 'rabbit', 'horse']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_56",
      "puzzle": {
        "id": "simple_2x3_56",
        "title": "Einstein Puzzle simple_2x3_56 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004925583000000011
        },
        "clues": [
          "the person who likes juice is to the right of the person who likes crime movies (not necessarily immediately)",
          "the person who likes scientific movies is immediately to the right of the person who likes juice",
          "the person who likes western movies is to the left of the person who likes coffee (not necessarily immediately)"
        ],
        "categories": [
          "Beverage",
          "Movie"
        ],
        "items": {
          "Beverage": [
            "milk",
            "juice",
            "coffee"
          ],
          "Movie": [
            "crime",
            "western",
            "scientific"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"milk\", \"juice\", \"coffee\"], \"Movie\": [\"crime\", \"western\", \"scientific\"]}"
      },
      "puzzle_hash": "e25fbcd1e1de19ac87ef65c73bb8607d",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Movie\"]\n    items = {\n        \"Beverage\": [\"milk\", \"juice\", \"coffee\"],\n        \"Movie\": [\"crime\", \"western\", \"scientific\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes juice is to the right of the person who likes crime movies (not necessarily immediately)\n    problem.addConstraint(lambda juice, crime: juice > crime, [\"Beverage:juice\", \"Movie:crime\"])\n    \n    # Clue 2: the person who likes scientific movies is immediately to the right of the person who likes juice\n    problem.addConstraint(lambda scientific, juice: scientific == juice + 1, [\"Movie:scientific\", \"Beverage:juice\"])\n    \n    # Clue 3: the person who likes western movies is to the left of the person who likes coffee (not necessarily immediately)\n    problem.addConstraint(lambda western, coffee: western < coffee, [\"Movie:western\", \"Beverage:coffee\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['milk', 'juice', 'coffee'], 'Movie': ['crime', 'western', 'scientific']}\n",
      "success": true,
      "execution_time": 0.001373,
      "timestamp": "20250918_085154",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['milk', 'juice', 'coffee'], 'Movie': ['crime', 'western', 'scientific']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_57",
      "puzzle": {
        "id": "simple_2x3_57",
        "title": "Einstein Puzzle simple_2x3_57 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.008336999999999983
        },
        "clues": [
          "the person who has hamster as a pet is a different person than the person who likes corn",
          "the person who likes asparagus is to the right of the person who likes corn (not necessarily immediately)",
          "the person who has rat as a pet is to the right of the person who likes corn (not necessarily immediately)",
          "the person who likes asparagus is at an end position (either leftmost or rightmost)",
          "the person who has lizard as a pet is adjacent to the person who likes asparagus (either immediately left or right)"
        ],
        "categories": [
          "Food",
          "Pet"
        ],
        "items": {
          "Food": [
            "raspberry",
            "corn",
            "asparagus"
          ],
          "Pet": [
            "hamster",
            "lizard",
            "rat"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"raspberry\", \"corn\", \"asparagus\"], \"Pet\": [\"hamster\", \"lizard\", \"rat\"]}"
      },
      "puzzle_hash": "64b66638596cf11d12845d8cd0303534",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Food\", \"Pet\"]\n    items = {\n        \"Food\": [\"raspberry\", \"corn\", \"asparagus\"],\n        \"Pet\": [\"hamster\", \"lizard\", \"rat\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who has hamster as a pet is a different person than the person who likes corn\n    problem.addConstraint(lambda hamster_pos, corn_pos: hamster_pos != corn_pos,\n                          [\"Pet:hamster\", \"Food:corn\"])\n    \n    # Clue 2: the person who likes asparagus is to the right of the person who likes corn (not necessarily immediately)\n    problem.addConstraint(lambda asparagus_pos, corn_pos: asparagus_pos > corn_pos,\n                          [\"Food:asparagus\", \"Food:corn\"])\n    \n    # Clue 3: the person who has rat as a pet is to the right of the person who likes corn (not necessarily immediately)\n    problem.addConstraint(lambda rat_pos, corn_pos: rat_pos > corn_pos,\n                          [\"Pet:rat\", \"Food:corn\"])\n    \n    # Clue 4: the person who likes asparagus is at an end position (either leftmost or rightmost)\n    problem.addConstraint(lambda asparagus_pos: asparagus_pos == 0 or asparagus_pos == num_positions - 1,\n                          [\"Food:asparagus\"])\n    \n    # Clue 5: the person who has lizard as a pet is adjacent to the person who likes asparagus (either immediately left or right)\n    problem.addConstraint(lambda lizard_pos, asparagus_pos: abs(lizard_pos - asparagus_pos) == 1,\n                          [\"Pet:lizard\", \"Food:asparagus\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['raspberry', 'corn', 'asparagus'], 'Pet': ['hamster', 'lizard', 'rat']}\n",
      "success": true,
      "execution_time": 0.002818,
      "timestamp": "20250918_085203",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['raspberry', 'corn', 'asparagus'], 'Pet': ['hamster', 'lizard', 'rat']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_58",
      "puzzle": {
        "id": "simple_2x3_58",
        "title": "Einstein Puzzle simple_2x3_58 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006215874999999982
        },
        "clues": [
          "the person who likes cabbage is at the same position as or to the right of the person who plays snowboarding",
          "the person who plays handball is immediately to the right of the person who plays rugby",
          "the person who likes broccoli is adjacent to the person who likes cabbage (either immediately left or right)",
          "the person who plays handball is at an even-numbered position"
        ],
        "categories": [
          "Food",
          "Sport"
        ],
        "items": {
          "Food": [
            "grapefruit",
            "broccoli",
            "cabbage"
          ],
          "Sport": [
            "rugby",
            "handball",
            "snowboarding"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"grapefruit\", \"broccoli\", \"cabbage\"], \"Sport\": [\"rugby\", \"handball\", \"snowboarding\"]}"
      },
      "puzzle_hash": "e26617f633b77fb8a92f11180aa30f06",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Food\", \"Sport\"]\n    items = {\n        \"Food\": [\"grapefruit\", \"broccoli\", \"cabbage\"],\n        \"Sport\": [\"rugby\", \"handball\", \"snowboarding\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes cabbage is at the same position as or to the right of the person who plays snowboarding\n    problem.addConstraint(lambda cabbage_pos, snowboarding_pos: cabbage_pos >= snowboarding_pos,\n                          [\"Food:cabbage\", \"Sport:snowboarding\"])\n    \n    # Clue 2: the person who plays handball is immediately to the right of the person who plays rugby\n    problem.addConstraint(lambda handball_pos, rugby_pos: handball_pos == rugby_pos + 1,\n                          [\"Sport:handball\", \"Sport:rugby\"])\n    \n    # Clue 3: the person who likes broccoli is adjacent to the person who likes cabbage (either immediately left or right)\n    problem.addConstraint(lambda broccoli_pos, cabbage_pos: abs(broccoli_pos - cabbage_pos) == 1,\n                          [\"Food:broccoli\", \"Food:cabbage\"])\n    \n    # Clue 4: the person who plays handball is at an even-numbered position\n    problem.addConstraint(lambda handball_pos: handball_pos % 2 == 0,\n                          [\"Sport:handball\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "",
      "success": false,
      "execution_time": 0.025072,
      "timestamp": "20250918_085217",
      "verification": {
        "verified": true,
        "is_correct": false,
        "ground_truth": "{'Food': ['grapefruit', 'broccoli', 'cabbage'], 'Sport': ['rugby', 'handball', 'snowboarding']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_59",
      "puzzle": {
        "id": "simple_2x3_59",
        "title": "Einstein Puzzle simple_2x3_59 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003959917000000035
        },
        "clues": [
          "the person who works as a lawyer is to the right of the person who likes adventure movies (not necessarily immediately)",
          "the person who works as a firefighter is directly between the person who works as a teacher and the person who likes family movies",
          "the person who likes mystery movies is immediately to the left of the person who likes adventure movies"
        ],
        "categories": [
          "Job",
          "Movie"
        ],
        "items": {
          "Job": [
            "teacher",
            "firefighter",
            "lawyer"
          ],
          "Movie": [
            "mystery",
            "adventure",
            "family"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"teacher\", \"firefighter\", \"lawyer\"], \"Movie\": [\"mystery\", \"adventure\", \"family\"]}"
      },
      "puzzle_hash": "85dd7dc47a1c6d465b6445a58aeadddd",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Job\", \"Movie\"]\n    items = {\n        \"Job\": [\"teacher\", \"firefighter\", \"lawyer\"],\n        \"Movie\": [\"mystery\", \"adventure\", \"family\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who works as a lawyer is to the right of the person who likes adventure movies (not necessarily immediately)\n    problem.addConstraint(lambda lawyer, adventure: lawyer > adventure, [\"Job:lawyer\", \"Movie:adventure\"])\n    \n    # Clue 2: the person who works as a firefighter is directly between the person who works as a teacher and the person who likes family movies\n    # That means firefighter position is one more than teacher and one less than family, or one less than teacher and one more than family\n    problem.addConstraint(lambda firefighter, teacher, family: (firefighter == teacher + 1 and firefighter == family - 1) or (firefighter == teacher - 1 and firefighter == family + 1), [\"Job:firefighter\", \"Job:teacher\", \"Movie:family\"])\n    \n    # Clue 3: the person who likes mystery movies is immediately to the left of the person who likes adventure movies\n    problem.addConstraint(lambda mystery, adventure: mystery == adventure - 1, [\"Movie:mystery\", \"Movie:adventure\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['teacher', 'firefighter', 'lawyer'], 'Movie': ['mystery', 'adventure', 'family']}\n",
      "success": true,
      "execution_time": 0.00273,
      "timestamp": "20250918_085225",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['teacher', 'firefighter', 'lawyer'], 'Movie': ['mystery', 'adventure', 'family']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_60",
      "puzzle": {
        "id": "simple_2x3_60",
        "title": "Einstein Puzzle simple_2x3_60 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004513458000000026
        },
        "clues": [
          "the person who uses subway for transportation is to the left of the person who likes watermelon (not necessarily immediately)",
          "the person who uses helicopter for transportation is at position 3(the rightmost position)",
          "the person who likes lime is at position 3(the rightmost position)"
        ],
        "categories": [
          "Food",
          "Transport"
        ],
        "items": {
          "Food": [
            "peach",
            "watermelon",
            "lime"
          ],
          "Transport": [
            "subway",
            "quad-bike",
            "helicopter"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"peach\", \"watermelon\", \"lime\"], \"Transport\": [\"subway\", \"quad-bike\", \"helicopter\"]}"
      },
      "puzzle_hash": "748fd50134b45a4e264a8992991f134f",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Transport\"]\n    items = {\n        \"Food\": [\"peach\", \"watermelon\", \"lime\"],\n        \"Transport\": [\"subway\", \"quad-bike\", \"helicopter\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: subway is to the left of watermelon (not necessarily immediately)\n    problem.addConstraint(lambda subway_pos, watermelon_pos: subway_pos < watermelon_pos,\n                          [\"Transport:subway\", \"Food:watermelon\"])\n    \n    # Clue 2: helicopter is at position 3 (rightmost, index 2)\n    problem.addConstraint(lambda helicopter_pos: helicopter_pos == 2, [\"Transport:helicopter\"])\n    \n    # Clue 3: lime is at position 3 (rightmost, index 2)\n    problem.addConstraint(lambda lime_pos: lime_pos == 2, [\"Food:lime\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['peach', 'watermelon', 'lime'], 'Transport': ['subway', 'quad-bike', 'helicopter']}\n",
      "success": true,
      "execution_time": 0.002917,
      "timestamp": "20250918_085230",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['peach', 'watermelon', 'lime'], 'Transport': ['subway', 'quad-bike', 'helicopter']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_61",
      "puzzle": {
        "id": "simple_2x3_61",
        "title": "Einstein Puzzle simple_2x3_61 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004088207999999982
        },
        "clues": [
          "the person who has bird as a pet is somewhere between the person who has ferret as a pet and the polish person (not necessarily immediately adjacent)",
          "the dutch person and the person who has ferret as a pet are at positions with different parity (one at odd, one at even position)",
          "the person who has chinchilla as a pet is at position 3(the rightmost position)"
        ],
        "categories": [
          "Nationality",
          "Pet"
        ],
        "items": {
          "Nationality": [
            "australian",
            "dutch",
            "polish"
          ],
          "Pet": [
            "ferret",
            "bird",
            "chinchilla"
          ]
        },
        "ground_truth_solution": "{\"Nationality\": [\"australian\", \"dutch\", \"polish\"], \"Pet\": [\"ferret\", \"bird\", \"chinchilla\"]}"
      },
      "puzzle_hash": "452f1c3e27fa9c1f20c57982caf54758",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Nationality\", \"Pet\"]\n    items = {\n        \"Nationality\": [\"australian\", \"dutch\", \"polish\"],\n        \"Pet\": [\"ferret\", \"bird\", \"chinchilla\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who has bird as a pet is somewhere between the person who has ferret as a pet and the polish person (not necessarily immediately adjacent)\n    # That means bird position is strictly between ferret and polish positions\n    problem.addConstraint(\n        lambda bird, ferret, polish: (ferret < bird < polish) or (polish < bird < ferret),\n        [\"Pet:bird\", \"Pet:ferret\", \"Nationality:polish\"]\n    )\n    \n    # Clue 2: the dutch person and the person who has ferret as a pet are at positions with different parity (one at odd, one at even position)\n    problem.addConstraint(\n        lambda dutch, ferret: (dutch % 2) != (ferret % 2),\n        [\"Nationality:dutch\", \"Pet:ferret\"]\n    )\n    \n    # Clue 3: the person who has chinchilla as a pet is at position 3 (the rightmost position)\n    # Positions are 0-indexed, so position 3 is index 2\n    problem.addConstraint(\n        lambda chinchilla: chinchilla == 2,\n        [\"Pet:chinchilla\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['australian', 'dutch', 'polish'], 'Pet': ['ferret', 'bird', 'chinchilla']}\n",
      "success": true,
      "execution_time": 0.00335,
      "timestamp": "20250918_085239",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['australian', 'dutch', 'polish'], 'Pet': ['ferret', 'bird', 'chinchilla']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_62",
      "puzzle": {
        "id": "simple_2x3_62",
        "title": "Einstein Puzzle simple_2x3_62 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0032298330000000153
        },
        "clues": [
          "the person who likes coffee is immediately to the left of the person who plays tennis",
          "the person who likes sprite is to the left of the person who likes coffee (not necessarily immediately)",
          "the person who plays tennis is adjacent to the person who plays surfing (either immediately left or right)"
        ],
        "categories": [
          "Beverage",
          "Sport"
        ],
        "items": {
          "Beverage": [
            "sprite",
            "coffee",
            "cola"
          ],
          "Sport": [
            "skateboarding",
            "surfing",
            "tennis"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"sprite\", \"coffee\", \"cola\"], \"Sport\": [\"skateboarding\", \"surfing\", \"tennis\"]}"
      },
      "puzzle_hash": "34bf18cbd7070e4a9a43e85f579ab3d2",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Sport\"]\n    items = {\n        \"Beverage\": [\"sprite\", \"coffee\", \"cola\"],\n        \"Sport\": [\"skateboarding\", \"surfing\", \"tennis\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes coffee is immediately to the left of the person who plays tennis\n    problem.addConstraint(lambda coffee, tennis: coffee == tennis - 1, [\"Beverage:coffee\", \"Sport:tennis\"])\n    \n    # Clue 2: the person who likes sprite is to the left of the person who likes coffee (not necessarily immediately)\n    problem.addConstraint(lambda sprite, coffee: sprite < coffee, [\"Beverage:sprite\", \"Beverage:coffee\"])\n    \n    # Clue 3: the person who plays tennis is adjacent to the person who plays surfing (either immediately left or right)\n    problem.addConstraint(lambda tennis, surfing: abs(tennis - surfing) == 1, [\"Sport:tennis\", \"Sport:surfing\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['sprite', 'coffee', 'cola'], 'Sport': ['skateboarding', 'surfing', 'tennis']}\n",
      "success": true,
      "execution_time": 0.00258,
      "timestamp": "20250918_085245",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['sprite', 'coffee', 'cola'], 'Sport': ['skateboarding', 'surfing', 'tennis']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_63",
      "puzzle": {
        "id": "simple_2x3_63",
        "title": "Einstein Puzzle simple_2x3_63 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0042694589999999755
        },
        "clues": [
          "the person who plays biathlon is immediately to the right of the person who works as a photographer",
          "the person who plays handball is to the left of the person who works as a paramedic (not necessarily immediately)",
          "the person who works as a paramedic is immediately to the right of the person who plays biathlon"
        ],
        "categories": [
          "Job",
          "Sport"
        ],
        "items": {
          "Job": [
            "photographer",
            "engineer",
            "paramedic"
          ],
          "Sport": [
            "handball",
            "biathlon",
            "tennis"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"photographer\", \"engineer\", \"paramedic\"], \"Sport\": [\"handball\", \"biathlon\", \"tennis\"]}"
      },
      "puzzle_hash": "af2a37e6ee069f7ac075a81dce454aae",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Sport\"]\n    items = {\n        \"Job\": [\"photographer\", \"engineer\", \"paramedic\"],\n        \"Sport\": [\"handball\", \"biathlon\", \"tennis\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays biathlon is immediately to the right of the person who works as a photographer\n    problem.addConstraint(lambda biathlon, photographer: biathlon == photographer + 1,\n                          [\"Sport:biathlon\", \"Job:photographer\"])\n    \n    # Clue 2: the person who plays handball is to the left of the person who works as a paramedic (not necessarily immediately)\n    problem.addConstraint(lambda handball, paramedic: handball < paramedic,\n                          [\"Sport:handball\", \"Job:paramedic\"])\n    \n    # Clue 3: the person who works as a paramedic is immediately to the right of the person who plays biathlon\n    problem.addConstraint(lambda paramedic, biathlon: paramedic == biathlon + 1,\n                          [\"Job:paramedic\", \"Sport:biathlon\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['photographer', 'engineer', 'paramedic'], 'Sport': ['handball', 'biathlon', 'tennis']}\n",
      "success": true,
      "execution_time": 0.002877,
      "timestamp": "20250918_085254",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['photographer', 'engineer', 'paramedic'], 'Sport': ['handball', 'biathlon', 'tennis']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_64",
      "puzzle": {
        "id": "simple_2x3_64",
        "title": "Einstein Puzzle simple_2x3_64 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006195457999999987
        },
        "clues": [
          "the person who plays badminton is adjacent to the person who works as a scientist (either immediately left or right)",
          "the person who works as a teacher is to the left of the person who works as a scientist (not necessarily immediately)",
          "the person who works as a teacher is immediately to the right of the person who plays cycling"
        ],
        "categories": [
          "Job",
          "Sport"
        ],
        "items": {
          "Job": [
            "manager",
            "teacher",
            "scientist"
          ],
          "Sport": [
            "cycling",
            "badminton",
            "basketball"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"manager\", \"teacher\", \"scientist\"], \"Sport\": [\"cycling\", \"badminton\", \"basketball\"]}"
      },
      "puzzle_hash": "b69436e91ae9ee33d23e36d6534ea510",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Sport\"]\n    items = {\n        \"Job\": [\"manager\", \"teacher\", \"scientist\"],\n        \"Sport\": [\"cycling\", \"badminton\", \"basketball\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays badminton is adjacent to the person who works as a scientist\n    problem.addConstraint(lambda badminton, scientist: abs(badminton - scientist) == 1,\n                          [\"Sport:badminton\", \"Job:scientist\"])\n    \n    # Clue 2: the person who works as a teacher is to the left of the person who works as a scientist (not necessarily immediately)\n    problem.addConstraint(lambda teacher, scientist: teacher < scientist,\n                          [\"Job:teacher\", \"Job:scientist\"])\n    \n    # Clue 3: the person who works as a teacher is immediately to the right of the person who plays cycling\n    problem.addConstraint(lambda cycling, teacher: teacher == cycling + 1,\n                          [\"Sport:cycling\", \"Job:teacher\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['manager', 'teacher', 'scientist'], 'Sport': ['cycling', 'badminton', 'basketball']}\n",
      "success": true,
      "execution_time": 0.002792,
      "timestamp": "20250918_085301",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['manager', 'teacher', 'scientist'], 'Sport': ['cycling', 'badminton', 'basketball']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_65",
      "puzzle": {
        "id": "simple_2x3_65",
        "title": "Einstein Puzzle simple_2x3_65 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00498420799999999
        },
        "clues": [
          "the person who likes milk is somewhere between the person who likes time-travel movies and the person who likes sports movies (not necessarily immediately adjacent)",
          "the person who likes sports movies is to the right of the person who likes almond-milk (not necessarily immediately)"
        ],
        "categories": [
          "Beverage",
          "Movie"
        ],
        "items": {
          "Beverage": [
            "almond-milk",
            "milk",
            "coffee"
          ],
          "Movie": [
            "time-travel",
            "spy",
            "sports"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"almond-milk\", \"milk\", \"coffee\"], \"Movie\": [\"time-travel\", \"spy\", \"sports\"]}"
      },
      "puzzle_hash": "5d38b5babaa77df1bd6f7717a5809e69",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Movie\"]\n    items = {\n        \"Beverage\": [\"almond-milk\", \"milk\", \"coffee\"],\n        \"Movie\": [\"time-travel\", \"spy\", \"sports\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes milk is somewhere between the person who likes time-travel movies and the person who likes sports movies (not necessarily immediately adjacent)\n    # This means milk position is strictly between time-travel and sports positions\n    def between(milk, time_travel, sports):\n        return (time_travel < milk < sports) or (sports < milk < time_travel)\n    problem.addConstraint(between, [\"Beverage:milk\", \"Movie:time-travel\", \"Movie:sports\"])\n    \n    # Clue 2: the person who likes sports movies is to the right of the person who likes almond-milk (not necessarily immediately)\n    problem.addConstraint(lambda sports, almond_milk: sports > almond_milk, [\"Movie:sports\", \"Beverage:almond-milk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['almond-milk', 'milk', 'coffee'], 'Movie': ['time-travel', 'spy', 'sports']}\n",
      "success": true,
      "execution_time": 0.002942,
      "timestamp": "20250918_085307",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['almond-milk', 'milk', 'coffee'], 'Movie': ['time-travel', 'spy', 'sports']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_66",
      "puzzle": {
        "id": "simple_2x3_66",
        "title": "Einstein Puzzle simple_2x3_66 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005033584000000035
        },
        "clues": [
          "the person who likes ambient music is to the right of the person who uses boat for transportation (not necessarily immediately)",
          "the person who likes dubstep music is adjacent to the person who uses trike for transportation (either immediately left or right)",
          "the person who likes blues music is at position 3(the rightmost position)"
        ],
        "categories": [
          "Music",
          "Transport"
        ],
        "items": {
          "Music": [
            "dubstep",
            "ambient",
            "blues"
          ],
          "Transport": [
            "boat",
            "trike",
            "tram"
          ]
        },
        "ground_truth_solution": "{\"Music\": [\"dubstep\", \"ambient\", \"blues\"], \"Transport\": [\"boat\", \"trike\", \"tram\"]}"
      },
      "puzzle_hash": "fc164635a0ce68fb457aa07375b01da6",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Music\", \"Transport\"]\n    items = {\n        \"Music\": [\"dubstep\", \"ambient\", \"blues\"],\n        \"Transport\": [\"boat\", \"trike\", \"tram\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: ambient music is to the right of boat (not necessarily immediately)\n    problem.addConstraint(lambda ambient_pos, boat_pos: ambient_pos > boat_pos,\n                          [\"Music:ambient\", \"Transport:boat\"])\n    \n    # Clue 2: dubstep music is adjacent to trike (immediately left or right)\n    problem.addConstraint(lambda dubstep_pos, trike_pos: abs(dubstep_pos - trike_pos) == 1,\n                          [\"Music:dubstep\", \"Transport:trike\"])\n    \n    # Clue 3: blues music is at position 3 (rightmost position, index 2)\n    problem.addConstraint(lambda blues_pos: blues_pos == 2, [\"Music:blues\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['dubstep', 'ambient', 'blues'], 'Transport': ['boat', 'trike', 'tram']}\n",
      "success": true,
      "execution_time": 0.002963,
      "timestamp": "20250918_085318",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['dubstep', 'ambient', 'blues'], 'Transport': ['boat', 'trike', 'tram']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_67",
      "puzzle": {
        "id": "simple_2x3_67",
        "title": "Einstein Puzzle simple_2x3_67 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003212875000000004
        },
        "clues": [
          "the malaysian person is to the right of the canadian person (not necessarily immediately)",
          "the canadian person is adjacent to the person who likes water (either immediately left or right)",
          "the nigerian person is at the center position (position 2)",
          "the person who likes 7up is at position 3(the rightmost position)"
        ],
        "categories": [
          "Beverage",
          "Nationality"
        ],
        "items": {
          "Beverage": [
            "cola",
            "water",
            "7up"
          ],
          "Nationality": [
            "canadian",
            "nigerian",
            "malaysian"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"cola\", \"water\", \"7up\"], \"Nationality\": [\"canadian\", \"nigerian\", \"malaysian\"]}"
      },
      "puzzle_hash": "e187b251e8bf9777780ca85b7aa0d43b",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Nationality\"]\n    items = {\n        \"Beverage\": [\"cola\", \"water\", \"7up\"],\n        \"Nationality\": [\"canadian\", \"nigerian\", \"malaysian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the malaysian person is to the right of the canadian person (not necessarily immediately)\n    problem.addConstraint(lambda mal, can: mal > can, [\"Nationality:malaysian\", \"Nationality:canadian\"])\n    \n    # Clue 2: the canadian person is adjacent to the person who likes water (either immediately left or right)\n    problem.addConstraint(lambda can, wat: abs(can - wat) == 1, [\"Nationality:canadian\", \"Beverage:water\"])\n    \n    # Clue 3: the nigerian person is at the center position (position 2 -> index 1)\n    problem.addConstraint(lambda nig: nig == 1, [\"Nationality:nigerian\"])\n    \n    # Clue 4: the person who likes 7up is at position 3 (rightmost position, index 2)\n    problem.addConstraint(lambda sev: sev == 2, [\"Beverage:7up\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['cola', 'water', '7up'], 'Nationality': ['canadian', 'nigerian', 'malaysian']}\n",
      "success": true,
      "execution_time": 0.002837,
      "timestamp": "20250918_085327",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['cola', 'water', '7up'], 'Nationality': ['canadian', 'nigerian', 'malaysian']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_68",
      "puzzle": {
        "id": "simple_2x3_68",
        "title": "Einstein Puzzle simple_2x3_68 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004346792000000044
        },
        "clues": [
          "the person who works as a chef is somewhere between the person who likes reggae music and the person who works as a dressmaker (not necessarily immediately adjacent)",
          "the person who works as a pilot is to the right of the person who works as a dressmaker (not necessarily immediately)",
          "the person who likes metal music and the person who works as a pilot are at positions with the same parity (both at odd or both at even positions)"
        ],
        "categories": [
          "Job",
          "Music"
        ],
        "items": {
          "Job": [
            "dressmaker",
            "chef",
            "pilot"
          ],
          "Music": [
            "metal",
            "hip-hop",
            "reggae"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"dressmaker\", \"chef\", \"pilot\"], \"Music\": [\"metal\", \"hip-hop\", \"reggae\"]}"
      },
      "puzzle_hash": "d31c281eba42055a50b3fd284b028d1c",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Music\"]\n    items = {\n        \"Job\": [\"dressmaker\", \"chef\", \"pilot\"],\n        \"Music\": [\"metal\", \"hip-hop\", \"reggae\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who works as a chef is somewhere between the person who likes reggae music and the person who works as a dressmaker (not necessarily immediately adjacent)\n    problem.addConstraint(\n        lambda chef, reggae, dressmaker: (reggae < chef < dressmaker) or (dressmaker < chef < reggae),\n        [\"Job:chef\", \"Music:reggae\", \"Job:dressmaker\"]\n    )\n    \n    # Clue 2: the person who works as a pilot is to the right of the person who works as a dressmaker (not necessarily immediately)\n    problem.addConstraint(\n        lambda pilot, dressmaker: pilot > dressmaker,\n        [\"Job:pilot\", \"Job:dressmaker\"]\n    )\n    \n    # Clue 3: the person who likes metal music and the person who works as a pilot are at positions with the same parity (both at odd or both at even positions)\n    problem.addConstraint(\n        lambda metal, pilot: metal % 2 == pilot % 2,\n        [\"Music:metal\", \"Job:pilot\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['dressmaker', 'chef', 'pilot'], 'Music': ['metal', 'hip-hop', 'reggae']}\n",
      "success": true,
      "execution_time": 0.002885,
      "timestamp": "20250918_085336",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['dressmaker', 'chef', 'pilot'], 'Music': ['metal', 'hip-hop', 'reggae']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_69",
      "puzzle": {
        "id": "simple_2x3_69",
        "title": "Einstein Puzzle simple_2x3_69 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005504624999999985
        },
        "clues": [
          "the person who likes iced-tea is at position 3(the rightmost position)",
          "the person who enjoys filmmaking is immediately to the left of the person who enjoys chess",
          "the person who enjoys chess is adjacent to the person who likes milk (either immediately left or right)",
          "the person who enjoys board-games and the person who likes milk are at positions with different parity (one at odd, one at even position)"
        ],
        "categories": [
          "Beverage",
          "Hobby"
        ],
        "items": {
          "Beverage": [
            "lemonade",
            "milk",
            "iced-tea"
          ],
          "Hobby": [
            "board-games",
            "filmmaking",
            "chess"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"lemonade\", \"milk\", \"iced-tea\"], \"Hobby\": [\"board-games\", \"filmmaking\", \"chess\"]}"
      },
      "puzzle_hash": "d8a309b6d0fc90e3b7b8afa847b08900",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Hobby\"]\n    items = {\n        \"Beverage\": [\"lemonade\", \"milk\", \"iced-tea\"],\n        \"Hobby\": [\"board-games\", \"filmmaking\", \"chess\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes iced-tea is at position 3 (index 2)\n    problem.addConstraint(lambda x: x == 2, [\"Beverage:iced-tea\"])\n    \n    # Clue 2: the person who enjoys filmmaking is immediately to the left of the person who enjoys chess\n    problem.addConstraint(lambda x, y: x == y - 1, [\"Hobby:filmmaking\", \"Hobby:chess\"])\n    \n    # Clue 3: the person who enjoys chess is adjacent to the person who likes milk\n    problem.addConstraint(lambda x, y: abs(x - y) == 1, [\"Hobby:chess\", \"Beverage:milk\"])\n    \n    # Clue 4: the person who enjoys board-games and the person who likes milk are at positions with different parity\n    problem.addConstraint(lambda x, y: (x % 2) != (y % 2), [\"Hobby:board-games\", \"Beverage:milk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['lemonade', 'milk', 'iced-tea'], 'Hobby': ['board-games', 'filmmaking', 'chess']}\n",
      "success": true,
      "execution_time": 0.002858,
      "timestamp": "20250918_085347",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['lemonade', 'milk', 'iced-tea'], 'Hobby': ['board-games', 'filmmaking', 'chess']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_70",
      "puzzle": {
        "id": "simple_2x3_70",
        "title": "Einstein Puzzle simple_2x3_70 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0029767909999999786
        },
        "clues": [
          "the person who enjoys woodworking is immediately to the right of the person who works as a mechanic",
          "the person who enjoys skydiving is immediately to the right of the person who enjoys woodworking",
          "the person who works as a social-worker is at the same position as or to the right of the person who enjoys skydiving"
        ],
        "categories": [
          "Hobby",
          "Job"
        ],
        "items": {
          "Hobby": [
            "baking",
            "woodworking",
            "skydiving"
          ],
          "Job": [
            "mechanic",
            "journalist",
            "social-worker"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"baking\", \"woodworking\", \"skydiving\"], \"Job\": [\"mechanic\", \"journalist\", \"social-worker\"]}"
      },
      "puzzle_hash": "e4dd8c7f5be56efd8f679424c4f6ee4f",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Hobby\", \"Job\"]\n    items = {\n        \"Hobby\": [\"baking\", \"woodworking\", \"skydiving\"],\n        \"Job\": [\"mechanic\", \"journalist\", \"social-worker\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: woodworking is immediately to the right of mechanic\n    problem.addConstraint(lambda w, m: w == m + 1, [\"Hobby:woodworking\", \"Job:mechanic\"])\n    # Clue 2: skydiving is immediately to the right of woodworking\n    problem.addConstraint(lambda s, w: s == w + 1, [\"Hobby:skydiving\", \"Hobby:woodworking\"])\n    # Clue 3: social-worker is at the same position as or to the right of skydiving\n    problem.addConstraint(lambda sw, s: sw >= s, [\"Job:social-worker\", \"Hobby:skydiving\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['baking', 'woodworking', 'skydiving'], 'Job': ['mechanic', 'journalist', 'social-worker']}\n",
      "success": true,
      "execution_time": 0.002573,
      "timestamp": "20250918_085355",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['baking', 'woodworking', 'skydiving'], 'Job': ['mechanic', 'journalist', 'social-worker']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_71",
      "puzzle": {
        "id": "simple_2x3_71",
        "title": "Einstein Puzzle simple_2x3_71 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.007828583
        },
        "clues": [
          "the person who likes tea is to the right of the person who likes mirinda (not necessarily immediately)",
          "the person who likes 7up is at position 3(the rightmost position)",
          "the person who likes 7up is the same person as the person who likes house music",
          "the person who likes r&b music and the person who likes mirinda are at positions with different parity (one at odd, one at even position)"
        ],
        "categories": [
          "Beverage",
          "Music"
        ],
        "items": {
          "Beverage": [
            "mirinda",
            "tea",
            "7up"
          ],
          "Music": [
            "electronic",
            "r&b",
            "house"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"mirinda\", \"tea\", \"7up\"], \"Music\": [\"electronic\", \"r&b\", \"house\"]}"
      },
      "puzzle_hash": "6499a7c09e4521bc95f78f0ec24fb322",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Music\"]\n    items = {\n        \"Beverage\": [\"mirinda\", \"tea\", \"7up\"],\n        \"Music\": [\"electronic\", \"r&b\", \"house\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes tea is to the right of the person who likes mirinda (not necessarily immediately)\n    problem.addConstraint(lambda tea, mirinda: tea > mirinda, [\"Beverage:tea\", \"Beverage:mirinda\"])\n    \n    # Clue 2: the person who likes 7up is at position 3 (rightmost position, zero-indexed 2)\n    problem.addConstraint(lambda sevenup: sevenup == 2, [\"Beverage:7up\"])\n    \n    # Clue 3: the person who likes 7up is the same person as the person who likes house music\n    problem.addConstraint(lambda sevenup, house: sevenup == house, [\"Beverage:7up\", \"Music:house\"])\n    \n    # Clue 4: the person who likes r&b music and the person who likes mirinda are at positions with different parity\n    problem.addConstraint(lambda rnb, mirinda: (rnb % 2) != (mirinda % 2), [\"Music:r&b\", \"Beverage:mirinda\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['mirinda', 'tea', '7up'], 'Music': ['electronic', 'r&b', 'house']}\n",
      "success": true,
      "execution_time": 0.002618,
      "timestamp": "20250918_085404",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['mirinda', 'tea', '7up'], 'Music': ['electronic', 'r&b', 'house']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_72",
      "puzzle": {
        "id": "simple_2x3_72",
        "title": "Einstein Puzzle simple_2x3_72 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.007535707999999974
        },
        "clues": [
          "the person who likes milk is at the same position as or to the left of the chinese person",
          "the japanese person is to the right of the chinese person (not necessarily immediately)",
          "the russian person is immediately to the right of the person who likes mirinda"
        ],
        "categories": [
          "Beverage",
          "Nationality"
        ],
        "items": {
          "Beverage": [
            "milk",
            "mirinda",
            "sprite"
          ],
          "Nationality": [
            "chinese",
            "japanese",
            "russian"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"milk\", \"mirinda\", \"sprite\"], \"Nationality\": [\"chinese\", \"japanese\", \"russian\"]}"
      },
      "puzzle_hash": "ae086bc1c55eea7c00418ee82e1de91a",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Nationality\"]\n    items = {\n        \"Beverage\": [\"milk\", \"mirinda\", \"sprite\"],\n        \"Nationality\": [\"chinese\", \"japanese\", \"russian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes milk is at the same position as or to the left of the chinese person\n    problem.addConstraint(lambda milk_pos, chinese_pos: milk_pos <= chinese_pos,\n                          [\"Beverage:milk\", \"Nationality:chinese\"])\n    \n    # Clue 2: the japanese person is to the right of the chinese person (not necessarily immediately)\n    problem.addConstraint(lambda chinese_pos, japanese_pos: chinese_pos < japanese_pos,\n                          [\"Nationality:chinese\", \"Nationality:japanese\"])\n    \n    # Clue 3: the russian person is immediately to the right of the person who likes mirinda\n    problem.addConstraint(lambda mirinda_pos, russian_pos: mirinda_pos == russian_pos - 1,\n                          [\"Beverage:mirinda\", \"Nationality:russian\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['milk', 'mirinda', 'sprite'], 'Nationality': ['chinese', 'japanese', 'russian']}\n",
      "success": true,
      "execution_time": 0.002868,
      "timestamp": "20250918_085417",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['milk', 'mirinda', 'sprite'], 'Nationality': ['chinese', 'japanese', 'russian']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_73",
      "puzzle": {
        "id": "simple_2x3_73",
        "title": "Einstein Puzzle simple_2x3_73 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00724029100000001
        },
        "clues": [
          "the person who uses ship for transportation and the person who works as a scientist are at positions with different parity (one at odd, one at even position)",
          "the person who works as a security-guard is to the left of the person who works as a pilot (not necessarily immediately)",
          "the person who uses boat for transportation is to the left of the person who works as a security-guard (not necessarily immediately)"
        ],
        "categories": [
          "Job",
          "Transport"
        ],
        "items": {
          "Job": [
            "scientist",
            "security-guard",
            "pilot"
          ],
          "Transport": [
            "boat",
            "ship",
            "car"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"scientist\", \"security-guard\", \"pilot\"], \"Transport\": [\"boat\", \"ship\", \"car\"]}"
      },
      "puzzle_hash": "c332dbb59145b995db5f9c68bbfa401c",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Transport\"]\n    items = {\n        \"Job\": [\"scientist\", \"security-guard\", \"pilot\"],\n        \"Transport\": [\"boat\", \"ship\", \"car\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: ship and scientist are at positions with different parity\n    problem.addConstraint(\n        lambda ship_pos, scientist_pos: (ship_pos % 2) != (scientist_pos % 2),\n        [\"Transport:ship\", \"Job:scientist\"]\n    )\n    \n    # Clue 2: security-guard is to the left of pilot (not necessarily immediately)\n    problem.addConstraint(\n        lambda sg_pos, pilot_pos: sg_pos < pilot_pos,\n        [\"Job:security-guard\", \"Job:pilot\"]\n    )\n    \n    # Clue 3: boat is to the left of security-guard (not necessarily immediately)\n    problem.addConstraint(\n        lambda boat_pos, sg_pos: boat_pos < sg_pos,\n        [\"Transport:boat\", \"Job:security-guard\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['scientist', 'security-guard', 'pilot'], 'Transport': ['boat', 'ship', 'car']}\n",
      "success": true,
      "execution_time": 0.002647,
      "timestamp": "20250918_085426",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['scientist', 'security-guard', 'pilot'], 'Transport': ['boat', 'ship', 'car']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_74",
      "puzzle": {
        "id": "simple_2x3_74",
        "title": "Einstein Puzzle simple_2x3_74 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00384391700000003
        },
        "clues": [
          "the person who likes cucumber is adjacent to the person who likes zombie movies (either immediately left or right)",
          "the person who likes family movies is at the same position as or to the right of the person who likes cucumber",
          "the person who likes animation movies is at the center position (position 2)",
          "the person who likes cucumber is at the same position as or to the right of the person who likes peach"
        ],
        "categories": [
          "Food",
          "Movie"
        ],
        "items": {
          "Food": [
            "peach",
            "cucumber",
            "kiwi"
          ],
          "Movie": [
            "zombie",
            "animation",
            "family"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"peach\", \"cucumber\", \"kiwi\"], \"Movie\": [\"zombie\", \"animation\", \"family\"]}"
      },
      "puzzle_hash": "21d7065f50b107d02cec8778244eb5dd",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Movie\"]\n    items = {\n        \"Food\": [\"peach\", \"cucumber\", \"kiwi\"],\n        \"Movie\": [\"zombie\", \"animation\", \"family\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: cucumber adjacent to zombie\n    problem.addConstraint(lambda c, z: abs(c - z) == 1, [\"Food:cucumber\", \"Movie:zombie\"])\n    \n    # Clue 2: family at same position or to the right of cucumber\n    problem.addConstraint(lambda f, c: f >= c, [\"Movie:family\", \"Food:cucumber\"])\n    \n    # Clue 3: animation at center position (position 2 -> index 1)\n    problem.addConstraint(lambda a: a == 1, [\"Movie:animation\"])\n    \n    # Clue 4: cucumber at same position or to the right of peach\n    problem.addConstraint(lambda c, p: c >= p, [\"Food:cucumber\", \"Food:peach\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['peach', 'cucumber', 'kiwi'], 'Movie': ['zombie', 'animation', 'family']}\n",
      "success": true,
      "execution_time": 0.002506,
      "timestamp": "20250918_085431",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['peach', 'cucumber', 'kiwi'], 'Movie': ['zombie', 'animation', 'family']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_75",
      "puzzle": {
        "id": "simple_2x3_75",
        "title": "Einstein Puzzle simple_2x3_75 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004314040999999991
        },
        "clues": [
          "the person who plays water-polo is at position 3(the rightmost position)",
          "the person who likes disco music is immediately to the left of the person who plays golf",
          "the person who likes rock music is to the right of the person who likes dubstep music (not necessarily immediately)"
        ],
        "categories": [
          "Music",
          "Sport"
        ],
        "items": {
          "Music": [
            "disco",
            "dubstep",
            "rock"
          ],
          "Sport": [
            "sailing",
            "golf",
            "water-polo"
          ]
        },
        "ground_truth_solution": "{\"Music\": [\"disco\", \"dubstep\", \"rock\"], \"Sport\": [\"sailing\", \"golf\", \"water-polo\"]}"
      },
      "puzzle_hash": "1789495042d015b9309e3ed4b0f13b49",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Music\", \"Sport\"]\n    items = {\n        \"Music\": [\"disco\", \"dubstep\", \"rock\"],\n        \"Sport\": [\"sailing\", \"golf\", \"water-polo\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays water-polo is at position 3 (index 2)\n    problem.addConstraint(lambda x: x == 2, [\"Sport:water-polo\"])\n    \n    # Clue 2: the person who likes disco music is immediately to the left of the person who plays golf\n    problem.addConstraint(lambda disco, golf: disco == golf - 1, [\"Music:disco\", \"Sport:golf\"])\n    \n    # Clue 3: the person who likes rock music is to the right of the person who likes dubstep music (not necessarily immediately)\n    problem.addConstraint(lambda dubstep, rock: dubstep < rock, [\"Music:dubstep\", \"Music:rock\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['disco', 'dubstep', 'rock'], 'Sport': ['sailing', 'golf', 'water-polo']}\n",
      "success": true,
      "execution_time": 0.002919,
      "timestamp": "20250918_085438",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['disco', 'dubstep', 'rock'], 'Sport': ['sailing', 'golf', 'water-polo']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_76",
      "puzzle": {
        "id": "simple_2x3_76",
        "title": "Einstein Puzzle simple_2x3_76 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00435554199999999
        },
        "clues": [
          "the person who likes house music is at the same position as or to the left of the person who likes ambient music",
          "the person who likes house music is to the right of the thai person (not necessarily immediately)",
          "the indonesian person is to the left of the turkish person (not necessarily immediately)"
        ],
        "categories": [
          "Music",
          "Nationality"
        ],
        "items": {
          "Music": [
            "soul",
            "house",
            "ambient"
          ],
          "Nationality": [
            "thai",
            "indonesian",
            "turkish"
          ]
        },
        "ground_truth_solution": "{\"Music\": [\"soul\", \"house\", \"ambient\"], \"Nationality\": [\"thai\", \"indonesian\", \"turkish\"]}"
      },
      "puzzle_hash": "62a201e26e681318c6ed5d6bb5c25249",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Music\", \"Nationality\"]\n    items = {\n        \"Music\": [\"soul\", \"house\", \"ambient\"],\n        \"Nationality\": [\"thai\", \"indonesian\", \"turkish\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes house music is at the same position as or to the left of the person who likes ambient music\n    problem.addConstraint(lambda house_pos, ambient_pos: house_pos <= ambient_pos,\n                          [\"Music:house\", \"Music:ambient\"])\n    \n    # Clue 2: the person who likes house music is to the right of the thai person (not necessarily immediately)\n    problem.addConstraint(lambda house_pos, thai_pos: house_pos > thai_pos,\n                          [\"Music:house\", \"Nationality:thai\"])\n    \n    # Clue 3: the indonesian person is to the left of the turkish person (not necessarily immediately)\n    problem.addConstraint(lambda indo_pos, turk_pos: indo_pos < turk_pos,\n                          [\"Nationality:indonesian\", \"Nationality:turkish\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['soul', 'house', 'ambient'], 'Nationality': ['thai', 'indonesian', 'turkish']}\n",
      "success": true,
      "execution_time": 0.002793,
      "timestamp": "20250918_085446",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['soul', 'house', 'ambient'], 'Nationality': ['thai', 'indonesian', 'turkish']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_77",
      "puzzle": {
        "id": "simple_2x3_77",
        "title": "Einstein Puzzle simple_2x3_77 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00750466700000002
        },
        "clues": [
          "the person who has hedgehog as a pet is to the right of the person who has turtle as a pet (not necessarily immediately)",
          "the person who has rat as a pet is immediately to the right of the person who likes pear",
          "the person who likes pear is somewhere between the person who likes zucchini and the person who likes pineapple (not necessarily immediately adjacent)",
          "the person who likes zucchini is to the right of the person who has turtle as a pet (not necessarily immediately)"
        ],
        "categories": [
          "Food",
          "Pet"
        ],
        "items": {
          "Food": [
            "pineapple",
            "pear",
            "zucchini"
          ],
          "Pet": [
            "turtle",
            "hedgehog",
            "rat"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"pineapple\", \"pear\", \"zucchini\"], \"Pet\": [\"turtle\", \"hedgehog\", \"rat\"]}"
      },
      "puzzle_hash": "6be77f4500846a70f88c47558e998e62",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Pet\"]\n    items = {\n        \"Food\": [\"pineapple\", \"pear\", \"zucchini\"],\n        \"Pet\": [\"turtle\", \"hedgehog\", \"rat\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: hedgehog is to the right of turtle (not necessarily immediately)\n    problem.addConstraint(lambda hedgehog, turtle: hedgehog > turtle,\n                          [\"Pet:hedgehog\", \"Pet:turtle\"])\n    \n    # Clue 2: rat is immediately to the right of pear\n    problem.addConstraint(lambda rat, pear: rat == pear + 1,\n                          [\"Pet:rat\", \"Food:pear\"])\n    \n    # Clue 3: pear is somewhere between zucchini and pineapple (not necessarily immediately)\n    # means pear position is strictly between zucchini and pineapple positions\n    def between(pear, zucchini, pineapple):\n        return (zucchini < pear < pineapple) or (pineapple < pear < zucchini)\n    problem.addConstraint(between,\n                          [\"Food:pear\", \"Food:zucchini\", \"Food:pineapple\"])\n    \n    # Clue 4: zucchini is to the right of turtle (not necessarily immediately)\n    problem.addConstraint(lambda zucchini, turtle: zucchini > turtle,\n                          [\"Food:zucchini\", \"Pet:turtle\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['pineapple', 'pear', 'zucchini'], 'Pet': ['turtle', 'hedgehog', 'rat']}\n",
      "success": true,
      "execution_time": 0.002914,
      "timestamp": "20250918_085453",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['pineapple', 'pear', 'zucchini'], 'Pet': ['turtle', 'hedgehog', 'rat']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_78",
      "puzzle": {
        "id": "simple_2x3_78",
        "title": "Einstein Puzzle simple_2x3_78 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0050855419999999985
        },
        "clues": [
          "the person who likes zombie movies is to the right of the person who enjoys traveling (not necessarily immediately)",
          "the person who likes zombie movies is adjacent to the person who likes adventure movies (either immediately left or right)",
          "the person who enjoys photography is immediately to the left of the person who enjoys traveling"
        ],
        "categories": [
          "Hobby",
          "Movie"
        ],
        "items": {
          "Hobby": [
            "photography",
            "traveling",
            "rock-climbing"
          ],
          "Movie": [
            "horror",
            "adventure",
            "zombie"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"photography\", \"traveling\", \"rock-climbing\"], \"Movie\": [\"horror\", \"adventure\", \"zombie\"]}"
      },
      "puzzle_hash": "770e85662cc2f1312ebc739d85e5a5c0",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Movie\"]\n    items = {\n        \"Hobby\": [\"photography\", \"traveling\", \"rock-climbing\"],\n        \"Movie\": [\"horror\", \"adventure\", \"zombie\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes zombie movies is to the right of the person who enjoys traveling (not necessarily immediately)\n    problem.addConstraint(lambda zombie, traveling: zombie > traveling, [\"Movie:zombie\", \"Hobby:traveling\"])\n    \n    # Clue 2: the person who likes zombie movies is adjacent to the person who likes adventure movies (either immediately left or right)\n    problem.addConstraint(lambda zombie, adventure: abs(zombie - adventure) == 1, [\"Movie:zombie\", \"Movie:adventure\"])\n    \n    # Clue 3: the person who enjoys photography is immediately to the left of the person who enjoys traveling\n    problem.addConstraint(lambda photography, traveling: photography == traveling - 1, [\"Hobby:photography\", \"Hobby:traveling\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['photography', 'traveling', 'rock-climbing'], 'Movie': ['horror', 'adventure', 'zombie']}\n",
      "success": true,
      "execution_time": 0.002525,
      "timestamp": "20250918_085500",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['photography', 'traveling', 'rock-climbing'], 'Movie': ['horror', 'adventure', 'zombie']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_79",
      "puzzle": {
        "id": "simple_2x3_79",
        "title": "Einstein Puzzle simple_2x3_79 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006023582999999999
        },
        "clues": [
          "the person who likes lemon and the person who likes disco music are at positions with different parity (one at odd, one at even position)",
          "the person who likes pepper is at the same position as or to the left of the person who likes disco music",
          "the person who likes metal music is immediately to the left of the person who likes lettuce",
          "the person who likes lemon and the person who likes country music are at positions with the same parity (both at odd or both at even positions)"
        ],
        "categories": [
          "Food",
          "Music"
        ],
        "items": {
          "Food": [
            "pepper",
            "lettuce",
            "lemon"
          ],
          "Music": [
            "metal",
            "disco",
            "country"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"pepper\", \"lettuce\", \"lemon\"], \"Music\": [\"metal\", \"disco\", \"country\"]}"
      },
      "puzzle_hash": "178cb1d8886cd95ab4ef4dfce75a8ba6",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Music\"]\n    items = {\n        \"Food\": [\"pepper\", \"lettuce\", \"lemon\"],\n        \"Music\": [\"metal\", \"disco\", \"country\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: lemon and disco are at positions with different parity\n    problem.addConstraint(lambda lemon, disco: (lemon % 2) != (disco % 2),\n                          [\"Food:lemon\", \"Music:disco\"])\n    \n    # Clue 2: pepper is at the same position as or to the left of disco\n    problem.addConstraint(lambda pepper, disco: pepper <= disco,\n                          [\"Food:pepper\", \"Music:disco\"])\n    \n    # Clue 3: metal is immediately to the left of lettuce\n    problem.addConstraint(lambda metal, lettuce: metal == lettuce - 1,\n                          [\"Music:metal\", \"Food:lettuce\"])\n    \n    # Clue 4: lemon and country are at positions with the same parity\n    problem.addConstraint(lambda lemon, country: (lemon % 2) == (country % 2),\n                          [\"Food:lemon\", \"Music:country\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['pepper', 'lettuce', 'lemon'], 'Music': ['metal', 'disco', 'country']}\n",
      "success": true,
      "execution_time": 0.002924,
      "timestamp": "20250918_085510",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['pepper', 'lettuce', 'lemon'], 'Music': ['metal', 'disco', 'country']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_80",
      "puzzle": {
        "id": "simple_2x3_80",
        "title": "Einstein Puzzle simple_2x3_80 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0038665840000000062
        },
        "clues": [
          "the pakistani person is at an even-numbered position",
          "the person who works as a librarian is to the left of the egyptian person (not necessarily immediately)",
          "the malaysian person is at the same position as or to the right of the person who works as a analyst"
        ],
        "categories": [
          "Job",
          "Nationality"
        ],
        "items": {
          "Job": [
            "analyst",
            "librarian",
            "nurse"
          ],
          "Nationality": [
            "malaysian",
            "pakistani",
            "egyptian"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"analyst\", \"librarian\", \"nurse\"], \"Nationality\": [\"malaysian\", \"pakistani\", \"egyptian\"]}"
      },
      "puzzle_hash": "5bf0b74e82db842ea134e5d525a9cd21",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Nationality\"]\n    items = {\n        \"Job\": [\"analyst\", \"librarian\", \"nurse\"],\n        \"Nationality\": [\"malaysian\", \"pakistani\", \"egyptian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the pakistani person is at an even-numbered position\n    problem.addConstraint(lambda x: x % 2 == 0, [\"Nationality:pakistani\"])\n    \n    # Clue 2: the person who works as a librarian is to the left of the egyptian person (not necessarily immediately)\n    problem.addConstraint(lambda x, y: x < y, [\"Job:librarian\", \"Nationality:egyptian\"])\n    \n    # Clue 3: the malaysian person is at the same position as or to the right of the person who works as an analyst\n    problem.addConstraint(lambda x, y: x >= y, [\"Nationality:malaysian\", \"Job:analyst\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "",
      "success": false,
      "execution_time": 0.014395,
      "timestamp": "20250918_085518",
      "verification": {
        "verified": true,
        "is_correct": false,
        "ground_truth": "{'Job': ['analyst', 'librarian', 'nurse'], 'Nationality': ['malaysian', 'pakistani', 'egyptian']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_81",
      "puzzle": {
        "id": "simple_2x3_81",
        "title": "Einstein Puzzle simple_2x3_81 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006868959000000008
        },
        "clues": [
          "the person who uses tram for transportation is at position 1 (the leftmost position)",
          "the person who enjoys traveling is directly between the person who enjoys woodworking and the person who uses taxi for transportation"
        ],
        "categories": [
          "Hobby",
          "Transport"
        ],
        "items": {
          "Hobby": [
            "woodworking",
            "traveling",
            "filmmaking"
          ],
          "Transport": [
            "tram",
            "helicopter",
            "taxi"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"woodworking\", \"traveling\", \"filmmaking\"], \"Transport\": [\"tram\", \"helicopter\", \"taxi\"]}"
      },
      "puzzle_hash": "8eefaa53ee6e0211995742fef2bb9a5b",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Transport\"]\n    items = {\n        \"Hobby\": [\"woodworking\", \"traveling\", \"filmmaking\"],\n        \"Transport\": [\"tram\", \"helicopter\", \"taxi\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses tram for transportation is at position 1 (0-indexed)\n    problem.addConstraint(lambda x: x == 0, [\"Transport:tram\"])\n    \n    # Clue 2: the person who enjoys traveling is directly between the person who enjoys woodworking and the person who uses taxi\n    problem.addConstraint(\n        lambda traveling, woodworking, taxi: (traveling == woodworking + 1 and traveling == taxi - 1) or (traveling == taxi + 1 and traveling == woodworking - 1),\n        [\"Hobby:traveling\", \"Hobby:woodworking\", \"Transport:taxi\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['woodworking', 'traveling', 'filmmaking'], 'Transport': ['tram', 'helicopter', 'taxi']}\n",
      "success": true,
      "execution_time": 0.003036,
      "timestamp": "20250918_085524",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['woodworking', 'traveling', 'filmmaking'], 'Transport': ['tram', 'helicopter', 'taxi']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_82",
      "puzzle": {
        "id": "simple_2x3_82",
        "title": "Einstein Puzzle simple_2x3_82 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003654959000000013
        },
        "clues": [
          "the person who plays basketball is to the right of the egyptian person (not necessarily immediately)",
          "the person who plays rugby and the egyptian person are at positions with different parity (one at odd, one at even position)",
          "the person who plays volleyball is immediately to the left of the person who plays rugby",
          "the pakistani person is at an odd-numbered position"
        ],
        "categories": [
          "Nationality",
          "Sport"
        ],
        "items": {
          "Nationality": [
            "egyptian",
            "french",
            "pakistani"
          ],
          "Sport": [
            "volleyball",
            "rugby",
            "basketball"
          ]
        },
        "ground_truth_solution": "{\"Nationality\": [\"egyptian\", \"french\", \"pakistani\"], \"Sport\": [\"volleyball\", \"rugby\", \"basketball\"]}"
      },
      "puzzle_hash": "4337530cb8efa65e437192026488ac8f",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Nationality\", \"Sport\"]\n    items = {\n        \"Nationality\": [\"egyptian\", \"french\", \"pakistani\"],\n        \"Sport\": [\"volleyball\", \"rugby\", \"basketball\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: basketball is to the right of egyptian (not necessarily immediately)\n    problem.addConstraint(lambda egyptian_pos, basketball_pos: egyptian_pos < basketball_pos,\n                          [\"Nationality:egyptian\", \"Sport:basketball\"])\n    \n    # Clue 2: rugby and egyptian are at positions with different parity\n    problem.addConstraint(lambda rugby_pos, egyptian_pos: (rugby_pos % 2) != (egyptian_pos % 2),\n                          [\"Sport:rugby\", \"Nationality:egyptian\"])\n    \n    # Clue 3: volleyball is immediately to the left of rugby\n    problem.addConstraint(lambda volleyball_pos, rugby_pos: volleyball_pos == rugby_pos - 1,\n                          [\"Sport:volleyball\", \"Sport:rugby\"])\n    \n    # Clue 4: pakistani is at an odd-numbered position (positions are 0-indexed)\n    problem.addConstraint(lambda pakistani_pos: pakistani_pos % 2 == 1,\n                          [\"Nationality:pakistani\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['egyptian', 'pakistani', 'french'], 'Sport': ['volleyball', 'rugby', 'basketball']}\n",
      "success": true,
      "execution_time": 0.002704,
      "timestamp": "20250918_085531",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['egyptian', 'french', 'pakistani'], 'Sport': ['volleyball', 'rugby', 'basketball']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_83",
      "puzzle": {
        "id": "simple_2x3_83",
        "title": "Einstein Puzzle simple_2x3_83 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003513665999999971
        },
        "clues": [
          "the italian person is to the left of the russian person (not necessarily immediately)",
          "the italian person is somewhere between the russian person and the person who enjoys filmmaking (not necessarily immediately adjacent)",
          "the person who enjoys writing is directly between the french person and the russian person"
        ],
        "categories": [
          "Hobby",
          "Nationality"
        ],
        "items": {
          "Hobby": [
            "filmmaking",
            "writing",
            "woodworking"
          ],
          "Nationality": [
            "french",
            "italian",
            "russian"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"filmmaking\", \"writing\", \"woodworking\"], \"Nationality\": [\"french\", \"italian\", \"russian\"]}"
      },
      "puzzle_hash": "d37343a5eb5c57d6f15c0182b88b7f45",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Nationality\"]\n    items = {\n        \"Hobby\": [\"filmmaking\", \"writing\", \"woodworking\"],\n        \"Nationality\": [\"french\", \"italian\", \"russian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the italian person is to the left of the russian person (not necessarily immediately)\n    problem.addConstraint(lambda italian, russian: italian < russian,\n                          [\"Nationality:italian\", \"Nationality:russian\"])\n    \n    # Clue 2: the italian person is somewhere between the russian person and the person who enjoys filmmaking\n    # This means italian is between russian and filmmaking, so italian is greater than min(russian, filmmaking)\n    # and less than max(russian, filmmaking)\n    def italian_between_russian_and_filmmaking(italian, russian, filmmaking):\n        return (min(russian, filmmaking) < italian < max(russian, filmmaking))\n    problem.addConstraint(italian_between_russian_and_filmmaking,\n                          [\"Nationality:italian\", \"Nationality:russian\", \"Hobby:filmmaking\"])\n    \n    # Clue 3: the person who enjoys writing is directly between the french person and the russian person\n    # Writing is at position between french and russian, so writing is immediately between them\n    # i.e. writing == french + 1 and writing == russian -1 or writing == russian +1 and writing == french -1\n    def writing_between_french_and_russian(writing, french, russian):\n        return (writing == french + 1 and writing == russian - 1) or (writing == russian + 1 and writing == french - 1)\n    problem.addConstraint(writing_between_french_and_russian,\n                          [\"Hobby:writing\", \"Nationality:french\", \"Nationality:russian\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['filmmaking', 'writing', 'woodworking'], 'Nationality': ['french', 'italian', 'russian']}\n",
      "success": true,
      "execution_time": 0.001792,
      "timestamp": "20250918_085548",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['filmmaking', 'writing', 'woodworking'], 'Nationality': ['french', 'italian', 'russian']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_84",
      "puzzle": {
        "id": "simple_2x3_84",
        "title": "Einstein Puzzle simple_2x3_84 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00672670799999997
        },
        "clues": [
          "the person who uses van for transportation is adjacent to the person who uses boat for transportation (either immediately left or right)",
          "the person who works as a pilot is to the right of the person who works as a photographer (not necessarily immediately)",
          "the person who works as a pilot is at the center position (position 2)",
          "the person who uses boat for transportation is immediately to the right of the person who uses ship for transportation"
        ],
        "categories": [
          "Job",
          "Transport"
        ],
        "items": {
          "Job": [
            "photographer",
            "pilot",
            "nurse"
          ],
          "Transport": [
            "ship",
            "boat",
            "van"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"photographer\", \"pilot\", \"nurse\"], \"Transport\": [\"ship\", \"boat\", \"van\"]}"
      },
      "puzzle_hash": "b5433f5ade52f0cbb348c701c6eced24",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Transport\"]\n    items = {\n        \"Job\": [\"photographer\", \"pilot\", \"nurse\"],\n        \"Transport\": [\"ship\", \"boat\", \"van\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses van for transportation is adjacent to the person who uses boat for transportation\n    problem.addConstraint(lambda van, boat: abs(van - boat) == 1, [\"Transport:van\", \"Transport:boat\"])\n    \n    # Clue 2: the person who works as a pilot is to the right of the person who works as a photographer (not necessarily immediately)\n    problem.addConstraint(lambda pilot, photographer: pilot > photographer, [\"Job:pilot\", \"Job:photographer\"])\n    \n    # Clue 3: the person who works as a pilot is at the center position (position 2)\n    problem.addConstraint(lambda pilot: pilot == 1, [\"Job:pilot\"])\n    \n    # Clue 4: the person who uses boat for transportation is immediately to the right of the person who uses ship for transportation\n    problem.addConstraint(lambda boat, ship: boat == ship + 1, [\"Transport:boat\", \"Transport:ship\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['photographer', 'pilot', 'nurse'], 'Transport': ['ship', 'boat', 'van']}\n",
      "success": true,
      "execution_time": 0.002857,
      "timestamp": "20250918_085557",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['photographer', 'pilot', 'nurse'], 'Transport': ['ship', 'boat', 'van']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_85",
      "puzzle": {
        "id": "simple_2x3_85",
        "title": "Einstein Puzzle simple_2x3_85 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006591750000000007
        },
        "clues": [
          "the person who works as a designer is at an odd-numbered position",
          "the person who likes pop music is immediately to the left of the person who works as a firefighter",
          "the person who likes folk music is to the left of the person who likes pop music (not necessarily immediately)"
        ],
        "categories": [
          "Job",
          "Music"
        ],
        "items": {
          "Job": [
            "designer",
            "paramedic",
            "firefighter"
          ],
          "Music": [
            "folk",
            "pop",
            "soul"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"designer\", \"paramedic\", \"firefighter\"], \"Music\": [\"folk\", \"pop\", \"soul\"]}"
      },
      "puzzle_hash": "6975a7ba34a744cbb02b0a8e83ccc95b",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Music\"]\n    items = {\n        \"Job\": [\"designer\", \"paramedic\", \"firefighter\"],\n        \"Music\": [\"folk\", \"pop\", \"soul\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who works as a designer is at an odd-numbered position\n    problem.addConstraint(lambda x: x % 2 == 0, [\"Job:designer\"])  # positions 0,2 are odd-numbered houses 1,3 (0-indexed)\n    \n    # Clue 2: the person who likes pop music is immediately to the left of the person who works as a firefighter\n    problem.addConstraint(lambda pop, fire: pop == fire - 1, [\"Music:pop\", \"Job:firefighter\"])\n    \n    # Clue 3: the person who likes folk music is to the left of the person who likes pop music (not necessarily immediately)\n    problem.addConstraint(lambda folk, pop: folk < pop, [\"Music:folk\", \"Music:pop\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['designer', 'paramedic', 'firefighter'], 'Music': ['folk', 'pop', 'soul']}\n",
      "success": true,
      "execution_time": 0.002548,
      "timestamp": "20250918_085604",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['designer', 'paramedic', 'firefighter'], 'Music': ['folk', 'pop', 'soul']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_86",
      "puzzle": {
        "id": "simple_2x3_86",
        "title": "Einstein Puzzle simple_2x3_86 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003280124999999967
        },
        "clues": [
          "the person who uses jet-ski for transportation is to the right of the person who enjoys video-games (not necessarily immediately)",
          "the person who enjoys cooking is at an odd-numbered position",
          "the person who uses snowmobile for transportation is immediately to the right of the person who enjoys cooking"
        ],
        "categories": [
          "Hobby",
          "Transport"
        ],
        "items": {
          "Hobby": [
            "cooking",
            "video-games",
            "traveling"
          ],
          "Transport": [
            "helicopter",
            "snowmobile",
            "jet-ski"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"cooking\", \"video-games\", \"traveling\"], \"Transport\": [\"helicopter\", \"snowmobile\", \"jet-ski\"]}"
      },
      "puzzle_hash": "200490b839b5c32eb6309ab5f12c0e03",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Transport\"]\n    items = {\n        \"Hobby\": [\"cooking\", \"video-games\", \"traveling\"],\n        \"Transport\": [\"helicopter\", \"snowmobile\", \"jet-ski\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses jet-ski for transportation is to the right of the person who enjoys video-games (not necessarily immediately)\n    problem.addConstraint(lambda jet_ski_pos, video_games_pos: jet_ski_pos > video_games_pos,\n                          [\"Transport:jet-ski\", \"Hobby:video-games\"])\n    \n    # Clue 2: the person who enjoys cooking is at an odd-numbered position\n    problem.addConstraint(lambda cooking_pos: cooking_pos % 2 == 1, [\"Hobby:cooking\"])\n    \n    # Clue 3: the person who uses snowmobile for transportation is immediately to the right of the person who enjoys cooking\n    problem.addConstraint(lambda cooking_pos, snowmobile_pos: snowmobile_pos == cooking_pos + 1,\n                          [\"Hobby:cooking\", \"Transport:snowmobile\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['video-games', 'cooking', 'traveling'], 'Transport': ['helicopter', 'jet-ski', 'snowmobile']}\n",
      "success": true,
      "execution_time": 0.002923,
      "timestamp": "20250918_085612",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['cooking', 'video-games', 'traveling'], 'Transport': ['helicopter', 'snowmobile', 'jet-ski']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_87",
      "puzzle": {
        "id": "simple_2x3_87",
        "title": "Einstein Puzzle simple_2x3_87 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.006495583000000027
        },
        "clues": [
          "the person who uses bike for transportation is at position 1 (the leftmost position)",
          "the person who likes r&b music is at an end position (either leftmost or rightmost)",
          "the person who likes salsa music is immediately to the right of the person who uses taxi for transportation"
        ],
        "categories": [
          "Music",
          "Transport"
        ],
        "items": {
          "Music": [
            "r&b",
            "ambient",
            "salsa"
          ],
          "Transport": [
            "bike",
            "taxi",
            "car"
          ]
        },
        "ground_truth_solution": "{\"Music\": [\"r&b\", \"ambient\", \"salsa\"], \"Transport\": [\"bike\", \"taxi\", \"car\"]}"
      },
      "puzzle_hash": "690b24bdef5f9182cdad502cbff245e9",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Music\", \"Transport\"]\n    items = {\n        \"Music\": [\"r&b\", \"ambient\", \"salsa\"],\n        \"Transport\": [\"bike\", \"taxi\", \"car\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses bike for transportation is at position 1 (0-indexed)\n    problem.addConstraint(lambda x: x == 0, [\"Transport:bike\"])\n    \n    # Clue 2: the person who likes r&b music is at an end position (0 or 2)\n    problem.addConstraint(lambda x: x == 0 or x == 2, [\"Music:r&b\"])\n    \n    # Clue 3: the person who likes salsa music is immediately to the right of the person who uses taxi\n    problem.addConstraint(lambda salsa_pos, taxi_pos: salsa_pos == taxi_pos + 1, [\"Music:salsa\", \"Transport:taxi\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['r&b', 'ambient', 'salsa'], 'Transport': ['bike', 'taxi', 'car']}\n",
      "success": true,
      "execution_time": 0.002909,
      "timestamp": "20250918_085619",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['r&b', 'ambient', 'salsa'], 'Transport': ['bike', 'taxi', 'car']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_88",
      "puzzle": {
        "id": "simple_2x3_88",
        "title": "Einstein Puzzle simple_2x3_88 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.009785999999999961
        },
        "clues": [
          "the person who likes sprite and the person who has guinea-pig as a pet are at positions with the same parity (both at odd or both at even positions)",
          "the person who has hamster as a pet is at the same position as or to the right of the person who has guinea-pig as a pet",
          "the person who likes tea is to the right of the person who has hamster as a pet (not necessarily immediately)"
        ],
        "categories": [
          "Beverage",
          "Pet"
        ],
        "items": {
          "Beverage": [
            "sprite",
            "fanta",
            "tea"
          ],
          "Pet": [
            "guinea-pig",
            "hamster",
            "hedgehog"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"sprite\", \"fanta\", \"tea\"], \"Pet\": [\"guinea-pig\", \"hamster\", \"hedgehog\"]}"
      },
      "puzzle_hash": "e39333ba59397613cf86c0cf187230ca",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Pet\"]\n    items = {\n        \"Beverage\": [\"sprite\", \"fanta\", \"tea\"],\n        \"Pet\": [\"guinea-pig\", \"hamster\", \"hedgehog\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: sprite and guinea-pig are at positions with same parity\n    problem.addConstraint(lambda x, y: x % 2 == y % 2, [\"Beverage:sprite\", \"Pet:guinea-pig\"])\n    \n    # Clue 2: hamster is at same position or to the right of guinea-pig\n    problem.addConstraint(lambda x, y: x >= y, [\"Pet:hamster\", \"Pet:guinea-pig\"])\n    \n    # Clue 3: tea is to the right of hamster\n    problem.addConstraint(lambda x, y: x > y, [\"Beverage:tea\", \"Pet:hamster\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['sprite', 'fanta', 'tea'], 'Pet': ['guinea-pig', 'hamster', 'hedgehog']}\n",
      "success": true,
      "execution_time": 0.002858,
      "timestamp": "20250918_085626",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['sprite', 'fanta', 'tea'], 'Pet': ['guinea-pig', 'hamster', 'hedgehog']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_89",
      "puzzle": {
        "id": "simple_2x3_89",
        "title": "Einstein Puzzle simple_2x3_89 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00478287500000002
        },
        "clues": [
          "the person who uses motorbike for transportation is immediately to the right of the person who likes trance music",
          "the person who uses motorbike for transportation is to the left of the person who uses scooter for transportation (not necessarily immediately)",
          "the person who likes dubstep music and the person who uses scooter for transportation are at positions with the same parity (both at odd or both at even positions)"
        ],
        "categories": [
          "Music",
          "Transport"
        ],
        "items": {
          "Music": [
            "trance",
            "ambient",
            "dubstep"
          ],
          "Transport": [
            "subway",
            "motorbike",
            "scooter"
          ]
        },
        "ground_truth_solution": "{\"Music\": [\"trance\", \"ambient\", \"dubstep\"], \"Transport\": [\"subway\", \"motorbike\", \"scooter\"]}"
      },
      "puzzle_hash": "5ee214d6989bc241857f9f30ae108b46",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Music\", \"Transport\"]\n    items = {\n        \"Music\": [\"trance\", \"ambient\", \"dubstep\"],\n        \"Transport\": [\"subway\", \"motorbike\", \"scooter\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: motorbike is immediately to the right of trance\n    problem.addConstraint(lambda trance_pos, motorbike_pos: motorbike_pos == trance_pos + 1,\n                          [\"Music:trance\", \"Transport:motorbike\"])\n    \n    # Clue 2: motorbike is to the left of scooter (not necessarily immediately)\n    problem.addConstraint(lambda motorbike_pos, scooter_pos: motorbike_pos < scooter_pos,\n                          [\"Transport:motorbike\", \"Transport:scooter\"])\n    \n    # Clue 3: dubstep and scooter are at positions with the same parity\n    problem.addConstraint(lambda dubstep_pos, scooter_pos: dubstep_pos % 2 == scooter_pos % 2,\n                          [\"Music:dubstep\", \"Transport:scooter\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['trance', 'ambient', 'dubstep'], 'Transport': ['subway', 'motorbike', 'scooter']}\n",
      "success": true,
      "execution_time": 0.002718,
      "timestamp": "20250918_085635",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['trance', 'ambient', 'dubstep'], 'Transport': ['subway', 'motorbike', 'scooter']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_90",
      "puzzle": {
        "id": "simple_2x3_90",
        "title": "Einstein Puzzle simple_2x3_90 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0023756249999999923
        },
        "clues": [
          "the person who uses motorbike for transportation is immediately to the right of the person who plays skateboarding",
          "the person who uses jet-ski for transportation is directly between the person who uses car for transportation and the person who plays tennis"
        ],
        "categories": [
          "Sport",
          "Transport"
        ],
        "items": {
          "Sport": [
            "ice-hockey",
            "skateboarding",
            "tennis"
          ],
          "Transport": [
            "car",
            "jet-ski",
            "motorbike"
          ]
        },
        "ground_truth_solution": "{\"Sport\": [\"ice-hockey\", \"skateboarding\", \"tennis\"], \"Transport\": [\"car\", \"jet-ski\", \"motorbike\"]}"
      },
      "puzzle_hash": "d6733df644acd3c16989abea17051456",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3  # 3 houses\n    \n    categories = [\"Sport\", \"Transport\"]\n    items = {\n        \"Sport\": [\"ice-hockey\", \"skateboarding\", \"tennis\"],\n        \"Transport\": [\"car\", \"jet-ski\", \"motorbike\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who uses motorbike for transportation is immediately to the right of the person who plays skateboarding\n    problem.addConstraint(lambda motorbike, skateboarding: motorbike == skateboarding + 1,\n                          [\"Transport:motorbike\", \"Sport:skateboarding\"])\n    \n    # Clue 2: the person who uses jet-ski for transportation is directly between the person who uses car for transportation and the person who plays tennis\n    problem.addConstraint(lambda jetski, car, tennis:\n                          (jetski == car + 1 and jetski == tennis - 1) or (jetski == tennis + 1 and jetski == car - 1),\n                          [\"Transport:jet-ski\", \"Transport:car\", \"Sport:tennis\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['ice-hockey', 'skateboarding', 'tennis'], 'Transport': ['car', 'jet-ski', 'motorbike']}\n",
      "success": true,
      "execution_time": 0.002771,
      "timestamp": "20250918_085642",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Sport': ['ice-hockey', 'skateboarding', 'tennis'], 'Transport': ['car', 'jet-ski', 'motorbike']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_91",
      "puzzle": {
        "id": "simple_2x3_91",
        "title": "Einstein Puzzle simple_2x3_91 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0037672909999999504
        },
        "clues": [
          "the person who likes 7up is to the right of the british person (not necessarily immediately)",
          "the british person is directly between the person who likes 7up and the pakistani person",
          "the person who likes coffee is immediately to the right of the person who likes fanta"
        ],
        "categories": [
          "Beverage",
          "Nationality"
        ],
        "items": {
          "Beverage": [
            "fanta",
            "coffee",
            "7up"
          ],
          "Nationality": [
            "pakistani",
            "british",
            "dutch"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"fanta\", \"coffee\", \"7up\"], \"Nationality\": [\"pakistani\", \"british\", \"dutch\"]}"
      },
      "puzzle_hash": "d2d30d0c0026fb545d79472478a7a96c",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Nationality\"]\n    items = {\n        \"Beverage\": [\"fanta\", \"coffee\", \"7up\"],\n        \"Nationality\": [\"pakistani\", \"british\", \"dutch\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes 7up is to the right of the british person (not necessarily immediately)\n    problem.addConstraint(lambda sevenup, british: sevenup > british,\n                          [\"Beverage:7up\", \"Nationality:british\"])\n    \n    # Clue 2: the british person is directly between the person who likes 7up and the pakistani person\n    # That means british is at position between 7up and pakistani\n    # So british is directly between 7up and pakistani: british == 7up + 1 and british == pakistani - 1\n    # or british == pakistani + 1 and british == 7up - 1\n    problem.addConstraint(lambda british, sevenup, pakistani:\n                          (british == sevenup + 1 and british == pakistani - 1) or\n                          (british == pakistani + 1 and british == sevenup - 1),\n                          [\"Nationality:british\", \"Beverage:7up\", \"Nationality:pakistani\"])\n    \n    # Clue 3: the person who likes coffee is immediately to the right of the person who likes fanta\n    problem.addConstraint(lambda coffee, fanta: coffee == fanta + 1,\n                          [\"Beverage:coffee\", \"Beverage:fanta\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['fanta', 'coffee', '7up'], 'Nationality': ['pakistani', 'british', 'dutch']}\n",
      "success": true,
      "execution_time": 0.002692,
      "timestamp": "20250918_085652",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['fanta', 'coffee', '7up'], 'Nationality': ['pakistani', 'british', 'dutch']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_92",
      "puzzle": {
        "id": "simple_2x3_92",
        "title": "Einstein Puzzle simple_2x3_92 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.007498333000000024
        },
        "clues": [
          "the person who has frog as a pet and the person who likes mirinda are at positions with the same parity (both at odd or both at even positions)",
          "the person who likes milk is at the same position as or to the left of the person who likes tea",
          "the person who likes tea is at the same position as or to the left of the person who has rabbit as a pet",
          "the person who has frog as a pet is at the same position as or to the right of the person who likes tea"
        ],
        "categories": [
          "Beverage",
          "Pet"
        ],
        "items": {
          "Beverage": [
            "milk",
            "tea",
            "mirinda"
          ],
          "Pet": [
            "goat",
            "rabbit",
            "frog"
          ]
        },
        "ground_truth_solution": "{\"Beverage\": [\"milk\", \"tea\", \"mirinda\"], \"Pet\": [\"goat\", \"rabbit\", \"frog\"]}"
      },
      "puzzle_hash": "33f8f17cb2fe0217bf0c2504616217b9",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Beverage\", \"Pet\"]\n    items = {\n        \"Beverage\": [\"milk\", \"tea\", \"mirinda\"],\n        \"Pet\": [\"goat\", \"rabbit\", \"frog\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: frog and mirinda are at positions with the same parity\n    problem.addConstraint(lambda frog_pos, mirinda_pos: frog_pos % 2 == mirinda_pos % 2,\n                          [\"Pet:frog\", \"Beverage:mirinda\"])\n    \n    # Clue 2: milk is at the same position as or to the left of tea\n    problem.addConstraint(lambda milk_pos, tea_pos: milk_pos <= tea_pos,\n                          [\"Beverage:milk\", \"Beverage:tea\"])\n    \n    # Clue 3: tea is at the same position as or to the left of rabbit\n    problem.addConstraint(lambda tea_pos, rabbit_pos: tea_pos <= rabbit_pos,\n                          [\"Beverage:tea\", \"Pet:rabbit\"])\n    \n    # Clue 4: frog is at the same position as or to the right of tea\n    problem.addConstraint(lambda frog_pos, tea_pos: frog_pos >= tea_pos,\n                          [\"Pet:frog\", \"Beverage:tea\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['milk', 'tea', 'mirinda'], 'Pet': ['goat', 'rabbit', 'frog']}\n",
      "success": true,
      "execution_time": 0.002942,
      "timestamp": "20250918_085700",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['milk', 'tea', 'mirinda'], 'Pet': ['goat', 'rabbit', 'frog']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_93",
      "puzzle": {
        "id": "simple_2x3_93",
        "title": "Einstein Puzzle simple_2x3_93 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.004427958000000065
        },
        "clues": [
          "the person who enjoys chess is to the left of the person who likes grapes (not necessarily immediately)",
          "the person who likes apricot is at position 1 (the leftmost position)",
          "the person who enjoys woodworking is the same person as the person who likes apricot"
        ],
        "categories": [
          "Food",
          "Hobby"
        ],
        "items": {
          "Food": [
            "apricot",
            "cranberry",
            "grapes"
          ],
          "Hobby": [
            "woodworking",
            "chess",
            "photography"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"apricot\", \"cranberry\", \"grapes\"], \"Hobby\": [\"woodworking\", \"chess\", \"photography\"]}"
      },
      "puzzle_hash": "14915aee18108edcba1f402e25de9ac9",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Hobby\"]\n    items = {\n        \"Food\": [\"apricot\", \"cranberry\", \"grapes\"],\n        \"Hobby\": [\"woodworking\", \"chess\", \"photography\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys chess is to the left of the person who likes grapes (not necessarily immediately)\n    problem.addConstraint(lambda chess_pos, grapes_pos: chess_pos < grapes_pos,\n                          [\"Hobby:chess\", \"Food:grapes\"])\n    \n    # Clue 2: the person who likes apricot is at position 1 (0-indexed)\n    problem.addConstraint(lambda apricot_pos: apricot_pos == 0, [\"Food:apricot\"])\n    \n    # Clue 3: the person who enjoys woodworking is the same person as the person who likes apricot\n    problem.addConstraint(lambda woodworking_pos, apricot_pos: woodworking_pos == apricot_pos,\n                          [\"Hobby:woodworking\", \"Food:apricot\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['apricot', 'cranberry', 'grapes'], 'Hobby': ['woodworking', 'chess', 'photography']}\n",
      "success": true,
      "execution_time": 0.002738,
      "timestamp": "20250918_085708",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['apricot', 'cranberry', 'grapes'], 'Hobby': ['woodworking', 'chess', 'photography']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_94",
      "puzzle": {
        "id": "simple_2x3_94",
        "title": "Einstein Puzzle simple_2x3_94 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.007600749999999934
        },
        "clues": [
          "the person who likes western movies is at position 3(the rightmost position)",
          "the person who plays lacrosse is at position 1 (the leftmost position)",
          "the person who likes satire movies and the person who plays lacrosse are at positions with different parity (one at odd, one at even position)",
          "the person who plays sailing is adjacent to the person who likes western movies (either immediately left or right)"
        ],
        "categories": [
          "Movie",
          "Sport"
        ],
        "items": {
          "Movie": [
            "comedy",
            "satire",
            "western"
          ],
          "Sport": [
            "lacrosse",
            "sailing",
            "skateboarding"
          ]
        },
        "ground_truth_solution": "{\"Movie\": [\"comedy\", \"satire\", \"western\"], \"Sport\": [\"lacrosse\", \"sailing\", \"skateboarding\"]}"
      },
      "puzzle_hash": "2df3a8d51fecf0a795169114e16086dc",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Movie\", \"Sport\"]\n    items = {\n        \"Movie\": [\"comedy\", \"satire\", \"western\"],\n        \"Sport\": [\"lacrosse\", \"sailing\", \"skateboarding\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes western movies is at position 3 (index 2)\n    problem.addConstraint(lambda x: x == 2, [\"Movie:western\"])\n    \n    # Clue 2: the person who plays lacrosse is at position 1 (index 0)\n    problem.addConstraint(lambda x: x == 0, [\"Sport:lacrosse\"])\n    \n    # Clue 3: satire movie and lacrosse are at positions with different parity\n    problem.addConstraint(lambda x, y: (x % 2) != (y % 2), [\"Movie:satire\", \"Sport:lacrosse\"])\n    \n    # Clue 4: sailing is adjacent to western\n    problem.addConstraint(lambda x, y: abs(x - y) == 1, [\"Sport:sailing\", \"Movie:western\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['comedy', 'satire', 'western'], 'Sport': ['lacrosse', 'sailing', 'skateboarding']}\n",
      "success": true,
      "execution_time": 0.002863,
      "timestamp": "20250918_085715",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['comedy', 'satire', 'western'], 'Sport': ['lacrosse', 'sailing', 'skateboarding']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_95",
      "puzzle": {
        "id": "simple_2x3_95",
        "title": "Einstein Puzzle simple_2x3_95 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0047714169999999445
        },
        "clues": [
          "the person who has ferret as a pet is to the left of the person who works as a firefighter (not necessarily immediately)",
          "the person who works as a firefighter is a different person than the person who has pony as a pet",
          "the person who works as a photographer is at position 3(the rightmost position)"
        ],
        "categories": [
          "Job",
          "Pet"
        ],
        "items": {
          "Job": [
            "designer",
            "firefighter",
            "photographer"
          ],
          "Pet": [
            "ferret",
            "fish",
            "pony"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"designer\", \"firefighter\", \"photographer\"], \"Pet\": [\"ferret\", \"fish\", \"pony\"]}"
      },
      "puzzle_hash": "832319e231fb89f82bac1cbc4b3318e8",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Pet\"]\n    items = {\n        \"Job\": [\"designer\", \"firefighter\", \"photographer\"],\n        \"Pet\": [\"ferret\", \"fish\", \"pony\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who has ferret as a pet is to the left of the person who works as a firefighter (not necessarily immediately)\n    problem.addConstraint(lambda ferret_pos, firefighter_pos: ferret_pos < firefighter_pos,\n                          [\"Pet:ferret\", \"Job:firefighter\"])\n    \n    # Clue 2: the person who works as a firefighter is a different person than the person who has pony as a pet\n    problem.addConstraint(lambda firefighter_pos, pony_pos: firefighter_pos != pony_pos,\n                          [\"Job:firefighter\", \"Pet:pony\"])\n    \n    # Clue 3: the person who works as a photographer is at position 3 (rightmost position, index 2)\n    problem.addConstraint(lambda photographer_pos: photographer_pos == 2,\n                          [\"Job:photographer\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['designer', 'firefighter', 'photographer'], 'Pet': ['ferret', 'fish', 'pony']}\n",
      "success": true,
      "execution_time": 0.002923,
      "timestamp": "20250918_085722",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['designer', 'firefighter', 'photographer'], 'Pet': ['ferret', 'fish', 'pony']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_96",
      "puzzle": {
        "id": "simple_2x3_96",
        "title": "Einstein Puzzle simple_2x3_96 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0027983750000000196
        },
        "clues": [
          "the person who works as a chef and the person who enjoys hiking are at positions with the same parity (both at odd or both at even positions)",
          "the person who enjoys filmmaking is immediately to the left of the person who works as a accountant",
          "the person who works as a chef is to the right of the person who enjoys video-games (not necessarily immediately)"
        ],
        "categories": [
          "Hobby",
          "Job"
        ],
        "items": {
          "Hobby": [
            "filmmaking",
            "video-games",
            "hiking"
          ],
          "Job": [
            "writer",
            "accountant",
            "chef"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"filmmaking\", \"video-games\", \"hiking\"], \"Job\": [\"writer\", \"accountant\", \"chef\"]}"
      },
      "puzzle_hash": "d28afd21824304c766d2c5d267df7407",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Job\"]\n    items = {\n        \"Hobby\": [\"filmmaking\", \"video-games\", \"hiking\"],\n        \"Job\": [\"writer\", \"accountant\", \"chef\"]\n    }\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: chef and hiking have same parity\n    problem.addConstraint(lambda chef, hiking: chef % 2 == hiking % 2,\n                          [\"Job:chef\", \"Hobby:hiking\"])\n    \n    # Clue 2: filmmaking immediately to the left of accountant\n    problem.addConstraint(lambda filmmaking, accountant: filmmaking == accountant - 1,\n                          [\"Hobby:filmmaking\", \"Job:accountant\"])\n    \n    # Clue 3: chef is to the right of video-games (not necessarily immediately)\n    problem.addConstraint(lambda chef, videogames: chef > videogames,\n                          [\"Job:chef\", \"Hobby:video-games\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['filmmaking', 'video-games', 'hiking'], 'Job': ['writer', 'accountant', 'chef']}\n",
      "success": true,
      "execution_time": 0.003078,
      "timestamp": "20250918_085738",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['filmmaking', 'video-games', 'hiking'], 'Job': ['writer', 'accountant', 'chef']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_97",
      "puzzle": {
        "id": "simple_2x3_97",
        "title": "Einstein Puzzle simple_2x3_97 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.005621999999999905
        },
        "clues": [
          "the person who plays sailing is somewhere between the person who has bird as a pet and the person who has dog as a pet (not necessarily immediately adjacent)",
          "the person who has bird as a pet is immediately to the right of the person who plays sailing",
          "the person who has frog as a pet is at the same position as or to the right of the person who plays climbing"
        ],
        "categories": [
          "Pet",
          "Sport"
        ],
        "items": {
          "Pet": [
            "dog",
            "frog",
            "bird"
          ],
          "Sport": [
            "climbing",
            "sailing",
            "tennis"
          ]
        },
        "ground_truth_solution": "{\"Pet\": [\"dog\", \"frog\", \"bird\"], \"Sport\": [\"climbing\", \"sailing\", \"tennis\"]}"
      },
      "puzzle_hash": "16f227817d5989254d785c6b7aa58ad1",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Pet\", \"Sport\"]\n    items = {\n        \"Pet\": [\"dog\", \"frog\", \"bird\"],\n        \"Sport\": [\"climbing\", \"sailing\", \"tennis\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays sailing is somewhere between the person who has bird as a pet and the person who has dog as a pet (not necessarily immediately adjacent)\n    # This means sailing position is strictly between bird and dog positions\n    problem.addConstraint(\n        lambda sailing, bird, dog: (bird < sailing < dog) or (dog < sailing < bird),\n        [\"Sport:sailing\", \"Pet:bird\", \"Pet:dog\"]\n    )\n    \n    # Clue 2: the person who has bird as a pet is immediately to the right of the person who plays sailing\n    problem.addConstraint(\n        lambda bird, sailing: bird == sailing + 1,\n        [\"Pet:bird\", \"Sport:sailing\"]\n    )\n    \n    # Clue 3: the person who has frog as a pet is at the same position as or to the right of the person who plays climbing\n    problem.addConstraint(\n        lambda frog, climbing: frog >= climbing,\n        [\"Pet:frog\", \"Sport:climbing\"]\n    )\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Pet': ['dog', 'frog', 'bird'], 'Sport': ['climbing', 'sailing', 'tennis']}\n",
      "success": true,
      "execution_time": 0.002677,
      "timestamp": "20250918_085748",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Pet': ['dog', 'frog', 'bird'], 'Sport': ['climbing', 'sailing', 'tennis']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_98",
      "puzzle": {
        "id": "simple_2x3_98",
        "title": "Einstein Puzzle simple_2x3_98 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.0047791669999999176
        },
        "clues": [
          "the person who likes spinach is to the left of the person who uses bike for transportation (not necessarily immediately)",
          "the person who uses bike for transportation is somewhere between the person who likes spinach and the person who uses van for transportation (not necessarily immediately adjacent)",
          "the person who likes lettuce is to the left of the person who likes tomato (not necessarily immediately)"
        ],
        "categories": [
          "Food",
          "Transport"
        ],
        "items": {
          "Food": [
            "spinach",
            "lettuce",
            "tomato"
          ],
          "Transport": [
            "scooter",
            "bike",
            "van"
          ]
        },
        "ground_truth_solution": "{\"Food\": [\"spinach\", \"lettuce\", \"tomato\"], \"Transport\": [\"scooter\", \"bike\", \"van\"]}"
      },
      "puzzle_hash": "7e7eeecaa200281af52ede30152b5058",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Food\", \"Transport\"]\n    items = {\n        \"Food\": [\"spinach\", \"lettuce\", \"tomato\"],\n        \"Transport\": [\"scooter\", \"bike\", \"van\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes spinach is to the left of the person who uses bike for transportation\n    problem.addConstraint(lambda spinach_pos, bike_pos: spinach_pos < bike_pos,\n                          [\"Food:spinach\", \"Transport:bike\"])\n    \n    # Clue 2: the person who uses bike for transportation is somewhere between the person who likes spinach and the person who uses van for transportation\n    problem.addConstraint(lambda spinach_pos, bike_pos, van_pos:\n                          (spinach_pos < bike_pos < van_pos) or (van_pos < bike_pos < spinach_pos),\n                          [\"Food:spinach\", \"Transport:bike\", \"Transport:van\"])\n    \n    # Clue 3: the person who likes lettuce is to the left of the person who likes tomato\n    problem.addConstraint(lambda lettuce_pos, tomato_pos: lettuce_pos < tomato_pos,\n                          [\"Food:lettuce\", \"Food:tomato\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['spinach', 'lettuce', 'tomato'], 'Transport': ['scooter', 'bike', 'van']}\n",
      "success": true,
      "execution_time": 0.002624,
      "timestamp": "20250918_085756",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['spinach', 'lettuce', 'tomato'], 'Transport': ['scooter', 'bike', 'van']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_99",
      "puzzle": {
        "id": "simple_2x3_99",
        "title": "Einstein Puzzle simple_2x3_99 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.003638750000000024
        },
        "clues": [
          "the person who likes salsa music is to the right of the person who works as a accountant (not necessarily immediately)",
          "the person who likes salsa music is directly between the person who works as a doctor and the person who likes funk music"
        ],
        "categories": [
          "Job",
          "Music"
        ],
        "items": {
          "Job": [
            "accountant",
            "electrician",
            "doctor"
          ],
          "Music": [
            "funk",
            "salsa",
            "hip-hop"
          ]
        },
        "ground_truth_solution": "{\"Job\": [\"accountant\", \"electrician\", \"doctor\"], \"Music\": [\"funk\", \"salsa\", \"hip-hop\"]}"
      },
      "puzzle_hash": "86f89ad5be4720866d92295803442bc9",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Job\", \"Music\"]\n    items = {\n        \"Job\": [\"accountant\", \"electrician\", \"doctor\"],\n        \"Music\": [\"funk\", \"salsa\", \"hip-hop\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes salsa music is to the right of the person who works as a accountant (not necessarily immediately)\n    problem.addConstraint(lambda salsa_pos, accountant_pos: salsa_pos > accountant_pos,\n                          [\"Music:salsa\", \"Job:accountant\"])\n    \n    # Clue 2: the person who likes salsa music is directly between the person who works as a doctor and the person who likes funk music\n    # That means salsa_pos is between doctor_pos and funk_pos\n    problem.addConstraint(lambda salsa_pos, doctor_pos, funk_pos:\n                          (salsa_pos == doctor_pos + 1 and salsa_pos == funk_pos - 1) or\n                          (salsa_pos == funk_pos + 1 and salsa_pos == doctor_pos - 1),\n                          [\"Music:salsa\", \"Job:doctor\", \"Music:funk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['accountant', 'electrician', 'doctor'], 'Music': ['funk', 'salsa', 'hip-hop']}\n",
      "success": true,
      "execution_time": 0.002161,
      "timestamp": "20250918_085805",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['accountant', 'electrician', 'doctor'], 'Music': ['funk', 'salsa', 'hip-hop']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    },
    {
      "puzzle_id": "simple_2x3_100",
      "puzzle": {
        "id": "simple_2x3_100",
        "title": "Einstein Puzzle simple_2x3_100 (2x3, level 12)",
        "problem": "You are given an Einstein logic puzzle with 3 houses and 2 attributes. Each house has exactly one attribute from each category. No two houses share the same attribute from any category. Your task is to determine which attributes belong to which house based on the given clues.",
        "source": "generated_simple",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 3,
          "difficulty_level": 12,
          "generation_time": 0.00416354200000002
        },
        "clues": [
          "the person who enjoys traveling is to the right of the person who has guinea-pig as a pet (not necessarily immediately)",
          "the person who has frog as a pet is immediately to the left of the person who enjoys traveling",
          "the person who enjoys magic-tricks is immediately to the left of the person who has ferret as a pet"
        ],
        "categories": [
          "Hobby",
          "Pet"
        ],
        "items": {
          "Hobby": [
            "reading",
            "magic-tricks",
            "traveling"
          ],
          "Pet": [
            "guinea-pig",
            "frog",
            "ferret"
          ]
        },
        "ground_truth_solution": "{\"Hobby\": [\"reading\", \"magic-tricks\", \"traveling\"], \"Pet\": [\"guinea-pig\", \"frog\", \"ferret\"]}"
      },
      "puzzle_hash": "01a1697ed12a8782931e26bdf4810c02",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 3\n    \n    categories = [\"Hobby\", \"Pet\"]\n    items = {\n        \"Hobby\": [\"reading\", \"magic-tricks\", \"traveling\"],\n        \"Pet\": [\"guinea-pig\", \"frog\", \"ferret\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who enjoys traveling is to the right of the person who has guinea-pig as a pet (not necessarily immediately)\n    problem.addConstraint(lambda traveling, guinea_pig: traveling > guinea_pig,\n                          [\"Hobby:traveling\", \"Pet:guinea-pig\"])\n    \n    # Clue 2: the person who has frog as a pet is immediately to the left of the person who enjoys traveling\n    problem.addConstraint(lambda frog, traveling: frog == traveling - 1,\n                          [\"Pet:frog\", \"Hobby:traveling\"])\n    \n    # Clue 3: the person who enjoys magic-tricks is immediately to the left of the person who has ferret as a pet\n    problem.addConstraint(lambda magic, ferret: magic == ferret - 1,\n                          [\"Hobby:magic-tricks\", \"Pet:ferret\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['reading', 'magic-tricks', 'traveling'], 'Pet': ['guinea-pig', 'frog', 'ferret']}\n",
      "success": true,
      "execution_time": 0.002821,
      "timestamp": "20250918_085814",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['reading', 'magic-tricks', 'traveling'], 'Pet': ['guinea-pig', 'frog', 'ferret']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250918_084345"
      }
    }
  ],
  "metadata": {
    "data_source": "EinsteinPuzzleLoader",
    "last_updated": "2025-09-18 08:58:14",
    "success_rate": 0.94,
    "successful_puzzles": 94,
    "timestamp": "20250918_084345",
    "total_puzzles_planned": 100,
    "total_puzzles_processed": 100,
    "verification_success_count": 94,
    "verification_success_rate": 0.94,
    "verified_puzzles": 100,
    "solver_type": "EinsteinPuzzleSolver",
    "dataset_name": "einstein",
    "dataset_split": null,
    "average_execution_time": 0.0034388900000000017,
    "run_id": "20250918_084345"
  },
  "timestamp": "20250918_084345",
  "version": "1.0"
}