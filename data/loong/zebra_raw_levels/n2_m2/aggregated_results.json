{
  "results": [
    {
      "puzzle_id": "einstein_2x2_5_61764495",
      "puzzle": {
        "id": "einstein_2x2_5_61764495",
        "title": "Zebra Puzzle einstein_2x2_5_61764495",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Nationality: polish, chinese\n2. Sport: swimming, water-polo\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who plays swimming is immediately to the left of the chinese person\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Nationality\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 5,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0006565840449184179,
          "n_level": 1,
          "table_markdown": "|               |    1     |     2      |\n| Nationality   | polish   | chinese    |\n| Sport         | swimming | water-polo |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Nationality\": [\"polish\", \"chinese\"], \"Sport\": [\"swimming\", \"water-polo\"]}"
      },
      "puzzle_hash": "52c1ac3fcc014482708fa87f8cad20b7",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Sport\"]\n    items = {\n        \"Nationality\": [\"polish\", \"chinese\"],\n        \"Sport\": [\"swimming\", \"water-polo\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who plays swimming is immediately to the left of the chinese person\n    problem.addConstraint(lambda swim_pos, chinese_pos: swim_pos == chinese_pos - 1,\n                          [\"Sport:swimming\", \"Nationality:chinese\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['polish', 'chinese'], 'Sport': ['swimming', 'water-polo']}\n",
      "success": true,
      "execution_time": 0.001419,
      "timestamp": "20250814_084052",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['polish', 'chinese'], 'Sport': ['swimming', 'water-polo']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_6_6a1da99b",
      "puzzle": {
        "id": "einstein_2x2_6_6a1da99b",
        "title": "Zebra Puzzle einstein_2x2_6_6a1da99b",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Nationality: spanish, italian\n2. Hobby: singing, magic-tricks\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys singing is immediately to the right of the italian person\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Nationality\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 6,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005174998659640551,
          "n_level": 1,
          "table_markdown": "|               |      1       |    2    |\n| Hobby         | magic-tricks | singing |\n| Nationality   | italian      | spanish |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"magic-tricks\", \"singing\"], \"Nationality\": [\"italian\", \"spanish\"]}"
      },
      "puzzle_hash": "4f90d7090c75f04c4373ac04aea353f1",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Hobby\"]\n    items = {\n        \"Nationality\": [\"spanish\", \"italian\"],\n        \"Hobby\": [\"singing\", \"magic-tricks\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who enjoys singing is immediately to the right of the italian person\n    problem.addConstraint(lambda italian_pos, singing_pos: singing_pos == italian_pos + 1,\n                          [\"Nationality:italian\", \"Hobby:singing\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['italian', 'spanish'], 'Hobby': ['magic-tricks', 'singing']}\n",
      "success": true,
      "execution_time": 0.001638,
      "timestamp": "20250814_084056",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['magic-tricks', 'singing'], 'Nationality': ['italian', 'spanish']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_7_cd418c5a",
      "puzzle": {
        "id": "einstein_2x2_7_cd418c5a",
        "title": "Zebra Puzzle einstein_2x2_7_cd418c5a",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Transport: snowmobile, boat\n2. Job: engineer, doctor\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who uses boat for transportation is immediately to the right of the person who works as a doctor\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Job\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 7,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003723751287907362,
          "n_level": 1,
          "table_markdown": "|             |     1      |    2     |\n| Job         | doctor     | engineer |\n| Transport   | snowmobile | boat     |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Job\": [\"doctor\", \"engineer\"], \"Transport\": [\"snowmobile\", \"boat\"]}"
      },
      "puzzle_hash": "ee6d282c6af1f0804f3462571936001c",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Transport\", \"Job\"]\n    items = {\n        \"Transport\": [\"snowmobile\", \"boat\"],\n        \"Job\": [\"engineer\", \"doctor\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who uses boat for transportation is immediately to the right of the person who works as a doctor\n    problem.addConstraint(lambda doctor_pos, boat_pos: boat_pos == doctor_pos + 1, [\"Job:doctor\", \"Transport:boat\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Transport': ['snowmobile', 'boat'], 'Job': ['doctor', 'engineer']}\n",
      "success": true,
      "execution_time": 0.002233,
      "timestamp": "20250814_084100",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['doctor', 'engineer'], 'Transport': ['snowmobile', 'boat']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_8_1569a624",
      "puzzle": {
        "id": "einstein_2x2_8_1569a624",
        "title": "Zebra Puzzle einstein_2x2_8_1569a624",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Transport: jet-ski, scooter\n2. Hobby: hiking, magic-tricks\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys hiking is immediately to the left of the person who uses scooter for transportation\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 8,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.000527125084772706,
          "n_level": 1,
          "table_markdown": "|             |    1    |      2       |\n| Hobby       | hiking  | magic-tricks |\n| Transport   | jet-ski | scooter      |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"hiking\", \"magic-tricks\"], \"Transport\": [\"jet-ski\", \"scooter\"]}"
      },
      "puzzle_hash": "db45d6d7bf6928d43df285bf4da027b7",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Transport\", \"Hobby\"]\n    items = {\n        \"Transport\": [\"jet-ski\", \"scooter\"],\n        \"Hobby\": [\"hiking\", \"magic-tricks\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who enjoys hiking is immediately to the left of the person who uses scooter for transportation\n    problem.addConstraint(lambda hiking_pos, scooter_pos: hiking_pos == scooter_pos - 1,\n                          [\"Hobby:hiking\", \"Transport:scooter\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Transport': ['jet-ski', 'scooter'], 'Hobby': ['hiking', 'magic-tricks']}\n",
      "success": true,
      "execution_time": 0.001172,
      "timestamp": "20250814_084104",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['hiking', 'magic-tricks'], 'Transport': ['jet-ski', 'scooter']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_9_f9ae755a",
      "puzzle": {
        "id": "einstein_2x2_9_f9ae755a",
        "title": "Zebra Puzzle einstein_2x2_9_f9ae755a",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Nationality: indonesian, french\n2. Hobby: drawing, camping\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the indonesian person is immediately to the right of the person who enjoys camping\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Nationality\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 9,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.002286624861881137,
          "n_level": 1,
          "table_markdown": "|               |    1    |     2      |\n| Hobby         | camping | drawing    |\n| Nationality   | french  | indonesian |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"camping\", \"drawing\"], \"Nationality\": [\"french\", \"indonesian\"]}"
      },
      "puzzle_hash": "c40caf1ea19db8fbf6b63b136d3791c8",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Hobby\"]\n    items = {\n        \"Nationality\": [\"indonesian\", \"french\"],\n        \"Hobby\": [\"drawing\", \"camping\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the indonesian person is immediately to the right of the person who enjoys camping\n    problem.addConstraint(lambda ind, camp: ind == camp + 1, [\"Nationality:indonesian\", \"Hobby:camping\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['french', 'indonesian'], 'Hobby': ['camping', 'drawing']}\n",
      "success": true,
      "execution_time": 0.001205,
      "timestamp": "20250814_084109",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['camping', 'drawing'], 'Nationality': ['french', 'indonesian']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_10_119f1a68",
      "puzzle": {
        "id": "einstein_2x2_10_119f1a68",
        "title": "Zebra Puzzle einstein_2x2_10_119f1a68",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Transport: tram, airplane\n2. Beverage: lemonade, iced-tea\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who uses airplane for transportation is immediately to the left of the person who likes lemonade\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 10,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0006342921406030655,
          "n_level": 1,
          "table_markdown": "|             |    1     |    2     |\n| Beverage    | iced-tea | lemonade |\n| Transport   | airplane | tram     |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"iced-tea\", \"lemonade\"], \"Transport\": [\"airplane\", \"tram\"]}"
      },
      "puzzle_hash": "28bb65ac5237ecde123ef5c714f1b246",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Transport\", \"Beverage\"]\n    items = {\n        \"Transport\": [\"tram\", \"airplane\"],\n        \"Beverage\": [\"lemonade\", \"iced-tea\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who uses airplane for transportation is immediately to the left of the person who likes lemonade\n    problem.addConstraint(lambda airplane_pos, lemonade_pos: airplane_pos == lemonade_pos - 1,\n                          [\"Transport:airplane\", \"Beverage:lemonade\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Transport': ['airplane', 'tram'], 'Beverage': ['iced-tea', 'lemonade']}\n",
      "success": true,
      "execution_time": 0.001175,
      "timestamp": "20250814_084114",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['iced-tea', 'lemonade'], 'Transport': ['airplane', 'tram']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_11_381a84c4",
      "puzzle": {
        "id": "einstein_2x2_11_381a84c4",
        "title": "Zebra Puzzle einstein_2x2_11_381a84c4",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: climbing, skateboarding\n2. Beverage: cola, coffee\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes cola is immediately to the left of the person who plays skateboarding\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 11,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0004676668904721737,
          "n_level": 1,
          "table_markdown": "|            |    1     |       2       |\n| Beverage   | cola     | coffee        |\n| Sport      | climbing | skateboarding |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"cola\", \"coffee\"], \"Sport\": [\"climbing\", \"skateboarding\"]}"
      },
      "puzzle_hash": "a22e30ee8998856db52c60466ec6faf4",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Beverage\"]\n    items = {\n        \"Sport\": [\"climbing\", \"skateboarding\"],\n        \"Beverage\": [\"cola\", \"coffee\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes cola is immediately to the left of the person who plays skateboarding\n    problem.addConstraint(lambda cola_pos, skate_pos: cola_pos == skate_pos - 1,\n                          [\"Beverage:cola\", \"Sport:skateboarding\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['climbing', 'skateboarding'], 'Beverage': ['cola', 'coffee']}\n",
      "success": true,
      "execution_time": 0.001154,
      "timestamp": "20250814_084118",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['cola', 'coffee'], 'Sport': ['climbing', 'skateboarding']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_12_1ae6cb3f",
      "puzzle": {
        "id": "einstein_2x2_12_1ae6cb3f",
        "title": "Zebra Puzzle einstein_2x2_12_1ae6cb3f",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Nationality: italian, polish\n2. Sport: handball, cricket\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who plays cricket is immediately to the left of the polish person\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Nationality\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 12,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003937501460313797,
          "n_level": 1,
          "table_markdown": "|               |    1    |    2     |\n| Nationality   | italian | polish   |\n| Sport         | cricket | handball |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Nationality\": [\"italian\", \"polish\"], \"Sport\": [\"cricket\", \"handball\"]}"
      },
      "puzzle_hash": "16a197a336cb571091423684fc102fd5",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Sport\"]\n    items = {\n        \"Nationality\": [\"italian\", \"polish\"],\n        \"Sport\": [\"handball\", \"cricket\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # 1. the person who plays cricket is immediately to the left of the polish person\n    problem.addConstraint(lambda cricket_pos, polish_pos: cricket_pos == polish_pos - 1,\n                          [\"Sport:cricket\", \"Nationality:polish\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['italian', 'polish'], 'Sport': ['cricket', 'handball']}\n",
      "success": true,
      "execution_time": 0.001252,
      "timestamp": "20250814_084122",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['italian', 'polish'], 'Sport': ['cricket', 'handball']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_13_b0e1d950",
      "puzzle": {
        "id": "einstein_2x2_13_b0e1d950",
        "title": "Zebra Puzzle einstein_2x2_13_b0e1d950",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Job: doctor, dancer\n2. Movie: action, comedy\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. 0 is at position 2\n2. the person who works as a dancer is immediately to the right of the person who works as a doctor\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Job\", \"Movie\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 13,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0008156672120094299,
          "n_level": 1,
          "table_markdown": "|         |   1    |   2    |\n| Job     | doctor | dancer |\n| Movie   | comedy | action |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Job\": [\"doctor\", \"dancer\"], \"Movie\": [\"comedy\", \"action\"]}"
      },
      "puzzle_hash": "035e760540fabb7eed325829ee686db4",
      "code": null,
      "execution_result": "Error: 1 validation error for VerificationResult\nground_truth\n  Input should be a valid string [type=string_type, input_value={'Job': ['doctor', 'dance...': ['comedy', 'action']}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/string_type",
      "success": false,
      "execution_time": null,
      "timestamp": "20250814_084127",
      "verification": null,
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_14_df392324",
      "puzzle": {
        "id": "einstein_2x2_14_df392324",
        "title": "Zebra Puzzle einstein_2x2_14_df392324",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: spy, action\n2. Pet: hedgehog, hamster\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes spy movies is immediately to the left of the person who has hedgehog as a pet\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Pet\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 14,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0006450831424444914,
          "n_level": 1,
          "table_markdown": "|         |    1    |    2     |\n| Movie   | spy     | action   |\n| Pet     | hamster | hedgehog |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"spy\", \"action\"], \"Pet\": [\"hamster\", \"hedgehog\"]}"
      },
      "puzzle_hash": "982a675238188c94dd1ff32b24503cb6",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Pet\"]\n    items = {\n        \"Movie\": [\"spy\", \"action\"],\n        \"Pet\": [\"hedgehog\", \"hamster\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes spy movies is immediately to the left of the person who has hedgehog as a pet\n    problem.addConstraint(lambda spy_pos, hedgehog_pos: spy_pos == hedgehog_pos - 1,\n                          [\"Movie:spy\", \"Pet:hedgehog\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['spy', 'action'], 'Pet': ['hamster', 'hedgehog']}\n",
      "success": true,
      "execution_time": 0.001315,
      "timestamp": "20250814_084131",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['spy', 'action'], 'Pet': ['hamster', 'hedgehog']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_15_9c83944e",
      "puzzle": {
        "id": "einstein_2x2_15_9c83944e",
        "title": "Zebra Puzzle einstein_2x2_15_9c83944e",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: snowboarding, sailing\n2. Job: analyst, freelancer\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who plays sailing is immediately to the left of the person who works as a analyst\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Job\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 15,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00031137512996792793,
          "n_level": 1,
          "table_markdown": "|         |     1      |      2       |\n| Job     | freelancer | analyst      |\n| Sport   | sailing    | snowboarding |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Job\": [\"freelancer\", \"analyst\"], \"Sport\": [\"sailing\", \"snowboarding\"]}"
      },
      "puzzle_hash": "b99b3f260111691f5f8aa40e8405d3c7",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Job\"]\n    items = {\n        \"Sport\": [\"snowboarding\", \"sailing\"],\n        \"Job\": [\"analyst\", \"freelancer\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who plays sailing is immediately to the left of the person who works as a analyst\n    problem.addConstraint(lambda sailing_pos, analyst_pos: sailing_pos == analyst_pos - 1,\n                          [\"Sport:sailing\", \"Job:analyst\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['sailing', 'snowboarding'], 'Job': ['freelancer', 'analyst']}\n",
      "success": true,
      "execution_time": 0.001857,
      "timestamp": "20250814_084137",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['freelancer', 'analyst'], 'Sport': ['sailing', 'snowboarding']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_16_8c0368c5",
      "puzzle": {
        "id": "einstein_2x2_16_8c0368c5",
        "title": "Zebra Puzzle einstein_2x2_16_8c0368c5",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: swimming, weightlifting\n2. Hobby: sudoku, baking\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys sudoku is immediately to the right of the person who plays weightlifting\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 16,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005476248916238546,
          "n_level": 1,
          "table_markdown": "|         |       1       |    2     |\n| Hobby   | baking        | sudoku   |\n| Sport   | weightlifting | swimming |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"baking\", \"sudoku\"], \"Sport\": [\"weightlifting\", \"swimming\"]}"
      },
      "puzzle_hash": "bed689c6d91152c3745da30ec2820f3e",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Hobby\"]\n    items = {\n        \"Sport\": [\"swimming\", \"weightlifting\"],\n        \"Hobby\": [\"sudoku\", \"baking\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who enjoys sudoku is immediately to the right of the person who plays weightlifting\n    problem.addConstraint(lambda weightlifting_pos, sudoku_pos: weightlifting_pos == sudoku_pos - 1,\n                          [\"Sport:weightlifting\", \"Hobby:sudoku\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['weightlifting', 'swimming'], 'Hobby': ['baking', 'sudoku']}\n",
      "success": true,
      "execution_time": 0.001953,
      "timestamp": "20250814_084141",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['baking', 'sudoku'], 'Sport': ['weightlifting', 'swimming']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_17_7252c61e",
      "puzzle": {
        "id": "einstein_2x2_17_7252c61e",
        "title": "Zebra Puzzle einstein_2x2_17_7252c61e",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Job: firefighter, musician\n2. Transport: skateboard, van\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who works as a firefighter is immediately to the right of the person who uses van for transportation\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Job\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 17,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0004028750117868185,
          "n_level": 1,
          "table_markdown": "|             |    1     |      2      |\n| Job         | musician | firefighter |\n| Transport   | van      | skateboard  |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Job\": [\"musician\", \"firefighter\"], \"Transport\": [\"van\", \"skateboard\"]}"
      },
      "puzzle_hash": "04af452efa2da5305171176508644fa7",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Job\", \"Transport\"]\n    items = {\n        \"Job\": [\"firefighter\", \"musician\"],\n        \"Transport\": [\"skateboard\", \"van\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who works as a firefighter is immediately to the right of the person who uses van for transportation\n    problem.addConstraint(lambda firefighter_pos, van_pos: firefighter_pos == van_pos + 1,\n                          [\"Job:firefighter\", \"Transport:van\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['musician', 'firefighter'], 'Transport': ['van', 'skateboard']}\n",
      "success": true,
      "execution_time": 0.001261,
      "timestamp": "20250814_084144",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['musician', 'firefighter'], 'Transport': ['van', 'skateboard']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_18_88a5a16b",
      "puzzle": {
        "id": "einstein_2x2_18_88a5a16b",
        "title": "Zebra Puzzle einstein_2x2_18_88a5a16b",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: cycling, rugby\n2. Music: electronic, country\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes electronic music is immediately to the right of the person who plays rugby\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Music\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 18,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00039016688242554665,
          "n_level": 1,
          "table_markdown": "|         |    1    |     2      |\n| Music   | country | electronic |\n| Sport   | rugby   | cycling    |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Music\": [\"country\", \"electronic\"], \"Sport\": [\"rugby\", \"cycling\"]}"
      },
      "puzzle_hash": "9774083e56b5dcdc2b8727dc73b8afe5",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Music\"]\n    items = {\n        \"Sport\": [\"cycling\", \"rugby\"],\n        \"Music\": [\"electronic\", \"country\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes electronic music is immediately to the right of the person who plays rugby\n    problem.addConstraint(lambda rugby_pos, electronic_pos: rugby_pos == electronic_pos - 1,\n                          [\"Sport:rugby\", \"Music:electronic\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['rugby', 'cycling'], 'Music': ['country', 'electronic']}\n",
      "success": true,
      "execution_time": 0.002556,
      "timestamp": "20250814_084148",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['country', 'electronic'], 'Sport': ['rugby', 'cycling']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_19_a95155d7",
      "puzzle": {
        "id": "einstein_2x2_19_a95155d7",
        "title": "Zebra Puzzle einstein_2x2_19_a95155d7",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Hobby: photography, sudoku\n2. Movie: martial-arts, epic\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys photography is immediately to the right of the person who likes epic movies\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Movie\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 19,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0004957912024110556,
          "n_level": 1,
          "table_markdown": "|         |   1    |      2       |\n| Hobby   | sudoku | photography  |\n| Movie   | epic   | martial-arts |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"sudoku\", \"photography\"], \"Movie\": [\"epic\", \"martial-arts\"]}"
      },
      "puzzle_hash": "1fb0ae2008530ec3cb9164c7673f4877",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Hobby\", \"Movie\"]\n    items = {\n        \"Hobby\": [\"photography\", \"sudoku\"],\n        \"Movie\": [\"martial-arts\", \"epic\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who enjoys photography is immediately to the right of the person who likes epic movies\n    problem.addConstraint(lambda photo_pos, epic_pos: photo_pos == epic_pos + 1, [\"Hobby:photography\", \"Movie:epic\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['sudoku', 'photography'], 'Movie': ['epic', 'martial-arts']}\n",
      "success": true,
      "execution_time": 0.001155,
      "timestamp": "20250814_084153",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['sudoku', 'photography'], 'Movie': ['epic', 'martial-arts']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_20_eda9d11c",
      "puzzle": {
        "id": "einstein_2x2_20_eda9d11c",
        "title": "Zebra Puzzle einstein_2x2_20_eda9d11c",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Nationality: malaysian, dutch\n2. Pet: hamster, chinchilla\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the malaysian person is at position 1 (the leftmost position)\n2. the person who has hamster as a pet is the same person as the malaysian person\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Nationality\", \"Pet\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 20,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0009994169231504202,
          "n_level": 1,
          "table_markdown": "|               |     1     |     2      |\n| Nationality   | malaysian | dutch      |\n| Pet           | hamster   | chinchilla |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Nationality\": [\"malaysian\", \"dutch\"], \"Pet\": [\"hamster\", \"chinchilla\"]}"
      },
      "puzzle_hash": "16ace27a3b0f4c7f19dda685ed9e28a3",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Pet\"]\n    items = {\n        \"Nationality\": [\"malaysian\", \"dutch\"],\n        \"Pet\": [\"hamster\", \"chinchilla\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the malaysian person is at position 1 (leftmost position, index 0)\n    problem.addConstraint(lambda x: x == 0, [\"Nationality:malaysian\"])\n    \n    # Clue 2: the person who has hamster as a pet is the same person as the malaysian person\n    problem.addConstraint(lambda x, y: x == y, [\"Nationality:malaysian\", \"Pet:hamster\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['malaysian', 'dutch'], 'Pet': ['hamster', 'chinchilla']}\n",
      "success": true,
      "execution_time": 0.001174,
      "timestamp": "20250814_084158",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['malaysian', 'dutch'], 'Pet': ['hamster', 'chinchilla']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_21_c2fc5bf9",
      "puzzle": {
        "id": "einstein_2x2_21_c2fc5bf9",
        "title": "Zebra Puzzle einstein_2x2_21_c2fc5bf9",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: baseball, rowing\n2. Music: rock, disco\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes disco music is immediately to the right of the person who plays baseball\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Music\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 21,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003171658609062433,
          "n_level": 1,
          "table_markdown": "|         |    1     |   2    |\n| Music   | rock     | disco  |\n| Sport   | baseball | rowing |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Music\": [\"rock\", \"disco\"], \"Sport\": [\"baseball\", \"rowing\"]}"
      },
      "puzzle_hash": "382e66610260eb9494837b1dcff0c78a",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Music\"]\n    items = {\n        \"Sport\": [\"baseball\", \"rowing\"],\n        \"Music\": [\"rock\", \"disco\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes disco music is immediately to the right of the person who plays baseball\n    problem.addConstraint(lambda baseball_pos, disco_pos: baseball_pos == disco_pos - 1,\n                          [\"Sport:baseball\", \"Music:disco\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['baseball', 'rowing'], 'Music': ['rock', 'disco']}\n",
      "success": true,
      "execution_time": 0.001351,
      "timestamp": "20250814_084201",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['rock', 'disco'], 'Sport': ['baseball', 'rowing']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_22_0266ed1a",
      "puzzle": {
        "id": "einstein_2x2_22_0266ed1a",
        "title": "Zebra Puzzle einstein_2x2_22_0266ed1a",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Job: librarian, architect\n2. Hobby: baking, camping\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who works as a librarian is immediately to the right of the person who enjoys baking\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Job\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 22,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00041741691529750824,
          "n_level": 1,
          "table_markdown": "|         |     1     |     2     |\n| Hobby   | baking    | camping   |\n| Job     | architect | librarian |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"baking\", \"camping\"], \"Job\": [\"architect\", \"librarian\"]}"
      },
      "puzzle_hash": "23bdd89ed19403c578e911469c905e0b",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Job\", \"Hobby\"]\n    items = {\n        \"Job\": [\"librarian\", \"architect\"],\n        \"Hobby\": [\"baking\", \"camping\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who works as a librarian is immediately to the right of the person who enjoys baking\n    problem.addConstraint(lambda librarian_pos, baking_pos: librarian_pos == baking_pos + 1,\n                          [\"Job:librarian\", \"Hobby:baking\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['architect', 'librarian'], 'Hobby': ['baking', 'camping']}\n",
      "success": true,
      "execution_time": 0.002038,
      "timestamp": "20250814_084206",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['baking', 'camping'], 'Job': ['architect', 'librarian']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_23_1bc2f001",
      "puzzle": {
        "id": "einstein_2x2_23_1bc2f001",
        "title": "Zebra Puzzle einstein_2x2_23_1bc2f001",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: crime, epic\n2. Nationality: german, dutch\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes epic movies is immediately to the left of the german person\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Nationality\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 23,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003751248586922884,
          "n_level": 1,
          "table_markdown": "|               |   1   |   2    |\n| Movie         | epic  | crime  |\n| Nationality   | dutch | german |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"epic\", \"crime\"], \"Nationality\": [\"dutch\", \"german\"]}"
      },
      "puzzle_hash": "a7ac27a6d3db1684249b6935b01f9a4a",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Nationality\"]\n    items = {\n        \"Movie\": [\"crime\", \"epic\"],\n        \"Nationality\": [\"german\", \"dutch\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes epic movies is immediately to the left of the german person\n    problem.addConstraint(lambda epic_pos, german_pos: epic_pos == german_pos - 1,\n                          [\"Movie:epic\", \"Nationality:german\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['epic', 'crime'], 'Nationality': ['dutch', 'german']}\n",
      "success": true,
      "execution_time": 0.004381,
      "timestamp": "20250814_084210",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['epic', 'crime'], 'Nationality': ['dutch', 'german']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_24_65f3a734",
      "puzzle": {
        "id": "einstein_2x2_24_65f3a734",
        "title": "Zebra Puzzle einstein_2x2_24_65f3a734",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: basketball, ice-hockey\n2. Music: ambient, house\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes ambient music is immediately to the right of the person who plays ice-hockey\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Music\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 24,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00044841598719358444,
          "n_level": 1,
          "table_markdown": "|         |     1      |     2      |\n| Music   | house      | ambient    |\n| Sport   | ice-hockey | basketball |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Music\": [\"house\", \"ambient\"], \"Sport\": [\"ice-hockey\", \"basketball\"]}"
      },
      "puzzle_hash": "48809a48b956b47070af577e615556b0",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Music\"]\n    items = {\n        \"Sport\": [\"basketball\", \"ice-hockey\"],\n        \"Music\": [\"ambient\", \"house\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes ambient music is immediately to the right of the person who plays ice-hockey\n    problem.addConstraint(lambda ice_hockey_pos, ambient_pos: ambient_pos == ice_hockey_pos + 1,\n                          [\"Sport:ice-hockey\", \"Music:ambient\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['ice-hockey', 'basketball'], 'Music': ['house', 'ambient']}\n",
      "success": true,
      "execution_time": 0.001184,
      "timestamp": "20250814_084215",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['house', 'ambient'], 'Sport': ['ice-hockey', 'basketball']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_25_d4e03f73",
      "puzzle": {
        "id": "einstein_2x2_25_d4e03f73",
        "title": "Zebra Puzzle einstein_2x2_25_d4e03f73",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Nationality: argentine, mexican\n2. Music: soul, pop\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes soul music is immediately to the right of the mexican person\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Music\", \"Nationality\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 25,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0004252498038113117,
          "n_level": 1,
          "table_markdown": "|               |    1    |     2     |\n| Music         | pop     | soul      |\n| Nationality   | mexican | argentine |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Music\": [\"pop\", \"soul\"], \"Nationality\": [\"mexican\", \"argentine\"]}"
      },
      "puzzle_hash": "4cdc6695c99ee407747dfd1183a74523",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Music\"]\n    items = {\n        \"Nationality\": [\"argentine\", \"mexican\"],\n        \"Music\": [\"soul\", \"pop\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes soul music is immediately to the right of the mexican person\n    problem.addConstraint(lambda mexican_pos, soul_pos: soul_pos == mexican_pos + 1,\n                          [\"Nationality:mexican\", \"Music:soul\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['mexican', 'argentine'], 'Music': ['pop', 'soul']}\n",
      "success": true,
      "execution_time": 0.001202,
      "timestamp": "20250814_084219",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['pop', 'soul'], 'Nationality': ['mexican', 'argentine']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_26_9908e338",
      "puzzle": {
        "id": "einstein_2x2_26_9908e338",
        "title": "Zebra Puzzle einstein_2x2_26_9908e338",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Job: architect, dancer\n2. Nationality: chinese, canadian\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who works as a dancer is immediately to the left of the canadian person\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Job\", \"Nationality\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 26,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00035187508910894394,
          "n_level": 1,
          "table_markdown": "|               |    1    |     2     |\n| Job           | dancer  | architect |\n| Nationality   | chinese | canadian  |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Job\": [\"dancer\", \"architect\"], \"Nationality\": [\"chinese\", \"canadian\"]}"
      },
      "puzzle_hash": "50fe4619f0820e7f56a74225c3cc779d",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Job\", \"Nationality\"]\n    items = {\n        \"Job\": [\"architect\", \"dancer\"],\n        \"Nationality\": [\"chinese\", \"canadian\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who works as a dancer is immediately to the left of the canadian person\n    problem.addConstraint(lambda dancer_pos, canadian_pos: dancer_pos == canadian_pos - 1,\n                          [\"Job:dancer\", \"Nationality:canadian\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['dancer', 'architect'], 'Nationality': ['chinese', 'canadian']}\n",
      "success": true,
      "execution_time": 0.001151,
      "timestamp": "20250814_084223",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['dancer', 'architect'], 'Nationality': ['chinese', 'canadian']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_27_b570d741",
      "puzzle": {
        "id": "einstein_2x2_27_b570d741",
        "title": "Zebra Puzzle einstein_2x2_27_b570d741",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: cycling, cricket\n2. Food: peas, lettuce\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes peas is immediately to the left of the person who plays cycling\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 27,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0006883328314870596,
          "n_level": 1,
          "table_markdown": "|         |    1    |    2    |\n| Food    | peas    | lettuce |\n| Sport   | cricket | cycling |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"peas\", \"lettuce\"], \"Sport\": [\"cricket\", \"cycling\"]}"
      },
      "puzzle_hash": "53b65d507f791cb7d3e0196fae9236e0",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Food\", \"Sport\"]\n    items = {\n        \"Food\": [\"peas\", \"lettuce\"],\n        \"Sport\": [\"cycling\", \"cricket\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # the person who likes peas is immediately to the left of the person who plays cycling\n    problem.addConstraint(lambda peas_pos, cycling_pos: peas_pos == cycling_pos - 1,\n                          [\"Food:peas\", \"Sport:cycling\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['peas', 'lettuce'], 'Sport': ['cricket', 'cycling']}\n",
      "success": true,
      "execution_time": 0.001589,
      "timestamp": "20250814_084227",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['peas', 'lettuce'], 'Sport': ['cricket', 'cycling']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_28_7b45e62e",
      "puzzle": {
        "id": "einstein_2x2_28_7b45e62e",
        "title": "Zebra Puzzle einstein_2x2_28_7b45e62e",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Pet: goldfish, hamster\n2. Sport: skateboarding, cricket\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who has hamster as a pet is immediately to the left of the person who plays cricket\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Pet\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 28,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005930829793214798,
          "n_level": 1,
          "table_markdown": "|         |       1       |    2     |\n| Pet     | hamster       | goldfish |\n| Sport   | skateboarding | cricket  |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Pet\": [\"hamster\", \"goldfish\"], \"Sport\": [\"skateboarding\", \"cricket\"]}"
      },
      "puzzle_hash": "cc473b9ed74913c8139ac250b1229ba8",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Pet\", \"Sport\"]\n    items = {\n        \"Pet\": [\"goldfish\", \"hamster\"],\n        \"Sport\": [\"skateboarding\", \"cricket\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who has hamster as a pet is immediately to the left of the person who plays cricket\n    problem.addConstraint(lambda hamster_pos, cricket_pos: hamster_pos == cricket_pos - 1,\n                          [\"Pet:hamster\", \"Sport:cricket\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Pet': ['hamster', 'goldfish'], 'Sport': ['skateboarding', 'cricket']}\n",
      "success": true,
      "execution_time": 0.001203,
      "timestamp": "20250814_084231",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Pet': ['hamster', 'goldfish'], 'Sport': ['skateboarding', 'cricket']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_29_1397391b",
      "puzzle": {
        "id": "einstein_2x2_29_1397391b",
        "title": "Zebra Puzzle einstein_2x2_29_1397391b",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Pet: guinea-pig, turtle\n2. Sport: skateboarding, surfing\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who plays skateboarding is the same person as the person who has guinea-pig as a pet\n2. the person who plays surfing is at position 1 (the leftmost position)\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Pet\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 29,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.001423874869942665,
          "n_level": 1,
          "table_markdown": "|         |    1    |       2       |\n| Pet     | turtle  | guinea-pig    |\n| Sport   | surfing | skateboarding |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Pet\": [\"turtle\", \"guinea-pig\"], \"Sport\": [\"surfing\", \"skateboarding\"]}"
      },
      "puzzle_hash": "425314c8b395fbf80cdc609d89b34411",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Pet\", \"Sport\"]\n    items = {\n        \"Pet\": [\"guinea-pig\", \"turtle\"],\n        \"Sport\": [\"skateboarding\", \"surfing\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays skateboarding is the same person as the person who has guinea-pig as a pet\n    problem.addConstraint(lambda skateboarding_pos, guinea_pig_pos: skateboarding_pos == guinea_pig_pos,\n                          [\"Sport:skateboarding\", \"Pet:guinea-pig\"])\n    \n    # Clue 2: the person who plays surfing is at position 1 (leftmost position, zero-indexed 0)\n    problem.addConstraint(lambda surfing_pos: surfing_pos == 0, [\"Sport:surfing\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Pet': ['turtle', 'guinea-pig'], 'Sport': ['surfing', 'skateboarding']}\n",
      "success": true,
      "execution_time": 0.001505,
      "timestamp": "20250814_084236",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Pet': ['turtle', 'guinea-pig'], 'Sport': ['surfing', 'skateboarding']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_30_f4a72182",
      "puzzle": {
        "id": "einstein_2x2_30_f4a72182",
        "title": "Zebra Puzzle einstein_2x2_30_f4a72182",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Nationality: pakistani, indonesian\n2. Movie: satire, documentary\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes documentary movies is immediately to the right of the pakistani person\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Nationality\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 30,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003726249560713768,
          "n_level": 1,
          "table_markdown": "|               |     1     |      2      |\n| Movie         | satire    | documentary |\n| Nationality   | pakistani | indonesian  |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"satire\", \"documentary\"], \"Nationality\": [\"pakistani\", \"indonesian\"]}"
      },
      "puzzle_hash": "be72558421fc160be1efdd989a54ebc9",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Movie\"]\n    items = {\n        \"Nationality\": [\"pakistani\", \"indonesian\"],\n        \"Movie\": [\"satire\", \"documentary\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes documentary movies is immediately to the right of the pakistani person\n    problem.addConstraint(lambda pakistani_pos, documentary_pos: documentary_pos == pakistani_pos + 1,\n                          [\"Nationality:pakistani\", \"Movie:documentary\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['pakistani', 'indonesian'], 'Movie': ['satire', 'documentary']}\n",
      "success": true,
      "execution_time": 0.001198,
      "timestamp": "20250814_084240",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['satire', 'documentary'], 'Nationality': ['pakistani', 'indonesian']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_31_bdade8e8",
      "puzzle": {
        "id": "einstein_2x2_31_bdade8e8",
        "title": "Zebra Puzzle einstein_2x2_31_bdade8e8",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Food: raspberry, lemon\n2. Sport: soccer, badminton\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes raspberry is immediately to the left of the person who plays badminton\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 31,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005240000318735838,
          "n_level": 1,
          "table_markdown": "|         |     1     |     2     |\n| Food    | raspberry | lemon     |\n| Sport   | soccer    | badminton |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"raspberry\", \"lemon\"], \"Sport\": [\"soccer\", \"badminton\"]}"
      },
      "puzzle_hash": "5a49f3a693915fdd7aa7e4583fd2e79a",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Food\", \"Sport\"]\n    items = {\n        \"Food\": [\"raspberry\", \"lemon\"],\n        \"Sport\": [\"soccer\", \"badminton\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # 1. the person who likes raspberry is immediately to the left of the person who plays badminton\n    problem.addConstraint(lambda raspberry_pos, badminton_pos: raspberry_pos == badminton_pos - 1,\n                          [\"Food:raspberry\", \"Sport:badminton\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['raspberry', 'lemon'], 'Sport': ['soccer', 'badminton']}\n",
      "success": true,
      "execution_time": 0.00119,
      "timestamp": "20250814_084243",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['raspberry', 'lemon'], 'Sport': ['soccer', 'badminton']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_32_bd1fa5d1",
      "puzzle": {
        "id": "einstein_2x2_32_bd1fa5d1",
        "title": "Zebra Puzzle einstein_2x2_32_bd1fa5d1",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Food: spinach, carrot\n2. Transport: helicopter, quad-bike\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes carrot is the same person as the person who uses helicopter for transportation\n2. 0 is at position 2\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 32,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0006738328374922276,
          "n_level": 1,
          "table_markdown": "|             |     1      |     2     |\n| Food        | carrot     | spinach   |\n| Transport   | helicopter | quad-bike |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"carrot\", \"spinach\"], \"Transport\": [\"helicopter\", \"quad-bike\"]}"
      },
      "puzzle_hash": "103f9722d1d2ad91fdd7f69c075987e6",
      "code": null,
      "execution_result": "Error: 1 validation error for VerificationResult\nground_truth\n  Input should be a valid string [type=string_type, input_value={'Food': ['carrot', 'spin...licopter', 'quad-bike']}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/string_type",
      "success": false,
      "execution_time": null,
      "timestamp": "20250814_084250",
      "verification": null,
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_33_4f4b58b6",
      "puzzle": {
        "id": "einstein_2x2_33_4f4b58b6",
        "title": "Zebra Puzzle einstein_2x2_33_4f4b58b6",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Nationality: indonesian, american\n2. Sport: rugby, cricket\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the american person is immediately to the left of the person who plays rugby\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Nationality\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 33,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00042566703632473946,
          "n_level": 1,
          "table_markdown": "|               |    1     |     2      |\n| Nationality   | american | indonesian |\n| Sport         | cricket  | rugby      |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Nationality\": [\"american\", \"indonesian\"], \"Sport\": [\"cricket\", \"rugby\"]}"
      },
      "puzzle_hash": "f1e419ce9a6122a81f10923200c0b6e4",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Sport\"]\n    items = {\n        \"Nationality\": [\"indonesian\", \"american\"],\n        \"Sport\": [\"rugby\", \"cricket\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # 1. the american person is immediately to the left of the person who plays rugby\n    problem.addConstraint(lambda american_pos, rugby_pos: american_pos == rugby_pos - 1,\n                          [\"Nationality:american\", \"Sport:rugby\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['american', 'indonesian'], 'Sport': ['cricket', 'rugby']}\n",
      "success": true,
      "execution_time": 0.001214,
      "timestamp": "20250814_084255",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['american', 'indonesian'], 'Sport': ['cricket', 'rugby']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_34_e9547dd6",
      "puzzle": {
        "id": "einstein_2x2_34_e9547dd6",
        "title": "Zebra Puzzle einstein_2x2_34_e9547dd6",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Job: designer, fisherman\n2. Music: techno, soul\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who works as a designer is immediately to the left of the person who likes techno music\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Job\", \"Music\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 34,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005288340616971254,
          "n_level": 1,
          "table_markdown": "|         |    1     |     2     |\n| Job     | designer | fisherman |\n| Music   | soul     | techno    |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Job\": [\"designer\", \"fisherman\"], \"Music\": [\"soul\", \"techno\"]}"
      },
      "puzzle_hash": "31022bdf3748a8864ed1cec0d9382af2",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Job\", \"Music\"]\n    items = {\n        \"Job\": [\"designer\", \"fisherman\"],\n        \"Music\": [\"techno\", \"soul\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # 1. the person who works as a designer is immediately to the left of the person who likes techno music\n    problem.addConstraint(lambda designer_pos, techno_pos: designer_pos == techno_pos - 1,\n                          [\"Job:designer\", \"Music:techno\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Job': ['designer', 'fisherman'], 'Music': ['soul', 'techno']}\n",
      "success": true,
      "execution_time": 0.001175,
      "timestamp": "20250814_084259",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['designer', 'fisherman'], 'Music': ['soul', 'techno']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_35_3517f121",
      "puzzle": {
        "id": "einstein_2x2_35_3517f121",
        "title": "Zebra Puzzle einstein_2x2_35_3517f121",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Hobby: hiking, magic-tricks\n2. Movie: adventure, comedy\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. 0 is at position 2\n2. the person who enjoys magic-tricks is at position 1 (the leftmost position)\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Movie\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 35,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0008367081172764301,
          "n_level": 1,
          "table_markdown": "|         |      1       |     2     |\n| Hobby   | magic-tricks | hiking    |\n| Movie   | comedy       | adventure |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"magic-tricks\", \"hiking\"], \"Movie\": [\"comedy\", \"adventure\"]}"
      },
      "puzzle_hash": "1bc5a0f068bc6c9c59028f209f1ae08f",
      "code": null,
      "execution_result": "Error: 1 validation error for VerificationResult\nground_truth\n  Input should be a valid string [type=string_type, input_value={'Hobby': ['magic-tricks'...['comedy', 'adventure']}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/string_type",
      "success": false,
      "execution_time": null,
      "timestamp": "20250814_084305",
      "verification": null,
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_36_3c419564",
      "puzzle": {
        "id": "einstein_2x2_36_3c419564",
        "title": "Zebra Puzzle einstein_2x2_36_3c419564",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Nationality: dutch, french\n2. Food: pepper, garlic\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes garlic is immediately to the right of the french person\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Nationality\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 36,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0008590421639382839,
          "n_level": 1,
          "table_markdown": "|               |   1    |   2    |\n| Food          | pepper | garlic |\n| Nationality   | french | dutch  |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"pepper\", \"garlic\"], \"Nationality\": [\"french\", \"dutch\"]}"
      },
      "puzzle_hash": "fbfdcf29ee76c9f244a9949e3015ccce",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Food\"]\n    items = {\n        \"Nationality\": [\"dutch\", \"french\"],\n        \"Food\": [\"pepper\", \"garlic\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes garlic is immediately to the right of the french person\n    problem.addConstraint(lambda french_pos, garlic_pos: garlic_pos == french_pos + 1,\n                          [\"Nationality:french\", \"Food:garlic\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['french', 'dutch'], 'Food': ['pepper', 'garlic']}\n",
      "success": true,
      "execution_time": 0.001202,
      "timestamp": "20250814_084309",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['pepper', 'garlic'], 'Nationality': ['french', 'dutch']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_37_9ee621b3",
      "puzzle": {
        "id": "einstein_2x2_37_9ee621b3",
        "title": "Zebra Puzzle einstein_2x2_37_9ee621b3",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: ice-hockey, parkour\n2. Job: designer, manager\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who works as a manager is immediately to the right of the person who plays parkour\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Job\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 37,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.000424874946475029,
          "n_level": 1,
          "table_markdown": "|         |    1     |     2      |\n| Job     | designer | manager    |\n| Sport   | parkour  | ice-hockey |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Job\": [\"designer\", \"manager\"], \"Sport\": [\"parkour\", \"ice-hockey\"]}"
      },
      "puzzle_hash": "a8857cf632eb75be7efabe9e45dc0f18",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Job\"]\n    items = {\n        \"Sport\": [\"ice-hockey\", \"parkour\"],\n        \"Job\": [\"designer\", \"manager\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who works as a manager is immediately to the right of the person who plays parkour\n    problem.addConstraint(lambda parkour_pos, manager_pos: manager_pos == parkour_pos + 1,\n                          [\"Sport:parkour\", \"Job:manager\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['parkour', 'ice-hockey'], 'Job': ['designer', 'manager']}\n",
      "success": true,
      "execution_time": 0.001243,
      "timestamp": "20250814_084314",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['designer', 'manager'], 'Sport': ['parkour', 'ice-hockey']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_38_69a96995",
      "puzzle": {
        "id": "einstein_2x2_38_69a96995",
        "title": "Zebra Puzzle einstein_2x2_38_69a96995",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Music: punk, jazz\n2. Movie: documentary, romance\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes jazz music is immediately to the left of the person who likes documentary movies\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Music\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 38,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005328331608325243,
          "n_level": 1,
          "table_markdown": "|         |    1    |      2      |\n| Movie   | romance | documentary |\n| Music   | jazz    | punk        |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"romance\", \"documentary\"], \"Music\": [\"jazz\", \"punk\"]}"
      },
      "puzzle_hash": "11e8aaa31e9beadc69ba7992fe84fe13",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Music\", \"Movie\"]\n    items = {\n        \"Music\": [\"punk\", \"jazz\"],\n        \"Movie\": [\"documentary\", \"romance\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes jazz music is immediately to the left of the person who likes documentary movies\n    problem.addConstraint(lambda jazz_pos, doc_pos: jazz_pos == doc_pos - 1, [\"Music:jazz\", \"Movie:documentary\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['jazz', 'punk'], 'Movie': ['romance', 'documentary']}\n",
      "success": true,
      "execution_time": 0.001264,
      "timestamp": "20250814_084317",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['romance', 'documentary'], 'Music': ['jazz', 'punk']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_39_e393ff0d",
      "puzzle": {
        "id": "einstein_2x2_39_e393ff0d",
        "title": "Zebra Puzzle einstein_2x2_39_e393ff0d",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: sports, comedy\n2. Pet: ferret, guinea-pig\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes sports movies is immediately to the left of the person who has guinea-pig as a pet\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Pet\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 39,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0004326249472796917,
          "n_level": 1,
          "table_markdown": "|         |   1    |     2      |\n| Movie   | sports | comedy     |\n| Pet     | ferret | guinea-pig |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"sports\", \"comedy\"], \"Pet\": [\"ferret\", \"guinea-pig\"]}"
      },
      "puzzle_hash": "2f1eec13b1f40fd02814089756699e5e",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Pet\"]\n    items = {\n        \"Movie\": [\"sports\", \"comedy\"],\n        \"Pet\": [\"ferret\", \"guinea-pig\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes sports movies is immediately to the left of the person who has guinea-pig as a pet\n    problem.addConstraint(lambda sports_pos, guinea_pig_pos: sports_pos == guinea_pig_pos - 1,\n                          [\"Movie:sports\", \"Pet:guinea-pig\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['sports', 'comedy'], 'Pet': ['ferret', 'guinea-pig']}\n",
      "success": true,
      "execution_time": 0.001157,
      "timestamp": "20250814_084321",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['sports', 'comedy'], 'Pet': ['ferret', 'guinea-pig']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_40_8927b1c8",
      "puzzle": {
        "id": "einstein_2x2_40_8927b1c8",
        "title": "Zebra Puzzle einstein_2x2_40_8927b1c8",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Beverage: milk, 7up\n2. Music: metal, classical\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes 7up is immediately to the right of the person who likes classical music\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Music\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 40,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00039062509313225746,
          "n_level": 1,
          "table_markdown": "|            |     1     |   2   |\n| Beverage   | milk      | 7up   |\n| Music      | classical | metal |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"milk\", \"7up\"], \"Music\": [\"classical\", \"metal\"]}"
      },
      "puzzle_hash": "893fdca5e2bc2015cecb3346b67f6e77",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Beverage\", \"Music\"]\n    items = {\n        \"Beverage\": [\"milk\", \"7up\"],\n        \"Music\": [\"metal\", \"classical\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes 7up is immediately to the right of the person who likes classical music\n    problem.addConstraint(lambda classical_pos, sevenup_pos: sevenup_pos == classical_pos + 1,\n                          [\"Music:classical\", \"Beverage:7up\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['milk', '7up'], 'Music': ['classical', 'metal']}\n",
      "success": true,
      "execution_time": 0.001216,
      "timestamp": "20250814_084325",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['milk', '7up'], 'Music': ['classical', 'metal']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_41_5f222a6c",
      "puzzle": {
        "id": "einstein_2x2_41_5f222a6c",
        "title": "Zebra Puzzle einstein_2x2_41_5f222a6c",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Music: electronic, indie\n2. Movie: romance, mystery\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes romance movies is immediately to the left of the person who likes electronic music\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Music\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 41,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00046274997293949127,
          "n_level": 1,
          "table_markdown": "|         |    1    |     2      |\n| Movie   | romance | mystery    |\n| Music   | indie   | electronic |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"romance\", \"mystery\"], \"Music\": [\"indie\", \"electronic\"]}"
      },
      "puzzle_hash": "bbacf0082e56381f1006265f94f16556",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Music\", \"Movie\"]\n    items = {\n        \"Music\": [\"electronic\", \"indie\"],\n        \"Movie\": [\"romance\", \"mystery\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes romance movies is immediately to the left of the person who likes electronic music\n    problem.addConstraint(lambda romance_pos, electronic_pos: romance_pos == electronic_pos - 1,\n                          [\"Movie:romance\", \"Music:electronic\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['indie', 'electronic'], 'Movie': ['romance', 'mystery']}\n",
      "success": true,
      "execution_time": 0.001193,
      "timestamp": "20250814_084328",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['romance', 'mystery'], 'Music': ['indie', 'electronic']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_42_6af5568a",
      "puzzle": {
        "id": "einstein_2x2_42_6af5568a",
        "title": "Zebra Puzzle einstein_2x2_42_6af5568a",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: biathlon, badminton\n2. Nationality: egyptian, german\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the german person is immediately to the left of the person who plays biathlon\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Nationality\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 42,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00048737507313489914,
          "n_level": 1,
          "table_markdown": "|               |     1     |    2     |\n| Nationality   | german    | egyptian |\n| Sport         | badminton | biathlon |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Nationality\": [\"german\", \"egyptian\"], \"Sport\": [\"badminton\", \"biathlon\"]}"
      },
      "puzzle_hash": "b1c02feda37e1ff86b4a73ead2102cda",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Nationality\"]\n    items = {\n        \"Sport\": [\"biathlon\", \"badminton\"],\n        \"Nationality\": [\"egyptian\", \"german\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # 1. the german person is immediately to the left of the person who plays biathlon\n    problem.addConstraint(lambda german_pos, biathlon_pos: german_pos == biathlon_pos - 1,\n                          [\"Nationality:german\", \"Sport:biathlon\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['badminton', 'biathlon'], 'Nationality': ['german', 'egyptian']}\n",
      "success": true,
      "execution_time": 0.001212,
      "timestamp": "20250814_084332",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['german', 'egyptian'], 'Sport': ['badminton', 'biathlon']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_43_b0da110b",
      "puzzle": {
        "id": "einstein_2x2_43_b0da110b",
        "title": "Zebra Puzzle einstein_2x2_43_b0da110b",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Hobby: collecting, magic-tricks\n2. Music: gospel, ambient\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes gospel music is immediately to the right of the person who enjoys collecting\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Music\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 43,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0008184160105884075,
          "n_level": 1,
          "table_markdown": "|         |     1      |      2       |\n| Hobby   | collecting | magic-tricks |\n| Music   | ambient    | gospel       |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"collecting\", \"magic-tricks\"], \"Music\": [\"ambient\", \"gospel\"]}"
      },
      "puzzle_hash": "ef926f334235f7fc608d4144f1667e11",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Hobby\", \"Music\"]\n    items = {\n        \"Hobby\": [\"collecting\", \"magic-tricks\"],\n        \"Music\": [\"gospel\", \"ambient\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # 1. the person who likes gospel music is immediately to the right of the person who enjoys collecting\n    problem.addConstraint(lambda collecting_pos, gospel_pos: gospel_pos == collecting_pos + 1,\n                          [\"Hobby:collecting\", \"Music:gospel\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['collecting', 'magic-tricks'], 'Music': ['ambient', 'gospel']}\n",
      "success": true,
      "execution_time": 0.001192,
      "timestamp": "20250814_084336",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['collecting', 'magic-tricks'], 'Music': ['ambient', 'gospel']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_44_58970f96",
      "puzzle": {
        "id": "einstein_2x2_44_58970f96",
        "title": "Zebra Puzzle einstein_2x2_44_58970f96",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: swimming, lacrosse\n2. Movie: romance, western\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who plays swimming is immediately to the right of the person who likes western movies\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 44,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0009377079550176859,
          "n_level": 1,
          "table_markdown": "|         |    1     |    2     |\n| Movie   | western  | romance  |\n| Sport   | lacrosse | swimming |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"western\", \"romance\"], \"Sport\": [\"lacrosse\", \"swimming\"]}"
      },
      "puzzle_hash": "7c79364f7d016987edfe897f70b6ec41",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Movie\"]\n    items = {\n        \"Sport\": [\"swimming\", \"lacrosse\"],\n        \"Movie\": [\"romance\", \"western\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who plays swimming is immediately to the right of the person who likes western movies\n    problem.addConstraint(lambda swimming_pos, western_pos: swimming_pos == western_pos + 1,\n                          [\"Sport:swimming\", \"Movie:western\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['lacrosse', 'swimming'], 'Movie': ['western', 'romance']}\n",
      "success": true,
      "execution_time": 0.001213,
      "timestamp": "20250814_084340",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['western', 'romance'], 'Sport': ['lacrosse', 'swimming']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_45_83880683",
      "puzzle": {
        "id": "einstein_2x2_45_83880683",
        "title": "Zebra Puzzle einstein_2x2_45_83880683",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Music: soul, punk\n2. Transport: airplane, skateboard\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who uses airplane for transportation is immediately to the left of the person who likes punk music\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Music\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 45,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005445419810712337,
          "n_level": 1,
          "table_markdown": "|             |    1     |     2      |\n| Music       | soul     | punk       |\n| Transport   | airplane | skateboard |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Music\": [\"soul\", \"punk\"], \"Transport\": [\"airplane\", \"skateboard\"]}"
      },
      "puzzle_hash": "8f0a97ab5ecf9c382786a9e47eda9848",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Music\", \"Transport\"]\n    items = {\n        \"Music\": [\"soul\", \"punk\"],\n        \"Transport\": [\"airplane\", \"skateboard\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who uses airplane for transportation is immediately to the left of the person who likes punk music\n    problem.addConstraint(lambda airplane_pos, punk_pos: airplane_pos == punk_pos - 1,\n                          [\"Transport:airplane\", \"Music:punk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Music': ['soul', 'punk'], 'Transport': ['airplane', 'skateboard']}\n",
      "success": true,
      "execution_time": 0.001519,
      "timestamp": "20250814_084344",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['soul', 'punk'], 'Transport': ['airplane', 'skateboard']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_46_7b9d5330",
      "puzzle": {
        "id": "einstein_2x2_46_7b9d5330",
        "title": "Zebra Puzzle einstein_2x2_46_7b9d5330",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Beverage: mirinda, fanta\n2. Pet: bird, lizard\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes mirinda is immediately to the left of the person who likes fanta\n2. 0 is at position 2\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Pet\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 46,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0013237500097602606,
          "n_level": 1,
          "table_markdown": "|            |    1    |   2    |\n| Beverage   | mirinda | fanta  |\n| Pet        | bird    | lizard |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"mirinda\", \"fanta\"], \"Pet\": [\"bird\", \"lizard\"]}"
      },
      "puzzle_hash": "7e5b3b6d1628be0f4edd1d7ea41b3fa7",
      "code": null,
      "execution_result": "Error: 1 validation error for VerificationResult\nground_truth\n  Input should be a valid string [type=string_type, input_value={'Beverage': ['mirinda', ...et': ['bird', 'lizard']}, input_type=dict]\n    For further information visit https://errors.pydantic.dev/2.11/v/string_type",
      "success": false,
      "execution_time": null,
      "timestamp": "20250814_084353",
      "verification": null,
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_47_3ac8e89d",
      "puzzle": {
        "id": "einstein_2x2_47_3ac8e89d",
        "title": "Zebra Puzzle einstein_2x2_47_3ac8e89d",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: romance, musical\n2. Hobby: cooking, collecting\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys cooking is immediately to the right of the person who likes musical movies\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Movie\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 47,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0004358747974038124,
          "n_level": 1,
          "table_markdown": "|         |     1      |    2    |\n| Hobby   | collecting | cooking |\n| Movie   | musical    | romance |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"collecting\", \"cooking\"], \"Movie\": [\"musical\", \"romance\"]}"
      },
      "puzzle_hash": "6a191e3c4286d0752a1eb359d05b3e42",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Hobby\"]\n    items = {\n        \"Movie\": [\"romance\", \"musical\"],\n        \"Hobby\": [\"cooking\", \"collecting\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who enjoys cooking is immediately to the right of the person who likes musical movies\n    # cooking position == musical position + 1\n    problem.addConstraint(lambda cooking_pos, musical_pos: cooking_pos == musical_pos + 1,\n                          [\"Hobby:cooking\", \"Movie:musical\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['musical', 'romance'], 'Hobby': ['collecting', 'cooking']}\n",
      "success": true,
      "execution_time": 0.002663,
      "timestamp": "20250814_084356",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['collecting', 'cooking'], 'Movie': ['musical', 'romance']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_48_afc87d48",
      "puzzle": {
        "id": "einstein_2x2_48_afc87d48",
        "title": "Zebra Puzzle einstein_2x2_48_afc87d48",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: action, spy\n2. Beverage: juice, milk\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes spy movies is immediately to the left of the person who likes milk\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Movie\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 48,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00046524987556040287,
          "n_level": 1,
          "table_markdown": "|            |   1   |   2    |\n| Beverage   | juice | milk   |\n| Movie      | spy   | action |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"juice\", \"milk\"], \"Movie\": [\"spy\", \"action\"]}"
      },
      "puzzle_hash": "0273841ca62d2fefc828a13b61ef93c3",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Beverage\"]\n    items = {\n        \"Movie\": [\"action\", \"spy\"],\n        \"Beverage\": [\"juice\", \"milk\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes spy movies is immediately to the left of the person who likes milk\n    problem.addConstraint(lambda spy_pos, milk_pos: spy_pos == milk_pos - 1, [\"Movie:spy\", \"Beverage:milk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['spy', 'action'], 'Beverage': ['juice', 'milk']}\n",
      "success": true,
      "execution_time": 0.001206,
      "timestamp": "20250814_084401",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['juice', 'milk'], 'Movie': ['spy', 'action']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_49_b8c4a771",
      "puzzle": {
        "id": "einstein_2x2_49_b8c4a771",
        "title": "Zebra Puzzle einstein_2x2_49_b8c4a771",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Beverage: tea, fanta\n2. Food: kiwi, tomato\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes tomato is immediately to the left of the person who likes tea\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Food\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 49,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005466248840093613,
          "n_level": 1,
          "table_markdown": "|            |   1    |  2   |\n| Beverage   | fanta  | tea  |\n| Food       | tomato | kiwi |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"fanta\", \"tea\"], \"Food\": [\"tomato\", \"kiwi\"]}"
      },
      "puzzle_hash": "01707fdd40533acdb3316a313f9aa9c5",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Beverage\", \"Food\"]\n    items = {\n        \"Beverage\": [\"tea\", \"fanta\"],\n        \"Food\": [\"kiwi\", \"tomato\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes tomato is immediately to the left of the person who likes tea\n    problem.addConstraint(lambda tomato_pos, tea_pos: tomato_pos == tea_pos - 1,\n                          [\"Food:tomato\", \"Beverage:tea\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['fanta', 'tea'], 'Food': ['tomato', 'kiwi']}\n",
      "success": true,
      "execution_time": 0.00119,
      "timestamp": "20250814_084405",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['fanta', 'tea'], 'Food': ['tomato', 'kiwi']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_50_64f1ab14",
      "puzzle": {
        "id": "einstein_2x2_50_64f1ab14",
        "title": "Zebra Puzzle einstein_2x2_50_64f1ab14",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: mystery, thriller\n2. Food: nectarine, carrot\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes mystery movies is immediately to the left of the person who likes nectarine\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Movie\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 50,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00035329186357557774,
          "n_level": 1,
          "table_markdown": "|         |    1    |     2     |\n| Food    | carrot  | nectarine |\n| Movie   | mystery | thriller  |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"carrot\", \"nectarine\"], \"Movie\": [\"mystery\", \"thriller\"]}"
      },
      "puzzle_hash": "b9418664effbd1ba69b942880fd408da",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Food\"]\n    items = {\n        \"Movie\": [\"mystery\", \"thriller\"],\n        \"Food\": [\"nectarine\", \"carrot\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes mystery movies is immediately to the left of the person who likes nectarine\n    problem.addConstraint(lambda m, f: m == f - 1, [\"Movie:mystery\", \"Food:nectarine\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['mystery', 'thriller'], 'Food': ['carrot', 'nectarine']}\n",
      "success": true,
      "execution_time": 0.001263,
      "timestamp": "20250814_084409",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['carrot', 'nectarine'], 'Movie': ['mystery', 'thriller']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_51_f1e4bab4",
      "puzzle": {
        "id": "einstein_2x2_51_f1e4bab4",
        "title": "Zebra Puzzle einstein_2x2_51_f1e4bab4",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Food: radish, carrot\n2. Sport: skateboarding, volleyball\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes carrot is immediately to the right of the person who plays skateboarding\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 51,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003361657727509737,
          "n_level": 1,
          "table_markdown": "|         |       1       |     2      |\n| Food    | radish        | carrot     |\n| Sport   | skateboarding | volleyball |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"radish\", \"carrot\"], \"Sport\": [\"skateboarding\", \"volleyball\"]}"
      },
      "puzzle_hash": "fb10a65b143ee97fea64b967758801ad",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Food\", \"Sport\"]\n    items = {\n        \"Food\": [\"radish\", \"carrot\"],\n        \"Sport\": [\"skateboarding\", \"volleyball\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes carrot is immediately to the right of the person who plays skateboarding\n    problem.addConstraint(lambda skateboarding_pos, carrot_pos: carrot_pos == skateboarding_pos + 1,\n                          [\"Sport:skateboarding\", \"Food:carrot\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['radish', 'carrot'], 'Sport': ['skateboarding', 'volleyball']}\n",
      "success": true,
      "execution_time": 0.001199,
      "timestamp": "20250814_084414",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['radish', 'carrot'], 'Sport': ['skateboarding', 'volleyball']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_52_3cd622a4",
      "puzzle": {
        "id": "einstein_2x2_52_3cd622a4",
        "title": "Zebra Puzzle einstein_2x2_52_3cd622a4",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: biathlon, snowboarding\n2. Job: doctor, analyst\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who plays snowboarding is at position 1 (the leftmost position)\n2. the person who plays snowboarding is the same person as the person who works as a analyst\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Job\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 52,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0007044589146971703,
          "n_level": 1,
          "table_markdown": "|         |      1       |    2     |\n| Job     | analyst      | doctor   |\n| Sport   | snowboarding | biathlon |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Job\": [\"analyst\", \"doctor\"], \"Sport\": [\"snowboarding\", \"biathlon\"]}"
      },
      "puzzle_hash": "d736698551c17335f035daf1f4f82c3d",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Job\"]\n    items = {\n        \"Sport\": [\"biathlon\", \"snowboarding\"],\n        \"Job\": [\"doctor\", \"analyst\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who plays snowboarding is at position 1 (0-indexed position 0)\n    problem.addConstraint(lambda x: x == 0, [\"Sport:snowboarding\"])\n    \n    # Clue 2: the person who plays snowboarding is the same person as the person who works as an analyst\n    problem.addConstraint(lambda x, y: x == y, [\"Sport:snowboarding\", \"Job:analyst\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['snowboarding', 'biathlon'], 'Job': ['analyst', 'doctor']}\n",
      "success": true,
      "execution_time": 0.002763,
      "timestamp": "20250814_084418",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Job': ['analyst', 'doctor'], 'Sport': ['snowboarding', 'biathlon']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_53_8699b55a",
      "puzzle": {
        "id": "einstein_2x2_53_8699b55a",
        "title": "Zebra Puzzle einstein_2x2_53_8699b55a",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Hobby: gardening, filmmaking\n2. Food: lettuce, radish\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys filmmaking is immediately to the left of the person who likes radish\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Hobby\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 53,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005052080377936363,
          "n_level": 1,
          "table_markdown": "|         |     1      |     2     |\n| Food    | lettuce    | radish    |\n| Hobby   | filmmaking | gardening |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"lettuce\", \"radish\"], \"Hobby\": [\"filmmaking\", \"gardening\"]}"
      },
      "puzzle_hash": "54fdd8dae4ac84a81063313865c2048d",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Hobby\", \"Food\"]\n    items = {\n        \"Hobby\": [\"gardening\", \"filmmaking\"],\n        \"Food\": [\"lettuce\", \"radish\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who enjoys filmmaking is immediately to the left of the person who likes radish\n    problem.addConstraint(lambda filmmaking_pos, radish_pos: filmmaking_pos == radish_pos - 1,\n                          [\"Hobby:filmmaking\", \"Food:radish\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['filmmaking', 'gardening'], 'Food': ['lettuce', 'radish']}\n",
      "success": true,
      "execution_time": 0.001221,
      "timestamp": "20250814_084425",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['lettuce', 'radish'], 'Hobby': ['filmmaking', 'gardening']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_54_2717e64d",
      "puzzle": {
        "id": "einstein_2x2_54_2717e64d",
        "title": "Zebra Puzzle einstein_2x2_54_2717e64d",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Food: garlic, cherry\n2. Beverage: milk, fanta\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes milk is the same person as the person who likes cherry\n2. the person who likes cherry is at position 1 (the leftmost position)\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Food\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 54,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0007855829317122698,
          "n_level": 1,
          "table_markdown": "|            |   1    |   2    |\n| Beverage   | milk   | fanta  |\n| Food       | cherry | garlic |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"milk\", \"fanta\"], \"Food\": [\"cherry\", \"garlic\"]}"
      },
      "puzzle_hash": "edd55b566b6f03675c22ce7aeb48332b",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Food\", \"Beverage\"]\n    items = {\n        \"Food\": [\"garlic\", \"cherry\"],\n        \"Beverage\": [\"milk\", \"fanta\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: the person who likes milk is the same person as the person who likes cherry\n    problem.addConstraint(lambda milk_pos, cherry_pos: milk_pos == cherry_pos, [\"Beverage:milk\", \"Food:cherry\"])\n    \n    # Clue 2: the person who likes cherry is at position 1 (leftmost position, 0-indexed)\n    problem.addConstraint(lambda cherry_pos: cherry_pos == 0, [\"Food:cherry\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['cherry', 'garlic'], 'Beverage': ['milk', 'fanta']}\n",
      "success": true,
      "execution_time": 0.001213,
      "timestamp": "20250814_084429",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['milk', 'fanta'], 'Food': ['cherry', 'garlic']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_55_08962650",
      "puzzle": {
        "id": "einstein_2x2_55_08962650",
        "title": "Zebra Puzzle einstein_2x2_55_08962650",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Transport: ship, bus\n2. Movie: musical, crime\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who uses ship for transportation is immediately to the left of the person who likes crime movies\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 55,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003739169333130121,
          "n_level": 1,
          "table_markdown": "|             |    1    |   2   |\n| Movie       | musical | crime |\n| Transport   | ship    | bus   |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"musical\", \"crime\"], \"Transport\": [\"ship\", \"bus\"]}"
      },
      "puzzle_hash": "bb386e34e0bd1873dfa9bd5de9bcde2f",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Transport\", \"Movie\"]\n    items = {\n        \"Transport\": [\"ship\", \"bus\"],\n        \"Movie\": [\"musical\", \"crime\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # 1. the person who uses ship for transportation is immediately to the left of the person who likes crime movies\n    problem.addConstraint(lambda ship_pos, crime_pos: ship_pos == crime_pos - 1, [\"Transport:ship\", \"Movie:crime\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Transport': ['ship', 'bus'], 'Movie': ['musical', 'crime']}\n",
      "success": true,
      "execution_time": 0.001192,
      "timestamp": "20250814_084433",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['musical', 'crime'], 'Transport': ['ship', 'bus']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_56_0bea892d",
      "puzzle": {
        "id": "einstein_2x2_56_0bea892d",
        "title": "Zebra Puzzle einstein_2x2_56_0bea892d",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Transport: helicopter, tram\n2. Nationality: british, australian\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the australian person is immediately to the left of the person who uses helicopter for transportation\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Nationality\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 56,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00034208293072879314,
          "n_level": 1,
          "table_markdown": "|               |     1      |     2      |\n| Nationality   | australian | british    |\n| Transport     | tram       | helicopter |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Nationality\": [\"australian\", \"british\"], \"Transport\": [\"tram\", \"helicopter\"]}"
      },
      "puzzle_hash": "4a7644e2aa37eb6df211554a9a11f4ec",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Transport\"]\n    items = {\n        \"Nationality\": [\"british\", \"australian\"],\n        \"Transport\": [\"helicopter\", \"tram\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the australian person is immediately to the left of the person who uses helicopter for transportation\n    problem.addConstraint(lambda australian_pos, helicopter_pos: australian_pos == helicopter_pos - 1,\n                          [\"Nationality:australian\", \"Transport:helicopter\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['australian', 'british'], 'Transport': ['tram', 'helicopter']}\n",
      "success": true,
      "execution_time": 0.001224,
      "timestamp": "20250814_084437",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['australian', 'british'], 'Transport': ['tram', 'helicopter']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_57_ec60b1ae",
      "puzzle": {
        "id": "einstein_2x2_57_ec60b1ae",
        "title": "Zebra Puzzle einstein_2x2_57_ec60b1ae",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: badminton, lacrosse\n2. Beverage: tea, almond-milk\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes almond-milk is immediately to the right of the person who plays badminton\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 57,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003487919457256794,
          "n_level": 1,
          "table_markdown": "|            |     1     |      2      |\n| Beverage   | tea       | almond-milk |\n| Sport      | badminton | lacrosse    |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"tea\", \"almond-milk\"], \"Sport\": [\"badminton\", \"lacrosse\"]}"
      },
      "puzzle_hash": "14c699038610a7bdd41238b3444b84f3",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Beverage\"]\n    items = {\n        \"Sport\": [\"badminton\", \"lacrosse\"],\n        \"Beverage\": [\"tea\", \"almond-milk\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes almond-milk is immediately to the right of the person who plays badminton\n    problem.addConstraint(lambda badminton_pos, almond_pos: almond_pos == badminton_pos + 1,\n                          [\"Sport:badminton\", \"Beverage:almond-milk\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['badminton', 'lacrosse'], 'Beverage': ['tea', 'almond-milk']}\n",
      "success": true,
      "execution_time": 0.001158,
      "timestamp": "20250814_084441",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['tea', 'almond-milk'], 'Sport': ['badminton', 'lacrosse']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_58_0afec1be",
      "puzzle": {
        "id": "einstein_2x2_58_0afec1be",
        "title": "Zebra Puzzle einstein_2x2_58_0afec1be",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Hobby: photography, magic-tricks\n2. Movie: zombie, mystery\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys magic-tricks is immediately to the right of the person who likes mystery movies\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Movie\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 58,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0006542918272316456,
          "n_level": 1,
          "table_markdown": "|         |      1      |      2       |\n| Hobby   | photography | magic-tricks |\n| Movie   | mystery     | zombie       |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"photography\", \"magic-tricks\"], \"Movie\": [\"mystery\", \"zombie\"]}"
      },
      "puzzle_hash": "7b1a1563d36d1d3bf13370bf7db57af8",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Hobby\", \"Movie\"]\n    items = {\n        \"Hobby\": [\"photography\", \"magic-tricks\"],\n        \"Movie\": [\"zombie\", \"mystery\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue:\n    # the person who enjoys magic-tricks is immediately to the right of the person who likes mystery movies\n    problem.addConstraint(lambda magic_pos, mystery_pos: magic_pos == mystery_pos + 1,\n                          [\"Hobby:magic-tricks\", \"Movie:mystery\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['photography', 'magic-tricks'], 'Movie': ['mystery', 'zombie']}\n",
      "success": true,
      "execution_time": 0.001182,
      "timestamp": "20250814_084446",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['photography', 'magic-tricks'], 'Movie': ['mystery', 'zombie']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_59_84514ac0",
      "puzzle": {
        "id": "einstein_2x2_59_84514ac0",
        "title": "Zebra Puzzle einstein_2x2_59_84514ac0",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Pet: rabbit, horse\n2. Sport: sailing, water-polo\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who has rabbit as a pet is immediately to the left of the person who plays sailing\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Pet\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 59,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00034841708838939667,
          "n_level": 1,
          "table_markdown": "|         |     1      |    2    |\n| Pet     | rabbit     | horse   |\n| Sport   | water-polo | sailing |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Pet\": [\"rabbit\", \"horse\"], \"Sport\": [\"water-polo\", \"sailing\"]}"
      },
      "puzzle_hash": "184ff191bdd6bb7adc01ce70cf5d2cb2",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Pet\", \"Sport\"]\n    items = {\n        \"Pet\": [\"rabbit\", \"horse\"],\n        \"Sport\": [\"sailing\", \"water-polo\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # 1. the person who has rabbit as a pet is immediately to the left of the person who plays sailing\n    problem.addConstraint(lambda rabbit_pos, sailing_pos: rabbit_pos == sailing_pos - 1, [\"Pet:rabbit\", \"Sport:sailing\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Pet': ['rabbit', 'horse'], 'Sport': ['water-polo', 'sailing']}\n",
      "success": true,
      "execution_time": 0.0012,
      "timestamp": "20250814_084450",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Pet': ['rabbit', 'horse'], 'Sport': ['water-polo', 'sailing']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_60_615b9e00",
      "puzzle": {
        "id": "einstein_2x2_60_615b9e00",
        "title": "Zebra Puzzle einstein_2x2_60_615b9e00",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Hobby: video-games, baking\n2. Transport: skateboard, train\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys video-games is immediately to the right of the person who uses train for transportation\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 60,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0006102079059928656,
          "n_level": 1,
          "table_markdown": "|             |   1    |      2      |\n| Hobby       | baking | video-games |\n| Transport   | train  | skateboard  |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"baking\", \"video-games\"], \"Transport\": [\"train\", \"skateboard\"]}"
      },
      "puzzle_hash": "b438ee09cbe417a0cbf590dcf3709bd4",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Hobby\", \"Transport\"]\n    items = {\n        \"Hobby\": [\"video-games\", \"baking\"],\n        \"Transport\": [\"skateboard\", \"train\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who enjoys video-games is immediately to the right of the person who uses train for transportation\n    problem.addConstraint(lambda vg_pos, train_pos: vg_pos == train_pos + 1, [\"Hobby:video-games\", \"Transport:train\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['baking', 'video-games'], 'Transport': ['train', 'skateboard']}\n",
      "success": true,
      "execution_time": 0.003,
      "timestamp": "20250814_084454",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['baking', 'video-games'], 'Transport': ['train', 'skateboard']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_61_f77cb8a6",
      "puzzle": {
        "id": "einstein_2x2_61_f77cb8a6",
        "title": "Zebra Puzzle einstein_2x2_61_f77cb8a6",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Transport: boat, tram\n2. Food: lime, grapefruit\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes grapefruit is immediately to the right of the person who uses tram for transportation\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 61,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005110420752316713,
          "n_level": 1,
          "table_markdown": "|             |  1   |     2      |\n| Food        | lime | grapefruit |\n| Transport   | tram | boat       |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"lime\", \"grapefruit\"], \"Transport\": [\"tram\", \"boat\"]}"
      },
      "puzzle_hash": "0a9ecc48e5594710ca5da3c88fffa950",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Transport\", \"Food\"]\n    items = {\n        \"Transport\": [\"boat\", \"tram\"],\n        \"Food\": [\"lime\", \"grapefruit\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes grapefruit is immediately to the right of the person who uses tram for transportation\n    problem.addConstraint(lambda tram_pos, grapefruit_pos: tram_pos == grapefruit_pos - 1,\n                          [\"Transport:tram\", \"Food:grapefruit\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Transport': ['tram', 'boat'], 'Food': ['lime', 'grapefruit']}\n",
      "success": true,
      "execution_time": 0.001266,
      "timestamp": "20250814_084458",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['lime', 'grapefruit'], 'Transport': ['tram', 'boat']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_62_26965fd8",
      "puzzle": {
        "id": "einstein_2x2_62_26965fd8",
        "title": "Zebra Puzzle einstein_2x2_62_26965fd8",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: lacrosse, golf\n2. Hobby: magic-tricks, card-games\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys card-games is immediately to the left of the person who plays golf\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 62,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005618750583380461,
          "n_level": 1,
          "table_markdown": "|         |     1      |      2       |\n| Hobby   | card-games | magic-tricks |\n| Sport   | lacrosse   | golf         |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"card-games\", \"magic-tricks\"], \"Sport\": [\"lacrosse\", \"golf\"]}"
      },
      "puzzle_hash": "ea83b7ff660cf3740bbc1a7a8697552a",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Hobby\"]\n    items = {\n        \"Sport\": [\"lacrosse\", \"golf\"],\n        \"Hobby\": [\"magic-tricks\", \"card-games\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who enjoys card-games is immediately to the left of the person who plays golf\n    problem.addConstraint(lambda card_games_pos, golf_pos: card_games_pos == golf_pos - 1,\n                          [\"Hobby:card-games\", \"Sport:golf\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['lacrosse', 'golf'], 'Hobby': ['card-games', 'magic-tricks']}\n",
      "success": true,
      "execution_time": 0.002765,
      "timestamp": "20250814_084502",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['card-games', 'magic-tricks'], 'Sport': ['lacrosse', 'golf']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_63_9f5b4ad9",
      "puzzle": {
        "id": "einstein_2x2_63_9f5b4ad9",
        "title": "Zebra Puzzle einstein_2x2_63_9f5b4ad9",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Beverage: soy-milk, fanta\n2. Movie: musical, satire\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes musical movies is immediately to the right of the person who likes soy-milk\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Movie\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 63,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0004155829083174467,
          "n_level": 1,
          "table_markdown": "|            |    1     |    2    |\n| Beverage   | soy-milk | fanta   |\n| Movie      | satire   | musical |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"soy-milk\", \"fanta\"], \"Movie\": [\"satire\", \"musical\"]}"
      },
      "puzzle_hash": "207b32bba5c749e29c09c1592e3d9f21",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Beverage\", \"Movie\"]\n    items = {\n        \"Beverage\": [\"soy-milk\", \"fanta\"],\n        \"Movie\": [\"musical\", \"satire\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes musical movies is immediately to the right of the person who likes soy-milk\n    problem.addConstraint(lambda soy, musical: soy == musical - 1, [\"Beverage:soy-milk\", \"Movie:musical\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['soy-milk', 'fanta'], 'Movie': ['satire', 'musical']}\n",
      "success": true,
      "execution_time": 0.001466,
      "timestamp": "20250814_084505",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['soy-milk', 'fanta'], 'Movie': ['satire', 'musical']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_64_4d5ab151",
      "puzzle": {
        "id": "einstein_2x2_64_4d5ab151",
        "title": "Zebra Puzzle einstein_2x2_64_4d5ab151",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Food: plum, corn\n2. Pet: cat, ferret\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who has cat as a pet is immediately to the left of the person who likes corn\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Pet\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 64,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00034254114143550396,
          "n_level": 1,
          "table_markdown": "|        |  1   |   2    |\n| Food   | plum | corn   |\n| Pet    | cat  | ferret |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"plum\", \"corn\"], \"Pet\": [\"cat\", \"ferret\"]}"
      },
      "puzzle_hash": "aae57d6afb756f40b41f1dcb4dea9bab",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Food\", \"Pet\"]\n    items = {\n        \"Food\": [\"plum\", \"corn\"],\n        \"Pet\": [\"cat\", \"ferret\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who has cat as a pet is immediately to the left of the person who likes corn\n    problem.addConstraint(lambda cat_pos, corn_pos: cat_pos == corn_pos - 1, [\"Pet:cat\", \"Food:corn\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['plum', 'corn'], 'Pet': ['cat', 'ferret']}\n",
      "success": true,
      "execution_time": 0.001185,
      "timestamp": "20250814_084509",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['plum', 'corn'], 'Pet': ['cat', 'ferret']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_65_3d8df846",
      "puzzle": {
        "id": "einstein_2x2_65_3d8df846",
        "title": "Zebra Puzzle einstein_2x2_65_3d8df846",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: biathlon, skateboarding\n2. Pet: fish, snake\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who has fish as a pet is immediately to the left of the person who plays biathlon\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Pet\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 65,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00042554200626909733,
          "n_level": 1,
          "table_markdown": "|         |       1       |    2     |\n| Pet     | fish          | snake    |\n| Sport   | skateboarding | biathlon |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Pet\": [\"fish\", \"snake\"], \"Sport\": [\"skateboarding\", \"biathlon\"]}"
      },
      "puzzle_hash": "2a73042f654e6147062d3b5bfb41d803",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Pet\"]\n    items = {\n        \"Sport\": [\"biathlon\", \"skateboarding\"],\n        \"Pet\": [\"fish\", \"snake\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # 1. the person who has fish as a pet is immediately to the left of the person who plays biathlon\n    problem.addConstraint(lambda fish_pos, biathlon_pos: fish_pos == biathlon_pos - 1, [\"Pet:fish\", \"Sport:biathlon\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['skateboarding', 'biathlon'], 'Pet': ['fish', 'snake']}\n",
      "success": true,
      "execution_time": 0.001189,
      "timestamp": "20250814_084512",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Pet': ['fish', 'snake'], 'Sport': ['skateboarding', 'biathlon']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_66_18add04e",
      "puzzle": {
        "id": "einstein_2x2_66_18add04e",
        "title": "Zebra Puzzle einstein_2x2_66_18add04e",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Pet: lizard, dog\n2. Sport: ice-hockey, baseball\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who plays ice-hockey is immediately to the right of the person who has lizard as a pet\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Pet\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 66,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003860408905893564,
          "n_level": 1,
          "table_markdown": "|         |    1     |     2      |\n| Pet     | lizard   | dog        |\n| Sport   | baseball | ice-hockey |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Pet\": [\"lizard\", \"dog\"], \"Sport\": [\"baseball\", \"ice-hockey\"]}"
      },
      "puzzle_hash": "416a60757487956911c01e8c062ec5f1",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Pet\", \"Sport\"]\n    items = {\n        \"Pet\": [\"lizard\", \"dog\"],\n        \"Sport\": [\"ice-hockey\", \"baseball\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who plays ice-hockey is immediately to the right of the person who has lizard as a pet\n    problem.addConstraint(lambda lizard_pos, ice_hockey_pos: ice_hockey_pos == lizard_pos + 1,\n                          [\"Pet:lizard\", \"Sport:ice-hockey\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Pet': ['lizard', 'dog'], 'Sport': ['baseball', 'ice-hockey']}\n",
      "success": true,
      "execution_time": 0.001261,
      "timestamp": "20250814_084516",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Pet': ['lizard', 'dog'], 'Sport': ['baseball', 'ice-hockey']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_67_79901ca2",
      "puzzle": {
        "id": "einstein_2x2_67_79901ca2",
        "title": "Zebra Puzzle einstein_2x2_67_79901ca2",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Transport: motorbike, taxi\n2. Music: electronic, soul\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes electronic music is immediately to the left of the person who uses motorbike for transportation\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Music\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 67,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00033729104325175285,
          "n_level": 1,
          "table_markdown": "|             |     1      |     2     |\n| Music       | electronic | soul      |\n| Transport   | taxi       | motorbike |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Music\": [\"electronic\", \"soul\"], \"Transport\": [\"taxi\", \"motorbike\"]}"
      },
      "puzzle_hash": "f2b7f843540bba355348c792eb08690b",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Transport\", \"Music\"]\n    items = {\n        \"Transport\": [\"motorbike\", \"taxi\"],\n        \"Music\": [\"electronic\", \"soul\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # the person who likes electronic music is immediately to the left of the person who uses motorbike for transportation\n    problem.addConstraint(lambda electronic_pos, motorbike_pos: electronic_pos == motorbike_pos - 1,\n                          [\"Music:electronic\", \"Transport:motorbike\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Transport': ['taxi', 'motorbike'], 'Music': ['electronic', 'soul']}\n",
      "success": true,
      "execution_time": 0.001153,
      "timestamp": "20250814_084519",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['electronic', 'soul'], 'Transport': ['taxi', 'motorbike']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_68_f75112d5",
      "puzzle": {
        "id": "einstein_2x2_68_f75112d5",
        "title": "Zebra Puzzle einstein_2x2_68_f75112d5",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Transport: boat, snowmobile\n2. Music: reggae, salsa\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes reggae music is immediately to the left of the person who uses boat for transportation\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Music\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 68,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005375419277697802,
          "n_level": 1,
          "table_markdown": "|             |     1      |   2   |\n| Music       | reggae     | salsa |\n| Transport   | snowmobile | boat  |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Music\": [\"reggae\", \"salsa\"], \"Transport\": [\"snowmobile\", \"boat\"]}"
      },
      "puzzle_hash": "0f7f350d42bd0670fc4e89ae41156dab",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Transport\", \"Music\"]\n    items = {\n        \"Transport\": [\"boat\", \"snowmobile\"],\n        \"Music\": [\"reggae\", \"salsa\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes reggae music is immediately to the left of the person who uses boat for transportation\n    problem.addConstraint(lambda reggae_pos, boat_pos: reggae_pos == boat_pos - 1, [\"Music:reggae\", \"Transport:boat\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Transport': ['snowmobile', 'boat'], 'Music': ['reggae', 'salsa']}\n",
      "success": true,
      "execution_time": 0.001251,
      "timestamp": "20250814_084524",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['reggae', 'salsa'], 'Transport': ['snowmobile', 'boat']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_69_9db863d8",
      "puzzle": {
        "id": "einstein_2x2_69_9db863d8",
        "title": "Zebra Puzzle einstein_2x2_69_9db863d8",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Hobby: skydiving, writing\n2. Music: disco, dubstep\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes dubstep music is immediately to the left of the person who enjoys skydiving\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Music\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 69,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003420421853661537,
          "n_level": 1,
          "table_markdown": "|         |    1    |     2     |\n| Hobby   | writing | skydiving |\n| Music   | dubstep | disco     |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"writing\", \"skydiving\"], \"Music\": [\"dubstep\", \"disco\"]}"
      },
      "puzzle_hash": "1d3e8955acf43bcb47c29cc268682945",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Hobby\", \"Music\"]\n    items = {\n        \"Hobby\": [\"skydiving\", \"writing\"],\n        \"Music\": [\"disco\", \"dubstep\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes dubstep music is immediately to the left of the person who enjoys skydiving\n    problem.addConstraint(lambda dubstep_pos, skydiving_pos: dubstep_pos == skydiving_pos - 1,\n                          [\"Music:dubstep\", \"Hobby:skydiving\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['writing', 'skydiving'], 'Music': ['dubstep', 'disco']}\n",
      "success": true,
      "execution_time": 0.001433,
      "timestamp": "20250814_084529",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['writing', 'skydiving'], 'Music': ['dubstep', 'disco']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_70_0a606502",
      "puzzle": {
        "id": "einstein_2x2_70_0a606502",
        "title": "Zebra Puzzle einstein_2x2_70_0a606502",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Beverage: coffee, cola\n2. Job: scientist, writer\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes cola is immediately to the left of the person who works as a scientist\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Job\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 70,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0009373750071972609,
          "n_level": 1,
          "table_markdown": "|            |   1    |     2     |\n| Beverage   | cola   | coffee    |\n| Job        | writer | scientist |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"cola\", \"coffee\"], \"Job\": [\"writer\", \"scientist\"]}"
      },
      "puzzle_hash": "40877c3d8fc753c0f8b11f5c272113d7",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Beverage\", \"Job\"]\n    items = {\n        \"Beverage\": [\"coffee\", \"cola\"],\n        \"Job\": [\"scientist\", \"writer\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes cola is immediately to the left of the person who works as a scientist\n    problem.addConstraint(lambda cola_pos, scientist_pos: cola_pos == scientist_pos - 1,\n                          [\"Beverage:cola\", \"Job:scientist\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['cola', 'coffee'], 'Job': ['writer', 'scientist']}\n",
      "success": true,
      "execution_time": 0.001237,
      "timestamp": "20250814_084534",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['cola', 'coffee'], 'Job': ['writer', 'scientist']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_71_0b246f5d",
      "puzzle": {
        "id": "einstein_2x2_71_0b246f5d",
        "title": "Zebra Puzzle einstein_2x2_71_0b246f5d",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Hobby: chess, dancing\n2. Food: cherry, carrot\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys chess is at position 1 (the leftmost position)\n2. the person who likes cherry is at position 1 (the leftmost position)\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Hobby\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 71,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.000738582806661725,
          "n_level": 1,
          "table_markdown": "|         |   1    |    2    |\n| Food    | cherry | carrot  |\n| Hobby   | chess  | dancing |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"cherry\", \"carrot\"], \"Hobby\": [\"chess\", \"dancing\"]}"
      },
      "puzzle_hash": "99df41da5203cca72e019820f99cd974",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Hobby\", \"Food\"]\n    items = {\n        \"Hobby\": [\"chess\", \"dancing\"],\n        \"Food\": [\"cherry\", \"carrot\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # 1. the person who enjoys chess is at position 1 (0-indexed position 0)\n    problem.addConstraint(lambda x: x == 0, [\"Hobby:chess\"])\n    # 2. the person who likes cherry is at position 1 (0-indexed position 0)\n    problem.addConstraint(lambda x: x == 0, [\"Food:cherry\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Hobby': ['chess', 'dancing'], 'Food': ['cherry', 'carrot']}\n",
      "success": true,
      "execution_time": 0.00132,
      "timestamp": "20250814_084538",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['cherry', 'carrot'], 'Hobby': ['chess', 'dancing']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_72_7311da74",
      "puzzle": {
        "id": "einstein_2x2_72_7311da74",
        "title": "Zebra Puzzle einstein_2x2_72_7311da74",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Transport: tram, helicopter\n2. Music: indie, rock\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who uses helicopter for transportation is immediately to the right of the person who likes rock music\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Music\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 72,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0007150841411203146,
          "n_level": 1,
          "table_markdown": "|             |  1   |     2      |\n| Music       | rock | indie      |\n| Transport   | tram | helicopter |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Music\": [\"rock\", \"indie\"], \"Transport\": [\"tram\", \"helicopter\"]}"
      },
      "puzzle_hash": "c49bc6f1804d69de3c5524ca1bf73868",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Transport\", \"Music\"]\n    items = {\n        \"Transport\": [\"tram\", \"helicopter\"],\n        \"Music\": [\"indie\", \"rock\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who uses helicopter for transportation is immediately to the right of the person who likes rock music\n    problem.addConstraint(lambda rock_pos, heli_pos: heli_pos == rock_pos + 1, [\"Music:rock\", \"Transport:helicopter\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Transport': ['tram', 'helicopter'], 'Music': ['rock', 'indie']}\n",
      "success": true,
      "execution_time": 0.001979,
      "timestamp": "20250814_084542",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['rock', 'indie'], 'Transport': ['tram', 'helicopter']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_73_8ebf2d5e",
      "puzzle": {
        "id": "einstein_2x2_73_8ebf2d5e",
        "title": "Zebra Puzzle einstein_2x2_73_8ebf2d5e",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Pet: ferret, chinchilla\n2. Food: grapes, lemon\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. 0 is at position 2\n2. the person who likes grapes is the same person as the person who has ferret as a pet\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Pet\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 73,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0006755408830940723,
          "n_level": 1,
          "table_markdown": "|        |   1    |     2      |\n| Food   | grapes | lemon      |\n| Pet    | ferret | chinchilla |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"grapes\", \"lemon\"], \"Pet\": [\"ferret\", \"chinchilla\"]}"
      },
      "puzzle_hash": "073801a0c0bf76c333aab730b4aee089",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Pet\", \"Food\"]\n    items = {\n        \"Pet\": [\"ferret\", \"chinchilla\"],\n        \"Food\": [\"grapes\", \"lemon\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: 0 is at position 2 (0-indexed position 1)\n    # Since we have only 2 positions (0 and 1), position 2 means index 1\n    # The person 0 is at position 2 means the person with index 0 is at position 1\n    # We interpret \"0\" as the person at index 0, so we fix position 1 for person 0\n    # But we don't have person variables, only attributes. So we interpret \"0 is at position 2\" as the person at position 1 is person 0.\n    # Since we have only 2 people, positions 0 and 1, and the puzzle is about attributes assigned to positions.\n    # We can interpret this clue as: the person at position 1 is person 0.\n    # Since the puzzle only has attributes, and no explicit person variables, this clue is ambiguous.\n    # However, since the puzzle states \"0 is at position 2\", we can interpret it as the person at position 1 is person 0.\n    # So we can fix the position of person 0's attributes to be 1.\n    # Since person 0 has exactly one attribute from each category, and person 1 has the other attributes.\n    # So we can fix all attributes of person 0 to position 1, and all attributes of person 1 to position 0.\n    # But we don't have person variables, so we can assign one attribute from each category to position 1 (person 0), and the other to position 0 (person 1).\n    # So we can fix one attribute from each category to position 1.\n    # Let's fix \"Pet:ferret\" to position 1 (person 0), and \"Food:grapes\" to position 1 (person 0).\n    # But clue 2 says \"the person who likes grapes is the same person as the person who has ferret as a pet\"\n    # So \"Pet:ferret\" and \"Food:grapes\" must be at the same position.\n    # So we can fix \"Pet:ferret\" to position 1.\n    problem.addConstraint(lambda x: x == 1, [\"Pet:ferret\"])\n    \n    # Clue 2: the person who likes grapes is the same person as the person who has ferret as a pet\n    problem.addConstraint(lambda x, y: x == y, [\"Food:grapes\", \"Pet:ferret\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Pet': ['chinchilla', 'ferret'], 'Food': ['lemon', 'grapes']}\n",
      "success": true,
      "execution_time": 0.001279,
      "timestamp": "20250814_084550",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['grapes', 'lemon'], 'Pet': ['ferret', 'chinchilla']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_74_b01009e9",
      "puzzle": {
        "id": "einstein_2x2_74_b01009e9",
        "title": "Zebra Puzzle einstein_2x2_74_b01009e9",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: superhero, disaster\n2. Sport: cycling, surfing\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who plays surfing is immediately to the right of the person who likes disaster movies\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 74,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0004432499408721924,
          "n_level": 1,
          "table_markdown": "|         |    1     |     2     |\n| Movie   | disaster | superhero |\n| Sport   | cycling  | surfing   |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"disaster\", \"superhero\"], \"Sport\": [\"cycling\", \"surfing\"]}"
      },
      "puzzle_hash": "67a69cf2cbc6193f02aa09c70d33a9df",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Sport\"]\n    items = {\n        \"Movie\": [\"superhero\", \"disaster\"],\n        \"Sport\": [\"cycling\", \"surfing\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who plays surfing is immediately to the right of the person who likes disaster movies\n    problem.addConstraint(lambda disaster_pos, surfing_pos: surfing_pos == disaster_pos + 1,\n                          [\"Movie:disaster\", \"Sport:surfing\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['disaster', 'superhero'], 'Sport': ['cycling', 'surfing']}\n",
      "success": true,
      "execution_time": 0.001242,
      "timestamp": "20250814_084554",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['disaster', 'superhero'], 'Sport': ['cycling', 'surfing']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_75_0291de5f",
      "puzzle": {
        "id": "einstein_2x2_75_0291de5f",
        "title": "Zebra Puzzle einstein_2x2_75_0291de5f",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: horror, thriller\n2. Pet: turtle, horse\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who has horse as a pet is immediately to the right of the person who likes thriller movies\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Pet\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 75,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0006115420255810022,
          "n_level": 1,
          "table_markdown": "|         |    1     |   2    |\n| Movie   | thriller | horror |\n| Pet     | turtle   | horse  |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"thriller\", \"horror\"], \"Pet\": [\"turtle\", \"horse\"]}"
      },
      "puzzle_hash": "d5fd5300a94c441ee7f8f4fc1f6d3d86",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Pet\"]\n    items = {\n        \"Movie\": [\"horror\", \"thriller\"],\n        \"Pet\": [\"turtle\", \"horse\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who has horse as a pet is immediately to the right of the person who likes thriller movies\n    problem.addConstraint(lambda movie_thriller, pet_horse: pet_horse == movie_thriller + 1,\n                          [\"Movie:thriller\", \"Pet:horse\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['thriller', 'horror'], 'Pet': ['turtle', 'horse']}\n",
      "success": true,
      "execution_time": 0.001242,
      "timestamp": "20250814_084558",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['thriller', 'horror'], 'Pet': ['turtle', 'horse']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_76_bcc2fb68",
      "puzzle": {
        "id": "einstein_2x2_76_bcc2fb68",
        "title": "Zebra Puzzle einstein_2x2_76_bcc2fb68",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Beverage: juice, cola\n2. Transport: motorbike, ship\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes cola is immediately to the right of the person who uses motorbike for transportation\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 76,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003824590239673853,
          "n_level": 1,
          "table_markdown": "|             |     1     |  2   |\n| Beverage    | juice     | cola |\n| Transport   | motorbike | ship |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"juice\", \"cola\"], \"Transport\": [\"motorbike\", \"ship\"]}"
      },
      "puzzle_hash": "b6214c2c57eef1b9e6c97914df002507",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Beverage\", \"Transport\"]\n    items = {\n        \"Beverage\": [\"juice\", \"cola\"],\n        \"Transport\": [\"motorbike\", \"ship\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes cola is immediately to the right of the person who uses motorbike for transportation\n    problem.addConstraint(lambda motorbike_pos, cola_pos: cola_pos == motorbike_pos + 1,\n                          [\"Transport:motorbike\", \"Beverage:cola\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Beverage': ['juice', 'cola'], 'Transport': ['motorbike', 'ship']}\n",
      "success": true,
      "execution_time": 0.001245,
      "timestamp": "20250814_084602",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['juice', 'cola'], 'Transport': ['motorbike', 'ship']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_77_2b2ba653",
      "puzzle": {
        "id": "einstein_2x2_77_2b2ba653",
        "title": "Zebra Puzzle einstein_2x2_77_2b2ba653",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: time-travel, action\n2. Beverage: fanta, milk\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes action movies is immediately to the right of the person who likes fanta\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Movie\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 77,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0007027920801192522,
          "n_level": 1,
          "table_markdown": "|            |      1      |   2    |\n| Beverage   | fanta       | milk   |\n| Movie      | time-travel | action |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"fanta\", \"milk\"], \"Movie\": [\"time-travel\", \"action\"]}"
      },
      "puzzle_hash": "b7417e7f10855e548c4547e24c14545b",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Beverage\"]\n    items = {\n        \"Movie\": [\"time-travel\", \"action\"],\n        \"Beverage\": [\"fanta\", \"milk\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes action movies is immediately to the right of the person who likes fanta\n    problem.addConstraint(lambda action_pos, fanta_pos: action_pos == fanta_pos + 1,\n                          [\"Movie:action\", \"Beverage:fanta\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['time-travel', 'action'], 'Beverage': ['fanta', 'milk']}\n",
      "success": true,
      "execution_time": 0.001432,
      "timestamp": "20250814_084606",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['fanta', 'milk'], 'Movie': ['time-travel', 'action']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_78_1cb1991c",
      "puzzle": {
        "id": "einstein_2x2_78_1cb1991c",
        "title": "Zebra Puzzle einstein_2x2_78_1cb1991c",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Nationality: dutch, colombian\n2. Transport: helicopter, taxi\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. 0 is at position 2\n2. the colombian person is the same person as the person who uses helicopter for transportation\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Nationality\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 78,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.000856917118653655,
          "n_level": 1,
          "table_markdown": "|               |   1   |     2      |\n| Nationality   | dutch | colombian  |\n| Transport     | taxi  | helicopter |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Nationality\": [\"dutch\", \"colombian\"], \"Transport\": [\"taxi\", \"helicopter\"]}"
      },
      "puzzle_hash": "3317a80430e521bc13f72a416cb5fa54",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Nationality\", \"Transport\"]\n    items = {\n        \"Nationality\": [\"dutch\", \"colombian\"],\n        \"Transport\": [\"helicopter\", \"taxi\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue 1: 0 is at position 2 (0-indexed position 1)\n    problem.addConstraint(lambda x: x == 1, [\"Nationality:dutch\"])\n    \n    # Clue 2: the colombian person is the same person as the person who uses helicopter for transportation\n    problem.addConstraint(lambda x, y: x == y, [\"Nationality:colombian\", \"Transport:helicopter\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Nationality': ['colombian', 'dutch'], 'Transport': ['helicopter', 'taxi']}\n",
      "success": true,
      "execution_time": 0.001217,
      "timestamp": "20250814_084610",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Nationality': ['dutch', 'colombian'], 'Transport': ['taxi', 'helicopter']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_79_1b4f1ee4",
      "puzzle": {
        "id": "einstein_2x2_79_1b4f1ee4",
        "title": "Zebra Puzzle einstein_2x2_79_1b4f1ee4",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Pet: horse, mouse\n2. Sport: weightlifting, rugby\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who plays rugby is immediately to the left of the person who has mouse as a pet\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Pet\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 79,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0005322091747075319,
          "n_level": 1,
          "table_markdown": "|         |   1   |       2       |\n| Pet     | horse | mouse         |\n| Sport   | rugby | weightlifting |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Pet\": [\"horse\", \"mouse\"], \"Sport\": [\"rugby\", \"weightlifting\"]}"
      },
      "puzzle_hash": "0a1688ea033a0bec367bc4fa450f8898",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Pet\", \"Sport\"]\n    items = {\n        \"Pet\": [\"horse\", \"mouse\"],\n        \"Sport\": [\"weightlifting\", \"rugby\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # the person who plays rugby is immediately to the left of the person who has mouse as a pet\n    problem.addConstraint(lambda rugby_pos, mouse_pos: rugby_pos == mouse_pos - 1,\n                          [\"Sport:rugby\", \"Pet:mouse\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Pet': ['horse', 'mouse'], 'Sport': ['rugby', 'weightlifting']}\n",
      "success": true,
      "execution_time": 0.001249,
      "timestamp": "20250814_084613",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Pet': ['horse', 'mouse'], 'Sport': ['rugby', 'weightlifting']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_084048"
      }
    },
    {
      "puzzle_id": "einstein_2x2_0_3095afa9",
      "puzzle": {
        "id": "einstein_2x2_0_3095afa9",
        "title": "Zebra Puzzle einstein_2x2_0_3095afa9",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: superhero, martial-arts\n2. Beverage: 7up, iced-tea\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes martial-arts movies is immediately to the left of the person who likes iced-tea\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Beverage\", \"Movie\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 0,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.000490417005494237,
          "n_level": 1,
          "table_markdown": "|            |      1       |     2     |\n| Beverage   | 7up          | iced-tea  |\n| Movie      | martial-arts | superhero |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Beverage\": [\"7up\", \"iced-tea\"], \"Movie\": [\"martial-arts\", \"superhero\"]}"
      },
      "puzzle_hash": "8f7d8e0de6c1852083f815f25135e5f8",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Beverage\"]\n    items = {\n        \"Movie\": [\"superhero\", \"martial-arts\"],\n        \"Beverage\": [\"7up\", \"iced-tea\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who likes martial-arts movies is immediately to the left of the person who likes iced-tea\n    problem.addConstraint(lambda m, b: m == b - 1, [\"Movie:martial-arts\", \"Beverage:iced-tea\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['martial-arts', 'superhero'], 'Beverage': ['7up', 'iced-tea']}\n",
      "success": true,
      "execution_time": 0.001348,
      "timestamp": "20250814_080726",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Beverage': ['7up', 'iced-tea'], 'Movie': ['martial-arts', 'superhero']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_080721"
      }
    },
    {
      "puzzle_id": "einstein_2x2_1_62998523",
      "puzzle": {
        "id": "einstein_2x2_1_62998523",
        "title": "Zebra Puzzle einstein_2x2_1_62998523",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Sport: badminton, water-polo\n2. Music: blues, classical\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who plays badminton is immediately to the left of the person who likes classical music\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Music\", \"Sport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 1,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0003627908881753683,
          "n_level": 1,
          "table_markdown": "|         |     1     |     2      |\n| Music   | blues     | classical  |\n| Sport   | badminton | water-polo |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Music\": [\"blues\", \"classical\"], \"Sport\": [\"badminton\", \"water-polo\"]}"
      },
      "puzzle_hash": "4a71bd5927dcf04a67318e74731bbca4",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Sport\", \"Music\"]\n    items = {\n        \"Sport\": [\"badminton\", \"water-polo\"],\n        \"Music\": [\"blues\", \"classical\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Add constraints from clues here\n    # Clue: the person who plays badminton is immediately to the left of the person who likes classical music\n    problem.addConstraint(lambda badminton_pos, classical_pos: badminton_pos == classical_pos - 1,\n                          [\"Sport:badminton\", \"Music:classical\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Sport': ['badminton', 'water-polo'], 'Music': ['blues', 'classical']}\n",
      "success": true,
      "execution_time": 0.002016,
      "timestamp": "20250814_080752",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Music': ['blues', 'classical'], 'Sport': ['badminton', 'water-polo']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_080721"
      }
    },
    {
      "puzzle_id": "einstein_2x2_2_8cfa193d",
      "puzzle": {
        "id": "einstein_2x2_2_8cfa193d",
        "title": "Zebra Puzzle einstein_2x2_2_8cfa193d",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Food: kale, radish\n2. Hobby: gardening, dancing\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys gardening is immediately to the left of the person who likes radish\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Food\", \"Hobby\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 2,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.00044141593389213085,
          "n_level": 1,
          "table_markdown": "|         |     1     |    2    |\n| Food    | kale      | radish  |\n| Hobby   | gardening | dancing |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Food\": [\"kale\", \"radish\"], \"Hobby\": [\"gardening\", \"dancing\"]}"
      },
      "puzzle_hash": "4aa58a296dc4821a9680172e061f4d6f",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Food\", \"Hobby\"]\n    items = {\n        \"Food\": [\"kale\", \"radish\"],\n        \"Hobby\": [\"gardening\", \"dancing\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who enjoys gardening is immediately to the left of the person who likes radish\n    problem.addConstraint(lambda gardening_pos, radish_pos: gardening_pos == radish_pos - 1,\n                          [\"Hobby:gardening\", \"Food:radish\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Food': ['kale', 'radish'], 'Hobby': ['gardening', 'dancing']}\n",
      "success": true,
      "execution_time": 0.00197,
      "timestamp": "20250814_080756",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Food': ['kale', 'radish'], 'Hobby': ['gardening', 'dancing']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_080721"
      }
    },
    {
      "puzzle_id": "einstein_2x2_3_bf9fe331",
      "puzzle": {
        "id": "einstein_2x2_3_bf9fe331",
        "title": "Zebra Puzzle einstein_2x2_3_bf9fe331",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Movie: fantasy, sports\n2. Transport: snowmobile, subway\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who likes sports movies is immediately to the left of the person who uses subway for transportation\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Movie\", \"Transport\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 3,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0016154581680893898,
          "n_level": 1,
          "table_markdown": "|             |     1      |    2    |\n| Movie       | sports     | fantasy |\n| Transport   | snowmobile | subway  |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Movie\": [\"sports\", \"fantasy\"], \"Transport\": [\"snowmobile\", \"subway\"]}"
      },
      "puzzle_hash": "cf5aa09c4d327e3f2fee3e4f174ea146",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Movie\", \"Transport\"]\n    items = {\n        \"Movie\": [\"fantasy\", \"sports\"],\n        \"Transport\": [\"snowmobile\", \"subway\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who likes sports movies is immediately to the left of the person who uses subway for transportation\n    problem.addConstraint(lambda sports_pos, subway_pos: sports_pos == subway_pos - 1,\n                          [\"Movie:sports\", \"Transport:subway\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Movie': ['sports', 'fantasy'], 'Transport': ['snowmobile', 'subway']}\n",
      "success": true,
      "execution_time": 0.002448,
      "timestamp": "20250814_080800",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Movie': ['sports', 'fantasy'], 'Transport': ['snowmobile', 'subway']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_080721"
      }
    },
    {
      "puzzle_id": "einstein_2x2_4_d7f4590a",
      "puzzle": {
        "id": "einstein_2x2_4_d7f4590a",
        "title": "Zebra Puzzle einstein_2x2_4_d7f4590a",
        "problem": "You are given an Einstein logic puzzle. In this puzzle, there are 2 people living in the same community. Each person has exactly one attribute from each of 2 different categories (like nationality, pet, drink, etc.). No two people share the same attribute from any category. Your task is to determine which attributes belong to which person based on the given clues. The clues describe relationships between people and their attributes. For example 'the person with the red house is immediately to the left of the person who drinks coffee'. By logically combining all clues, you should be able to determine the complete solution.\n\nSetup:\n\nThe puzzle involves the following categories, each with 2 unique items:\n\n1. Pet: horse, mouse\n2. Hobby: skydiving, rock-climbing\n\nEach category has exactly 2 items, and no item repeats within a category.\n\nClues:\n\n1. the person who enjoys rock-climbing is immediately to the left of the person who has horse as a pet\n\nExpected Output Format:\n\nYour solution should be a dictionary where:\n- Each key is a category name (e.g., \"Hobby\", \"Pet\").\n- Each value is a list of items, ordered by position from left to right (position 1 to position 2).\n- Each item in a category must appear exactly once.\n",
        "source": "zebra_raw_n2_m2",
        "metadata": {
          "n_attributes": 2,
          "m_objects": 2,
          "difficulty_score": 4,
          "batch_source": "n2_m2",
          "config": {
            "config_index": 4,
            "m_objects": 2,
            "n_attributes": 2,
            "n_level": 1
          },
          "generation_time": 0.0020932499319314957,
          "n_level": 1,
          "table_markdown": "|         |       1       |     2     |\n| Hobby   | rock-climbing | skydiving |\n| Pet     | mouse         | horse     |"
        },
        "clues": [],
        "categories": [],
        "items": {},
        "ground_truth_solution": "{\"Hobby\": [\"rock-climbing\", \"skydiving\"], \"Pet\": [\"mouse\", \"horse\"]}"
      },
      "puzzle_hash": "4595ab8cfdd984c34c7ac76595c4d8c0",
      "code": "from constraint import Problem, AllDifferentConstraint\n\ndef solve_einstein_puzzle():\n    problem = Problem()\n    num_positions = 2  # Adjust based on puzzle size\n    \n    categories = [\"Pet\", \"Hobby\"]\n    items = {\n        \"Pet\": [\"horse\", \"mouse\"],\n        \"Hobby\": [\"skydiving\", \"rock-climbing\"]\n    }\n    \n    # Add variables for each item with domain being the possible positions\n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            problem.addVariable(variable_name, range(num_positions))\n    \n    # All items in the same category must have different positions\n    for category in categories:\n        category_items = [f\"{category}:{item}\" for item in items[category]]\n        problem.addConstraint(AllDifferentConstraint(), category_items)\n    \n    # Clue: the person who enjoys rock-climbing is immediately to the left of the person who has horse as a pet\n    problem.addConstraint(lambda rc_pos, horse_pos: rc_pos == horse_pos - 1,\n                          [\"Hobby:rock-climbing\", \"Pet:horse\"])\n    \n    solutions = problem.getSolutions()\n    \n    if not solutions:\n        return None\n    \n    if len(solutions) > 1:\n        raise ValueError(\"Multiple solutions found\")\n    \n    solution = solutions[0]\n    \n    # Format the solution as a dictionary\n    result_dict = {}\n    for category in categories:\n        result_dict[category] = [\"\"] * num_positions\n    \n    for category in categories:\n        for item in items[category]:\n            variable_name = f\"{category}:{item}\"\n            position = solution[variable_name]\n            result_dict[category][position] = item\n    \n    print(result_dict)\n\nsolve_einstein_puzzle()",
      "execution_result": "{'Pet': ['mouse', 'horse'], 'Hobby': ['rock-climbing', 'skydiving']}\n",
      "success": true,
      "execution_time": 0.001836,
      "timestamp": "20250814_080804",
      "verification": {
        "verified": true,
        "is_correct": true,
        "ground_truth": "{'Hobby': ['rock-climbing', 'skydiving'], 'Pet': ['mouse', 'horse']}",
        "verification_time": null,
        "verification_method": null,
        "verification_notes": null,
        "feedback": null
      },
      "additional_metadata": {
        "timestamp": "20250814_080721"
      }
    }
  ],
  "metadata": {
    "data_source": "ZebraDataLoader",
    "last_updated": "2025-08-14 08:46:13",
    "success_rate": 0.95,
    "successful_puzzles": 76,
    "timestamp": "20250814_080721",
    "total_puzzles_planned": 80,
    "total_puzzles_processed": 80,
    "verification_success_count": 76,
    "verification_success_rate": 1.0,
    "verified_puzzles": 76,
    "solver_type": "EinsteinPuzzleSolver",
    "dataset_name": "zebra",
    "dataset_split": null,
    "average_execution_time": 0.0014870263157894742,
    "run_id": "20250814_080721"
  },
  "timestamp": "20250814_080721",
  "version": "1.0"
}