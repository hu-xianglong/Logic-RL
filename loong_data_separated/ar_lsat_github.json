[
  {
    "question": "Exactly six trade representatives negotiate a treaty: Klosnik, Londi, Manley, Neri, Osata, Poirier. There are exactly six chairs evenly spaced around a circular table. The chairs are numbered 1 through 6, with successively numbered chairs next to each other and chair number 1 next to chair number 6. Each chair is occupied by exactly one of the representatives. The following conditions apply: Poirier sits immediately next to Neri. Londi sits immediately next to Manley, Neri, or both. Klosnik does not sit immediately next to Manley. If Osata sits immediately next to Poirier, Osata does not sit immediately next to Manley.\n\nWhich one of the following seating arrangements of the six representatives in chairs 1 through 6 would NOT violate the stated conditions?\n\nOptions:\n(A) Klosnik, Poirier, Neri, Manley, Osata, Londi\n(B) Klosnik, Londi, Manley, Poirier, Neri, Osata\n(C) Klosnik, Londi, Manley, Osata, Poirier, Neri\n(D) Klosnik, Osata, Poirier, Neri, Londi, Manley\n(E) Klosnik, Neri, Londi, Osata, Manley, Poirier",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nrepresentatives = ['Klosnik', 'Londi', 'Manley', 'Neri', 'Osata', 'Poirier']\nchairs = range(1, 7)\n\n# Map representative names to indices\nrep_idx = {rep: i for i, rep in enumerate(representatives)}\n\n# Create Z3 variables for each chair: which representative sits there\n# chair_vars[i] = representative index sitting in chair i+1\nchair_vars = [Int(f'ch{i+1}') for i in range(6)]\n\nsolver = Solver()\n\n# Each chair is occupied by exactly one representative (value in range)\nfor var in chair_vars:\n    solver.add(And(var >= 0, var < 6))\n\n# All representatives are seated exactly once (all different)\nsolver.add(Distinct(chair_vars))\n\n# Helper function: get neighbors of a chair index (0-based)\ndef neighbors(i):\n    return [(i-1) % 6, (i+1) % 6]\n\n# CONSTRAINTS\n# 1) Poirier sits immediately next to Neri\n# There exists chairs i,j such that chair_vars[i] = Poirier and chair_vars[j] = Neri and j is neighbor of i\n# We encode this by ensuring that the chair with Poirier has Neri in a neighbor chair\n\n# Create boolean variables for each chair whether Poirier sits there\npoirier_chairs = [chair_vars[i] == rep_idx['Poirier'] for i in range(6)]\nneri_chairs = [chair_vars[i] == rep_idx['Neri'] for i in range(6)]\n\n# For each chair i where Poirier sits, at least one neighbor j has Neri\npoirier_next_to_neri = []\nfor i in range(6):\n    neighs = neighbors(i)\n    neri_neighbors = [neri_chairs[j] for j in neighs]\n    poirier_next_to_neri.append(Implies(poirier_chairs[i], Or(neri_neighbors)))\n\nsolver.add(And(poirier_next_to_neri))\n\n# 2) Londi sits immediately next to Manley, Neri, or both\n# For the chair i where Londi sits, at least one neighbor j has Manley or Neri\nlondi_chairs = [chair_vars[i] == rep_idx['Londi'] for i in range(6)]\nmanley_chairs = [chair_vars[i] == rep_idx['Manley'] for i in range(6)]\n\nlondi_next_to_manley_or_neri = []\nfor i in range(6):\n    neighs = neighbors(i)\n    neighbors_m_or_n = [Or(manley_chairs[j], neri_chairs[j]) for j in neighs]\n    londi_next_to_manley_or_neri.append(Implies(londi_chairs[i], Or(neighbors_m_or_n)))\n\nsolver.add(And(londi_next_to_manley_or_neri))\n\n# 3) Klosnik does not sit immediately next to Manley\n# For chair i where Klosnik sits, no neighbor j has Manley\nklosnik_chairs = [chair_vars[i] == rep_idx['Klosnik'] for i in range(6)]\n\nklosnik_not_next_to_manley = []\nfor i in range(6):\n    neighs = neighbors(i)\n    neighbors_manley = [manley_chairs[j] for j in neighs]\n    # None of neighbors_manley is True\n    no_manley_neighbors = And([Not(x) for x in neighbors_manley])\n    klosnik_not_next_to_manley.append(Implies(klosnik_chairs[i], no_manley_neighbors))\n\nsolver.add(And(klosnik_not_next_to_manley))\n\n# 4) If Osata sits immediately next to Poirier, Osata does not sit immediately next to Manley\n# For chair i where Osata sits:\n# If any neighbor j has Poirier, then no neighbor k has Manley\nosata_chairs = [chair_vars[i] == rep_idx['Osata'] for i in range(6)]\n\nfor i in range(6):\n    neighs = neighbors(i)\n    neighbors_poirier = [poirier_chairs[j] for j in neighs]\n    neighbors_manley = [manley_chairs[j] for j in neighs]\n    osata_condition = Implies(\n        And(osata_chairs[i], Or(neighbors_poirier)),\n        And([Not(x) for x in neighbors_manley])\n    )\n    solver.add(osata_condition)\n\n# OPTION CHECKING\n# Each option is a list of representatives in chairs 1 through 6\noptions = [\n    ['Klosnik', 'Poirier', 'Neri', 'Manley', 'Osata', 'Londi'],  # A\n    ['Klosnik', 'Londi', 'Manley', 'Poirier', 'Neri', 'Osata'],  # B\n    ['Klosnik', 'Londi', 'Manley', 'Osata', 'Poirier', 'Neri'],  # C\n    ['Klosnik', 'Osata', 'Poirier', 'Neri', 'Londi', 'Manley'],  # D\n    ['Klosnik', 'Neri', 'Londi', 'Osata', 'Manley', 'Poirier'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that chair_vars correspond to this option seating\n    option_constraints = []\n    for chair_i, rep in enumerate(option):\n        option_constraints.append(chair_vars[chair_i] == rep_idx[rep])\n    solver.add(option_constraints)\n\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly six trade representatives negotiate a treaty: Klosnik, Londi, Manley, Neri, Osata, Poirier. There are exactly six chairs evenly spaced around a circular table. The chairs are numbered 1 through 6, with successively numbered chairs next to each other and chair number 1 next to chair number 6. Each chair is occupied by exactly one of the representatives. The following conditions apply: Poirier sits immediately next to Neri. Londi sits immediately next to Manley, Neri, or both. Klosnik does not sit immediately next to Manley. If Osata sits immediately next to Poirier, Osata does not sit immediately next to Manley.\n\nIf Londi sits immediately next to Manley, then which one of the following is a complete and accurate list of representatives any one of whom could also sit immediately next to Londi?\n\nOptions:\n(A) Klosnik\n(B) Klosnik, Neri\n(C) Neri, Poirier\n(D) Klosnik, Osata, Poirier\n(E) Klosnik, Neri, Osata, Poirier",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nrepresentatives = ['Klosnik', 'Londi', 'Manley', 'Neri', 'Osata', 'Poirier']\nrep_idx = {r: i for i, r in enumerate(representatives)}\nnum_chairs = 6\nchairs = list(range(1, num_chairs + 1))\n\n# Variables: chair assigned to each representative\nchair = {r: Int(r) for r in representatives}\n\n# Helper function: check if two chairs are adjacent in the circle\ndef adjacent(c1, c2):\n    return Or(c1 == ((c2 % num_chairs) + 1), c1 == ((c2 - 2) % num_chairs) + 1)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each chair number is between 1 and 6\nfor r in representatives:\n    solver.add(And(chair[r] >= 1, chair[r] <= num_chairs))\n\n# All chairs are distinct (each rep has unique chair)\nsolver.add(Distinct([chair[r] for r in representatives]))\n\n# Poirier sits immediately next to Neri\nsolver.add(adjacent(chair['Poirier'], chair['Neri']))\n\n# Londi sits immediately next to Manley, Neri, or both\nlondi_adj_manley = adjacent(chair['Londi'], chair['Manley'])\nlondi_adj_neri = adjacent(chair['Londi'], chair['Neri'])\nsolver.add(Or(londi_adj_manley, londi_adj_neri))\n\n# Klosnik does not sit immediately next to Manley\nsolver.add(Not(adjacent(chair['Klosnik'], chair['Manley'])))\n\n# If Osata sits immediately next to Poirier, Osata does not sit immediately next to Manley\nosata_adj_poirier = adjacent(chair['Osata'], chair['Poirier'])\nosata_adj_manley = adjacent(chair['Osata'], chair['Manley'])\nsolver.add(Implies(osata_adj_poirier, Not(osata_adj_manley)))\n\n# OPTION CHECKING\n# Given: Londi sits immediately next to Manley\nsolver.push()\nsolver.add(londi_adj_manley)\n\n# We want to find the complete and accurate list of representatives any one of whom could also sit immediately next to Londi\n# So for each representative other than Londi and Manley, check if they can sit immediately next to Londi in some solution\npossible_neighbors = []\nfor r in representatives:\n    if r in ['Londi', 'Manley']:\n        continue\n    solver.push()\n    # Add constraint: r sits immediately next to Londi\n    solver.add(adjacent(chair[r], chair['Londi']))\n    if solver.check() == sat:\n        possible_neighbors.append(r)\n    solver.pop()\n\nsolver.pop()\n\n# Now check which option matches the possible_neighbors exactly\noptions = [\n    ['Klosnik'],\n    ['Klosnik', 'Neri'],\n    ['Neri', 'Poirier'],\n    ['Klosnik', 'Osata', 'Poirier'],\n    ['Klosnik', 'Neri', 'Osata', 'Poirier'],\n]\n\nfor i, option in enumerate(options):\n    # Sort both lists for comparison\n    if sorted(option) == sorted(possible_neighbors):\n        print(f\"'{chr(65 + i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six trade representatives negotiate a treaty: Klosnik, Londi, Manley, Neri, Osata, Poirier. There are exactly six chairs evenly spaced around a circular table. The chairs are numbered 1 through 6, with successively numbered chairs next to each other and chair number 1 next to chair number 6. Each chair is occupied by exactly one of the representatives. The following conditions apply: Poirier sits immediately next to Neri. Londi sits immediately next to Manley, Neri, or both. Klosnik does not sit immediately next to Manley. If Osata sits immediately next to Poirier, Osata does not sit immediately next to Manley.\n\nIf Londi sits immediately next to Neri, which one of the following statements must be false?\n\nOptions:\n(A) Klosnik sits immediately next to Osata.\n(B) Londi sits immediately next to Manley.\n(C) Osata sits immediately next to Poirier.\n(D) Neri sits directly between Londi and Poirier.\n(E) Osata sits directly between Klosnik and Manley.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nrepresentatives = ['Klosnik', 'Londi', 'Manley', 'Neri', 'Osata', 'Poirier']\nnum_chairs = 6\n\n# Map representatives to indices for easy reference\nrep_idx = {rep: i for i, rep in enumerate(representatives)}\n\n# Create integer variables for each representative's chair number (1 to 6)\nchairs = {rep: Int(rep) for rep in representatives}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each chair number must be between 1 and 6\nfor rep in representatives:\n    solver.add(And(chairs[rep] >= 1, chairs[rep] <= num_chairs))\n\n# All representatives must occupy distinct chairs\nsolver.add(Distinct([chairs[rep] for rep in representatives]))\n\n# Helper function to check if two reps sit immediately next to each other\ndef next_to(rep1, rep2):\n    c1 = chairs[rep1]\n    c2 = chairs[rep2]\n    # Chairs are in a circle: difference is 1 or 5 (since 6 and 1 are adjacent)\n    diff = Abs(c1 - c2)\n    return Or(diff == 1, diff == 5)\n\n# Helper function to check if rep2 sits directly between rep1 and rep3\n# That means rep2's chair is adjacent to both rep1 and rep3, and rep1 and rep3 are not adjacent\ndef directly_between(rep1, rep2, rep3):\n    c1 = chairs[rep1]\n    c2 = chairs[rep2]\n    c3 = chairs[rep3]\n    adj_12 = Or(Abs(c1 - c2) == 1, Abs(c1 - c2) == 5)\n    adj_23 = Or(Abs(c2 - c3) == 1, Abs(c2 - c3) == 5)\n    adj_13 = Or(Abs(c1 - c3) == 1, Abs(c1 - c3) == 5)\n    return And(adj_12, adj_23, Not(adj_13))\n\n# Given constraints:\n\n# 1) Poirier sits immediately next to Neri\nsolver.add(next_to('Poirier', 'Neri'))\n\n# 2) Londi sits immediately next to Manley, Neri, or both\nsolver.add(Or(next_to('Londi', 'Manley'), next_to('Londi', 'Neri')))\n\n# 3) Klosnik does not sit immediately next to Manley\nsolver.add(Not(next_to('Klosnik', 'Manley')))\n\n# 4) If Osata sits immediately next to Poirier, Osata does not sit immediately next to Manley\n# That is: next_to(Osata, Poirier) => Not(next_to(Osata, Manley))\nsolver.add(Implies(next_to('Osata', 'Poirier'), Not(next_to('Osata', 'Manley'))))\n\n# Additional given: Londi sits immediately next to Neri (condition for the question)\nsolver.add(next_to('Londi', 'Neri'))\n\n# OPTION CHECKING\n# Options:\n# (A) Klosnik sits immediately next to Osata.\n# (B) Londi sits immediately next to Manley.\n# (C) Osata sits immediately next to Poirier.\n# (D) Neri sits directly between Londi and Poirier.\n# (E) Osata sits directly between Klosnik and Manley.\n\noptions = [\n    next_to('Klosnik', 'Osata'),\n    next_to('Londi', 'Manley'),\n    next_to('Osata', 'Poirier'),\n    directly_between('Londi', 'Neri', 'Poirier'),\n    directly_between('Klosnik', 'Osata', 'Manley')\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == unsat:\n        # This option must be false under the given conditions\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly six trade representatives negotiate a treaty: Klosnik, Londi, Manley, Neri, Osata, Poirier. There are exactly six chairs evenly spaced around a circular table. The chairs are numbered 1 through 6, with successively numbered chairs next to each other and chair number 1 next to chair number 6. Each chair is occupied by exactly one of the representatives. The following conditions apply: Poirier sits immediately next to Neri. Londi sits immediately next to Manley, Neri, or both. Klosnik does not sit immediately next to Manley. If Osata sits immediately next to Poirier, Osata does not sit immediately next to Manley.\n\nIf Klosnik sits immediately next to Osata, then Londi CANNOT sit directly between\n\nOptions:\n(A) Klosnik and Manley\n(B) Klosnik and Neri\n(C) Manley and Neri\n(D) Manley and Poirier\n(E) Neri and Osata",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nrepresentatives = ['Klosnik', 'Londi', 'Manley', 'Neri', 'Osata', 'Poirier']\nrep_index = {rep: i for i, rep in enumerate(representatives)}\n\n# Chairs are numbered 1 to 6 around a circular table\nchairs = list(range(1, 7))\n\n# Create Z3 Int variables representing the chair number for each representative\nchair = {rep: Int(rep) for rep in representatives}\n\n# Helper function to check if two reps sit immediately next to each other\ndef adjacent(r1, r2):\n    c1 = chair[r1]\n    c2 = chair[r2]\n    # Chairs 1 and 6 are adjacent, and chairs i and i+1 are adjacent for i=1..5\n    return Or(c1 == c2 + 1, c1 == c2 - 1, And(c1 == 1, c2 == 6), And(c1 == 6, c2 == 1))\n\n# Helper function to check if rep r3 sits directly between r1 and r2\ndef between(r1, r3, r2):\n    # r3 is between r1 and r2 if r3's chair is adjacent to both r1 and r2\n    # and r1 and r2 are not adjacent (since if r1 and r2 adjacent, no one is between)\n    c1 = chair[r1]\n    c2 = chair[r2]\n    c3 = chair[r3]\n    adj_r1_r3 = Or(c3 == c1 + 1, c3 == c1 - 1, And(c3 == 1, c1 == 6), And(c3 == 6, c1 == 1))\n    adj_r3_r2 = Or(c3 == c2 + 1, c3 == c2 - 1, And(c3 == 1, c2 == 6), And(c3 == 6, c2 == 1))\n    adj_r1_r2 = Or(c1 == c2 + 1, c1 == c2 - 1, And(c1 == 1, c2 == 6), And(c1 == 6, c2 == 1))\n    return And(adj_r1_r3, adj_r3_r2, Not(adj_r1_r2))\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each representative sits in exactly one chair between 1 and 6\nfor rep in representatives:\n    solver.add(And(chair[rep] >= 1, chair[rep] <= 6))\n\n# All chairs are distinct (one rep per chair)\nsolver.add(Distinct([chair[rep] for rep in representatives]))\n\n# Poirier sits immediately next to Neri\nsolver.add(adjacent('Poirier', 'Neri'))\n\n# Londi sits immediately next to Manley, Neri, or both\nadj_londi_manley = adjacent('Londi', 'Manley')\nadj_londi_neri = adjacent('Londi', 'Neri')\nsolver.add(Or(adj_londi_manley, adj_londi_neri))\n\n# Klosnik does not sit immediately next to Manley\nsolver.add(Not(adjacent('Klosnik', 'Manley')))\n\n# If Osata sits immediately next to Poirier, Osata does not sit immediately next to Manley.\nosata_poirier_adj = adjacent('Osata', 'Poirier')\nosata_manley_adj = adjacent('Osata', 'Manley')\nsolver.add(Implies(osata_poirier_adj, Not(osata_manley_adj)))\n\n# OPTION CHECKING\n\noptions = {\n    'A': ('Klosnik', 'Manley'),\n    'B': ('Klosnik', 'Neri'),\n    'C': ('Manley', 'Neri'),\n    'D': ('Manley', 'Poirier'),\n    'E': ('Neri', 'Osata')\n}\n\n# We want to find which option cannot be true if Klosnik sits immediately next to Osata.\n\nfor letter, (r1, r2) in options.items():\n    solver.push()\n    # Add condition: Klosnik sits immediately next to Osata\n    solver.add(adjacent('Klosnik', 'Osata'))\n    # Add condition: Londi sits directly between r1 and r2\n    solver.add(between(r1, 'Londi', r2))\n    # Check if the model is satisfiable\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A small software firm has four offices, numbered 1, 2, 3, and 4. Each of its offices has exactly one computer and exactly one printer. Each of these eight machines was bought in either 1987, 1988, or 1989. The eight machines were bought in a manner consistent with the following conditions: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office. The computer in office 2 and the printer in office 1 were bought in the same year. The computer in office 3 and the printer in office 4 were bought in the same year. The computer in office 2 and the computer in office 3 were bought in different years. The computer in office 1 and the printer in office 3 were bought in 1988.\n\nIf the computer in office 3 was bought in an earlier year than the printer in office 3 was, then which one of the following statements could be true?\n\nOptions:\n(A) The computer in office 2 was bought in 1987.\n(B) The computer in office 2 was bought in 1988.\n(C) The computer in office 4 was bought in 1988.\n(D) The printer in office 4 was bought in 1988.\n(E) The printer in office 4 was bought in 1989.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nyears = [1987, 1988, 1989]\nyear_to_idx = {year: i for i, year in enumerate(years)}\n\noffices = [1, 2, 3, 4]\n\n# Create variables for computers and printers purchase years as indices (0,1,2)\ncomp = {o: Int(f'comp{o}') for o in offices}\nprin = {o: Int(f'prin{o}') for o in offices}\n\nsolver = Solver()\n\n# Each variable must be one of the valid year indices (0,1,2)\nfor o in offices:\n    solver.add(And(comp[o] >= 0, comp[o] < 3))\n    solver.add(And(prin[o] >= 0, prin[o] < 3))\n\n# CONSTRAINTS\n\n# The computer in each office was bought either in an earlier year than or in the same year as the printer in that office.\nfor o in offices:\n    solver.add(comp[o] <= prin[o])\n\n# The computer in office 2 and the printer in office 1 were bought in the same year.\nsolver.add(comp[2] == prin[1])\n\n# The computer in office 3 and the printer in office 4 were bought in the same year.\nsolver.add(comp[3] == prin[4])\n\n# The computer in office 2 and the computer in office 3 were bought in different years.\nsolver.add(comp[2] != comp[3])\n\n# The computer in office 1 and the printer in office 3 were bought in 1988.\nsolver.add(comp[1] == year_to_idx[1988])\nsolver.add(prin[3] == year_to_idx[1988])\n\n# The condition for the question: If the computer in office 3 was bought in an earlier year than the printer in office 3 was,\n# then which one of the following statements could be true?\n# So we add comp[3] < prin[3] as an additional constraint to test options.\n\nsolver.add(comp[3] < prin[3])\n\n# OPTION CHECKING\noptions = [\n    ('A', comp[2] == year_to_idx[1987]),\n    ('B', comp[2] == year_to_idx[1988]),\n    ('C', comp[4] == year_to_idx[1988]),\n    ('D', prin[4] == year_to_idx[1988]),\n    ('E', prin[4] == year_to_idx[1989]),\n]\n\nfor letter, option_constraint in options:\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A small software firm has four offices, numbered 1, 2, 3, and 4. Each of its offices has exactly one computer and exactly one printer. Each of these eight machines was bought in either 1987, 1988, or 1989. The eight machines were bought in a manner consistent with the following conditions: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office. The computer in office 2 and the printer in office 1 were bought in the same year. The computer in office 3 and the printer in office 4 were bought in the same year. The computer in office 2 and the computer in office 3 were bought in different years. The computer in office 1 and the printer in office 3 were bought in 1988.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) The printer in office 1 was bought in 1987.\n(B) The computer in office 2 was bought in 1987.\n(C) The computer in office 3 was bought in 1989.\n(D) The printer in office 4 was bought in 1988.\n(E) The printer in office 4 was bought in 1989.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nyears = [1987, 1988, 1989]\nyear_indices = {1987: 0, 1988: 1, 1989: 2}\n\noffices = [1, 2, 3, 4]\n\n# For each office, define variables for computer and printer purchase years as indices 0..2\ncomputer = {o: Int(f\"computer_{o}\") for o in offices}\nprinter = {o: Int(f\"printer_{o}\") for o in offices}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each variable must be one of the indices 0,1,2 corresponding to years 1987,1988,1989\nfor o in offices:\n    solver.add(And(computer[o] >= 0, computer[o] <= 2))\n    solver.add(And(printer[o] >= 0, printer[o] <= 2))\n\n# The computer in each office was bought either in an earlier year than or in the same year as the printer in that office.\nfor o in offices:\n    solver.add(computer[o] <= printer[o])\n\n# The computer in office 2 and the printer in office 1 were bought in the same year.\nsolver.add(computer[2] == printer[1])\n\n# The computer in office 3 and the printer in office 4 were bought in the same year.\nsolver.add(computer[3] == printer[4])\n\n# The computer in office 2 and the computer in office 3 were bought in different years.\nsolver.add(computer[2] != computer[3])\n\n# The computer in office 1 and the printer in office 3 were bought in 1988.\nsolver.add(computer[1] == year_indices[1988])\nsolver.add(printer[3] == year_indices[1988])\n\n# OPTION CHECKING\n# Define option constraints\noption_constraints = [\n    # (A) The printer in office 1 was bought in 1987.\n    printer[1] == year_indices[1987],\n    # (B) The computer in office 2 was bought in 1987.\n    computer[2] == year_indices[1987],\n    # (C) The computer in office 3 was bought in 1989.\n    computer[3] == year_indices[1989],\n    # (D) The printer in office 4 was bought in 1988.\n    printer[4] == year_indices[1988],\n    # (E) The printer in office 4 was bought in 1989.\n    printer[4] == year_indices[1989],\n]\n\nfor i, opt_constraint in enumerate(option_constraints):\n    solver.push()\n    solver.add(opt_constraint)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A small software firm has four offices, numbered 1, 2, 3, and 4. Each of its offices has exactly one computer and exactly one printer. Each of these eight machines was bought in either 1987, 1988, or 1989. The eight machines were bought in a manner consistent with the following conditions: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office. The computer in office 2 and the printer in office 1 were bought in the same year. The computer in office 3 and the printer in office 4 were bought in the same year. The computer in office 2 and the computer in office 3 were bought in different years. The computer in office 1 and the printer in office 3 were bought in 1988.\n\nIf as few of the eight machines as possible were bought in 1987, then what is the exact number of machines that were bought in 1987?\n\nOptions:\n(A) 0\n(B) 1\n(C) 2\n(D) 3\n(E) 4",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nyears = [1987, 1988, 1989]\nyear_to_idx = {y: i for i, y in enumerate(years)}\n\noffices = [1, 2, 3, 4]\n\n# Variables: For each office, computer year and printer year as indices 0,1,2 for 1987,1988,1989\ncomputer = {o: Int(f'computer_{o}') for o in offices}\nprinter = {o: Int(f'printer_{o}') for o in offices}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each computer and printer year is in range 0..2 (corresponding to 1987..1989)\nfor o in offices:\n    solver.add(And(computer[o] >= 0, computer[o] < 3))\n    solver.add(And(printer[o] >= 0, printer[o] < 3))\n\n# The computer in each office was bought either in an earlier year than or in the same year as the printer in that office.\nfor o in offices:\n    solver.add(computer[o] <= printer[o])\n\n# The computer in office 2 and the printer in office 1 were bought in the same year.\nsolver.add(computer[2] == printer[1])\n\n# The computer in office 3 and the printer in office 4 were bought in the same year.\nsolver.add(computer[3] == printer[4])\n\n# The computer in office 2 and the computer in office 3 were bought in different years.\nsolver.add(computer[2] != computer[3])\n\n# The computer in office 1 and the printer in office 3 were bought in 1988 (index 1).\nsolver.add(computer[1] == year_to_idx[1988])\nsolver.add(printer[3] == year_to_idx[1988])\n\n# OPTION CHECKING\n# We want to find the minimal number of machines bought in 1987 (index 0)\n# Then check which option matches that minimal number.\n\n# Count how many machines bought in 1987\nmachines = []\nfor o in offices:\n    machines.append(computer[o])\n    machines.append(printer[o])\n\nmachines_1987 = [If(m == year_to_idx[1987], 1, 0) for m in machines]\ntotal_1987 = Sum(machines_1987)\n\n# Find minimal total_1987\n# Use optimization to minimize total_1987\nopt = Optimize()\n\n# Add all constraints again to opt\nfor c in solver.assertions():\n    opt.add(c)\n\nh = opt.minimize(total_1987)\n\nif opt.check() == sat:\n    model = opt.model()\n    minimal_1987 = model.eval(total_1987).as_long()\nelse:\n    minimal_1987 = None\n\n# Now check each option against minimal_1987\noptions = [0, 1, 2, 3, 4]\nletters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, opt_val in enumerate(options):\n    if minimal_1987 == opt_val:\n        print(f\"'{letters[i]}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A small software firm has four offices, numbered 1, 2, 3, and 4. Each of its offices has exactly one computer and exactly one printer. Each of these eight machines was bought in either 1987, 1988, or 1989. The eight machines were bought in a manner consistent with the following conditions: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office. The computer in office 2 and the printer in office 1 were bought in the same year. The computer in office 3 and the printer in office 4 were bought in the same year. The computer in office 2 and the computer in office 3 were bought in different years. The computer in office 1 and the printer in office 3 were bought in 1988.\n\nIf the computer in office 4 was bought in 1988, then which one of the following statements must be true?\n\nOptions:\n(A) The printer in office 1 was bought in 1988.\n(B) The printer in office 1 was bought in 1989.\n(C) The computer in office 2 was bought in 1988.\n(D) The computer in office 3 was bought in 1987.\n(E) The printer in office 4 was bought in 1989.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nyears = [1987, 1988, 1989]\nyear_indices = {1987:0, 1988:1, 1989:2}\n\noffices = [1, 2, 3, 4]\n\n# Create variables for computers and printers for each office\n# Values are indices 0,1,2 corresponding to years 1987,1988,1989\ncomputer = dict()\nprinter = dict()\nfor o in offices:\n    computer[o] = Int(f'computer_{o}')\n    printer[o] = Int(f'printer_{o}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each machine was bought in one of the three years\nfor o in offices:\n    solver.add(And(computer[o] >= 0, computer[o] <= 2))\n    solver.add(And(printer[o] >= 0, printer[o] <= 2))\n\n# The computer in each office was bought either in an earlier year than or in the same year as the printer in that office.\nfor o in offices:\n    solver.add(computer[o] <= printer[o])\n\n# The computer in office 2 and the printer in office 1 were bought in the same year.\nsolver.add(computer[2] == printer[1])\n\n# The computer in office 3 and the printer in office 4 were bought in the same year.\nsolver.add(computer[3] == printer[4])\n\n# The computer in office 2 and the computer in office 3 were bought in different years.\nsolver.add(computer[2] != computer[3])\n\n# The computer in office 1 and the printer in office 3 were bought in 1988.\nsolver.add(computer[1] == year_indices[1988])\nsolver.add(printer[3] == year_indices[1988])\n\n# OPTION CHECKING\n# Given: The computer in office 4 was bought in 1988.\nsolver.add(computer[4] == year_indices[1988])\n\noptions = [\n    printer[1] == year_indices[1988],  # (A) The printer in office 1 was bought in 1988.\n    printer[1] == year_indices[1989],  # (B) The printer in office 1 was bought in 1989.\n    computer[2] == year_indices[1988], # (C) The computer in office 2 was bought in 1988.\n    computer[3] == year_indices[1987], # (D) The computer in office 3 was bought in 1987.\n    printer[4] == year_indices[1989],  # (E) The printer in office 4 was bought in 1989.\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))  # check if option can be false\n    if solver.check() == unsat:\n        # if adding Not(option) makes unsat, then option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A small software firm has four offices, numbered 1, 2, 3, and 4. Each of its offices has exactly one computer and exactly one printer. Each of these eight machines was bought in either 1987, 1988, or 1989. The eight machines were bought in a manner consistent with the following conditions: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office. The computer in office 2 and the printer in office 1 were bought in the same year. The computer in office 3 and the printer in office 4 were bought in the same year. The computer in office 2 and the computer in office 3 were bought in different years. The computer in office 1 and the printer in office 3 were bought in 1988.\n\nIf the computer in office 3 was bought in 1988, then which one of the following statements could be true?\n\nOptions:\n(A) The printer in office 1 was bought in 1988.\n(B) The computer in office 2 was bought in 1987.\n(C) The printer in office 2 was bought in 1988.\n(D) The computer in office 4 was bought in 1987.\n(E) The printer in office 4 was bought in 1989.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nyears = [1987, 1988, 1989]\nyear_indices = {1987:0, 1988:1, 1989:2}\n\noffices = [1, 2, 3, 4]\n\n# Variables: computer_year[office], printer_year[office]\ncomputer_year = {}\nprinter_year = {}\nfor o in offices:\n    computer_year[o] = Int(f'computer_{o}')\n    printer_year[o] = Int(f'printer_{o}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each machine's year is one of 1987, 1988, or 1989 (represented as indices 0,1,2)\nfor o in offices:\n    solver.add(And(computer_year[o] >= 0, computer_year[o] <= 2))\n    solver.add(And(printer_year[o] >= 0, printer_year[o] <= 2))\n\n# The computer in each office was bought either in an earlier year than or in the same year as the printer in that office.\nfor o in offices:\n    solver.add(computer_year[o] <= printer_year[o])\n\n# The computer in office 2 and the printer in office 1 were bought in the same year.\nsolver.add(computer_year[2] == printer_year[1])\n\n# The computer in office 3 and the printer in office 4 were bought in the same year.\nsolver.add(computer_year[3] == printer_year[4])\n\n# The computer in office 2 and the computer in office 3 were bought in different years.\nsolver.add(computer_year[2] != computer_year[3])\n\n# The computer in office 1 and the printer in office 3 were bought in 1988.\nsolver.add(computer_year[1] == year_indices[1988])\nsolver.add(printer_year[3] == year_indices[1988])\n\n# Additional condition: computer in office 3 was bought in 1988 (given in the question)\nsolver.add(computer_year[3] == year_indices[1988])\n\n# OPTION CHECKING\n# Define a function to check if an option can be true given the above constraints and the option's statement\ndef check_option(option_constraints):\n    solver.push()\n    for c in option_constraints:\n        solver.add(c)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# Option (A) The printer in office 1 was bought in 1988.\noption_A = [printer_year[1] == year_indices[1988]]\n\n# Option (B) The computer in office 2 was bought in 1987.\noption_B = [computer_year[2] == year_indices[1987]]\n\n# Option (C) The printer in office 2 was bought in 1988.\noption_C = [printer_year[2] == year_indices[1988]]\n\n# Option (D) The computer in office 4 was bought in 1987.\noption_D = [computer_year[4] == year_indices[1987]]\n\n# Option (E) The printer in office 4 was bought in 1989.\noption_E = [printer_year[4] == year_indices[1989]]\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, option in enumerate(options):\n    if check_option(option):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A small software firm has four offices, numbered 1, 2, 3, and 4. Each of its offices has exactly one computer and exactly one printer. Each of these eight machines was bought in either 1987, 1988, or 1989. The eight machines were bought in a manner consistent with the following conditions: The computer in each office was bought either in an earlier year than or in the same year as the printer in that office. The computer in office 2 and the printer in office 1 were bought in the same year. The computer in office 3 and the printer in office 4 were bought in the same year. The computer in office 2 and the computer in office 3 were bought in different years. The computer in office 1 and the printer in office 3 were bought in 1988.\n\nSuppose that the computer in office 2 and the computer in office 3 had been bought in the same year as each other. If all of the other conditions remained the same, then which one of the following machines could have been bought in 1989?\n\nOptions:\n(A) the printer in office 1\n(B) the computer in office 2\n(C) the printer in office 2\n(D) the computer in office 4\n(E) the printer in office 4",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nyears = [1987, 1988, 1989]\noffices = [1, 2, 3, 4]\nmachines = ['C', 'P']  # Computer, Printer\n\n# Create variables for each machine's purchase year\n# Key: (office, machine), value: Int variable representing year index (0 for 1987, 1 for 1988, 2 for 1989)\nyear_indices = {y: i for i, y in enumerate(years)}\nmachines_vars = dict()\nfor o in offices:\n    for m in machines:\n        machines_vars[(o, m)] = Int(f'y_{o}_{m}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each machine's year is in the range 0..2 (corresponding to 1987..1989)\nfor var in machines_vars.values():\n    solver.add(And(var >= 0, var <= 2))\n\n# Condition 1: Computer year <= Printer year in the same office\nfor o in offices:\n    c_var = machines_vars[(o, 'C')]\n    p_var = machines_vars[(o, 'P')]\n    solver.add(c_var <= p_var)\n\n# Condition 2: Computer in office 2 and printer in office 1 bought in the same year\nsolver.add(machines_vars[(2, 'C')] == machines_vars[(1, 'P')])\n\n# Condition 3: Computer in office 3 and printer in office 4 bought in the same year\nsolver.add(machines_vars[(3, 'C')] == machines_vars[(4, 'P')])\n\n# Condition 4: Computer in office 2 and computer in office 3 bought in different years\n# This condition will be replaced by the assumption in the question\n\n# Condition 5: Computer in office 1 and printer in office 3 bought in 1988\nsolver.add(machines_vars[(1, 'C')] == year_indices[1988])\nsolver.add(machines_vars[(3, 'P')] == year_indices[1988])\n\n# Now apply the supposition: computer in office 2 and computer in office 3 are bought in the same year\nsolver.add(machines_vars[(2, 'C')] == machines_vars[(3, 'C')])\n\n# Because of this, remove the original Condition 4 (different years) and replace by equality above\n\n# OPTION CHECKING\n# We need to check which machine could be bought in 1989 (year index 2) under the above constraints\noptions = [\n    (1, 'P'),  # (A) printer in office 1\n    (2, 'C'),  # (B) computer in office 2\n    (2, 'P'),  # (C) printer in office 2\n    (4, 'C'),  # (D) computer in office 4\n    (4, 'P')   # (E) printer in office 4\n]\n\nfor i, (office, machine) in enumerate(options):\n    solver.push()\n    solver.add(machines_vars[(office, machine)] == year_indices[1989])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "The eight partners of a law firm are Gregg, Hodges, Ivan, James, King, MacNeil, Nader, and Owens. In each of the years 1961 through 1968, exactly one of the partners joined the firm. Hodges joined the firm before Nader. King joined the firm before James. Nader and James joined the firm before Gregg. Nader joined the firm before Owens. James joined the firm before MacNeil. Gregg joined the firm before Ivan.\n\nWhich one of the following CANNOT be true?\n\nOptions:\n(A) Hodges joined the law firm in 1961.\n(B) Hodges joined the law firm in 1963.\n(C) Gregg joined the law firm in 1964.\n(D) MacNeil joined the law firm in 1964.\n(E) Owens joined the law firm in 1964.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npartners = ['Gregg', 'Hodges', 'Ivan', 'James', 'King', 'MacNeil', 'Nader', 'Owens']\nyears = list(range(1961, 1969))  # 1961 to 1968\n\n# Map partner names to Z3 Int variables representing the year they joined\njoin_year = {p: Int(p) for p in partners}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each partner joined in one of the years 1961-1968\nfor p in partners:\n    solver.add(And(join_year[p] >= 1961, join_year[p] <= 1968))\n\n# All partners joined in distinct years\nsolver.add(Distinct([join_year[p] for p in partners]))\n\n# Hodges joined before Nader\nsolver.add(join_year['Hodges'] < join_year['Nader'])\n\n# King joined before James\nsolver.add(join_year['King'] < join_year['James'])\n\n# Nader and James joined before Gregg\nsolver.add(join_year['Nader'] < join_year['Gregg'])\nsolver.add(join_year['James'] < join_year['Gregg'])\n\n# Nader joined before Owens\nsolver.add(join_year['Nader'] < join_year['Owens'])\n\n# James joined before MacNeil\nsolver.add(join_year['James'] < join_year['MacNeil'])\n\n# Gregg joined before Ivan\nsolver.add(join_year['Gregg'] < join_year['Ivan'])\n\n# OPTION CHECKING\noptions = {\n    'A': join_year['Hodges'] == 1961,\n    'B': join_year['Hodges'] == 1963,\n    'C': join_year['Gregg'] == 1964,\n    'D': join_year['MacNeil'] == 1964,\n    'E': join_year['Owens'] == 1964,\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "The eight partners of a law firm are Gregg, Hodges, Ivan, James, King, MacNeil, Nader, and Owens. In each of the years 1961 through 1968, exactly one of the partners joined the firm. Hodges joined the firm before Nader. King joined the firm before James. Nader and James joined the firm before Gregg. Nader joined the firm before Owens. James joined the firm before MacNeil. Gregg joined the firm before Ivan.\n\nIf James joined the firm in 1962, which one of the following CANNOT be true?\n\nOptions:\n(A) Hodges joined the firm in 1963.\n(B) MacNeil joined the firm in 1963.\n(C) Hodges joined the firm in 1964.\n(D) Nader joined the firm in 1964.\n(E) Owens joined the firm in 1964.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npartners = ['Gregg', 'Hodges', 'Ivan', 'James', 'King', 'MacNeil', 'Nader', 'Owens']\nyears = list(range(1961, 1969))  # 1961 to 1968 inclusive\n\n# Create a Z3 Int variable for each partner representing the year they joined\njoin_year = {p: Int(p) for p in partners}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each partner joined in a year from 1961 to 1968\nfor p in partners:\n    solver.add(And(join_year[p] >= 1961, join_year[p] <= 1968))\n\n# All partners joined in distinct years\nsolver.add(Distinct([join_year[p] for p in partners]))\n\n# Given constraints from the problem:\n# Hodges joined before Nader\nsolver.add(join_year['Hodges'] < join_year['Nader'])\n\n# King joined before James\nsolver.add(join_year['King'] < join_year['James'])\n\n# Nader and James joined before Gregg\nsolver.add(join_year['Nader'] < join_year['Gregg'])\nsolver.add(join_year['James'] < join_year['Gregg'])\n\n# Nader joined before Owens\nsolver.add(join_year['Nader'] < join_year['Owens'])\n\n# James joined before MacNeil\nsolver.add(join_year['James'] < join_year['MacNeil'])\n\n# Gregg joined before Ivan\nsolver.add(join_year['Gregg'] < join_year['Ivan'])\n\n# James joined in 1962\nsolver.add(join_year['James'] == 1962)\n\n# OPTION CHECKING\noptions = {\n    'A': join_year['Hodges'] == 1963,\n    'B': join_year['MacNeil'] == 1963,\n    'C': join_year['Hodges'] == 1964,\n    'D': join_year['Nader'] == 1964,\n    'E': join_year['Owens'] == 1964,\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "The eight partners of a law firm are Gregg, Hodges, Ivan, James, King, MacNeil, Nader, and Owens. In each of the years 1961 through 1968, exactly one of the partners joined the firm. Hodges joined the firm before Nader. King joined the firm before James. Nader and James joined the firm before Gregg. Nader joined the firm before Owens. James joined the firm before MacNeil. Gregg joined the firm before Ivan.\n\nIf Owens joined the firm in 1965 and MacNeil joined it in 1967, one can determine the years in which exactly how many of the other partners joined the firm?\n\nOptions:\n(A) 1\n(B) 2\n(C) 3\n(D) 4\n(E) 5",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npartners = ['Gregg', 'Hodges', 'Ivan', 'James', 'King', 'MacNeil', 'Nader', 'Owens']\nyears = list(range(1961, 1969))  # 1961 to 1968\n\n# Map each partner to an integer variable representing the year they joined\njoin_year = {p: Int(p) for p in partners}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each partner's join year must be between 1961 and 1968\nfor p in partners:\n    solver.add(And(join_year[p] >= 1961, join_year[p] <= 1968))\n\n# All join years are distinct\nsolver.add(Distinct([join_year[p] for p in partners]))\n\n# Given order constraints:\n# Hodges joined before Nader\nsolver.add(join_year['Hodges'] < join_year['Nader'])\n\n# King joined before James\nsolver.add(join_year['King'] < join_year['James'])\n\n# Nader and James joined before Gregg\nsolver.add(join_year['Nader'] < join_year['Gregg'])\nsolver.add(join_year['James'] < join_year['Gregg'])\n\n# Nader joined before Owens\nsolver.add(join_year['Nader'] < join_year['Owens'])\n\n# James joined before MacNeil\nsolver.add(join_year['James'] < join_year['MacNeil'])\n\n# Gregg joined before Ivan\nsolver.add(join_year['Gregg'] < join_year['Ivan'])\n\n# Owens joined in 1965\nsolver.add(join_year['Owens'] == 1965)\n\n# MacNeil joined in 1967\nsolver.add(join_year['MacNeil'] == 1967)\n\n# OPTION CHECKING\n# We want to find how many other partners' join years can be exactly determined.\n# For each partner other than Owens and MacNeil, check if their join year is uniquely determined.\n\nfixed_partners = ['Owens', 'MacNeil']\nother_partners = [p for p in partners if p not in fixed_partners]\n\ndef is_year_unique(partner):\n    # Check if join_year[partner] is uniquely determined\n    # First, find one solution with current constraints\n    if solver.check() != sat:\n        return False\n    model = solver.model()\n    val = model.evaluate(join_year[partner]).as_long()\n\n    # Add constraint that join_year[partner] != val and check if still satisfiable\n    solver.push()\n    solver.add(join_year[partner] != val)\n    res = solver.check()\n    solver.pop()\n    # If unsat, then the year is uniquely determined\n    return res == unsat\n\ncount_unique = 0\nfor p in other_partners:\n    if is_year_unique(p):\n        count_unique += 1\n\n# Print the letter of the correct option\n# Options: (A)1, (B)2, (C)3, (D)4, (E)5\noptions_map = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E'}\n\nprint(f\"'{options_map[count_unique]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "The eight partners of a law firm are Gregg, Hodges, Ivan, James, King, MacNeil, Nader, and Owens. In each of the years 1961 through 1968, exactly one of the partners joined the firm. Hodges joined the firm before Nader. King joined the firm before James. Nader and James joined the firm before Gregg. Nader joined the firm before Owens. James joined the firm before MacNeil. Gregg joined the firm before Ivan.\n\nAssume that Owens joined the law firm before MacNeil. Of the following, which one is the earliest year in which MacNeil could have joined it?\n\nOptions:\n(A) 1963\n(B) 1964\n(C) 1965\n(D) 1966\n(E) 1967",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npartners = ['Gregg', 'Hodges', 'Ivan', 'James', 'King', 'MacNeil', 'Nader', 'Owens']\nyears = list(range(1961, 1969))  # 1961 to 1968\n\n# Create a mapping from partner to their joining year (integer variable)\njoin_year = {p: Int(p) for p in partners}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each partner joined in a year between 1961 and 1968\nfor p in partners:\n    solver.add(And(join_year[p] >= 1961, join_year[p] <= 1968))\n\n# All partners joined in distinct years\nsolver.add(Distinct([join_year[p] for p in partners]))\n\n# Hodges joined before Nader\nsolver.add(join_year['Hodges'] < join_year['Nader'])\n\n# King joined before James\nsolver.add(join_year['King'] < join_year['James'])\n\n# Nader and James joined before Gregg\nsolver.add(join_year['Nader'] < join_year['Gregg'])\nsolver.add(join_year['James'] < join_year['Gregg'])\n\n# Nader joined before Owens\nsolver.add(join_year['Nader'] < join_year['Owens'])\n\n# James joined before MacNeil\nsolver.add(join_year['James'] < join_year['MacNeil'])\n\n# Gregg joined before Ivan\nsolver.add(join_year['Gregg'] < join_year['Ivan'])\n\n# Assume Owens joined before MacNeil\nsolver.add(join_year['Owens'] < join_year['MacNeil'])\n\n# OPTION CHECKING\n\noptions = [1963, 1964, 1965, 1966, 1967]\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, opt_year in enumerate(options):\n    solver.push()\n    # Add constraint that MacNeil joined in opt_year or earlier (to find earliest possible)\n    # Actually, we want to check if MacNeil could have joined exactly in opt_year\n    solver.add(join_year['MacNeil'] == opt_year)\n    if solver.check() == sat:\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A railway company has exactly three lines: line 1, line 2, and line 3. The company prints three sets of tickets for January and three sets of tickets for February: one set for each of its lines for each of the two months. The company's tickets are printed in a manner consistent with the following conditions: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow. For each line, the January tickets are a different color than the February tickets. For each month, tickets for different lines are in different colors. Exactly one set of January tickets is red. For line 3, either the January tickets or the February tickets, but not both, are green. The January tickets for line 2 are purple. No February tickets are purple.\n\nIf the line 3 tickets for January are red, then which one of the following statements must be true?\n\nOptions:\n(A) The line 1 tickets for January are green.\n(B) The line 1 tickets for January are yellow.\n(C) The line 1 tickets for February are red.\n(D) The line 2 tickets for February are yellow.\n(E) The line 3 tickets for February are green.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlines = [1, 2, 3]\nmonths = ['Jan', 'Feb']\ncolors = ['green', 'purple', 'red', 'yellow']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Variables: tickets[line][month] = color index\ntickets = {}\nfor line in lines:\n    for month in months:\n        tickets[(line, month)] = Int(f't{line}_{month}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each ticket color is valid\nfor line in lines:\n    for month in months:\n        solver.add(And(tickets[(line, month)] >= 0, tickets[(line, month)] < len(colors)))\n\n# For each line, January and February tickets are different colors\nfor line in lines:\n    solver.add(tickets[(line, 'Jan')] != tickets[(line, 'Feb')])\n\n# For each month, tickets for different lines have different colors\nfor month in months:\n    solver.add(Distinct([tickets[(line, month)] for line in lines]))\n\n# Exactly one set of January tickets is red\njan_reds = [tickets[(line, 'Jan')] == color_indices['red'] for line in lines]\nsolver.add(Sum([If(cond, 1, 0) for cond in jan_reds]) == 1)\n\n# For line 3, either January or February tickets (but not both) are green\nline3_jan_green = tickets[(3, 'Jan')] == color_indices['green']\nline3_feb_green = tickets[(3, 'Feb')] == color_indices['green']\nsolver.add(Xor(line3_jan_green, line3_feb_green))\n\n# January tickets for line 2 are purple\nsolver.add(tickets[(2, 'Jan')] == color_indices['purple'])\n\n# No February tickets are purple\nfor line in lines:\n    solver.add(tickets[(line, 'Feb')] != color_indices['purple'])\n\n# OPTION CHECKING\n\n# We add the condition: line 3 tickets for January are red\nsolver.push()\nsolver.add(tickets[(3, 'Jan')] == color_indices['red'])\n\noptions = [\n    ('A', tickets[(1, 'Jan')] == color_indices['green']),\n    ('B', tickets[(1, 'Jan')] == color_indices['yellow']),\n    ('C', tickets[(1, 'Feb')] == color_indices['red']),\n    ('D', tickets[(2, 'Feb')] == color_indices['yellow']),\n    ('E', tickets[(3, 'Feb')] == color_indices['green']),\n]\n\nfor letter, cond in options:\n    solver.push()\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        # If the negation is unsat, cond must be true in all solutions\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()\n\nsolver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A railway company has exactly three lines: line 1, line 2, and line 3. The company prints three sets of tickets for January and three sets of tickets for February: one set for each of its lines for each of the two months. The company's tickets are printed in a manner consistent with the following conditions: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow. For each line, the January tickets are a different color than the February tickets. For each month, tickets for different lines are in different colors. Exactly one set of January tickets is red. For line 3, either the January tickets or the February tickets, but not both, are green. The January tickets for line 2 are purple. No February tickets are purple.\n\nIf one set of the line 2 tickets is green, then which one of the following statements must be true?\n\nOptions:\n(A) The line 1 tickets for January are red.\n(B) The line 3 tickets for January are red.\n(C) The line 1 tickets for February are red.\n(D) The line 3 tickets for February are green.\n(E) The line 3 tickets for February are yellow.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlines = [1, 2, 3]\nmonths = ['Jan', 'Feb']\ncolors = ['green', 'purple', 'red', 'yellow']\n\n# Create Z3 Int variables for each line and month representing color index\ntickets = {}\nfor line in lines:\n    for month in months:\n        tickets[(line, month)] = Int(f\"line{line}_{month}\")\n\n# Map color names to indices\ncolor_indices = {color: i for i, color in enumerate(colors)}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each ticket color must be a valid index\nfor line in lines:\n    for month in months:\n        solver.add(And(tickets[(line, month)] >= 0, tickets[(line, month)] < len(colors)))\n\n# For each line, January and February tickets have different colors\nfor line in lines:\n    solver.add(tickets[(line, 'Jan')] != tickets[(line, 'Feb')])\n\n# For each month, tickets for different lines have different colors\nfor month in months:\n    solver.add(Distinct([tickets[(line, month)] for line in lines]))\n\n# Exactly one set of January tickets is red\njan_red_flags = [tickets[(line, 'Jan')] == color_indices['red'] for line in lines]\nsolver.add(Sum([If(flag, 1, 0) for flag in jan_red_flags]) == 1)\n\n# For line 3, either January or February tickets, but not both, are green\nline3_jan_green = tickets[(3, 'Jan')] == color_indices['green']\nline3_feb_green = tickets[(3, 'Feb')] == color_indices['green']\nsolver.add(Xor(line3_jan_green, line3_feb_green))\n\n# The January tickets for line 2 are purple\nsolver.add(tickets[(2, 'Jan')] == color_indices['purple'])\n\n# No February tickets are purple\nfor line in lines:\n    solver.add(tickets[(line, 'Feb')] != color_indices['purple'])\n\n# OPTION CHECKING\noptions = {\n    'A': tickets[(1, 'Jan')] == color_indices['red'],\n    'B': tickets[(3, 'Jan')] == color_indices['red'],\n    'C': tickets[(1, 'Feb')] == color_indices['red'],\n    'D': tickets[(3, 'Feb')] == color_indices['green'],\n    'E': tickets[(3, 'Feb')] == color_indices['yellow'],\n}\n\n# We add the condition: one set of line 2 tickets is green\n# That means either line 2 Jan is green or line 2 Feb is green\nline2_jan_green = tickets[(2, 'Jan')] == color_indices['green']\nline2_feb_green = tickets[(2, 'Feb')] == color_indices['green']\nsolver.add(Or([line2_jan_green, line2_feb_green]))\n\n# Check which option must be true under these constraints\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add negation of option to test if it can be false\n    solver.add(Not(options[opt]))\n    if solver.check() == unsat:\n        # If unsat, option must be true\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A railway company has exactly three lines: line 1, line 2, and line 3. The company prints three sets of tickets for January and three sets of tickets for February: one set for each of its lines for each of the two months. The company's tickets are printed in a manner consistent with the following conditions: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow. For each line, the January tickets are a different color than the February tickets. For each month, tickets for different lines are in different colors. Exactly one set of January tickets is red. For line 3, either the January tickets or the February tickets, but not both, are green. The January tickets for line 2 are purple. No February tickets are purple.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) No January ticket is green.\n(B) No February ticket is green.\n(C) Only line 2 tickets are red.\n(D) One set of January tickets is green and one set of January tickets is yellow.\n(E) The line 2 tickets for January are the same color as the line 1 tickets for February.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlines = [1, 2, 3]\nmonths = ['Jan', 'Feb']\ncolors = ['green', 'purple', 'red', 'yellow']\n\n# Create variables: color[line][month] = Int variable representing color index\ncolor = {}\nfor line in lines:\n    color[line] = {}\n    for month in months:\n        color[line][month] = Int(f\"color_{line}_{month}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each color variable must be valid index\nfor line in lines:\n    for month in months:\n        solver.add(And(color[line][month] >= 0, color[line][month] < len(colors)))\n\n# 2) For each line, January and February tickets differ in color\nfor line in lines:\n    solver.add(color[line]['Jan'] != color[line]['Feb'])\n\n# 3) For each month, tickets for different lines are different colors\nfor month in months:\n    solver.add(Distinct([color[line][month] for line in lines]))\n\n# 4) Exactly one set of January tickets is red\n# Count how many January tickets are red (color index of 'red' is colors.index('red')=2)\nred_index = colors.index('red')\njan_reds = [If(color[line]['Jan'] == red_index, 1, 0) for line in lines]\nsolver.add(Sum(jan_reds) == 1)\n\n# 5) For line 3, either January or February tickets (but not both) are green\ngreen_index = colors.index('green')\njan_green_line3 = color[3]['Jan'] == green_index\nfeb_green_line3 = color[3]['Feb'] == green_index\nsolver.add(Xor(jan_green_line3, feb_green_line3))\n\n# 6) January tickets for line 2 are purple\npurple_index = colors.index('purple')\nsolver.add(color[2]['Jan'] == purple_index)\n\n# 7) No February tickets are purple\nfor line in lines:\n    solver.add(color[line]['Feb'] != purple_index)\n\n# OPTION CHECKING\n\n# Define function to check if an option can be true\ndef check_option(option_constraints):\n    solver.push()\n    for c in option_constraints:\n        solver.add(c)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# Option (A) No January ticket is green\n# So for all lines, color[line]['Jan'] != green_index\noption_A = [color[line]['Jan'] != green_index for line in lines]\n\n# Option (B) No February ticket is green\noption_B = [color[line]['Feb'] != green_index for line in lines]\n\n# Option (C) Only line 2 tickets are red\n# So only line 2 tickets (Jan or Feb) are red, no other line tickets are red\n# Jan tickets red count is exactly one (already given), and that one is line 2 Jan or Feb red\n# But from constraint 4, exactly one January ticket is red, so the red must be Jan line 2 or other line Jan\n# So line 2 tickets are red means either Jan or Feb line 2 is red\n# But from constraint 7, no Feb tickets are purple, but Feb can be red\n# So check that only line 2 tickets are red (Jan or Feb), no other line tickets are red (Jan or Feb)\n# Let's encode it carefully:\n\n# First, get all tickets that are red:\nred_tickets = []\nfor line in lines:\n    for month in months:\n        red_tickets.append(If(color[line][month] == red_index, 1, 0))\n# Sum of red tickets is number of red tickets\nsum_red_tickets = Sum(red_tickets)\n\n# Count red tickets not line 2:\nred_not_line2 = []\nfor line in lines:\n    if line != 2:\n        for month in months:\n            red_not_line2.append(If(color[line][month] == red_index, 1, 0))\nsum_red_not_line2 = Sum(red_not_line2)\n\n# Option C constraints:\noption_C = [\n    # sum of red tickets >= 1 (at least one red ticket)\n    sum_red_tickets >= 1,\n    # red tickets not line 2 == 0\n    sum_red_not_line2 == 0,\n]\n\n# Option (D) One set of January tickets is green and one set of January tickets is yellow\nyellow_index = colors.index('yellow')\n# Count January green tickets\njan_green_count = Sum([If(color[line]['Jan'] == green_index, 1, 0) for line in lines])\n# Count January yellow tickets\njan_yellow_count = Sum([If(color[line]['Jan'] == yellow_index, 1, 0) for line in lines])\noption_D = [\n    jan_green_count == 1,\n    jan_yellow_count == 1,\n]\n\n# Option (E) The line 2 tickets for January are the same color as the line 1 tickets for February\noption_E = [color[2]['Jan'] == color[1]['Feb']]\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, option in enumerate(options):\n    if check_option(option):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A railway company has exactly three lines: line 1, line 2, and line 3. The company prints three sets of tickets for January and three sets of tickets for February: one set for each of its lines for each of the two months. The company's tickets are printed in a manner consistent with the following conditions: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow. For each line, the January tickets are a different color than the February tickets. For each month, tickets for different lines are in different colors. Exactly one set of January tickets is red. For line 3, either the January tickets or the February tickets, but not both, are green. The January tickets for line 2 are purple. No February tickets are purple.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) Both the line 1 tickets for January and the line 2 tickets for February are green.\n(B) Both the line 1 tickets for January and the line 2 tickets for February are yellow.\n(C) Both the line 1 tickets for January and the line 3 tickets for February are yellow.\n(D) The line 1 tickets for January are green, and the line 3 tickets for February are red.\n(E) The line 3 tickets for January are yellow, and the line 1 tickets for February are red.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlines = [1, 2, 3]\nmonths = ['Jan', 'Feb']\ncolors = ['green', 'purple', 'red', 'yellow']\n\n# Create variables: ticket_color[line][month] -> Int representing color index\nticket_color = {}\nfor line in lines:\n    ticket_color[line] = {}\n    for m in months:\n        ticket_color[line][m] = Int(f\"line{line}_{m}\")\n\n# Helper: color indices\ngreen = colors.index('green')\npurple = colors.index('purple')\nred = colors.index('red')\nyellow = colors.index('yellow')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each ticket color must be a valid color index\nfor line in lines:\n    for m in months:\n        solver.add(And(ticket_color[line][m] >= 0, ticket_color[line][m] < len(colors)))\n\n# For each line, January and February tickets are different colors\nfor line in lines:\n    solver.add(ticket_color[line]['Jan'] != ticket_color[line]['Feb'])\n\n# For each month, tickets for different lines are different colors\nfor m in months:\n    solver.add(Distinct([ticket_color[line][m] for line in lines]))\n\n# Exactly one set of January tickets is red\njan_red_flags = [If(ticket_color[line]['Jan'] == red, 1, 0) for line in lines]\nsolver.add(Sum(jan_red_flags) == 1)\n\n# For line 3, either January or February tickets, but not both, are green\njan_green = ticket_color[3]['Jan'] == green\nfeb_green = ticket_color[3]['Feb'] == green\nsolver.add(Xor(jan_green, feb_green))\n\n# The January tickets for line 2 are purple\nsolver.add(ticket_color[2]['Jan'] == purple)\n\n# No February tickets are purple\nfor line in lines:\n    solver.add(ticket_color[line]['Feb'] != purple)\n\n# OPTION CHECKING\noptions = [\n    # (A) Both the line 1 tickets for January and the line 2 tickets for February are green.\n    And(ticket_color[1]['Jan'] == green, ticket_color[2]['Feb'] == green),\n\n    # (B) Both the line 1 tickets for January and the line 2 tickets for February are yellow.\n    And(ticket_color[1]['Jan'] == yellow, ticket_color[2]['Feb'] == yellow),\n\n    # (C) Both the line 1 tickets for January and the line 3 tickets for February are yellow.\n    And(ticket_color[1]['Jan'] == yellow, ticket_color[3]['Feb'] == yellow),\n\n    # (D) The line 1 tickets for January are green, and the line 3 tickets for February are red.\n    And(ticket_color[1]['Jan'] == green, ticket_color[3]['Feb'] == red),\n\n    # (E) The line 3 tickets for January are yellow, and the line 1 tickets for February are red.\n    And(ticket_color[3]['Jan'] == yellow, ticket_color[1]['Feb'] == red)\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A railway company has exactly three lines: line 1, line 2, and line 3. The company prints three sets of tickets for January and three sets of tickets for February: one set for each of its lines for each of the two months. The company's tickets are printed in a manner consistent with the following conditions: Each of the six sets of tickets is exactly one of the following colors: green, purple, red, yellow. For each line, the January tickets are a different color than the February tickets. For each month, tickets for different lines are in different colors. Exactly one set of January tickets is red. For line 3, either the January tickets or the February tickets, but not both, are green. The January tickets for line 2 are purple. No February tickets are purple.\n\nIf the line 3 tickets for February are yellow, then each of the following statements must be true EXCEPT:\n\nOptions:\n(A) One set of January tickets is green.\n(B) One set of line 1 tickets is red.\n(C) One set of line 2 tickets is red.\n(D) The tickets in two of the six sets are red.\n(E) The tickets in two of the six sets are yellow.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlines = [1, 2, 3]\nmonths = ['Jan', 'Feb']\ncolors = ['green', 'purple', 'red', 'yellow']\n\n# Create Int variables for each line and month\n# color_vars[line][month] = color index\ncolor_vars = {}\nfor line in lines:\n    color_vars[line] = {}\n    for month in months:\n        color_vars[line][month] = Int(f\"line{line}_{month}\")\n\n# Helper function: count how many times a color occurs in a list of variables\ndef count_color(vars_list, color_index):\n    return Sum([If(v == color_index, 1, 0) for v in vars_list])\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each ticket set color is within valid range\nfor line in lines:\n    for month in months:\n        solver.add(And(color_vars[line][month] >= 0, color_vars[line][month] < len(colors)))\n\n# For each line, Jan and Feb tickets are different colors\nfor line in lines:\n    solver.add(color_vars[line]['Jan'] != color_vars[line]['Feb'])\n\n# For each month, tickets for different lines are different colors\nfor month in months:\n    solver.add(Distinct([color_vars[line][month] for line in lines]))\n\n# Exactly one set of January tickets is red\njan_colors = [color_vars[line]['Jan'] for line in lines]\nred_index = colors.index('red')\nsolver.add(count_color(jan_colors, red_index) == 1)\n\n# For line 3, either Jan or Feb tickets (but not both) are green\ngreen_index = colors.index('green')\njan_green = color_vars[3]['Jan'] == green_index\nfeb_green = color_vars[3]['Feb'] == green_index\nsolver.add(Xor(jan_green, feb_green))\n\n# The January tickets for line 2 are purple\npurple_index = colors.index('purple')\nsolver.add(color_vars[2]['Jan'] == purple_index)\n\n# No February tickets are purple\nfor line in lines:\n    solver.add(color_vars[line]['Feb'] != purple_index)\n\n# OPTION CHECKING\n\n# Given: line 3 tickets for February are yellow\nyellow_index = colors.index('yellow')\nsolver.add(color_vars[3]['Feb'] == yellow_index)\n\n# Options:\n# (A) One set of January tickets is green.\n# (B) One set of line 1 tickets is red.\n# (C) One set of line 2 tickets is red.\n# (D) The tickets in two of the six sets are red.\n# (E) The tickets in two of the six sets are yellow.\n\n# We'll test each option by adding its negation and checking satisfiability.\n# The option that contradicts the scenario (i.e., its negation is satisfiable)\n# is the one that is NOT necessarily true.\n\noptions = []\n\n# (A) One set of January tickets is green.\n# Negation: number of January green tickets != 1\njan_green_count = count_color(jan_colors, green_index)\noptions.append(jan_green_count != 1)\n\n# (B) One set of line 1 tickets is red.\n# Negation: line 1 tickets are not red in either month\nline1_jan_red = color_vars[1]['Jan'] == red_index\nline1_feb_red = color_vars[1]['Feb'] == red_index\noptions.append(Not(Or(line1_jan_red, line1_feb_red)))\n\n# (C) One set of line 2 tickets is red.\n# Negation: line 2 tickets are not red in either month\nline2_jan_red = color_vars[2]['Jan'] == red_index\nline2_feb_red = color_vars[2]['Feb'] == red_index\noptions.append(Not(Or(line2_jan_red, line2_feb_red)))\n\n# (D) The tickets in two of the six sets are red.\n# Negation: number of red tickets != 2\nall_vars = [color_vars[line][month] for line in lines for month in months]\nred_count = count_color(all_vars, red_index)\noptions.append(red_count != 2)\n\n# (E) The tickets in two of the six sets are yellow.\n# Negation: number of yellow tickets != 2\nyellow_count = count_color(all_vars, yellow_index)\noptions.append(yellow_count != 2)\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        # Negation satisfiable => option NOT necessarily true => this is the EXCEPT option\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "The Mammoth Corporation has just completed hiring nine new workers: Brandt, Calva, Duvall, Eberle, Fu, Garcia, Haga, Irving, and Jessup. Fu and Irving were hired on the same day as each other, and no one else was hired that day. Calva and Garcia were hired on the same day as each other, and no one else was hired that day. On each of the other days of hiring, exactly one worker was hired. Eberle was hired before Brandt. Haga was hired before Duvall. Duvall was hired after Irving but before Eberle. Garcia was hired after both Jessup and Brandt. Brandt was hired before Jessup.\n\nWho was hired on the fourth day of hiring?\n\nOptions:\n(A) Eberle\n(B) Brandt\n(C) Irving\n(D) Garcia\n(E) Jessup",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nworkers = ['Brandt', 'Calva', 'Duvall', 'Eberle', 'Fu', 'Garcia', 'Haga', 'Irving', 'Jessup']\nnum_days = 7  # Because 9 workers hired over days with some days having 2 hires\n\n# Create a mapping from worker to their hiring day (int)\nhire_day = {w: Int(w) for w in workers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Days range from 1 to 7\nfor w in workers:\n    solver.add(And(hire_day[w] >= 1, hire_day[w] <= num_days))\n\n# Fu and Irving hired same day, no one else that day\nsolver.add(hire_day['Fu'] == hire_day['Irving'])\nsolver.add(hire_day['Fu'] != hire_day['Brandt'])\nsolver.add(hire_day['Fu'] != hire_day['Calva'])\nsolver.add(hire_day['Fu'] != hire_day['Duvall'])\nsolver.add(hire_day['Fu'] != hire_day['Eberle'])\nsolver.add(hire_day['Fu'] != hire_day['Garcia'])\nsolver.add(hire_day['Fu'] != hire_day['Haga'])\nsolver.add(hire_day['Fu'] != hire_day['Jessup'])\n\n# Calva and Garcia hired same day, no one else that day\nsolver.add(hire_day['Calva'] == hire_day['Garcia'])\nsolver.add(hire_day['Calva'] != hire_day['Brandt'])\nsolver.add(hire_day['Calva'] != hire_day['Duvall'])\nsolver.add(hire_day['Calva'] != hire_day['Eberle'])\nsolver.add(hire_day['Calva'] != hire_day['Fu'])\nsolver.add(hire_day['Calva'] != hire_day['Haga'])\nsolver.add(hire_day['Calva'] != hire_day['Irving'])\nsolver.add(hire_day['Calva'] != hire_day['Jessup'])\n\n# On each other day exactly one worker hired\n# So all other workers have unique days different from Fu/Irving day and Calva/Garcia day\n# Collect the two double-hire days\nday_fu_irving = hire_day['Fu']\nday_calva_garcia = hire_day['Calva']\n\n# The two double-hire days must be different\nsolver.add(day_fu_irving != day_calva_garcia)\n\n# The other 5 workers (Brandt, Duvall, Eberle, Haga, Jessup) hired on days different from the double-hire days\nsingle_hire_workers = ['Brandt', 'Duvall', 'Eberle', 'Haga', 'Jessup']\nfor w in single_hire_workers:\n    solver.add(hire_day[w] != day_fu_irving)\n    solver.add(hire_day[w] != day_calva_garcia)\n\n# These 5 single hire workers hired on distinct days\nsolver.add(Distinct([hire_day[w] for w in single_hire_workers]))\n\n# The two double hire days and the 5 single hire days make up all 7 days\n# So all days assigned are distinct except the double hires on two days\n# So total days assigned are 7 distinct days\n\n# Eberle was hired before Brandt\nsolver.add(hire_day['Eberle'] < hire_day['Brandt'])\n\n# Haga was hired before Duvall\nsolver.add(hire_day['Haga'] < hire_day['Duvall'])\n\n# Duvall was hired after Irving but before Eberle\nsolver.add(hire_day['Duvall'] > hire_day['Irving'])\nsolver.add(hire_day['Duvall'] < hire_day['Eberle'])\n\n# Garcia was hired after both Jessup and Brandt\nsolver.add(hire_day['Garcia'] > hire_day['Jessup'])\nsolver.add(hire_day['Garcia'] > hire_day['Brandt'])\n\n# Brandt was hired before Jessup\nsolver.add(hire_day['Brandt'] < hire_day['Jessup'])\n\n# OPTION CHECKING\noptions = ['Eberle', 'Brandt', 'Irving', 'Garcia', 'Jessup']\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(hire_day[opt] == 4)\n    if solver.check() == sat:\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "The Mammoth Corporation has just completed hiring nine new workers: Brandt, Calva, Duvall, Eberle, Fu, Garcia, Haga, Irving, and Jessup. Fu and Irving were hired on the same day as each other, and no one else was hired that day. Calva and Garcia were hired on the same day as each other, and no one else was hired that day. On each of the other days of hiring, exactly one worker was hired. Eberle was hired before Brandt. Haga was hired before Duvall. Duvall was hired after Irving but before Eberle. Garcia was hired after both Jessup and Brandt. Brandt was hired before Jessup.\n\nExactly how many workers were hired before Jessup?\n\nOptions:\n(A) 6\n(B) 5\n(C) 4\n(D) 3\n(E) 2",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nworkers = ['Brandt', 'Calva', 'Duvall', 'Eberle', 'Fu', 'Garcia', 'Haga', 'Irving', 'Jessup']\nn = len(workers)\n\n# Create a Z3 Int variable for the hiring day of each worker (1 to 7)\n# Since Fu and Irving hired same day (only those two), Calva and Garcia same day (only those two),\n# and all other days exactly one worker, total days = 7\nday = {w: Int(w) for w in workers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Days range from 1 to 7\nfor w in workers:\n    solver.add(And(day[w] >= 1, day[w] <= 7))\n\n# Fu and Irving hired on the same day with no one else\nsolver.add(day['Fu'] == day['Irving'])\n# No one else hired that day\nfor w in workers:\n    if w not in ['Fu', 'Irving']:\n        solver.add(day[w] != day['Fu'])\n\n# Calva and Garcia hired on the same day with no one else\nsolver.add(day['Calva'] == day['Garcia'])\n# No one else hired that day\nfor w in workers:\n    if w not in ['Calva', 'Garcia']:\n        solver.add(day[w] != day['Calva'])\n\n# On each other day exactly one worker hired\n# So all other 5 workers have distinct days different from Fu/Irving day and Calva/Garcia day\nothers = [w for w in workers if w not in ['Fu', 'Irving', 'Calva', 'Garcia']]\nsolver.add(Distinct([day[w] for w in others]))\n\n# The days of Fu/Irving and Calva/Garcia are distinct\nsolver.add(day['Fu'] != day['Calva'])\n\n# Eberle was hired before Brandt\nsolver.add(day['Eberle'] < day['Brandt'])\n\n# Haga was hired before Duvall\nsolver.add(day['Haga'] < day['Duvall'])\n\n# Duvall was hired after Irving but before Eberle\nsolver.add(day['Duvall'] > day['Irving'])\nsolver.add(day['Duvall'] < day['Eberle'])\n\n# Garcia was hired after both Jessup and Brandt\nsolver.add(day['Garcia'] > day['Jessup'])\nsolver.add(day['Garcia'] > day['Brandt'])\n\n# Brandt was hired before Jessup\nsolver.add(day['Brandt'] < day['Jessup'])\n\n# OPTION CHECKING\n# We want to find how many workers hired before Jessup\n# That is number of workers w with day[w] < day['Jessup']\n\noptions = [6, 5, 4, 3, 2]  # Corresponding to A-E\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Count number of workers hired before Jessup\n    count_before = Sum([If(day[w] < day['Jessup'], 1, 0) for w in workers])\n    solver.add(count_before == opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "An apartment building has five floors. Each floor has either one or two apartments. There are exactly eight apartments in the building. The residents of the building are J, K, L, M, N, O, P, and Q, who each live in a different apartment. J lives on a floor with two apartments. K lives on the floor directly above P. The second floor is made up of only one apartment. M and N live on the same floor. O does not live on the same floor as Q. L lives in the only apartment on her floor. Q does not live on the first or second floor.\n\nIf M lives on the fourth floor, which one of the following must be false?\n\nOptions:\n(A) O lives on the fifth floor.\n(B) J lives on the first floor.\n(C) L lives on the second floor.\n(D) Q lives on the third floor.\n(E) P lives on the first floor.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nresidents = ['J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q']\nfloors = range(1, 6)  # Floors: 1 to 5\n\n# Each resident lives on a floor (Int variable)\nfloor_vars = {r: Int(r) for r in residents}\n\n# Apartment count per floor: 1 or 2 apartments\n# We will model the number of apartments per floor as variables\n# But since the problem states exactly 8 apartments total and 5 floors,\n# with each floor having either 1 or 2 apartments,\n# the sum of apartments per floor = 8\n# We can deduce which floors have 1 or 2 apartments by counting residents on each floor\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1) Each resident lives on a floor 1..5\nfor r in residents:\n    solver.add(And(floor_vars[r] >= 1, floor_vars[r] <= 5))\n\n# 2) There are exactly 8 apartments total, each resident in a different apartment\n# So all residents live on floors with apartments.\n# Number of residents on a floor = number of apartments on that floor\n# Each floor has either 1 or 2 apartments -> number of residents on floor must be 1 or 2\n# Count residents per floor\nfor f in floors:\n    count_on_floor = Sum([If(floor_vars[r] == f, 1, 0) for r in residents])\n    solver.add(Or(count_on_floor == 1, count_on_floor == 2))\n\n# 3) Total apartments = 8 (sum of residents)\n# sum of counts per floor = 8 (already true because 8 residents)\n# Just ensure total number of residents = 8\nsolver.add(Sum([1 for _ in residents]) == 8)  # always true, just for clarity\n\n# 4) J lives on a floor with two apartments\ncount_J_floor = Sum([If(floor_vars[r] == floor_vars['J'], 1, 0) for r in residents])\nsolver.add(count_J_floor == 2)\n\n# 5) K lives on the floor directly above P\nsolver.add(floor_vars['K'] == floor_vars['P'] + 1)\n\n# 6) The second floor is made up of only one apartment\ncount_floor_2 = Sum([If(floor_vars[r] == 2, 1, 0) for r in residents])\nsolver.add(count_floor_2 == 1)\n\n# 7) M and N live on the same floor\nsolver.add(floor_vars['M'] == floor_vars['N'])\n\n# 8) O does not live on the same floor as Q\nsolver.add(floor_vars['O'] != floor_vars['Q'])\n\n# 9) L lives in the only apartment on her floor (so her floor has only 1 apartment)\ncount_L_floor = Sum([If(floor_vars[r] == floor_vars['L'], 1, 0) for r in residents])\nsolver.add(count_L_floor == 1)\n\n# 10) Q does not live on the first or second floor\nsolver.add(And(floor_vars['Q'] != 1, floor_vars['Q'] != 2))\n\n# Additional constraint for the question:\n# If M lives on the fourth floor\nsolver.add(floor_vars['M'] == 4)\n\n# OPTION CHECKING\noptions = {\n    'A': floor_vars['O'] == 5,\n    'B': floor_vars['J'] == 1,\n    'C': floor_vars['L'] == 2,\n    'D': floor_vars['Q'] == 3,\n    'E': floor_vars['P'] == 1,\n}\n\nfor letter, opt_constraint in options.items():\n    solver.push()\n    solver.add(opt_constraint)\n    if solver.check() == sat:\n        # Option can be true\n        solver.pop()\n    else:\n        # Option must be false\n        print(f\"'{letter}'\")\n        solver.pop()\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Hannah spends 14 days, exclusive of travel time, in a total of six cities. Each city she visits is in one of three countries—X, Y, or Z. Each of the three countries has many cities. Hannah visits at least one city in each of the three countries. She spends at least two days in each city she visits. She spends only whole days in any city.\n\nIf Hannah spends exactly eight days in the cities of country X, then which one of the following CANNOT be true?\n\nOptions:\n(A) She visits exactly two cities in country X.\n(B) She visits exactly two cities in country Y.\n(C) She visits exactly two cities in country Z.\n(D) She visits more cities in country Y than in country Z.\n(E) She visits more cities in country Z than in country Y.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nnum_cities = 6\ntotal_days = 14\ncountries = ['X', 'Y', 'Z']\ncountry_indices = {c: i for i, c in enumerate(countries)}\n\n# Variables:\n# city_country[i]: which country city i belongs to (0=X,1=Y,2=Z)\ncity_country = [Int(f'city_country_{i}') for i in range(num_cities)]\n\n# city_days[i]: number of days spent in city i\ncity_days = [Int(f'city_days_{i}') for i in range(num_cities)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each city is assigned to one of the three countries\nfor i in range(num_cities):\n    solver.add(And(city_country[i] >= 0, city_country[i] < len(countries)))\n\n# Each city is visited at least 2 days, whole days only\nfor i in range(num_cities):\n    solver.add(city_days[i] >= 2)\n\n# Total days spent in all cities is 14\nsolver.add(Sum(city_days) == total_days)\n\n# Hannah visits at least one city in each country\nfor c in range(len(countries)):\n    # There is at least one city with country c\n    city_in_c = [city_country[i] == c for i in range(num_cities)]\n    solver.add(Or(city_in_c))\n\n# Exactly six cities visited (already fixed by num_cities=6)\n\n# She spends exactly 8 days in country X (country 0)\ndays_in_X = []\nfor i in range(num_cities):\n    is_X = city_country[i] == country_indices['X']\n    days_in_X.append(If(is_X, city_days[i], 0))\nsolver.add(Sum(days_in_X) == 8)\n\n# OPTION CHECKING\n\n# Helper: count how many cities are visited in a given country\ndef count_cities_in_country(c):\n    return Sum([If(city_country[i] == country_indices[c], 1, 0) for i in range(num_cities)])\n\noptions = []\n\n# (A) She visits exactly two cities in country X.\noption_A = count_cities_in_country('X') == 2\noptions.append(option_A)\n\n# (B) She visits exactly two cities in country Y.\noption_B = count_cities_in_country('Y') == 2\noptions.append(option_B)\n\n# (C) She visits exactly two cities in country Z.\noption_C = count_cities_in_country('Z') == 2\noptions.append(option_C)\n\n# (D) She visits more cities in country Y than in country Z.\noption_D = count_cities_in_country('Y') > count_cities_in_country('Z')\noptions.append(option_D)\n\n# (E) She visits more cities in country Z than in country Y.\noption_E = count_cities_in_country('Z') > count_cities_in_country('Y')\noptions.append(option_E)\n\n# Check each option for satisfiability with the base constraints\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Hannah spends 14 days, exclusive of travel time, in a total of six cities. Each city she visits is in one of three countries—X, Y, or Z. Each of the three countries has many cities. Hannah visits at least one city in each of the three countries. She spends at least two days in each city she visits. She spends only whole days in any city.\n\nIf Hannah spends three days in the cities of country Y and seven days in the cities of country Z, then which one of the following must be false?\n\nOptions:\n(A) She visits more cities in country X than in country Y.\n(B) She visits exactly two cities in country X.\n(C) She visits more cities in country Z than in country X.\n(D) She visits exactly two cities in country Z.\n(E) She visits exactly three cities in country Z.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Countries\ncountries = ['X', 'Y', 'Z']\ncountry_indices = {c: i for i, c in enumerate(countries)}\n\n# Number of cities visited in each country (variables)\n# Since she visits 6 cities total\ncities_in_country = {c: Int(f'cities_in_{c}') for c in countries}\n\n# Number of days spent in each country (given for Y and Z)\ndays_in_country = {c: Int(f'days_in_{c}') for c in countries}\n\n# Total cities = 6\ntotal_cities = 6\n# Total days = 14\ntotal_days = 14\n\n# Each city visited at least 2 days\n# So days_in_country[c] >= 2 * cities_in_country[c]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Cities visited constraints\nfor c in countries:\n    solver.add(cities_in_country[c] >= 1)  # At least one city in each country\n\nsolver.add(Sum([cities_in_country[c] for c in countries]) == total_cities)\n\n# Days spent constraints\n# Given days in Y and Z\nsolver.add(days_in_country['Y'] == 3)\nsolver.add(days_in_country['Z'] == 7)\nsolver.add(days_in_country['X'] == total_days - 3 - 7)  # days in X = 4\n\n# Days spent at least 2 days per city\nfor c in countries:\n    solver.add(days_in_country[c] >= 2 * cities_in_country[c])\n\n# Days spent are whole positive integers\nfor c in countries:\n    solver.add(days_in_country[c] >= 0)\n\n# OPTION CHECKING\noptions = [\n    # (A) She visits more cities in country X than in country Y.\n    lambda: cities_in_country['X'] > cities_in_country['Y'],\n    # (B) She visits exactly two cities in country X.\n    lambda: cities_in_country['X'] == 2,\n    # (C) She visits more cities in country Z than in country X.\n    lambda: cities_in_country['Z'] > cities_in_country['X'],\n    # (D) She visits exactly two cities in country Z.\n    lambda: cities_in_country['Z'] == 2,\n    # (E) She visits exactly three cities in country Z.\n    lambda: cities_in_country['Z'] == 3,\n]\n\n# We want to find which option MUST BE FALSE.\n# So for each option, we add the option's condition and check if the model is SAT.\n# If SAT, option can be true, so it is not necessarily false.\n# If UNSAT, option must be false.\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt())\n    if solver.check() == sat:\n        # Option can be true, so not necessarily false\n        solver.pop()\n    else:\n        # Option must be false\n        solver.pop()\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Hannah spends 14 days, exclusive of travel time, in a total of six cities. Each city she visits is in one of three countries—X, Y, or Z. Each of the three countries has many cities. Hannah visits at least one city in each of the three countries. She spends at least two days in each city she visits. She spends only whole days in any city.\n\nIf Hannah visits a combined total of four cities in countries X and Y, what is the greatest total number of days she can spend visiting cities in country Y?\n\nOptions:\n(A) 6\n(B) 7\n(C) 8\n(D) 9\n(E) 10",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Number of cities visited in each country\nX = Int('X')\nY = Int('Y')\nZ = Int('Z')\n\n# Days spent in each city in each country (lists of Ints)\n# Since total cities = 6, and X+Y+Z=6, max 6 cities in any country\n# We don't know exact distribution, but max cities in a country is 6\n# We'll create arrays of length 6 for each country, only first X, Y, Z elements used\ndays_X = [Int(f'days_X_{i}') for i in range(6)]\ndays_Y = [Int(f'days_Y_{i}') for i in range(6)]\ndays_Z = [Int(f'days_Z_{i}') for i in range(6)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Number of cities visited in each country, all >=1 since at least one city in each country\nsolver.add(X >= 1, Y >= 1, Z >= 1)\n\n# 2) Total cities is 6\nsolver.add(X + Y + Z == 6)\n\n# 3) Hannah visits a combined total of 4 cities in countries X and Y\nsolver.add(X + Y == 4)\n\n# 4) Each city visited is spent at least 2 days\nfor i in range(6):\n    # For days_X: if city i is visited (i < X), days_X[i] >= 2 else days_X[i] = 0\n    solver.add(If(i < X, days_X[i] >= 2, days_X[i] == 0))\n    # For days_Y: if city i is visited (i < Y), days_Y[i] >= 2 else days_Y[i] == 0\n    solver.add(If(i < Y, days_Y[i] >= 2, days_Y[i] == 0))\n    # For days_Z: if city i is visited (i < Z), days_Z[i] >= 2 else days_Z[i] == 0\n    solver.add(If(i < Z, days_Z[i] >= 2, days_Z[i] == 0))\n\n# 5) Days spent only whole days (non-negative integers already ensured by Int and constraints)\n# Already ensured by days_X[i] >= 0 and days_X[i] == 0 for unvisited cities\n\n# 6) Total days spent in all cities = 14\ntotal_days_X = Sum([days_X[i] for i in range(6)])\ntotal_days_Y = Sum([days_Y[i] for i in range(6)])\ntotal_days_Z = Sum([days_Z[i] for i in range(6)])\nsolver.add(total_days_X + total_days_Y + total_days_Z == 14)\n\n# 7) Objective: maximize total_days_Y\n# We'll do this by checking options from highest to lowest\n\noptions = [10, 9, 8, 7, 6]\nletters = ['E', 'D', 'C', 'B', 'A']\n\nfor days_y_target, letter in zip(options, letters):\n    solver.push()\n    solver.add(total_days_Y == days_y_target)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly six dogs—P, Q, R, S, T, and U—are entered in a dog show. The judge of the show awards exactly four ribbons, one for each of first, second, third, and fourth places, to four of the dogs. The information that follows is all that is available about the six dogs: Each dog is either a greyhound or a labrador, but not both. Two of the six dogs are female and four are male. The judge awards ribbons to both female dogs, exactly one of which is a labrador. Exactly one labrador wins a ribbon. Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T. Dogs P and R are greyhounds. Dogs S and U are labradors.\n\nWhich one of the following statements CANNOT be true?\n\nOptions:\n(A) A female greyhound wins the second place ribbon.\n(B) A female labrador wins the second place ribbon.\n(C) A female labrador wins the third place ribbon.\n(D) A male greyhound wins the fourth place ribbon.\n(E) A female greyhound wins the fourth place ribbon.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndogs = ['P', 'Q', 'R', 'S', 'T', 'U']\nplaces = ['1st', '2nd', '3rd', '4th']\ngenders = ['female', 'male']\nbreeds = ['greyhound', 'labrador']\n\n# Create Z3 Int variables for place of each dog (0 if no ribbon, else 1-4)\n# 0 means no ribbon, 1 means first place, ..., 4 means fourth place\nplace = {d: Int(f'place_{d}') for d in dogs}\n\n# Gender and breed variables: 0 for first in list, 1 for second\ngender = {d: Int(f'gender_{d}') for d in dogs}  # 0=female,1=male\nbreed = {d: Int(f'breed_{d}') for d in dogs}  # 0=greyhound,1=labrador\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each dog's place is between 0 and 4 (0 means no ribbon)\nfor d in dogs:\n    solver.add(And(place[d] >= 0, place[d] <= 4))\n\n# Exactly four dogs have a ribbon (place > 0)\nribbon_dogs = [place[d] > 0 for d in dogs]\nsolver.add(Sum([If(cond, 1, 0) for cond in ribbon_dogs]) == 4)\n\n# Places 1 to 4 are assigned to distinct dogs (no ties)\nribbon_places = [place[d] for d in dogs]\n# Only dogs with place > 0 count, so extract those places and ensure distinct\n# We'll enforce distinctness of places ignoring zeros\n# Collect places > 0\nplaces_assigned = [place[d] for d in dogs]\n# Enforce distinctness among places > 0\n# Approach: For all pairs of dogs with place > 0, places differ\nfor i in range(len(dogs)):\n    for j in range(i+1, len(dogs)):\n        di = dogs[i]\n        dj = dogs[j]\n        solver.add(Implies(And(place[di] > 0, place[dj] > 0), place[di] != place[dj]))\n\n# Each dog is either female or male (0 or 1)\nfor d in dogs:\n    solver.add(Or(gender[d] == 0, gender[d] == 1))\n\n# Exactly two females and four males\nsolver.add(Sum([If(gender[d] == 0, 1, 0) for d in dogs]) == 2)\nsolver.add(Sum([If(gender[d] == 1, 1, 0) for d in dogs]) == 4)\n\n# Each dog is either greyhound or labrador (0 or 1)\nfor d in dogs:\n    solver.add(Or(breed[d] == 0, breed[d] == 1))\n\n# Dogs P and R are greyhounds (breed=0)\nsolver.add(breed['P'] == 0)\nsolver.add(breed['R'] == 0)\n\n# Dogs S and U are labradors (breed=1)\nsolver.add(breed['S'] == 1)\nsolver.add(breed['U'] == 1)\n\n# The judge awards ribbons to both female dogs (both females have place > 0)\nfor d in dogs:\n    solver.add(Implies(gender[d] == 0, place[d] > 0))\n\n# Exactly one of the female dogs is a labrador\nfemale_labrador = [And(gender[d] == 0, breed[d] == 1) for d in dogs]\nsolver.add(Sum([If(cond, 1, 0) for cond in female_labrador]) == 1)\n\n# Exactly one labrador wins a ribbon (place > 0 and breed=1)\nlabrador_ribbon = [And(place[d] > 0, breed[d] == 1) for d in dogs]\nsolver.add(Sum([If(cond, 1, 0) for cond in labrador_ribbon]) == 1)\n\n# Order constraints:\n# Dogs P and R place ahead of dog S\nsolver.add(place['P'] > place['S'])\nsolver.add(place['R'] > place['S'])\n\n# Dog S places ahead of dogs Q and T\nsolver.add(place['S'] > place['Q'])\nsolver.add(place['S'] > place['T'])\n\n# Note: Dogs that do not have ribbons have place=0, which is less than any place 1-4\n# So \"places ahead\" means place number is greater (because 1st place is 4, 4th place is 1)\n# But our current model uses 1=1st, 4=4th, so lower place number means better place.\n# This is reversed, so we must fix the ordering:\n\n# Correction:\n# Let's redefine place variables so that 4=1st place, 3=2nd, 2=3rd, 1=4th, 0=no ribbon\n# So higher number means better place.\n\nfor d in dogs:\n    solver.add(And(place[d] >= 0, place[d] <= 4))\n\n# Re-define places assigned to be distinct among >0 values\nfor i in range(len(dogs)):\n    for j in range(i+1, len(dogs)):\n        di = dogs[i]\n        dj = dogs[j]\n        solver.add(Implies(And(place[di] > 0, place[dj] > 0), place[di] != place[dj]))\n\n# Update order constraints accordingly (higher place number means better place)\nsolver.add(place['P'] > place['S'])\nsolver.add(place['R'] > place['S'])\nsolver.add(place['S'] > place['Q'])\nsolver.add(place['S'] > place['T'])\n\n# OPTION CHECKING\n\n# Options:\n# (A) A female greyhound wins the second place ribbon.\n# (B) A female labrador wins the second place ribbon.\n# (C) A female labrador wins the third place ribbon.\n# (D) A male greyhound wins the fourth place ribbon.\n# (E) A female greyhound wins the fourth place ribbon.\n\n# Map place numbers to place names:\n# 4 = 1st\n# 3 = 2nd\n# 2 = 3rd\n# 1 = 4th\n# 0 = no ribbon\n\ndef check_option(option_letter):\n    solver.push()\n    if option_letter == 'A':\n        # A female greyhound wins the second place ribbon (place=3)\n        cond = Or([And(place[d] == 3, gender[d] == 0, breed[d] == 0) for d in dogs])\n        solver.add(cond)\n    elif option_letter == 'B':\n        # A female labrador wins the second place ribbon (place=3)\n        cond = Or([And(place[d] == 3, gender[d] == 0, breed[d] == 1) for d in dogs])\n        solver.add(cond)\n    elif option_letter == 'C':\n        # A female labrador wins the third place ribbon (place=2)\n        cond = Or([And(place[d] == 2, gender[d] == 0, breed[d] == 1) for d in dogs])\n        solver.add(cond)\n    elif option_letter == 'D':\n        # A male greyhound wins the fourth place ribbon (place=1)\n        cond = Or([And(place[d] == 1, gender[d] == 1, breed[d] == 0) for d in dogs])\n        solver.add(cond)\n    elif option_letter == 'E':\n        # A female greyhound wins the fourth place ribbon (place=1)\n        cond = Or([And(place[d] == 1, gender[d] == 0, breed[d] == 0) for d in dogs])\n        solver.add(cond)\n    else:\n        solver.pop()\n        return False\n\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\nfor opt in options:\n    if not check_option(opt):\n        print(f\"'{opt}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly six dogs—P, Q, R, S, T, and U—are entered in a dog show. The judge of the show awards exactly four ribbons, one for each of first, second, third, and fourth places, to four of the dogs. The information that follows is all that is available about the six dogs: Each dog is either a greyhound or a labrador, but not both. Two of the six dogs are female and four are male. The judge awards ribbons to both female dogs, exactly one of which is a labrador. Exactly one labrador wins a ribbon. Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T. Dogs P and R are greyhounds. Dogs S and U are labradors.\n\nWhich one of the following dogs must be male?\n\nOptions:\n(A) dog P\n(B) dog R\n(C) dog S\n(D) dog T\n(E) dog U",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndogs = ['P', 'Q', 'R', 'S', 'T', 'U']\nplaces = ['1st', '2nd', '3rd', '4th', 'no_ribbon']  # 4 ribbons + no ribbon\ngenders = ['male', 'female']\nbreeds = ['greyhound', 'labrador']\n\n# Create Z3 Int variables for each dog's place (0 to 4)\nplace = {d: Int(f'place_{d}') for d in dogs}\n\n# Create Z3 Int variables for each dog's gender (0=male,1=female)\ngender = {d: Int(f'gender_{d}') for d in dogs}\n\n# Create Z3 Int variables for each dog's breed (0=greyhound,1=labrador)\nbreed = {d: Int(f'breed_{d}') for d in dogs}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Places: 0 to 4 (0=1st,1=2nd,2=3rd,3=4th,4=no ribbon)\nfor d in dogs:\n    solver.add(And(place[d] >= 0, place[d] <= 4))\n\n# Exactly four ribbons awarded: exactly four dogs have place in [0..3]\nribbon_places = [place[d] for d in dogs]\nnum_ribbons = Sum([If(place[d] < 4, 1, 0) for d in dogs])\nsolver.add(num_ribbons == 4)\n\n# Each place 0..3 assigned to exactly one dog (ribbons are unique)\nfor p in range(4):\n    count_p = Sum([If(place[d] == p, 1, 0) for d in dogs])\n    solver.add(count_p == 1)\n\n# Genders: 0=male,1=female\nfor d in dogs:\n    solver.add(Or(gender[d] == 0, gender[d] == 1))\n\n# Exactly two females and four males\nnum_females = Sum([If(gender[d] == 1, 1, 0) for d in dogs])\nsolver.add(num_females == 2)\n\n# Breeds: 0=greyhound,1=labrador\nfor d in dogs:\n    solver.add(Or(breed[d] == 0, breed[d] == 1))\n\n# Each dog is either greyhound or labrador, not both (already by domain)\n\n# Dogs P and R are greyhounds\nsolver.add(breed['P'] == 0)\nsolver.add(breed['R'] == 0)\n\n# Dogs S and U are labradors\nsolver.add(breed['S'] == 1)\nsolver.add(breed['U'] == 1)\n\n# The judge awards ribbons to both female dogs\n# So both females have place in [0..3]\nfor d in dogs:\n    # If female, then place <4\n    solver.add(Implies(gender[d] == 1, place[d] < 4))\n\n# Exactly one of the female dogs is a labrador\n# So sum over females that are labrador == 1\nfemale_labradors = Sum([If(And(gender[d] == 1, breed[d] == 1), 1, 0) for d in dogs])\nsolver.add(female_labradors == 1)\n\n# The judge awards ribbons to both female dogs, exactly one of which is labrador\n# Also, exactly one labrador wins a ribbon\nnum_labrador_ribbons = Sum([If(And(breed[d] == 1, place[d] < 4), 1, 0) for d in dogs])\nsolver.add(num_labrador_ribbons == 1)\n\n# Dogs P and R place ahead of dog S\n# place number: smaller is better (0 is 1st)\nsolver.add(place['P'] < place['S'])\nsolver.add(place['R'] < place['S'])\n\n# Dog S places ahead of dogs Q and T\nsolver.add(place['S'] < place['Q'])\nsolver.add(place['S'] < place['T'])\n\n# OPTION CHECKING\noptions = ['P', 'R', 'S', 'T', 'U']\n\nfor i, d_opt in enumerate(options):\n    solver.push()\n    # Add constraint: dog d_opt is female (gender == 1)\n    solver.add(gender[d_opt] == 1)\n    # Check if model is satisfiable with this dog female\n    if solver.check() == sat:\n        # If satisfiable, then d_opt can be female, so it is not necessarily male\n        solver.pop()\n    else:\n        # If unsat, then d_opt cannot be female, so must be male\n        solver.pop()\n        print(f\"'{chr(65 + i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six dogs—P, Q, R, S, T, and U—are entered in a dog show. The judge of the show awards exactly four ribbons, one for each of first, second, third, and fourth places, to four of the dogs. The information that follows is all that is available about the six dogs: Each dog is either a greyhound or a labrador, but not both. Two of the six dogs are female and four are male. The judge awards ribbons to both female dogs, exactly one of which is a labrador. Exactly one labrador wins a ribbon. Dogs P and R place ahead of dog S, and dog S places ahead of dogs Q and T. Dogs P and R are greyhounds. Dogs S and U are labradors.\n\nWhich one of the following statements can be false?\n\nOptions:\n(A) Dog P places ahead of dog R.\n(B) Dog P places ahead of dog T.\n(C) Dog R places ahead of dog U.\n(D) Dog R places ahead of dog T.\n(E) Dog S places ahead of dog U.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\ndogs = ['P', 'Q', 'R', 'S', 'T', 'U']\n\n# Positions: 1=first, 2=second, 3=third, 4=fourth, 5= no ribbon, 6= no ribbon\n# We use Int variables for positions; dogs without ribbons have positions >4\npos = {d: Int(d) for d in dogs}\n\n# Gender: 0=male, 1=female\ngender = {d: Int('gender_' + d) for d in dogs}\n\n# Breed: 0=greyhound, 1=labrador\nbreed = {d: Int('breed_' + d) for d in dogs}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions domain: 1 to 6\nfor d in dogs:\n    solver.add(And(pos[d] >= 1, pos[d] <= 6))\n\n# Exactly four ribbons, positions 1-4 assigned to distinct dogs\n# So exactly four dogs have positions in 1..4, rest in 5..6\n# Enforce that exactly 4 dogs have pos <=4\nribbon_bools = [Bool('ribbon_'+d) for d in dogs]\nfor i,d in enumerate(dogs):\n    solver.add(ribbon_bools[i] == (pos[d] <= 4))\n\nsolver.add(Sum([If(rb,1,0) for rb in ribbon_bools]) == 4)\n\n# The four dogs with ribbons have distinct positions 1..4\nribbon_dogs = [pos[d] for d in dogs]\n# Positions 1..4 are assigned exactly once to the dogs who have ribbons\n# So all pos[d] with pos[d]<=4 are distinct and in 1..4\n# Enforce distinctness of positions of dogs with ribbons\n# We'll enforce distinctness of all pos[d] in 1..4 by:\n# Extract dogs with pos<=4 and enforce Distinct on their positions\n# But Z3 can't easily filter variables dynamically, so we enforce:\n# 1) All pos[d] in 1..6\n# 2) Exactly 4 pos[d] <=4\n# 3) The positions of dogs with pos[d]<=4 are distinct\n# We do this by adding pairwise constraints:\nfor i in range(len(dogs)):\n    for j in range(i+1, len(dogs)):\n        # If both have ribbons, their pos are distinct\n        solver.add(Implies(And(pos[dogs[i]] <= 4, pos[dogs[j]] <= 4), pos[dogs[i]] != pos[dogs[j]]))\n\n# Gender: two female (1), four male (0)\nfor d in dogs:\n    solver.add(Or(gender[d] == 0, gender[d] == 1))\nsolver.add(Sum([gender[d] for d in dogs]) == 2)\n\n# Breed: each dog either greyhound (0) or labrador (1)\nfor d in dogs:\n    solver.add(Or(breed[d] == 0, breed[d] == 1))\n\n# Dogs P and R are greyhounds (0)\nsolver.add(breed['P'] == 0)\nsolver.add(breed['R'] == 0)\n\n# Dogs S and U are labradors (1)\nsolver.add(breed['S'] == 1)\nsolver.add(breed['U'] == 1)\n\n# The judge awards ribbons to both female dogs, exactly one of which is a labrador.\n# So both female dogs have positions <=4 (ribbons)\n# Exactly one of the female dogs is labrador\nfemale_dogs = [d for d in dogs]\n# Enforce females have ribbons\nfor d in dogs:\n    # If female, then pos <=4\n    solver.add(Implies(gender[d] == 1, pos[d] <= 4))\n# Exactly one female dog is labrador\n# Sum of breed[d] for female dogs ==1\nfemale_breed_sum = Sum([If(gender[d] == 1, breed[d], 0) for d in dogs])\nsolver.add(female_breed_sum == 1)\n\n# Exactly one labrador wins a ribbon\n# Labradors: breed==1\n# Among dogs with ribbon (pos<=4), exactly one has breed==1\nlabrador_ribbon_sum = Sum([If(And(pos[d] <= 4, breed[d] == 1), 1, 0) for d in dogs])\nsolver.add(labrador_ribbon_sum == 1)\n\n# Dogs P and R place ahead of dog S\nsolver.add(pos['P'] < pos['S'])\nsolver.add(pos['R'] < pos['S'])\n\n# Dog S places ahead of dogs Q and T\nsolver.add(pos['S'] < pos['Q'])\nsolver.add(pos['S'] < pos['T'])\n\n# Dogs P and R are greyhounds (already set)\n\n# Dogs S and U are labradors (already set)\n\n# OPTION CHECKING\n\n# We want to check which option can be false.\n# For each option, add the negation of the option and check satisfiability.\n# The option that can be false is the one where negation is satisfiable.\n\noptions = {\n    'A': pos['P'] < pos['R'],  # Dog P places ahead of dog R\n    'B': pos['P'] < pos['T'],  # Dog P places ahead of dog T\n    'C': pos['R'] < pos['U'],  # Dog R places ahead of dog U\n    'D': pos['R'] < pos['T'],  # Dog R places ahead of dog T\n    'E': pos['S'] < pos['U'],  # Dog S places ahead of dog U\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    # Add negation of option condition\n    solver.add(Not(cond))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) John orders the same kind of entree as Marie does.\n(B) Kate orders the same kind of entree as Nat does.\n(C) Lewis orders the same kind of entree as Nat does.\n(D) Marie orders the same kind of entree as Olive does.\n(E) Nat orders the same kind of entree as Olive does.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['John', 'Kate', 'Lewis', 'Marie', 'Nat', 'Olive']\nmen = ['John', 'Lewis', 'Nat']\nwomen = ['Kate', 'Marie', 'Olive']\ncouples = [('John', 'Kate'), ('Lewis', 'Marie'), ('Nat', 'Olive')]\n\nentrees = ['pork chops', 'roast beef', 'swordfish', 'tilefish', 'veal cutlet']\nentree_indices = {e: i for i, e in enumerate(entrees)}\n\n# Create Z3 variables for each person's entree choice\nentree = {p: Int(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person orders exactly one entree (valid index)\nfor p in people:\n    solver.add(And(entree[p] >= 0, entree[p] < len(entrees)))\n\n# The two people in each couple do not order the same entree\nfor (p1, p2) in couples:\n    solver.add(entree[p1] != entree[p2])\n\n# None of the men order the same entree as any other men (all men entrees distinct)\nsolver.add(Distinct([entree[m] for m in men]))\n\n# Marie orders swordfish\nsolver.add(entree['Marie'] == entree_indices['swordfish'])\n\n# Neither John nor Nat orders a fish entree\nfish_entrees = ['swordfish', 'tilefish']\nfish_indices = [entree_indices[f] for f in fish_entrees]\nsolver.add(Not(Or([entree['John'] == f for f in fish_indices])))\nsolver.add(Not(Or([entree['Nat'] == f for f in fish_indices])))\n\n# Olive orders roast beef\nsolver.add(entree['Olive'] == entree_indices['roast beef'])\n\n# OPTION CHECKING\noptions = [\n    ('A', entree['John'] == entree['Marie']),      # John orders same as Marie\n    ('B', entree['Kate'] == entree['Nat']),        # Kate orders same as Nat\n    ('C', entree['Lewis'] == entree['Nat']),       # Lewis orders same as Nat\n    ('D', entree['Marie'] == entree['Olive']),     # Marie orders same as Olive\n    ('E', entree['Nat'] == entree['Olive']),       # Nat orders same as Olive\n]\n\nfor letter, condition in options:\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.\n\nWhich one of the following statements must be true?\n\nOptions:\n(A) One of the men orders pork chops or veal cutlet.\n(B) One of the men orders swordfish or veal cutlet.\n(C) Two of the women order tilefish.\n(D) None of the men orders a fish entree.\n(E) Exactly one of the women orders a fish entree.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['John', 'Kate', 'Lewis', 'Marie', 'Nat', 'Olive']\nmen = ['John', 'Lewis', 'Nat']\nwomen = ['Kate', 'Marie', 'Olive']\ncouples = [('John', 'Kate'), ('Lewis', 'Marie'), ('Nat', 'Olive')]\nentrees = ['pork chops', 'roast beef', 'swordfish', 'tilefish', 'veal cutlet']\nfish = ['swordfish', 'tilefish']\n\n# Create Z3 variables for each person: their entree index\nentree_vars = {p: Int(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person's entree is a valid index\nfor p in people:\n    solver.add(And(entree_vars[p] >= 0, entree_vars[p] < len(entrees)))\n\n# Couples do not order the same entree\nfor (p1, p2) in couples:\n    solver.add(entree_vars[p1] != entree_vars[p2])\n\n# None of the men order the same entree as any other men\nsolver.add(Distinct([entree_vars[m] for m in men]))\n\n# Marie orders swordfish\nsolver.add(entree_vars['Marie'] == entrees.index('swordfish'))\n\n# Neither John nor Nat orders a fish entree\nsolver.add(entree_vars['John'] != entrees.index('swordfish'))\nsolver.add(entree_vars['John'] != entrees.index('tilefish'))\nsolver.add(entree_vars['Nat'] != entrees.index('swordfish'))\nsolver.add(entree_vars['Nat'] != entrees.index('tilefish'))\n\n# Olive orders roast beef\nsolver.add(entree_vars['Olive'] == entrees.index('roast beef'))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) One of the men orders pork chops or veal cutlet.\n    Or([entree_vars[m] == entrees.index('pork chops') for m in men] +\n       [entree_vars[m] == entrees.index('veal cutlet') for m in men]),\n\n    # (B) One of the men orders swordfish or veal cutlet.\n    Or([entree_vars[m] == entrees.index('swordfish') for m in men] +\n       [entree_vars[m] == entrees.index('veal cutlet') for m in men]),\n\n    # (C) Two of the women order tilefish.\n    Sum([If(entree_vars[w] == entrees.index('tilefish'), 1, 0) for w in women]) == 2,\n\n    # (D) None of the men orders a fish entree.\n    And([entree_vars[m] != entrees.index('swordfish') for m in men] +\n        [entree_vars[m] != entrees.index('tilefish') for m in men]),\n\n    # (E) Exactly one of the women orders a fish entree.\n    Sum([If(entree_vars[w] == entrees.index('swordfish'), 1, 0) + If(entree_vars[w] == entrees.index('tilefish'), 1, 0) for w in women]) == 1\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.\n\nIf John orders veal cutlet, then which one of the following statements must be true?\n\nOptions:\n(A) Kate orders roast beef.\n(B) Kate orders swordfish.\n(C) Lewis orders tilefish.\n(D) Lewis orders veal cutlet.\n(E) Nat orders pork chops.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['John', 'Kate', 'Lewis', 'Marie', 'Nat', 'Olive']\ncouples = [('John', 'Kate'), ('Lewis', 'Marie'), ('Nat', 'Olive')]\nmen = ['John', 'Lewis', 'Nat']\nwomen = ['Kate', 'Marie', 'Olive']\n\nentrees = ['pork chops', 'roast beef', 'swordfish', 'tilefish', 'veal cutlet']\n\n# Map entree names to indices\nentree_indices = {entree: i for i, entree in enumerate(entrees)}\n\n# Create Z3 variables for each person representing entree index\norder = {p: Int(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person orders exactly one entree (valid index)\nfor p in people:\n    solver.add(And(order[p] >= 0, order[p] < len(entrees)))\n\n# The two people in each couple do not order the same entree\nfor (p1, p2) in couples:\n    solver.add(order[p1] != order[p2])\n\n# None of the men orders the same entree as any other man\nsolver.add(Distinct([order[m] for m in men]))\n\n# Marie orders swordfish\nsolver.add(order['Marie'] == entree_indices['swordfish'])\n\n# Neither John nor Nat orders a fish entree (fish entrees: swordfish, tilefish)\nfish_indices = [entree_indices['swordfish'], entree_indices['tilefish']]\nsolver.add(And(order['John'] != entree_indices['swordfish'], order['John'] != entree_indices['tilefish']))\nsolver.add(And(order['Nat'] != entree_indices['swordfish'], order['Nat'] != entree_indices['tilefish']))\n\n# Olive orders roast beef\nsolver.add(order['Olive'] == entree_indices['roast beef'])\n\n# John orders veal cutlet (given condition for the question)\nsolver.add(order['John'] == entree_indices['veal cutlet'])\n\n# OPTION CHECKING\noptions = [\n    ('Kate', entree_indices['roast beef']),    # (A) Kate orders roast beef\n    ('Kate', entree_indices['swordfish']),     # (B) Kate orders swordfish\n    ('Lewis', entree_indices['tilefish']),     # (C) Lewis orders tilefish\n    ('Lewis', entree_indices['veal cutlet']),  # (D) Lewis orders veal cutlet\n    ('Nat', entree_indices['pork chops'])      # (E) Nat orders pork chops\n]\n\nfor i, (person, entree_idx) in enumerate(options):\n    solver.push()\n    solver.add(order[person] == entree_idx)\n    if solver.check() == sat:\n        # Check if this option must be true by checking if negation is unsat\n        solver.pop()\n        solver.push()\n        solver.add(order[person] != entree_idx)\n        if solver.check() == unsat:\n            print(f\"'{chr(65+i)}'\")\n            solver.pop()\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.\n\nIf none of the six people orders pork chops, then which one of the following statements must be true?\n\nOptions:\n(A) John orders veal cutlet.\n(B) Kate orders tilefish.\n(C) Lewis orders tilefish.\n(D) One of the men orders swordfish.\n(E) One of the women orders tilefish.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['John', 'Kate', 'Lewis', 'Marie', 'Nat', 'Olive']\nmen = ['John', 'Lewis', 'Nat']\nwomen = ['Kate', 'Marie', 'Olive']\ncouples = [('John', 'Kate'), ('Lewis', 'Marie'), ('Nat', 'Olive')]\n\nentrees = ['pork chops', 'roast beef', 'swordfish', 'tilefish', 'veal cutlet']\n# Map entree names to indices\nentree_indices = {entree: i for i, entree in enumerate(entrees)}\n\n# Create Z3 variables for each person's entree choice\nentree_choice = {}\nfor person in people:\n    entree_choice[person] = Int(person)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person orders exactly one entree (index in range)\nfor person in people:\n    solver.add(And(entree_choice[person] >= 0, entree_choice[person] < len(entrees)))\n\n# None of the six people orders pork chops\npork_chops_index = entree_indices['pork chops']\nfor person in people:\n    solver.add(entree_choice[person] != pork_chops_index)\n\n# The two people in each couple do not order the same kind of entree\nfor (p1, p2) in couples:\n    solver.add(entree_choice[p1] != entree_choice[p2])\n\n# None of the men orders the same kind of entree as any of the other men\nsolver.add(Distinct([entree_choice[m] for m in men]))\n\n# Marie orders swordfish\nswordfish_index = entree_indices['swordfish']\nsolver.add(entree_choice['Marie'] == swordfish_index)\n\n# Neither John nor Nat orders a fish entree\n# Fish entrees are swordfish and tilefish\ntilefish_index = entree_indices['tilefish']\nfish_indices = [swordfish_index, tilefish_index]\nsolver.add(And(entree_choice['John'] != swordfish_index, entree_choice['John'] != tilefish_index))\nsolver.add(And(entree_choice['Nat'] != swordfish_index, entree_choice['Nat'] != tilefish_index))\n\n# Olive orders roast beef\nroast_beef_index = entree_indices['roast beef']\nsolver.add(entree_choice['Olive'] == roast_beef_index)\n\n# OPTION CHECKING\noptions = [\n    ('A', entree_choice['John'] == entree_indices['veal cutlet']),\n    ('B', entree_choice['Kate'] == tilefish_index),\n    ('C', entree_choice['Lewis'] == tilefish_index),\n    ('D', Or([entree_choice[m] == swordfish_index for m in men])),\n    ('E', Or([entree_choice[w] == tilefish_index for w in women]))\n]\n\nfor letter, condition in options:\n    solver.push()\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.\n\nIf Lewis orders pork chops, then which one of the following is a complete and accurate list of the entrees any one of which John could order?\n\nOptions:\n(A) roast beef\n(B) veal cutlet\n(C) roast beef, veal cutlet\n(D) roast beef, swordfish\n(E) pork chops, roast beef, swordfish",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['John', 'Kate', 'Lewis', 'Marie', 'Nat', 'Olive']\nmen = ['John', 'Lewis', 'Nat']\nwomen = ['Kate', 'Marie', 'Olive']\ncouples = [('John', 'Kate'), ('Lewis', 'Marie'), ('Nat', 'Olive')]\nentrees = ['pork chops', 'roast beef', 'swordfish', 'tilefish', 'veal cutlet']\n\n# Create Z3 Int variables for each person representing entree index\nentree_vars = {p: Int(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person orders exactly one entree (valid index)\nfor p in people:\n    solver.add(And(entree_vars[p] >= 0, entree_vars[p] < len(entrees)))\n\n# Couples do not order the same entree\nfor (p1, p2) in couples:\n    solver.add(entree_vars[p1] != entree_vars[p2])\n\n# None of the men orders the same entree as any other man\nsolver.add(Distinct([entree_vars[m] for m in men]))\n\n# Marie orders swordfish\nsolver.add(entree_vars['Marie'] == entrees.index('swordfish'))\n\n# Neither John nor Nat orders a fish entree (fish entrees are swordfish and tilefish)\nfish_indices = [entrees.index('swordfish'), entrees.index('tilefish')]\nsolver.add(Not(Or([entree_vars['John'] == i for i in fish_indices])))\nsolver.add(Not(Or([entree_vars['Nat'] == i for i in fish_indices])))\n\n# Olive orders roast beef\nsolver.add(entree_vars['Olive'] == entrees.index('roast beef'))\n\n# Lewis orders pork chops (given condition)\nsolver.add(entree_vars['Lewis'] == entrees.index('pork chops'))\n\n# OPTION CHECKING\noptions = {\n    'A': [entrees.index('roast beef')],\n    'B': [entrees.index('veal cutlet')],\n    'C': [entrees.index('roast beef'), entrees.index('veal cutlet')],\n    'D': [entrees.index('roast beef'), entrees.index('swordfish')],\n    'E': [entrees.index('pork chops'), entrees.index('roast beef'), entrees.index('swordfish')]\n}\n\n# Check which option correctly lists all possible entrees John could order\ncorrect_option = None\nfor letter, possible_entrees in options.items():\n    solver.push()\n    # John must order one of the possible entrees\n    solver.add(Or([entree_vars['John'] == e for e in possible_entrees]))\n    # Check if there is a solution where John orders something NOT in possible_entrees\n    solver.push()\n    solver.add(Not(Or([entree_vars['John'] == e for e in possible_entrees])))\n    if solver.check() == unsat:\n        # No solution exists where John orders outside possible_entrees\n        correct_option = letter\n        solver.pop()  # pop inner push\n        solver.pop()\n        break\n    solver.pop()  # pop inner push\n    solver.pop()\n\nprint(f\"'{correct_option}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Three couples—John and Kate, Lewis and Marie, and Nat and Olive have dinner in a restaurant together. Kate, Marie, and Olive are women; the other three are men. Each person orders one and only one of the following kinds of entrees: pork chops, roast beef, swordfish, tilefish, veal cutlet. The six people order in a manner consistent with the following conditions: The two people in each couple do not order the same kind of entree as each other. None of the men orders the same kind of entree as any of the other men. Marie orders swordfish. Neither John nor Nat orders a fish entree. Olive orders roast beef.\n\nSuppose that the people in each couple both order the same kind of entree as each other rather than order different kinds of entrees. If all other conditions remain the same, and no two women order the same kind of entree, then which one of the following statements could be true?\n\nOptions:\n(A) John orders roast beef.\n(B) John orders swordfish.\n(C) Kate orders roast beef.\n(D) Two of the people order pork chops.\n(E) Two of the people order tilefish.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['John', 'Kate', 'Lewis', 'Marie', 'Nat', 'Olive']\nmen = ['John', 'Lewis', 'Nat']\nwomen = ['Kate', 'Marie', 'Olive']\ncouples = [('John', 'Kate'), ('Lewis', 'Marie'), ('Nat', 'Olive')]\n\nentrees = ['pork chops', 'roast beef', 'swordfish', 'tilefish', 'veal cutlet']\nentree_indices = {e: i for i, e in enumerate(entrees)}\n\n# Create Z3 Int variables for each person's entree\norder = {p: Int(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person orders exactly one entree (valid entree index)\nfor p in people:\n    solver.add(And(order[p] >= 0, order[p] < len(entrees)))\n\n# New scenario: each couple orders the SAME kind of entree\nfor (p1, p2) in couples:\n    solver.add(order[p1] == order[p2])\n\n# None of the men orders the same entree as any other man\nsolver.add(Distinct([order[m] for m in men]))\n\n# Marie orders swordfish\nsolver.add(order['Marie'] == entree_indices['swordfish'])\n\n# Neither John nor Nat orders a fish entree\nfish_entrees = ['swordfish', 'tilefish']\nfish_indices = [entree_indices[f] for f in fish_entrees]\nsolver.add(Not(Or([order['John'] == f for f in fish_indices])))\nsolver.add(Not(Or([order['Nat'] == f for f in fish_indices])))\n\n# Olive orders roast beef\nsolver.add(order['Olive'] == entree_indices['roast beef'])\n\n# No two women order the same kind of entree\nsolver.add(Distinct([order[w] for w in women]))\n\n# OPTION CHECKING\noptions = {\n    'A': order['John'] == entree_indices['roast beef'],\n    'B': order['John'] == entree_indices['swordfish'],\n    'C': order['Kate'] == entree_indices['roast beef'],\n    'D': Sum([If(order[p] == entree_indices['pork chops'], 1, 0) for p in people]) == 2,\n    'E': Sum([If(order[p] == entree_indices['tilefish'], 1, 0) for p in people]) == 2,\n}\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[opt])\n    if solver.check() == sat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "There are exactly seven houses on a street. Each house is occupied by exactly one of seven families: the Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans. All the houses are on the same side of the street, which runs from west to east. The Rutans do not live in the first or the last house on the street. The Kahns live in the fourth house from the west end of the street. The Muirs live next to the Kahns. The Piatts live east of both the Kahns and the Muirs but west of the Lowes.\n\nWhich one of the following families could live in the house that is the farthest east?\n\nOptions:\n(A) the Kahns\n(B) the Muirs\n(C) the Newmans\n(D) the Piatts\n(E) the Rutans",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfamilies = ['Kahns', 'Lowes', 'Muirs', 'Newmans', 'Owens', 'Piatts', 'Rutans']\nnum_houses = 7\n\n# Create Int variables representing the house number (1 to 7) for each family\nhouse = {fam: Int(fam) for fam in families}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each family lives in a house numbered 1 through 7\nfor fam in families:\n    solver.add(And(house[fam] >= 1, house[fam] <= num_houses))\n\n# All families live in distinct houses\nsolver.add(Distinct([house[fam] for fam in families]))\n\n# The Rutans do not live in the first or last house\nsolver.add(house['Rutans'] != 1)\nsolver.add(house['Rutans'] != num_houses)\n\n# The Kahns live in the fourth house from the west end\nsolver.add(house['Kahns'] == 4)\n\n# The Muirs live next to the Kahns\nsolver.add(Or(house['Muirs'] == house['Kahns'] + 1, house['Muirs'] == house['Kahns'] - 1))\n\n# The Piatts live east of both the Kahns and the Muirs\nsolver.add(house['Piatts'] > house['Kahns'])\nsolver.add(house['Piatts'] > house['Muirs'])\n\n# The Piatts live west of the Lowes\nsolver.add(house['Piatts'] < house['Lowes'])\n\n# OPTION CHECKING\n# Check each option to see if that family can live in the farthest east house (house 7)\noptions = ['Kahns', 'Muirs', 'Newmans', 'Piatts', 'Rutans']\n\nfor i, fam in enumerate(options):\n    solver.push()\n    solver.add(house[fam] == num_houses)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "There are exactly seven houses on a street. Each house is occupied by exactly one of seven families: the Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans. All the houses are on the same side of the street, which runs from west to east. The Rutans do not live in the first or the last house on the street. The Kahns live in the fourth house from the west end of the street. The Muirs live next to the Kahns. The Piatts live east of both the Kahns and the Muirs but west of the Lowes.\n\nWhich one of the following families CANNOT live next to the Kahns?\n\nOptions:\n(A) the Lowes\n(B) the Newmans\n(C) the Owens\n(D) the Piatts\n(E) the Rutans",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfamilies = ['Kahns', 'Lowes', 'Muirs', 'Newmans', 'Owens', 'Piatts', 'Rutans']\nnum_houses = 7\n\n# Create an Int variable for each family representing their house position (1 to 7)\npositions = {family: Int(family) for family in families}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each family lives in a house numbered 1 to 7\nfor family in families:\n    solver.add(And(positions[family] >= 1, positions[family] <= num_houses))\n\n# All families live in distinct houses\nsolver.add(Distinct([positions[family] for family in families]))\n\n# The Kahns live in the fourth house from the west end\nsolver.add(positions['Kahns'] == 4)\n\n# The Rutans do not live in the first or last house\nsolver.add(positions['Rutans'] != 1)\nsolver.add(positions['Rutans'] != 7)\n\n# The Muirs live next to the Kahns\ndiff_muirs_kahns = Abs(positions['Muirs'] - positions['Kahns'])\nsolver.add(diff_muirs_kahns == 1)\n\n# The Piatts live east of both the Kahns and the Muirs\nsolver.add(positions['Piatts'] > positions['Kahns'])\nsolver.add(positions['Piatts'] > positions['Muirs'])\n\n# The Piatts live west of the Lowes\nsolver.add(positions['Piatts'] < positions['Lowes'])\n\n# OPTION CHECKING\n\n# We want to find which family CANNOT live next to the Kahns.\n# For each option, we check if the family can live next to Kahns.\n# If the solver says UNSAT with the added constraint that the family lives next to Kahns,\n# then that family cannot live next to Kahns.\n\noptions = ['Lowes', 'Newmans', 'Owens', 'Piatts', 'Rutans']\nfor i, family in enumerate(options):\n    solver.push()\n    # Add constraint that this family lives next to Kahns\n    diff = Abs(positions[family] - positions['Kahns'])\n    solver.add(diff == 1)\n    if solver.check() == unsat:\n        # This family cannot live next to Kahns\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "There are exactly seven houses on a street. Each house is occupied by exactly one of seven families: the Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans. All the houses are on the same side of the street, which runs from west to east. The Rutans do not live in the first or the last house on the street. The Kahns live in the fourth house from the west end of the street. The Muirs live next to the Kahns. The Piatts live east of both the Kahns and the Muirs but west of the Lowes.\n\nIf the Muirs live west of the Kahns, then the Rutans CANNOT live next to both\n\nOptions:\n(A) the Kahns and the Piatts\n(B) the Lowes and the Piatts\n(C) the Muirs and the Piatts\n(D) the Muirs and the Owens\n(E) the Muirs and the Newmans",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfamilies = ['Kahns', 'Lowes', 'Muirs', 'Newmans', 'Owens', 'Piatts', 'Rutans']\nnum_houses = 7\n\n# Create an Int variable for each family representing their house number (1 to 7)\nhouses = {fam: Int(fam) for fam in families}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each family lives in a house numbered 1 through 7\nfor fam in families:\n    solver.add(And(houses[fam] >= 1, houses[fam] <= num_houses))\n\n# All families live in distinct houses\nsolver.add(Distinct([houses[fam] for fam in families]))\n\n# The Rutans do not live in the first or last house\nsolver.add(houses['Rutans'] != 1)\nsolver.add(houses['Rutans'] != num_houses)\n\n# The Kahns live in the fourth house from the west end\nsolver.add(houses['Kahns'] == 4)\n\n# The Muirs live next to the Kahns\nsolver.add(Or(houses['Muirs'] == houses['Kahns'] - 1,\n              houses['Muirs'] == houses['Kahns'] + 1))\n\n# The Piatts live east of both the Kahns and the Muirs but west of the Lowes\nsolver.add(houses['Piatts'] > houses['Kahns'])\nsolver.add(houses['Piatts'] > houses['Muirs'])\nsolver.add(houses['Piatts'] < houses['Lowes'])\n\n# Additional constraint: Muirs live west of Kahns\nsolver.add(houses['Muirs'] < houses['Kahns'])\n\n# Helper function to check if Rutans live next to two given families simultaneously\ndef rutans_next_to_both(fam1, fam2):\n    r = houses['Rutans']\n    f1 = houses[fam1]\n    f2 = houses[fam2]\n    # Rutans next to fam1 and fam2 means Rutans is adjacent to both\n    cond1 = Or(r == f1 + 1, r == f1 - 1)\n    cond2 = Or(r == f2 + 1, r == f2 - 1)\n    return And(cond1, cond2)\n\n# OPTION CHECKING\noptions = [\n    ('A', ('Kahns', 'Piatts')),\n    ('B', ('Lowes', 'Piatts')),\n    ('C', ('Muirs', 'Piatts')),\n    ('D', ('Muirs', 'Owens')),\n    ('E', ('Muirs', 'Newmans')),\n]\n\nfor letter, (fam1, fam2) in options:\n    solver.push()\n    # Add constraint that Rutans live next to both fam1 and fam2\n    solver.add(rutans_next_to_both(fam1, fam2))\n    # Check if this is possible\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "There are exactly seven houses on a street. Each house is occupied by exactly one of seven families: the Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans. All the houses are on the same side of the street, which runs from west to east. The Rutans do not live in the first or the last house on the street. The Kahns live in the fourth house from the west end of the street. The Muirs live next to the Kahns. The Piatts live east of both the Kahns and the Muirs but west of the Lowes.\n\nIf the Newmans live immediately west of the Kahns, which one of the following statements must be false?\n\nOptions:\n(A) The Owens live next to the Newmans.\n(B) The Owens live next to the Rutans.\n(C) The Piatts live next to the Lowes.\n(D) The Piatts live next to the Muirs.\n(E) The Rutans live next to the Newmans.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfamilies = ['Kahns', 'Lowes', 'Muirs', 'Newmans', 'Owens', 'Piatts', 'Rutans']\nnum_houses = 7\n\n# Create Int variables for each family representing their house position (0-based index)\npositions = {fam: Int(fam) for fam in families}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each family lives in a house numbered 0 to 6\nfor fam in families:\n    solver.add(And(positions[fam] >= 0, positions[fam] < num_houses))\n\n# All families live in distinct houses\nsolver.add(Distinct([positions[fam] for fam in families]))\n\n# The Rutans do not live in the first or last house\nsolver.add(positions['Rutans'] != 0)\nsolver.add(positions['Rutans'] != num_houses - 1)\n\n# The Kahns live in the fourth house from the west end (index 3)\nsolver.add(positions['Kahns'] == 3)\n\n# The Muirs live next to the Kahns\ndiff_muirs_kahns = Abs(positions['Muirs'] - positions['Kahns'])\nsolver.add(diff_muirs_kahns == 1)\n\n# The Piatts live east of both the Kahns and the Muirs\nsolver.add(positions['Piatts'] > positions['Kahns'])\nsolver.add(positions['Piatts'] > positions['Muirs'])\n\n# The Piatts live west of the Lowes\nsolver.add(positions['Piatts'] < positions['Lowes'])\n\n# The Newmans live immediately west of the Kahns\nsolver.add(positions['Newmans'] == positions['Kahns'] - 1)\n\n# Helper function to check if two families live next to each other\ndef next_to(fam1, fam2):\n    return Or([Abs(positions[fam1] - positions[fam2]) == 1])\n\n# OPTION CHECKING\noptions = [\n    ('A', next_to('Owens', 'Newmans')),\n    ('B', next_to('Owens', 'Rutans')),\n    ('C', next_to('Piatts', 'Lowes')),\n    ('D', next_to('Piatts', 'Muirs')),\n    ('E', next_to('Rutans', 'Newmans'))\n]\n\n# We want to find which statement must be false.\n# So for each option, we check if it can be true given the constraints.\n# The one that cannot be true (unsat) is the must-be-false statement.\n\nfor letter, condition in options:\n    solver.push()\n    solver.add(condition)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "There are exactly seven houses on a street. Each house is occupied by exactly one of seven families: the Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans. All the houses are on the same side of the street, which runs from west to east. The Rutans do not live in the first or the last house on the street. The Kahns live in the fourth house from the west end of the street. The Muirs live next to the Kahns. The Piatts live east of both the Kahns and the Muirs but west of the Lowes.\n\nIf the Owens live east of the Muirs, which one of the following statements must be true?\n\nOptions:\n(A) The Kahns live east of the Muirs.\n(B) The Kahns live west of the Rutans.\n(C) The Owens live west of the Lowes.\n(D) The Owens live east of the Piatts.\n(E) The Owens live west of the Piatts.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Families\nfamilies = ['Kahn', 'Low', 'Muir', 'Newman', 'Owen', 'Piatt', 'Rutan']\n\n# Create integer variables for each family representing house positions (1 to 7)\nhouse_pos = {fam: Int(fam) for fam in families}\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each house position is between 1 and 7\nfor fam in families:\n    solver.add(And(house_pos[fam] >= 1, house_pos[fam] <= 7))\n\n# All families live in distinct houses\nsolver.add(Distinct([house_pos[fam] for fam in families]))\n\n# The Rutans do not live in the first or last house\nsolver.add(house_pos['Rutan'] != 1)\nsolver.add(house_pos['Rutan'] != 7)\n\n# The Kahns live in the fourth house from the west end\nsolver.add(house_pos['Kahn'] == 4)\n\n# The Muirs live next to the Kahns\ndiff_kahn_muir = house_pos['Kahn'] - house_pos['Muir']\nsolver.add(Or(diff_kahn_muir == 1, diff_kahn_muir == -1))\n\n# The Piatts live east of both the Kahns and the Muirs\nsolver.add(house_pos['Piatt'] > house_pos['Kahn'])\nsolver.add(house_pos['Piatt'] > house_pos['Muir'])\n\n# The Piatts live west of the Lowes\nsolver.add(house_pos['Piatt'] < house_pos['Low'])\n\n# The Owens live east of the Muirs (given condition)\nsolver.add(house_pos['Owen'] > house_pos['Muir'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': house_pos['Kahn'] > house_pos['Muir'],        # The Kahns live east of the Muirs.\n    'B': house_pos['Kahn'] < house_pos['Rutan'],       # The Kahns live west of the Rutans.\n    'C': house_pos['Owen'] < house_pos['Low'],         # The Owens live west of the Lowes.\n    'D': house_pos['Owen'] > house_pos['Piatt'],       # The Owens live east of the Piatts.\n    'E': house_pos['Owen'] < house_pos['Piatt'],       # The Owens live west of the Piatts.\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    # Add negation of the option condition to check if it can be false\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        # If negation is unsat, option condition must be true in all models\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "There are exactly seven houses on a street. Each house is occupied by exactly one of seven families: the Kahns, Lowes, Muirs, Newmans, Owens, Piatts, Rutans. All the houses are on the same side of the street, which runs from west to east. The Rutans do not live in the first or the last house on the street. The Kahns live in the fourth house from the west end of the street. The Muirs live next to the Kahns. The Piatts live east of both the Kahns and the Muirs but west of the Lowes.\n\nIf the Owens live east of the Kahns, which one of the following pairs of families must live next to each other?\n\nOptions:\n(A) the Kahns and the Piatts\n(B) the Lowes and the Owens\n(C) the Muirs and the Newmans\n(D) the Newmans and the Rutans\n(E) the Owens and the Piatts",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfamilies = ['Kahns', 'Lowes', 'Muirs', 'Newmans', 'Owens', 'Piatts', 'Rutans']\nnum_houses = 7\n\n# Create Int variables for each family representing their house number (1 to 7)\nhouse = {fam: Int(fam) for fam in families}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each family lives in a house numbered 1 through 7\nfor fam in families:\n    solver.add(And(house[fam] >= 1, house[fam] <= num_houses))\n\n# All houses are distinct\nsolver.add(Distinct([house[fam] for fam in families]))\n\n# The Rutans do not live in the first or the last house\nsolver.add(house['Rutans'] != 1)\nsolver.add(house['Rutans'] != num_houses)\n\n# The Kahns live in the fourth house from the west end of the street\nsolver.add(house['Kahns'] == 4)\n\n# The Muirs live next to the Kahns\nsolver.add(Or(house['Muirs'] == house['Kahns'] + 1, house['Muirs'] == house['Kahns'] - 1))\n\n# The Piatts live east of both the Kahns and the Muirs but west of the Lowes\nsolver.add(house['Piatts'] > house['Kahns'])\nsolver.add(house['Piatts'] > house['Muirs'])\nsolver.add(house['Piatts'] < house['Lowes'])\n\n# The Owens live east of the Kahns\nsolver.add(house['Owens'] > house['Kahns'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': Or(house['Kahns'] == house['Piatts'] + 1, house['Kahns'] == house['Piatts'] - 1),\n    'B': Or(house['Lowes'] == house['Owens'] + 1, house['Lowes'] == house['Owens'] - 1),\n    'C': Or(house['Muirs'] == house['Newmans'] + 1, house['Muirs'] == house['Newmans'] - 1),\n    'D': Or(house['Newmans'] == house['Rutans'] + 1, house['Newmans'] == house['Rutans'] - 1),\n    'E': Or(house['Owens'] == house['Piatts'] + 1, house['Owens'] == house['Piatts'] - 1),\n}\n\nfor option_letter, adjacency_condition in options.items():\n    solver.push()\n    solver.add(Not(adjacency_condition))  # Add negation of the option to test if it must be true\n    if solver.check() == unsat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "At an automobile exhibition, cars are displayed on each floor of a three-floor building. On each floor the cars are either all family cars or all sports cars, either all new or all used, and either all production models or all research models. The following conditions apply to this exhibition: If the exhibition includes both family cars and sports cars, then each family car is displayed on a lower numbered floor than any sports car. The exhibition includes no used research models. The exhibition includes no research models that are sports cars. There are new cars on floor 1. There are used cars on floor 3.\n\nIf there are sports cars on exactly two floors, then which one of the following statements could be true?\n\nOptions:\n(A) There are research models on floor 1.\n(B) There are sports cars on floor 1.\n(C) There are family cars on floor 2.\n(D) There are research models on floor 2.\n(E) There are family cars on floor 3.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfloors = [1, 2, 3]\n\n# Categories and their possible values as indices\ncar_types = ['family', 'sports']          # 0: family, 1: sports\nconditions = ['new', 'used']              # 0: new, 1: used\nmodels = ['production', 'research']       # 0: production, 1: research\n\n# Create Z3 variables for each floor and category\ncar_type = {f: Int(f'car_type_{f}') for f in floors}    # family or sports\ncondition = {f: Int(f'condition_{f}') for f in floors}  # new or used\nmodel = {f: Int(f'model_{f}') for f in floors}          # production or research\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each category variable must be in its domain\nfor f in floors:\n    solver.add(And(car_type[f] >= 0, car_type[f] < len(car_types)))\n    solver.add(And(condition[f] >= 0, condition[f] < len(conditions)))\n    solver.add(And(model[f] >= 0, model[f] < len(models)))\n\n# 1) If the exhibition includes both family cars and sports cars,\n# then each family car is displayed on a lower numbered floor than any sports car.\n# We encode this as:\n# If there exist floors f1, f2 with family on f1 and sports on f2, then f1 < f2 for all such pairs.\n\n# To encode this, we assert:\n# For all floors f1,f2: if car_type[f1] = family and car_type[f2] = sports then f1 < f2\n\nfor f1 in floors:\n    for f2 in floors:\n        cond1 = car_type[f1] == car_types.index('family')\n        cond2 = car_type[f2] == car_types.index('sports')\n        solver.add(Implies(And(cond1, cond2), f1 < f2))\n\n# 2) The exhibition includes no used research models.\n# So, no floor can have condition=used and model=research simultaneously.\nfor f in floors:\n    solver.add(Not(And(condition[f] == conditions.index('used'),\n                       model[f] == models.index('research'))))\n\n# 3) The exhibition includes no research models that are sports cars.\n# So, no floor can have model=research and car_type=sports simultaneously.\nfor f in floors:\n    solver.add(Not(And(model[f] == models.index('research'),\n                       car_type[f] == car_types.index('sports'))))\n\n# 4) There are new cars on floor 1.\nsolver.add(condition[1] == conditions.index('new'))\n\n# 5) There are used cars on floor 3.\nsolver.add(condition[3] == conditions.index('used'))\n\n# 6) If there are sports cars on exactly two floors\nsports_count = Sum([If(car_type[f] == car_types.index('sports'), 1, 0) for f in floors])\nsolver.add(sports_count == 2)\n\n# OPTION CHECKING\n# Options:\n# (A) There are research models on floor 1.\n# (B) There are sports cars on floor 1.\n# (C) There are family cars on floor 2.\n# (D) There are research models on floor 2.\n# (E) There are family cars on floor 3.\n\noptions = []\n\n# A\nsolver.push()\nsolver.add(model[1] == models.index('research'))\nif solver.check() == sat:\n    options.append('A')\nsolver.pop()\n\n# B\nsolver.push()\nsolver.add(car_type[1] == car_types.index('sports'))\nif solver.check() == sat:\n    options.append('B')\nsolver.pop()\n\n# C\nsolver.push()\nsolver.add(car_type[2] == car_types.index('family'))\nif solver.check() == sat:\n    options.append('C')\nsolver.pop()\n\n# D\nsolver.push()\nsolver.add(model[2] == models.index('research'))\nif solver.check() == sat:\n    options.append('D')\nsolver.pop()\n\n# E\nsolver.push()\nsolver.add(car_type[3] == car_types.index('family'))\nif solver.check() == sat:\n    options.append('E')\nsolver.pop()\n\n# Exactly one option should be true\n# Print the one that could be true\nprint(f\"'{options[0]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "At an automobile exhibition, cars are displayed on each floor of a three-floor building. On each floor the cars are either all family cars or all sports cars, either all new or all used, and either all production models or all research models. The following conditions apply to this exhibition: If the exhibition includes both family cars and sports cars, then each family car is displayed on a lower numbered floor than any sports car. The exhibition includes no used research models. The exhibition includes no research models that are sports cars. There are new cars on floor 1. There are used cars on floor 3.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) The exhibition includes new research model sports cars.\n(B) The exhibition includes used research model family cars.\n(C) The exhibition includes used research model sports cars.\n(D) There are research models on exactly one floor.\n(E) There are research models on all three floors.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfloors = [1, 2, 3]\n\n# Car types\ncar_types = ['family', 'sports']\ncar_type_map = {name: i for i, name in enumerate(car_types)}\n\n# Condition types\ncondition_types = ['new', 'used']\ncondition_type_map = {name: i for i, name in enumerate(condition_types)}\n\n# Model types\nmodel_types = ['production', 'research']\nmodel_type_map = {name: i for i, name in enumerate(model_types)}\n\n# Variables for each floor:\n# car_type[floor], condition[floor], model[floor]\ncar_type = {}\ncondition = {}\nmodel = {}\n\nfor f in floors:\n    car_type[f] = Int(f'car_type_{f}')     # 0=family, 1=sports\n    condition[f] = Int(f'condition_{f}')   # 0=new, 1=used\n    model[f] = Int(f'model_{f}')           # 0=production, 1=research\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Domain constraints\nfor f in floors:\n    solver.add(And(car_type[f] >= 0, car_type[f] < len(car_types)))\n    solver.add(And(condition[f] >= 0, condition[f] < len(condition_types)))\n    solver.add(And(model[f] >= 0, model[f] < len(model_types)))\n\n# On each floor, all cars are same type, condition, and model (already represented by single variable per floor)\n\n# 1) If the exhibition includes both family and sports cars,\n# then each family car is displayed on a lower numbered floor than any sports car.\n\n# First, define if family cars exist and if sports cars exist\nfamily_exists = Bool('family_exists')\nsports_exists = Bool('sports_exists')\n\nsolver.add(family_exists == Or([car_type[f] == car_type_map['family'] for f in floors]))\nsolver.add(sports_exists == Or([car_type[f] == car_type_map['sports'] for f in floors]))\n\n# If both exist, then for every floor with family cars and every floor with sports cars,\n# floor with family cars < floor with sports cars\nfamily_floors = [f for f in floors]\nsports_floors = [f for f in floors]\n\nfamily_sports_order_constraints = []\nfor ff in floors:\n    for sf in floors:\n        cond = Implies(And(family_exists, sports_exists,\n                          car_type[ff] == car_type_map['family'],\n                          car_type[sf] == car_type_map['sports']),\n                       ff < sf)\n        family_sports_order_constraints.append(cond)\nsolver.add(And(family_sports_order_constraints))\n\n# 2) The exhibition includes no used research models.\n# So no floor can have condition=used AND model=research\nfor f in floors:\n    solver.add(Not(And(condition[f] == condition_type_map['used'], model[f] == model_type_map['research'])))\n\n# 3) The exhibition includes no research models that are sports cars.\n# So no floor can have model=research AND car_type=sports\nfor f in floors:\n    solver.add(Not(And(model[f] == model_type_map['research'], car_type[f] == car_type_map['sports'])))\n\n# 4) There are new cars on floor 1.\nsolver.add(condition[1] == condition_type_map['new'])\n\n# 5) There are used cars on floor 3.\nsolver.add(condition[3] == condition_type_map['used'])\n\n# OPTION CHECKING\n\n# Options:\n# (A) The exhibition includes new research model sports cars.\n# (B) The exhibition includes used research model family cars.\n# (C) The exhibition includes used research model sports cars.\n# (D) There are research models on exactly one floor.\n# (E) There are research models on all three floors.\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\nfor i, option in enumerate(options):\n    solver.push()\n    if option == 'A':\n        # new research model sports cars exist\n        # So there is a floor with condition=new, model=research, car_type=sports\n        # But constraint 3 forbids research models that are sports cars, so this should be unsat\n        cond = Or([And(condition[f] == condition_type_map['new'],\n                       model[f] == model_type_map['research'],\n                       car_type[f] == car_type_map['sports']) for f in floors])\n        solver.add(cond)\n    elif option == 'B':\n        # used research model family cars exist\n        # used research models forbidden by constraint 2, so unsat\n        cond = Or([And(condition[f] == condition_type_map['used'],\n                       model[f] == model_type_map['research'],\n                       car_type[f] == car_type_map['family']) for f in floors])\n        solver.add(cond)\n    elif option == 'C':\n        # used research model sports cars exist\n        # forbidden by constraints 2 and 3, so unsat\n        cond = Or([And(condition[f] == condition_type_map['used'],\n                       model[f] == model_type_map['research'],\n                       car_type[f] == car_type_map['sports']) for f in floors])\n        solver.add(cond)\n    elif option == 'D':\n        # research models on exactly one floor\n        # count how many floors have model=research\n        research_counts = [If(model[f] == model_type_map['research'], 1, 0) for f in floors]\n        solver.add(Sum(research_counts) == 1)\n    elif option == 'E':\n        # research models on all three floors\n        for f in floors:\n            solver.add(model[f] == model_type_map['research'])\n\n    if solver.check() == sat:\n        print(f\"'{option}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "At an automobile exhibition, cars are displayed on each floor of a three-floor building. On each floor the cars are either all family cars or all sports cars, either all new or all used, and either all production models or all research models. The following conditions apply to this exhibition: If the exhibition includes both family cars and sports cars, then each family car is displayed on a lower numbered floor than any sports car. The exhibition includes no used research models. The exhibition includes no research models that are sports cars. There are new cars on floor 1. There are used cars on floor 3.\n\nWhich one of the following statements must be true?\n\nOptions:\n(A) There are production models on floor 1.\n(B) There are research models on floor 1.\n(C) There are production models on floor 2.\n(D) There are production models on floor 3.\n(E) There are research models on floor 3.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfloors = [1, 2, 3]\n\n# Categories and their possible values\ncar_types = ['family', 'sports']          # 0: family, 1: sports\nconditions = ['new', 'used']              # 0: new, 1: used\nmodels = ['production', 'research']       # 0: production, 1: research\n\n# Create Z3 Int variables for each floor and category\ncar_type = {f: Int(f'car_type_{f}') for f in floors}     # 0 or 1\ncondition = {f: Int(f'condition_{f}') for f in floors}   # 0 or 1\nmodel = {f: Int(f'model_{f}') for f in floors}           # 0 or 1\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each floor's variables must be within valid ranges\nfor f in floors:\n    solver.add(And(car_type[f] >= 0, car_type[f] < len(car_types)))\n    solver.add(And(condition[f] >= 0, condition[f] < len(conditions)))\n    solver.add(And(model[f] >= 0, model[f] < len(models)))\n\n# The cars on each floor are all the same type, condition, and model (already modeled by single variable per floor)\n\n# Condition 1:\n# If both family and sports cars are included in the exhibition,\n# then each family car is on a lower floor than any sports car.\n\n# We need to express:\n# If there exists at least one floor with family cars and at least one with sports cars,\n# then for any floor f1 with family cars and any floor f2 with sports cars, f1 < f2.\n\n# Define booleans for presence of family and sports cars on floors\nfamily_floors = [car_type[f] == 0 for f in floors]\nsports_floors = [car_type[f] == 1 for f in floors]\n\nfamily_exists = Or(family_floors)\nsports_exists = Or(sports_floors)\n\n# For all floors f1 family, f2 sports: f1 < f2\nfamily_sports_order = []\nfor f1 in floors:\n    for f2 in floors:\n        cond = Implies(And(car_type[f1] == 0, car_type[f2] == 1), f1 < f2)\n        family_sports_order.append(cond)\n\nsolver.add(Implies(And(family_exists, sports_exists), And(family_sports_order)))\n\n# Condition 2:\n# The exhibition includes no used research models.\n# So no floor can be both used (1) and research (1)\nfor f in floors:\n    solver.add(Not(And(condition[f] == 1, model[f] == 1)))\n\n# Condition 3:\n# The exhibition includes no research models that are sports cars.\n# So no floor can be both sports (1) and research (1)\nfor f in floors:\n    solver.add(Not(And(car_type[f] == 1, model[f] == 1)))\n\n# Condition 4:\n# There are new cars on floor 1\nsolver.add(condition[1] == 0)  # new\n\n# Condition 5:\n# There are used cars on floor 3\nsolver.add(condition[3] == 1)  # used\n\n# OPTION CHECKING\n\n# Options to check:\n# (A) There are production models on floor 1.\n# (B) There are research models on floor 1.\n# (C) There are production models on floor 2.\n# (D) There are production models on floor 3.\n# (E) There are research models on floor 3.\n\noptions = [\n    model[1] == 0,  # A: production on floor 1\n    model[1] == 1,  # B: research on floor 1\n    model[2] == 0,  # C: production on floor 2\n    model[3] == 0,  # D: production on floor 3\n    model[3] == 1   # E: research on floor 3\n]\n\n# We want to find which option MUST be true.\n# So for each option, check if the negation is SAT.\n# The option that cannot be false (negation UNSAT) must be true.\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(Not(opt))\n    if solver.check() == unsat:\n        # Option i must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "At an automobile exhibition, cars are displayed on each floor of a three-floor building. On each floor the cars are either all family cars or all sports cars, either all new or all used, and either all production models or all research models. The following conditions apply to this exhibition: If the exhibition includes both family cars and sports cars, then each family car is displayed on a lower numbered floor than any sports car. The exhibition includes no used research models. The exhibition includes no research models that are sports cars. There are new cars on floor 1. There are used cars on floor 3.\n\nIf there are research models on exactly two floors, then which one of the following statements can be false?\n\nOptions:\n(A) There are family cars on floor 1.\n(B) There are research models on floor 1.\n(C) There are new cars on floor 2.\n(D) There are research models on floor 2.\n(E) There are family cars on floor 3.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfloors = [1, 2, 3]\n\n# Enumerations for each attribute\ncar_types = ['family', 'sports']        # 0: family, 1: sports\nconditions = ['new', 'used']            # 0: new, 1: used\nmodels = ['production', 'research']    # 0: production, 1: research\n\n# Create variables for each floor and each attribute\ncar_type = {f: Int(f\"car_type_{f}\") for f in floors}       # 0 or 1\ncondition = {f: Int(f\"condition_{f}\") for f in floors}      # 0 or 1\nmodel = {f: Int(f\"model_{f}\") for f in floors}              # 0 or 1\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Domains for variables\nfor f in floors:\n    solver.add(And(car_type[f] >= 0, car_type[f] < len(car_types)))\n    solver.add(And(condition[f] >= 0, condition[f] < len(conditions)))\n    solver.add(And(model[f] >= 0, model[f] < len(models)))\n\n# Condition 1:\n# If the exhibition includes both family cars and sports cars,\n# then each family car is displayed on a lower numbered floor than any sports car.\n\n# We need to express:\n# If there exists f1, f2 such that car_type[f1]=family and car_type[f2]=sports,\n# then for all f1,f2: if car_type[f1]=family and car_type[f2]=sports then f1 < f2\n\nfamily_floors = [f for f in floors]\nsports_floors = [f for f in floors]\n\n# Create expressions for floors with family and sports\nfamily_exists = Or([car_type[f] == 0 for f in floors])\nsports_exists = Or([car_type[f] == 1 for f in floors])\n\n# For all f1,f2: if car_type[f1]=family and car_type[f2]=sports then f1 < f2\nfamily_lower_than_sports = And([\n    Implies(And(car_type[f1] == 0, car_type[f2] == 1), f1 < f2)\n    for f1 in floors for f2 in floors\n])\n\nsolver.add(Implies(And(family_exists, sports_exists), family_lower_than_sports))\n\n# Condition 2:\n# The exhibition includes no used research models.\n# So for all floors: not (condition=used and model=research)\nfor f in floors:\n    solver.add(Not(And(condition[f] == 1, model[f] == 1)))\n\n# Condition 3:\n# The exhibition includes no research models that are sports cars.\n# For all floors: not (model=research and car_type=sports)\nfor f in floors:\n    solver.add(Not(And(model[f] == 1, car_type[f] == 1)))\n\n# Condition 4:\n# There are new cars on floor 1.\nsolver.add(condition[1] == 0)\n\n# Condition 5:\n# There are used cars on floor 3.\nsolver.add(condition[3] == 1)\n\n# Additional condition from the question:\n# If there are research models on exactly two floors\n# sum over floors of (model == research) == 2\nresearch_count = Sum([If(model[f] == 1, 1, 0) for f in floors])\nsolver.add(research_count == 2)\n\n# OPTION CHECKING\n# We want to find which option can be false.\n# So for each option, we add the negation of the option and check satisfiability.\n# If satisfiable, then the option can be false.\n\n# (A) There are family cars on floor 1.\n# Negation: car_type[1] != family (i.e., car_type[1] != 0)\ndef check_option_A():\n    solver.push()\n    solver.add(car_type[1] != 0)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# (B) There are research models on floor 1.\n# Negation: model[1] != research (i.e., model[1] != 1)\ndef check_option_B():\n    solver.push()\n    solver.add(model[1] != 1)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# (C) There are new cars on floor 2.\n# Negation: condition[2] != new (i.e., condition[2] != 0)\ndef check_option_C():\n    solver.push()\n    solver.add(condition[2] != 0)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# (D) There are research models on floor 2.\n# Negation: model[2] != research (i.e., model[2] != 1)\ndef check_option_D():\n    solver.push()\n    solver.add(model[2] != 1)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# (E) There are family cars on floor 3.\n# Negation: car_type[3] != family (i.e., car_type[3] != 0)\ndef check_option_E():\n    solver.push()\n    solver.add(car_type[3] != 0)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\nif check_option_A():\n    print(\"'A'\")\nelif check_option_B():\n    print(\"'B'\")\nelif check_option_C():\n    print(\"'C'\")\nelif check_option_D():\n    print(\"'D'\")\nelif check_option_E():\n    print(\"'E'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "At an automobile exhibition, cars are displayed on each floor of a three-floor building. On each floor the cars are either all family cars or all sports cars, either all new or all used, and either all production models or all research models. The following conditions apply to this exhibition: If the exhibition includes both family cars and sports cars, then each family car is displayed on a lower numbered floor than any sports car. The exhibition includes no used research models. The exhibition includes no research models that are sports cars. There are new cars on floor 1. There are used cars on floor 3.\n\nIf all the new cars in the exhibition are research models, then which one of the following statements must be true?\n\nOptions:\n(A) All the family cars in the exhibition are new.\n(B) All the family cars in the exhibition are research models.\n(C) All the family cars in the exhibition are used.\n(D) All the new cars in the exhibition are family cars.\n(E) All the production models in the exhibition are family cars.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfloors = [1, 2, 3]\n\n# Attributes: family(0)/sports(1), new(0)/used(1), production(0)/research(1)\n# For each floor, define Int variables representing the attribute as 0 or 1\ncar_type = [Int(f\"car_type_{f}\") for f in floors]      # 0=family, 1=sports\ncar_condition = [Int(f\"car_condition_{f}\") for f in floors]  # 0=new, 1=used\ncar_model = [Int(f\"car_model_{f}\") for f in floors]    # 0=production, 1=research\n\n# DOMAIN constraints: each attribute is 0 or 1\ndomain_constraints = []\nfor f in range(3):\n    domain_constraints.append(And(car_type[f] >= 0, car_type[f] <= 1))\n    domain_constraints.append(And(car_condition[f] >= 0, car_condition[f] <= 1))\n    domain_constraints.append(And(car_model[f] >= 0, car_model[f] <= 1))\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Add domain constraints\nsolver.add(domain_constraints)\n\n# Condition 1:\n# If both family and sports cars are exhibited, then all family cars on lower floors than any sports cars\n# So if family and sports both appear, then for any floor f with family and floor g with sports, f < g\n# Implement: If Exists family and Exists sports:\n#   For all f,g: if floor f is family and floor g is sports then f < g\n\n# Define helper booleans for family and sports presence\nfamily_floors = [car_type[f] == 0 for f in range(3)]\nsports_floors = [car_type[f] == 1 for f in range(3)]\n\nfamily_exists = Or(family_floors)\nsports_exists = Or(sports_floors)\n\n# For all pairs f,g, if floor f is family and floor g is sports then f < g\nfloor_indices = [0,1,2]\nfamily_sports_order = []\nfor f in floor_indices:\n    for g in floor_indices:\n        cond = Implies(And(car_type[f] == 0, car_type[g] == 1), f < g)\n        family_sports_order.append(cond)\n\n# The entire condition:\ncondition1 = Implies(And(family_exists, sports_exists), And(family_sports_order))\nsolver.add(condition1)\n\n# Condition 2: No used research models\n# So no floor has used (1) and research (1) together\nfor f in range(3):\n    solver.add(Not(And(car_condition[f] == 1, car_model[f] == 1)))\n\n# Condition 3: No research models that are sports cars\n# So no floor has sports (1) and research (1) together\nfor f in range(3):\n    solver.add(Not(And(car_type[f] == 1, car_model[f] == 1)))\n\n# Condition 4: New cars on floor 1\nsolver.add(car_condition[0] == 0)\n\n# Condition 5: Used cars on floor 3\nsolver.add(car_condition[2] == 1)\n\n# Additional: On each floor, all cars have the same attribute values (already modeled by single variables per floor)\n\n# Now, the question:\n# \"If all the new cars in the exhibition are research models\"\n# That means: For all floors f, if car_condition[f] == new(0), then car_model[f] == research(1)\n\nall_new_are_research = []\nfor f in range(3):\n    all_new_are_research.append(Implies(car_condition[f] == 0, car_model[f] == 1))\n\nsolver.add(all_new_are_research)\n\n# OPTIONS:\n# (A) All the family cars in the exhibition are new.\n# (B) All the family cars in the exhibition are research models.\n# (C) All the family cars in the exhibition are used.\n# (D) All the new cars in the exhibition are family cars.\n# (E) All the production models in the exhibition are family cars.\n\noptions = {\n    'A': And([Implies(car_type[f] == 0, car_condition[f] == 0) for f in range(3)]),\n    'B': And([Implies(car_type[f] == 0, car_model[f] == 1) for f in range(3)]),\n    'C': And([Implies(car_type[f] == 0, car_condition[f] == 1) for f in range(3)]),\n    'D': And([Implies(car_condition[f] == 0, car_type[f] == 0) for f in range(3)]),\n    'E': And([Implies(car_model[f] == 0, car_type[f] == 0) for f in range(3)]),\n}\n\n# OPTION CHECKING\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add negation of the option to check if it is necessarily true\n    solver.add(Not(options[letter]))\n    if solver.check() == unsat:\n        # Option must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "At an automobile exhibition, cars are displayed on each floor of a three-floor building. On each floor the cars are either all family cars or all sports cars, either all new or all used, and either all production models or all research models. The following conditions apply to this exhibition: If the exhibition includes both family cars and sports cars, then each family car is displayed on a lower numbered floor than any sports car. The exhibition includes no used research models. The exhibition includes no research models that are sports cars. There are new cars on floor 1. There are used cars on floor 3.\n\nIf all the production models in the exhibition are used, then which one of the following statements must be true?\n\nOptions:\n(A) There are family cars on floor 1.\n(B) There are new cars on floor 2.\n(C) There are research models on floor 2.\n(D) There are family cars on floor 3.\n(E) There are sports cars on floor 3.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfloors = [1, 2, 3]\n\n# Enumerations as indices\ncar_types = ['family', 'sports']         # 0: family, 1: sports\nconditions = ['new', 'used']             # 0: new, 1: used\nmodels = ['production', 'research']      # 0: production, 1: research\n\n# Variables for each floor\ncar_type = {f: Int(f'car_type_{f}') for f in floors}       # 0 or 1\ncondition = {f: Int(f'condition_{f}') for f in floors}     # 0 or 1\nmodel = {f: Int(f'model_{f}') for f in floors}             # 0 or 1\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each floor's variables domain\nfor f in floors:\n    solver.add(And(car_type[f] >= 0, car_type[f] < 2))\n    solver.add(And(condition[f] >= 0, condition[f] < 2))\n    solver.add(And(model[f] >= 0, model[f] < 2))\n\n# 1) If the exhibition includes both family cars and sports cars,\n# then each family car is displayed on a lower numbered floor than any sports car.\n# This means: if family and sports both appear on some floors,\n# then for every floor with family cars and every floor with sports cars,\n# family floor < sports floor.\n# We encode this as a constraint over floors:\n# If there exists a floor with family and a floor with sports,\n# then for all family floors f and sports floors s, f < s.\n\n# To encode this, we use Bool variables indicating presence of family and sports cars on floors.\nfamily_floors = [car_type[f] == 0 for f in floors]  # family == 0\nsports_floors = [car_type[f] == 1 for f in floors]  # sports == 1\n\nfamily_exists = Or(family_floors)\nsports_exists = Or(sports_floors)\n\n# For all floors f and s:\n# If car_type[f] == family and car_type[s] == sports then f < s\n# We encode the contrapositive:\n# Not (car_type[f] == family and car_type[s] == sports and f >= s)\n# Which is equivalent to:\n# For all f,s: Not(car_type[f]==family and car_type[s]==sports and f>=s)\n# Or equivalently:\n# For all f,s: car_type[f] != family or car_type[s] != sports or f < s\n\n# We only apply this if family_exists and sports_exists\n\nfamily_sports_floor_order_constraints = []\nfor f in floors:\n    for s in floors:\n        cond = Or(car_type[f] != 0, car_type[s] != 1, f < s)\n        family_sports_floor_order_constraints.append(cond)\n\nsolver.add(Implies(And(family_exists, sports_exists), And(family_sports_floor_order_constraints)))\n\n# 2) The exhibition includes no used research models.\n# So no floor can be both used and research.\nfor f in floors:\n    solver.add(Not(And(condition[f] == 1, model[f] == 1)))\n\n# 3) The exhibition includes no research models that are sports cars.\n# So no floor can be both research and sports.\nfor f in floors:\n    solver.add(Not(And(model[f] == 1, car_type[f] == 1)))\n\n# 4) There are new cars on floor 1.\nsolver.add(condition[1] == 0)\n\n# 5) There are used cars on floor 3.\nsolver.add(condition[3] == 1)\n\n# OPTION CHECKING\n\noptions = [\n    ('A', car_type[1] == 0),  # family cars on floor 1\n    ('B', condition[2] == 0), # new cars on floor 2\n    ('C', model[2] == 1),     # research models on floor 2\n    ('D', car_type[3] == 0),  # family cars on floor 3\n    ('E', car_type[3] == 1)   # sports cars on floor 3\n]\n\n# Additional assumption for this question:\n# If all the production models in the exhibition are used,\n# then which statement must be true?\n\n# We encode \"all production models are used\":\n# For all floors f, if model[f] == production (0), then condition[f] == used (1)\nall_production_used = []\nfor f in floors:\n    all_production_used.append(Implies(model[f] == 0, condition[f] == 1))\nsolver.add(And(all_production_used))\n\n# We want to find which option must be true under these constraints.\n# So for each option, check if the negation is satisfiable.\n# If negation is unsat, then the option must be true.\n\nfor letter, opt_constraint in options:\n    solver.push()\n    solver.add(Not(opt_constraint))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Planes 1, 2, 3, and 4—and no others—are available to fly in an air show. Pilots Anna, Bob, and Cindy are all aboard planes that are flying in the show and they are the only qualified pilots in the show. Copilots Dave, Ed, and Fran are all aboard planes that are flying in the show and they are the only qualified copilots in the show. No plane flies in the show without a qualified pilot aboard. No one but qualified pilots and qualified copilots flies in the show. Anna will only fly in either plane 1 or plane 4. Dave will only fly in either plane 2 or plane 3.\n\nIf Bob and Anna fly on the same plane, which one of the following must be true?\n\nOptions:\n(A) Cindy flies with Dave and Ed.\n(B) Cindy flies with Ed.\n(C) Dave flies with Cindy.\n(D) Dave flies with Cindy, Ed, and Fran.\n(E) Fran flies with Ed.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nplanes = [1, 2, 3, 4]\n\npilots = ['Anna', 'Bob', 'Cindy']\ncopilots = ['Dave', 'Ed', 'Fran']\n\n# Create Z3 Int variables for pilot planes and copilot planes\npilot_plane = {p: Int(p) for p in pilots}\ncopilot_plane = {c: Int(c) for c in copilots}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each pilot flies exactly one plane from the available planes\nfor p in pilots:\n    solver.add(And(pilot_plane[p] >= 1, pilot_plane[p] <= 4))\n\n# Each copilot flies exactly one plane from the available planes\nfor c in copilots:\n    solver.add(And(copilot_plane[c] >= 1, copilot_plane[c] <= 4))\n\n# No plane flies without a qualified pilot aboard\n# So every plane that has a copilot must have a pilot\n# That means the set of planes with copilots is a subset of planes with pilots\n# In other words, for each copilot's plane, there exists a pilot flying that plane\n\n# We'll enforce this by ensuring for each copilot c, copilot_plane[c] == pilot_plane[p] for some p\n# We'll do this by adding an Or constraint for each copilot over pilots\nfor c in copilots:\n    pilot_matches = [copilot_plane[c] == pilot_plane[p] for p in pilots]\n    solver.add(Or(pilot_matches))\n\n# No one but qualified pilots and copilots flies in the show - already modeled by only these variables\n\n# Anna will only fly in either plane 1 or plane 4\nsolver.add(Or(pilot_plane['Anna'] == 1, pilot_plane['Anna'] == 4))\n\n# Dave will only fly in either plane 2 or plane 3\nsolver.add(Or(copilot_plane['Dave'] == 2, copilot_plane['Dave'] == 3))\n\n# All pilots fly on distinct planes (since only 4 planes and 3 pilots, no two pilots can share a plane?)\n# The problem does not say pilots must be on distinct planes, and in fact Bob and Anna can share a plane.\n# So pilots can share planes.\n\n# Similarly, copilots can share planes? The problem does not say otherwise.\n# But since only 4 planes and 6 people (3 pilots + 3 copilots), some planes must have multiple people.\n\n# No one but qualified pilots and copilots flies in the show - no other people variables needed.\n\n# OPTION CHECKING\n\noptions = {\n    'A': And(pilot_plane['Cindy'] == copilot_plane['Dave'], pilot_plane['Cindy'] == copilot_plane['Ed']),\n    'B': pilot_plane['Cindy'] == copilot_plane['Ed'],\n    'C': pilot_plane['Cindy'] == copilot_plane['Dave'],\n    'D': And(pilot_plane['Cindy'] == copilot_plane['Dave'], pilot_plane['Cindy'] == copilot_plane['Ed'], pilot_plane['Cindy'] == copilot_plane['Fran']),\n    'E': copilot_plane['Fran'] == copilot_plane['Ed']\n}\n\n# Add condition: Bob and Anna fly on the same plane\nsolver.add(pilot_plane['Bob'] == pilot_plane['Anna'])\n\n# Check each option\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(Not(options[letter]))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Planes 1, 2, 3, and 4—and no others—are available to fly in an air show. Pilots Anna, Bob, and Cindy are all aboard planes that are flying in the show and they are the only qualified pilots in the show. Copilots Dave, Ed, and Fran are all aboard planes that are flying in the show and they are the only qualified copilots in the show. No plane flies in the show without a qualified pilot aboard. No one but qualified pilots and qualified copilots flies in the show. Anna will only fly in either plane 1 or plane 4. Dave will only fly in either plane 2 or plane 3.\n\nIf Cindy and Fran are the only people in one of the planes, which one of the following must be true?\n\nOptions:\n(A) Bob flies with Anna.\n(B) Dave flies with Ed.\n(C) Dave and Ed fly with Bob.\n(D) Dave flies with Bob.\n(E) Ed flies with Anna.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nplanes = [1, 2, 3, 4]\npilots = ['Anna', 'Bob', 'Cindy']\ncopilots = ['Dave', 'Ed', 'Fran']\n\n# Create Z3 Int variables for pilot assignments: pilot -> plane\npilot_plane = {p: Int(p) for p in pilots}\n# Create Z3 Int variables for copilot assignments: copilot -> plane\ncopilot_plane = {c: Int(c) for c in copilots}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each pilot flies exactly one plane and plane number is valid\nfor p in pilots:\n    solver.add(And(pilot_plane[p] >= 1, pilot_plane[p] <= 4))\n\n# 2. Each copilot flies exactly one plane and plane number is valid\nfor c in copilots:\n    solver.add(And(copilot_plane[c] >= 1, copilot_plane[c] <= 4))\n\n# 3. No plane flies without a qualified pilot aboard\n# => Every plane that has a copilot also has a pilot\n# So for all planes, if a copilot is there, a pilot must be there\n\n# We will model the planes that have pilots and copilots by sets:\n# For each plane, check if a pilot assigned to it\n# For each plane, check if a copilot assigned to it\n# Then if copilot assigned to plane p => pilot assigned to plane p\n\nfor plane in planes:\n    pilot_on_plane = Or([pilot_plane[p] == plane for p in pilots])\n    for c in copilots:\n        solver.add(Implies(copilot_plane[c] == plane, pilot_on_plane))\n\n# 4. No one but qualified pilots and copilots flies in the show\n# => Only these 6 people are flying, so no other constraints needed here.\n\n# 5. Anna will only fly in either plane 1 or plane 4\nsolver.add(Or(pilot_plane['Anna'] == 1, pilot_plane['Anna'] == 4))\n\n# 6. Dave will only fly in either plane 2 or plane 3\nsolver.add(Or(copilot_plane['Dave'] == 2, copilot_plane['Dave'] == 3))\n\n# 7. Cindy and Fran are the only people in one of the planes\n# Means there is a plane p such that pilot_plane['Cindy'] == p and copilot_plane['Fran'] == p\n# and no other pilot or copilot is assigned to p\n\n# Let's create a variable for that plane:\nplane_cindy_fran = Int('plane_cindy_fran')\nsolver.add(And(plane_cindy_fran >= 1, plane_cindy_fran <= 4))\n\nsolver.add(pilot_plane['Cindy'] == plane_cindy_fran)\nsolver.add(copilot_plane['Fran'] == plane_cindy_fran)\n\n# No other pilot assigned to that plane:\nother_pilots = [p for p in pilots if p != 'Cindy']\nfor p in other_pilots:\n    solver.add(pilot_plane[p] != plane_cindy_fran)\n\n# No other copilot assigned to that plane:\nother_copilots = [c for c in copilots if c != 'Fran']\nfor c in other_copilots:\n    solver.add(copilot_plane[c] != plane_cindy_fran)\n\n# OPTION CHECKING\n\noptions = {\n    'A': pilot_plane['Bob'] == pilot_plane['Anna'],               # Bob flies with Anna\n    'B': And(copilot_plane['Dave'] == copilot_plane['Ed']),      # Dave flies with Ed\n    'C': And(copilot_plane['Dave'] == pilot_plane['Bob'],\n             copilot_plane['Ed'] == pilot_plane['Bob']),         # Dave and Ed fly with Bob\n    'D': copilot_plane['Dave'] == pilot_plane['Bob'],            # Dave flies with Bob\n    'E': copilot_plane['Ed'] == pilot_plane['Anna']              # Ed flies with Anna\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    # Add negation of condition to check if condition must be true\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Planes 1, 2, 3, and 4—and no others—are available to fly in an air show. Pilots Anna, Bob, and Cindy are all aboard planes that are flying in the show and they are the only qualified pilots in the show. Copilots Dave, Ed, and Fran are all aboard planes that are flying in the show and they are the only qualified copilots in the show. No plane flies in the show without a qualified pilot aboard. No one but qualified pilots and qualified copilots flies in the show. Anna will only fly in either plane 1 or plane 4. Dave will only fly in either plane 2 or plane 3.\n\nIf plane 1 is used, its crew could consist of\n\nOptions:\n(A) Anna, Bob, Cindy, Fran\n(B) Anna, Bob, Ed, Fran\n(C) Bob, Cindy, Ed, Fran\n(D) Bob, Cindy, Dave, Ed\n(E) Bob, Dave, Ed, Fran",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nplanes = [1, 2, 3, 4]\npilots = ['Anna', 'Bob', 'Cindy']\ncopilots = ['Dave', 'Ed', 'Fran']\n\n# Create variables for which plane each pilot is on (0 means not flying)\npilot_plane = {p: Int(p) for p in pilots}\ncopilot_plane = {c: Int(c) for c in copilots}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Pilots and copilots must be on planes 1-4 or 0 if not flying\nfor p in pilots:\n    solver.add(Or([pilot_plane[p] == pl for pl in planes]))\nfor c in copilots:\n    solver.add(Or([copilot_plane[c] == pl for pl in planes]))\n\n# Only these pilots and copilots fly (all must be assigned a plane)\n# Since only these pilots and copilots fly, all must be assigned to some plane 1-4\nfor p in pilots:\n    solver.add(And(pilot_plane[p] >= 1, pilot_plane[p] <= 4))\nfor c in copilots:\n    solver.add(And(copilot_plane[c] >= 1, copilot_plane[c] <= 4))\n\n# No plane flies without a qualified pilot aboard\n# For each plane, if it is used, it must have at least one pilot assigned\nfor pl in planes:\n    pilots_on_plane = [pilot_plane[p] == pl for p in pilots]\n    # plane used if any pilot assigned to it\n    # So if any copilot is assigned to that plane, then at least one pilot must be assigned\n    copilots_on_plane = [copilot_plane[c] == pl for c in copilots]\n    # If any copilot on plane, then Or pilots_on_plane must be true\n    # This is equivalent to: For all planes, if any copilot on plane, then at least one pilot on plane\n    solver.add(Implies(Or(copilots_on_plane), Or(pilots_on_plane)))\n\n# No one but qualified pilots and copilots flies in the show\n# This is already ensured by only having these pilots and copilots assigned to planes\n\n# Anna will only fly in either plane 1 or plane 4\nsolver.add(Or(pilot_plane['Anna'] == 1, pilot_plane['Anna'] == 4))\n\n# Dave will only fly in either plane 2 or plane 3\nsolver.add(Or(copilot_plane['Dave'] == 2, copilot_plane['Dave'] == 3))\n\n# Each pilot assigned to exactly one plane\n# Already ensured by variable domain and constraints above\n\n# Each copilot assigned to exactly one plane\n# Already ensured by variable domain and constraints above\n\n# Each plane can have multiple pilots and copilots, no explicit limit\n\n# OPTION CHECKING\noptions = [\n    # (Pilots, Copilots)\n    (['Anna', 'Bob', 'Cindy'], ['Fran']),        # A\n    (['Anna', 'Bob'], ['Ed', 'Fran']),           # B\n    (['Bob', 'Cindy'], ['Ed', 'Fran']),          # C\n    (['Bob', 'Cindy'], ['Dave', 'Ed']),          # D\n    (['Bob'], ['Dave', 'Ed', 'Fran'])             # E\n]\n\nfor i, (opt_pilots, opt_copilots) in enumerate(options):\n    solver.push()\n    # Plane 1 is used in this option with listed crew\n    # All listed pilots and copilots must be on plane 1\n    for p in opt_pilots:\n        solver.add(pilot_plane[p] == 1)\n    for c in opt_copilots:\n        solver.add(copilot_plane[c] == 1)\n    # No other pilots or copilots on plane 1\n    other_pilots = [p for p in pilots if p not in opt_pilots]\n    other_copilots = [c for c in copilots if c not in opt_copilots]\n    for p in other_pilots:\n        solver.add(pilot_plane[p] != 1)\n    for c in other_copilots:\n        solver.add(copilot_plane[c] != 1)\n    # Check if solution is possible\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Planes 1, 2, 3, and 4—and no others—are available to fly in an air show. Pilots Anna, Bob, and Cindy are all aboard planes that are flying in the show and they are the only qualified pilots in the show. Copilots Dave, Ed, and Fran are all aboard planes that are flying in the show and they are the only qualified copilots in the show. No plane flies in the show without a qualified pilot aboard. No one but qualified pilots and qualified copilots flies in the show. Anna will only fly in either plane 1 or plane 4. Dave will only fly in either plane 2 or plane 3.\n\nIf as many of the pilots and copilots as possible fly in plane 4, that group will consist of\n\nOptions:\n(A) exactly two people\n(B) exactly three people\n(C) exactly four people\n(D) exactly five people\n(E) three pilots and two copilots",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nplanes = [1, 2, 3, 4]\n\npilots = ['Anna', 'Bob', 'Cindy']\ncopilots = ['Dave', 'Ed', 'Fran']\n\n# Create Int variables for pilots and copilots representing their plane assignments\npilot_plane = {p: Int(p) for p in pilots}\ncopilot_plane = {c: Int(c) for c in copilots}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Pilots and copilots must be assigned to one of the four planes\nfor p in pilots:\n    solver.add(And(pilot_plane[p] >= 1, pilot_plane[p] <= 4))\nfor c in copilots:\n    solver.add(And(copilot_plane[c] >= 1, copilot_plane[c] <= 4))\n\n# No plane flies without a qualified pilot aboard\n# So every plane that has anyone flying must have at least one pilot\n# Since only 4 planes, we consider each plane: if any pilot or copilot assigned to that plane,\n# then at least one pilot assigned to that plane\n\nfor plane in planes:\n    # Is there any pilot in this plane?\n    pilot_in_plane = Or([pilot_plane[p] == plane for p in pilots])\n    # Is there any person (pilot or copilot) in this plane?\n    person_in_plane = Or([pilot_plane[p] == plane for p in pilots] + [copilot_plane[c] == plane for c in copilots])\n    # If there is any person in the plane, then pilot_in_plane must be true\n    solver.add(Implies(person_in_plane, pilot_in_plane))\n\n# Only qualified pilots and copilots fly in the show (already modeled by variables)\n\n# Anna will only fly in either plane 1 or plane 4\nsolver.add(Or(pilot_plane['Anna'] == 1, pilot_plane['Anna'] == 4))\n\n# Dave will only fly in either plane 2 or plane 3\nsolver.add(Or(copilot_plane['Dave'] == 2, copilot_plane['Dave'] == 3))\n\n# All pilots and copilots are aboard planes that are flying (all assigned to planes 1-4)\n# Already ensured by domain constraints above\n\n# No other pilots or copilots exist (only these six people)\n\n# Maximum number of pilots and copilots in plane 4\n# We want to maximize the number of people in plane 4\n\n# Define variables for counts in plane 4\nis_in_plane4 = {}\n\nfor p in pilots:\n    is_in_plane4[p] = If(pilot_plane[p] == 4, 1, 0)\nfor c in copilots:\n    is_in_plane4[c] = If(copilot_plane[c] == 4, 1, 0)\n\ntotal_in_plane4 = Sum([is_in_plane4[p] for p in pilots] + [is_in_plane4[c] for c in copilots])\n\n# OPTION CHECKING\n\n# Options:\n# (A) exactly two people\n# (B) exactly three people\n# (C) exactly four people\n# (D) exactly five people\n# (E) three pilots and two copilots\n\noptions = []\n\n# (A) exactly two people in plane 4\noptions.append(total_in_plane4 == 2)\n\n# (B) exactly three people in plane 4\noptions.append(total_in_plane4 == 3)\n\n# (C) exactly four people in plane 4\noptions.append(total_in_plane4 == 4)\n\n# (D) exactly five people in plane 4\noptions.append(total_in_plane4 == 5)\n\n# (E) three pilots and two copilots in plane 4\nnum_pilots_in_plane4 = Sum([If(pilot_plane[p] == 4, 1, 0) for p in pilots])\nnum_copilots_in_plane4 = Sum([If(copilot_plane[c] == 4, 1, 0) for c in copilots])\noptions.append(And(num_pilots_in_plane4 == 3, num_copilots_in_plane4 == 2))\n\n# We want to find the maximum number of people in plane 4 that is possible.\n# So first find the maximum number possible.\n\nmax_people = -1\nmax_people_val = None\n\nfor n in range(6, -1, -1):  # max possible is 6 people total\n    solver.push()\n    solver.add(total_in_plane4 == n)\n    if solver.check() == sat:\n        max_people = n\n        max_people_val = solver.model()\n        solver.pop()\n        break\n    solver.pop()\n\n# Now check which option matches the maximum number of people in plane 4\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add option constraint\n    solver.add(option)\n    # Add constraint that total_in_plane4 == max_people\n    solver.add(total_in_plane4 == max_people)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A law firm has exactly nine partners: Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, and Nassar. Kohn's salary is greater than both Inman's and Lopez's. Lopez's salary is greater than Nassar's. Inman's salary is greater than Fox's. Fox's salary is greater than Malloy's. Malloy's salary is greater than Glassen's. Glassen's salary is greater than Jacoby's. Jacoby's salary is greater than Hae's.\n\nWhich one of the following partners cannot have the third highest salary?\n\nOptions:\n(A) Fox\n(B) Inman\n(C) Lopez\n(D) Malloy\n(E) Nassar",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npartners = ['Fox', 'Glassen', 'Hae', 'Inman', 'Jacoby', 'Kohn', 'Lopez', 'Malloy', 'Nassar']\npartner_indices = {p: i for i, p in enumerate(partners)}\n\n# Create Int variables representing the rank of each partner's salary (1 = highest, 9 = lowest)\n# So lower number means higher salary\nsalary_rank = {p: Int(p) for p in partners}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each partner's rank must be between 1 and 9\nfor p in partners:\n    solver.add(And(salary_rank[p] >= 1, salary_rank[p] <= 9))\n\n# All ranks must be distinct\nsolver.add(Distinct([salary_rank[p] for p in partners]))\n\n# Kohn's salary is greater than both Inman's and Lopez's\n# means Kohn's rank < Inman's rank and Kohn's rank < Lopez's rank\nsolver.add(salary_rank['Kohn'] < salary_rank['Inman'])\nsolver.add(salary_rank['Kohn'] < salary_rank['Lopez'])\n\n# Lopez's salary is greater than Nassar's\nsolver.add(salary_rank['Lopez'] < salary_rank['Nassar'])\n\n# Inman's salary is greater than Fox's\nsolver.add(salary_rank['Inman'] < salary_rank['Fox'])\n\n# Fox's salary is greater than Malloy's\nsolver.add(salary_rank['Fox'] < salary_rank['Malloy'])\n\n# Malloy's salary is greater than Glassen's\nsolver.add(salary_rank['Malloy'] < salary_rank['Glassen'])\n\n# Glassen's salary is greater than Jacoby's\nsolver.add(salary_rank['Glassen'] < salary_rank['Jacoby'])\n\n# Jacoby's salary is greater than Hae's\nsolver.add(salary_rank['Jacoby'] < salary_rank['Hae'])\n\n# OPTION CHECKING\noptions = ['Fox', 'Inman', 'Lopez', 'Malloy', 'Nassar']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that this partner has the third highest salary rank = 3\n    solver.add(salary_rank[opt] == 3)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        # If unsat, this partner cannot have the third highest salary\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A law firm has exactly nine partners: Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, and Nassar. Kohn's salary is greater than both Inman's and Lopez's. Lopez's salary is greater than Nassar's. Inman's salary is greater than Fox's. Fox's salary is greater than Malloy's. Malloy's salary is greater than Glassen's. Glassen's salary is greater than Jacoby's. Jacoby's salary is greater than Hae's.\n\nThe salary rankings of each of the nine partners could be completely determined if which one of the following statements were true?\n\nOptions:\n(A) Lopez's salary is greater than Fox's.\n(B) Lopez's salary is greater than Inman's.\n(C) Nassar's salary is greater than Fox's.\n(D) Nassar's salary is greater than Inman's.\n(E) Nassar's salary is greater than Malloy's.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npartners = ['Fox', 'Glassen', 'Hae', 'Inman', 'Jacoby', 'Kohn', 'Lopez', 'Malloy', 'Nassar']\nnum_partners = len(partners)\n\n# Create a dictionary to hold the salary rank of each partner (0 highest, 8 lowest)\nsalary = {p: Int(p) for p in partners}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each partner's salary rank is between 0 and 8\nfor p in partners:\n    solver.add(And(salary[p] >= 0, salary[p] < num_partners))\n\n# All salary ranks are distinct\nsolver.add(Distinct([salary[p] for p in partners]))\n\n# Given inequalities:\n# Kohn's salary > Inman's and Lopez's\nsolver.add(salary['Kohn'] < salary['Inman'])\nsolver.add(salary['Kohn'] < salary['Lopez'])\n\n# Lopez's salary > Nassar's\nsolver.add(salary['Lopez'] < salary['Nassar'])\n\n# Inman's salary > Fox's\nsolver.add(salary['Inman'] < salary['Fox'])\n\n# Fox's salary > Malloy's\nsolver.add(salary['Fox'] < salary['Malloy'])\n\n# Malloy's salary > Glassen's\nsolver.add(salary['Malloy'] < salary['Glassen'])\n\n# Glassen's salary > Jacoby's\nsolver.add(salary['Glassen'] < salary['Jacoby'])\n\n# Jacoby's salary > Hae's\nsolver.add(salary['Jacoby'] < salary['Hae'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': salary['Lopez'] < salary['Fox'],     # Lopez > Fox\n    'B': salary['Lopez'] < salary['Inman'],   # Lopez > Inman\n    'C': salary['Nassar'] < salary['Fox'],    # Nassar > Fox\n    'D': salary['Nassar'] < salary['Inman'],  # Nassar > Inman\n    'E': salary['Nassar'] < salary['Malloy']  # Nassar > Malloy\n}\n\n# Function to check if salary rankings are completely determined:\n# That means there is exactly one solution that satisfies all constraints including the option.\ndef is_unique_solution(slv, variables):\n    if slv.check() != sat:\n        return False\n    m = slv.model()\n    # Add constraint to block this solution\n    block = []\n    for v in variables:\n        block.append(v != m[v])\n    slv.push()\n    slv.add(Or(block))\n    res = slv.check()\n    slv.pop()\n    return res == unsat\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[opt])\n    # Check if there is a solution\n    if solver.check() == sat:\n        # Check if solution is unique\n        unique = is_unique_solution(solver, [salary[p] for p in partners])\n        if unique:\n            print(f\"'{opt}'\")\n            solver.pop()\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A law firm has exactly nine partners: Fox, Glassen, Hae, Inman, Jacoby, Kohn, Lopez, Malloy, and Nassar. Kohn's salary is greater than both Inman's and Lopez's. Lopez's salary is greater than Nassar's. Inman's salary is greater than Fox's. Fox's salary is greater than Malloy's. Malloy's salary is greater than Glassen's. Glassen's salary is greater than Jacoby's. Jacoby's salary is greater than Hae's.\n\nIf Nassar's salary is the same as that of one other partner of the firm, which one of the following must be false?\n\nOptions:\n(A) Inman's salary is less than Lopez's.\n(B) Jacoby's salary is less than Lopez's.\n(C) Lopez's salary is less than Fox's.\n(D) Lopez's salary is less than Hae's.\n(E) Nassar's salary is less than Glassen's.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npartners = ['Fox', 'Glassen', 'Hae', 'Inman', 'Jacoby', 'Kohn', 'Lopez', 'Malloy', 'Nassar']\npartner_vars = {p: Int(p) for p in partners}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Salaries are integers (domain can be arbitrary large; just distinctness is important)\n# No explicit domain needed, but to avoid trivial solutions, we can restrict salaries between 1 and 100\nfor p in partners:\n    solver.add(And(partner_vars[p] >= 1, partner_vars[p] <= 100))\n\n# Kohn's salary is greater than both Inman's and Lopez's\nsolver.add(partner_vars['Kohn'] > partner_vars['Inman'])\nsolver.add(partner_vars['Kohn'] > partner_vars['Lopez'])\n\n# Lopez's salary is greater than Nassar's\nsolver.add(partner_vars['Lopez'] > partner_vars['Nassar'])\n\n# Inman's salary is greater than Fox's\nsolver.add(partner_vars['Inman'] > partner_vars['Fox'])\n\n# Fox's salary is greater than Malloy's\nsolver.add(partner_vars['Fox'] > partner_vars['Malloy'])\n\n# Malloy's salary is greater than Glassen's\nsolver.add(partner_vars['Malloy'] > partner_vars['Glassen'])\n\n# Glassen's salary is greater than Jacoby's\nsolver.add(partner_vars['Glassen'] > partner_vars['Jacoby'])\n\n# Jacoby's salary is greater than Hae's\nsolver.add(partner_vars['Jacoby'] > partner_vars['Hae'])\n\n# Nassar's salary is the same as that of one other partner of the firm\n# So there exists exactly one other partner (not Nassar) with the same salary as Nassar\nsame_salary_others = [partner_vars[p] == partner_vars['Nassar'] for p in partners if p != 'Nassar']\n# Exactly one partner other than Nassar has same salary as Nassar\n# So sum of these equalities is exactly 1\nsolver.add(Sum([If(cond, 1, 0) for cond in same_salary_others]) == 1)\n\n# OPTION CHECKING\n# Each option will be tested by adding its negation and checking satisfiability\n# If negation is unsat, then option must be true, so option cannot be false\n# If negation is sat, then option can be false, so option is not necessarily false\n# We want to find which option must be false, i.e., which option's negation is unsat\n\noptions = [\n    ('A', partner_vars['Inman'] < partner_vars['Lopez']),\n    ('B', partner_vars['Jacoby'] < partner_vars['Lopez']),\n    ('C', partner_vars['Lopez'] < partner_vars['Fox']),\n    ('D', partner_vars['Lopez'] < partner_vars['Hae']),\n    ('E', partner_vars['Nassar'] < partner_vars['Glassen']),\n]\n\nfor letter, cond in options:\n    solver.push()\n    # Add negation of the option condition to check if option can be false\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        # Negation is unsat, so option must be true and cannot be false\n        solver.pop()\n        continue\n    else:\n        # Negation is sat, so option can be false\n        # But we want the option that must be false, so this is a candidate\n        # However, we want the option that must be false, i.e. option itself is false in all models\n        # So option's negation is sat means option can be false, so option is not necessarily false\n        # So continue checking\n        solver.pop()\n        # Actually, we want the option that must be false, so the negation is always true (sat)\n        # So if negation is sat, option can be false, so option is not necessarily false\n        # If negation is unsat, option must be true, so option cannot be false\n        # This means we want option whose negation is sat always, so option can be false\n        # But question asks which must be false, so option must be false in all models\n        # So option is false in all models means option is unsat in all models\n        # So we test option itself for satisfiability with all constraints\n        # If option is unsat, then must be false\n        solver.push()\n        solver.add(cond)\n        if solver.check() == unsat:\n            # option must be false\n            print(f\"'{letter}'\")\n            solver.pop()\n            break\n        solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of five illnesses—J, K, L, M, and N—is characterized by at least one of the following three symptoms: fever, headache, and sneezing. None of the illnesses has any symptom that is not one of these three. Illness J is characterized by headache and sneezing. Illnesses J and K have no symptoms in common. Illnesses J and L have at least one symptom in common. Illness L has a greater number of symptoms than illness K. Illnesses L and N have no symptoms in common. Illness M has more symptoms than illness J.\n\nWhich one of the following statements must be false?\n\nOptions:\n(A) Illness J has exactly two symptoms.\n(B) Illness K has exactly one symptom.\n(C) Illness L has exactly two symptoms.\n(D) Illness M has exactly three symptoms.\n(E) Illness N has exactly two symptoms.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nillnesses = ['J', 'K', 'L', 'M', 'N']\nsymptoms = ['fever', 'headache', 'sneezing']\nnum_symptoms = len(symptoms)\n\n# Map symptoms to indices for easy reference\nfever = 0\nheadache = 1\nsneezing = 2\n\n# Create symptom presence variables: illness_symptom[illness][symptom] = Bool\nillness_symptom = {}\nfor ill in illnesses:\n    illness_symptom[ill] = [Bool(f\"{ill}_{symptoms[i]}\") for i in range(num_symptoms)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each illness has at least one symptom\nfor ill in illnesses:\n    solver.add(Or([illness_symptom[ill][i] for i in range(num_symptoms)]))\n\n# None of the illnesses has any symptom that is not one of the three (already ensured by modeling)\n\n# Illness J is characterized by headache and sneezing.\nsolver.add(illness_symptom['J'][headache] == True)\nsolver.add(illness_symptom['J'][sneezing] == True)\nsolver.add(illness_symptom['J'][fever] == False)\n\n# Illnesses J and K have no symptoms in common.\nfor i in range(num_symptoms):\n    solver.add(Or(illness_symptom['J'][i] == False, illness_symptom['K'][i] == False))\n\n# Illnesses J and L have at least one symptom in common.\ncommon_J_L = [And(illness_symptom['J'][i], illness_symptom['L'][i]) for i in range(num_symptoms)]\nsolver.add(Or(common_J_L))\n\n# Illness L has a greater number of symptoms than illness K.\n# Define functions to count symptoms for L and K\ndef count_symptoms(ill):\n    return Sum([If(illness_symptom[ill][i], 1, 0) for i in range(num_symptoms)])\n\nsolver.add(count_symptoms('L') > count_symptoms('K'))\n\n# Illnesses L and N have no symptoms in common.\nfor i in range(num_symptoms):\n    solver.add(Or(illness_symptom['L'][i] == False, illness_symptom['N'][i] == False))\n\n# Illness M has more symptoms than illness J.\nsolver.add(count_symptoms('M') > count_symptoms('J'))\n\n# OPTION CHECKING\noptions = [\n    ('A', count_symptoms('J') == 2),  # Illness J has exactly two symptoms.\n    ('B', count_symptoms('K') == 1),  # Illness K has exactly one symptom.\n    ('C', count_symptoms('L') == 2),  # Illness L has exactly two symptoms.\n    ('D', count_symptoms('M') == 3),  # Illness M has exactly three symptoms.\n    ('E', count_symptoms('N') == 2),  # Illness N has exactly two symptoms.\n]\n\nfor letter, option_constraint in options:\n    solver.push()\n    # Add the negation of the option to check if the option must be false\n    solver.add(Not(option_constraint))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true, so option cannot be false\n        solver.pop()\n        continue\n    else:\n        # If negation is sat, option can be false, so option does not have to be true, so option is not necessarily true\n        solver.pop()\n        # Now check if option is necessarily false by adding the option and checking unsat\n        solver.push()\n        solver.add(option_constraint)\n        if solver.check() == unsat:\n            # Option must be false\n            print(f\"'{letter}'\")\n            break\n        solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of five illnesses—J, K, L, M, and N—is characterized by at least one of the following three symptoms: fever, headache, and sneezing. None of the illnesses has any symptom that is not one of these three. Illness J is characterized by headache and sneezing. Illnesses J and K have no symptoms in common. Illnesses J and L have at least one symptom in common. Illness L has a greater number of symptoms than illness K. Illnesses L and N have no symptoms in common. Illness M has more symptoms than illness J.\n\nIn which one of the following pairs could the first member of the pair be characterized by exactly the same number and types of symptoms as the second member of the pair?\n\nOptions:\n(A) J and N\n(B) K and L\n(C) K and N\n(D) L and M\n(E) M and N",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nillnesses = ['J', 'K', 'L', 'M', 'N']\nsymptoms = ['fever', 'headache', 'sneezing']\n\n# Create a dictionary of symptom presence variables for each illness\n# symptom_vars[illness][symptom] = Bool variable indicating if illness has symptom\nsymptom_vars = {}\nfor illness in illnesses:\n    symptom_vars[illness] = {}\n    for symptom in symptoms:\n        symptom_vars[illness][symptom] = Bool(f\"{illness}_{symptom}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each illness is characterized by at least one symptom\nfor illness in illnesses:\n    solver.add(Or([symptom_vars[illness][symptom] for symptom in symptoms]))\n\n# None of the illnesses has any symptom that is not one of these three\n# (Already modeled by only these three symptoms per illness)\n\n# Illness J is characterized by headache and sneezing\nsolver.add(symptom_vars['J']['headache'])\nsolver.add(symptom_vars['J']['sneezing'])\n# J may or may not have fever, but based on problem statement \"Illness J is characterized by headache and sneezing\"\n# and \"None of the illnesses has any symptom that is not one of these three.\"\n# It is not explicitly stated if J has fever or not. But \"Illness J is characterized by headache and sneezing\" means at least these two.\n# So J may or may not have fever. The problem does not say J has fever, so we assume J does not have fever.\nsolver.add(Not(symptom_vars['J']['fever']))\n\n# Illnesses J and K have no symptoms in common\nfor symptom in symptoms:\n    # For each symptom, J and K cannot both have it\n    solver.add(Or(Not(symptom_vars['J'][symptom]), Not(symptom_vars['K'][symptom])))\n\n# Illnesses J and L have at least one symptom in common\ncommon_J_L = [And(symptom_vars['J'][symptom], symptom_vars['L'][symptom]) for symptom in symptoms]\nsolver.add(Or(common_J_L))\n\n# Illness L has a greater number of symptoms than illness K\n# Define counts of symptoms for L and K\ndef symptom_count(illness):\n    return Sum([If(symptom_vars[illness][symptom], 1, 0) for symptom in symptoms])\n\ncount_L = symptom_count('L')\ncount_K = symptom_count('K')\nsolver.add(count_L > count_K)\n\n# Illnesses L and N have no symptoms in common\nfor symptom in symptoms:\n    solver.add(Or(Not(symptom_vars['L'][symptom]), Not(symptom_vars['N'][symptom])))\n\n# Illness M has more symptoms than illness J\ncount_M = symptom_count('M')\ncount_J = symptom_count('J')\nsolver.add(count_M > count_J)\n\n# OPTION CHECKING\n# For each option, check if the first illness and the second illness could be characterized by exactly the same number and types of symptoms\n\noptions = [\n    ('J', 'N'),  # A\n    ('K', 'L'),  # B\n    ('K', 'N'),  # C\n    ('L', 'M'),  # D\n    ('M', 'N')   # E\n]\n\nfor i, (ill1, ill2) in enumerate(options):\n    solver.push()\n    # Add constraint that ill1 and ill2 have exactly the same symptoms\n    for symptom in symptoms:\n        solver.add(symptom_vars[ill1][symptom] == symptom_vars[ill2][symptom])\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of five illnesses—J, K, L, M, and N—is characterized by at least one of the following three symptoms: fever, headache, and sneezing. None of the illnesses has any symptom that is not one of these three. Illness J is characterized by headache and sneezing. Illnesses J and K have no symptoms in common. Illnesses J and L have at least one symptom in common. Illness L has a greater number of symptoms than illness K. Illnesses L and N have no symptoms in common. Illness M has more symptoms than illness J.\n\nIf illness L is characterized by a combination of symptoms different from any of the other illnesses, then which one of the following statements must be true?\n\nOptions:\n(A) Fever is a symptom of illness L.\n(B) Sneezing is a symptom of illness L.\n(C) Headache is a symptom of illness L.\n(D) Illnesses K and N are characterized by exactly the same symptoms.\n(E) Illnesses M and N are characterized by exactly the same symptoms.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nillnesses = ['J', 'K', 'L', 'M', 'N']\nsymptoms = ['fever', 'headache', 'sneezing']\nsymptom_idx = {symptoms[i]: i for i in range(len(symptoms))}\n\n# Create variables: For each illness, a Bool vector of length 3 representing presence of each symptom\nsym = {ill: [Bool(f\"{ill}_{s}\") for s in symptoms] for ill in illnesses}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each illness characterized by at least one symptom\nfor ill in illnesses:\n    solver.add(Or([sym[ill][i] for i in range(len(symptoms))]))\n\n# 2) None of the illnesses has any symptom not in {fever, headache, sneezing} - already modeled\n\n# 3) Illness J is characterized by headache and sneezing\nsolver.add(sym['J'][symptom_idx['headache']])\nsolver.add(sym['J'][symptom_idx['sneezing']])\nsolver.add(Not(sym['J'][symptom_idx['fever']]))\n\n# 4) Illnesses J and K have no symptoms in common\nfor i in range(len(symptoms)):\n    solver.add(Or(Not(sym['J'][i]), Not(sym['K'][i])))\n\n# 5) Illnesses J and L have at least one symptom in common\ncommon_JL = [And(sym['J'][i], sym['L'][i]) for i in range(len(symptoms))]\nsolver.add(Or(common_JL))\n\n# 6) Illness L has a greater number of symptoms than illness K\ncount_sym = lambda ill: Sum([If(sym[ill][i], 1, 0) for i in range(len(symptoms))])\nsolver.add(count_sym('L') > count_sym('K'))\n\n# 7) Illnesses L and N have no symptoms in common\nfor i in range(len(symptoms)):\n    solver.add(Or(Not(sym['L'][i]), Not(sym['N'][i])))\n\n# 8) Illness M has more symptoms than illness J\nsolver.add(count_sym('M') > count_sym('J'))\n\n# 9) Illness L is characterized by a combination of symptoms different from any of the other illnesses\n# For each illness other than L, the symptom vectors differ from L's vector\nfor ill in illnesses:\n    if ill == 'L':\n        continue\n    diff = []\n    for i in range(len(symptoms)):\n        diff.append(Xor(sym['L'][i], sym[ill][i]))\n    solver.add(Or(diff))\n\n# OPTION CHECKING\n\noptions = {\n    'A': sym['L'][symptom_idx['fever']],\n    'B': sym['L'][symptom_idx['sneezing']],\n    'C': sym['L'][symptom_idx['headache']],\n    'D': And([sym['K'][i] == sym['N'][i] for i in range(len(symptoms))]),\n    'E': And([sym['M'][i] == sym['N'][i] for i in range(len(symptoms))]),\n}\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add negation of option to check if model still satisfiable\n    solver.add(Not(options[opt]))\n    if solver.check() == unsat:\n        # If unsat, option must be true in all models satisfying constraints\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of five illnesses—J, K, L, M, and N—is characterized by at least one of the following three symptoms: fever, headache, and sneezing. None of the illnesses has any symptom that is not one of these three. Illness J is characterized by headache and sneezing. Illnesses J and K have no symptoms in common. Illnesses J and L have at least one symptom in common. Illness L has a greater number of symptoms than illness K. Illnesses L and N have no symptoms in common. Illness M has more symptoms than illness J.\n\nIf Walter has exactly two of the three symptoms, then he cannot have all of the symptoms of\n\nOptions:\n(A) both illness J and illness L\n(B) both illness J and illness N\n(C) both illness K and illness L\n(D) both illness K and illness N\n(E) both illness L and illness N",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nillnesses = ['J', 'K', 'L', 'M', 'N']\nsymptoms = ['fever', 'headache', 'sneezing']\n\n# Create variables: illness_symptom[illness][symptom] = Bool indicating if illness has symptom\nillness_symptom = {illness: {symptom: Bool(f\"{illness}_{symptom}\") for symptom in symptoms} for illness in illnesses}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Illness J is characterized by headache and sneezing\nsolver.add(illness_symptom['J']['headache'] == True)\nsolver.add(illness_symptom['J']['sneezing'] == True)\n# Since J is characterized by at least these two, and no symptoms other than the three,\n# and each illness has at least one symptom, we only need to ensure fever is False or True.\n# But J is characterized by headache and sneezing, so fever can be true or false.\n# The problem states \"Illness J is characterized by headache and sneezing\" - does that mean only those two or at least those two?\n# The wording \"Illness J is characterized by headache and sneezing\" means J has headache and sneezing, but may or may not have fever.\n# But the problem states \"Each of five illnesses... characterized by at least one of the following three symptoms\" and \"none has any symptom not one of these three\"\n# So fever can be True or False for J. But the problem does not explicitly say J has fever or not.\n# Let's check the other constraints to see if fever for J is constrained.\n# Illness M has more symptoms than illness J, so J must have at least 2 symptoms.\n# J has headache and sneezing (2 symptoms). Fever for J can be False.\nsolver.add(illness_symptom['J']['fever'] == False)\n\n# 2. Illnesses J and K have no symptoms in common\n# For each symptom, not both J and K have it\nfor s in symptoms:\n    solver.add(Or(Not(illness_symptom['J'][s]), Not(illness_symptom['K'][s])))\n\n# 3. Illnesses J and L have at least one symptom in common\ncommon_J_L = [And(illness_symptom['J'][s], illness_symptom['L'][s]) for s in symptoms]\nsolver.add(Or(common_J_L))\n\n# 4. Illness L has a greater number of symptoms than illness K\n# Count symptoms for L and K\ndef symptom_count(illness):\n    return Sum([If(illness_symptom[illness][s], 1, 0) for s in symptoms])\n\nsolver.add(symptom_count('L') > symptom_count('K'))\n\n# 5. Illnesses L and N have no symptoms in common\nfor s in symptoms:\n    solver.add(Or(Not(illness_symptom['L'][s]), Not(illness_symptom['N'][s])))\n\n# 6. Illness M has more symptoms than illness J\nsolver.add(symptom_count('M') > symptom_count('J'))\n\n# 7. Each illness has at least one symptom\nfor ill in illnesses:\n    solver.add(Or([illness_symptom[ill][s] for s in symptoms]))\n\n# 8. Each illness symptoms are only from the three symptoms (already ensured by variable domain)\n\n# OPTION CHECKING\n# Walter has exactly two of the three symptoms.\n# We want to find which option is impossible if Walter has exactly two symptoms,\n# meaning Walter cannot have all symptoms of both illnesses in that option.\n\noptions = {\n    'A': ('J', 'L'),\n    'B': ('J', 'N'),\n    'C': ('K', 'L'),\n    'D': ('K', 'N'),\n    'E': ('L', 'N'),\n}\n\n# For each option, check if Walter can have exactly two symptoms and have all symptoms of both illnesses\nfor opt_letter, (ill1, ill2) in options.items():\n    solver.push()\n    # Walter has exactly two symptoms\n    # Represent Walter's symptoms as Bool variables\n    Walter_symptoms = {s: Bool(f\"W_{s}\") for s in symptoms}\n    solver.add(Sum([If(Walter_symptoms[s], 1, 0) for s in symptoms]) == 2)\n\n    # Walter has all symptoms of illness 1 and illness 2\n    # That means for each symptom s, if illness has symptom s, Walter must have symptom s\n    for s in symptoms:\n        solver.add(Implies(illness_symptom[ill1][s], Walter_symptoms[s]))\n        solver.add(Implies(illness_symptom[ill2][s], Walter_symptoms[s]))\n\n    if solver.check() == sat:\n        solver.pop()\n        continue\n    else:\n        print(f\"'{opt_letter}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A street cleaning crew works only Monday to Friday, and only during the day. It takes the crew an entire morning or an entire afternoon to clean a street. During one week the crew cleaned exactly eight streets—First, Second, Third, Fourth, Fifth, Sixth, Seventh, and Eighth streets. The following is known about the crew's schedule for the week: The crew cleaned no street on Friday morning. The crew cleaned no street on Wednesday afternoon. It cleaned Fourth Street on Tuesday morning. It cleaned Seventh Street on Thursday morning. It cleaned Fourth Street before Sixth Street and after Eighth Street. It cleaned Second, Fifth, and Eighth streets on afternoons.\n\nIf the crew cleaned Second Street earlier in the week than Seventh Street, then it must have cleaned which one of the following streets on Tuesday afternoon?\n\nOptions:\n(A) First Street\n(B) Second Street\n(C) Third Street\n(D) Fifth Street\n(E) Eighth Street",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\ntimes = ['Morning', 'Afternoon']\nstreets = ['First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth']\n\n# Create a mapping from street to a variable representing the slot (0 to 9)\n# Slots: 0 - Monday Morning, 1 - Monday Afternoon, ..., 8 - Friday Morning, 9 - Friday Afternoon\nslots_count = len(days) * len(times)  # 10 slots\n\nstreet_slot = {}\nfor street in streets:\n    street_slot[street] = Int(street)\n\n# Helper functions to convert slot to day and time\ndef slot_day(slot):\n    return slot // 2  # integer division\n\ndef slot_time(slot):\n    return slot % 2  # 0 for morning, 1 for afternoon\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each street is assigned a slot from 0 to 9\nfor street in streets:\n    solver.add(And(street_slot[street] >= 0, street_slot[street] < slots_count))\n\n# No street cleaned on Friday morning (slot 8)\nfor street in streets:\n    solver.add(street_slot[street] != 8)\n\n# No street cleaned on Wednesday afternoon (slot 5)\nfor street in streets:\n    solver.add(street_slot[street] != 5)\n\n# Fourth Street on Tuesday morning\n# Tuesday morning slot is Monday=0, Tuesday=2*1=2, so slot = 2*1 + 0 = 2*1 + 0 = 2*1 + 0 = 2*1 + 0 = 2\n# Actually days index: Monday=0, Tuesday=1, Wednesday=2, Thursday=3, Friday=4\n# So Tuesday morning slot = day=1 * 2 + morning=0 = 2\nsolver.add(street_slot['Fourth'] == 2)\n\n# Seventh Street on Thursday morning\n# Thursday morning slot = day=3 * 2 + 0 = 6\nsolver.add(street_slot['Seventh'] == 6)\n\n# Fourth Street before Sixth Street and after Eighth Street\nsolver.add(street_slot['Eighth'] < street_slot['Fourth'])\nsolver.add(street_slot['Fourth'] < street_slot['Sixth'])\n\n# Second, Fifth, and Eighth streets on afternoons\n# Afternoon slots are odd numbers: 1,3,5,7,9\nfor s in ['Second', 'Fifth', 'Eighth']:\n    solver.add(slot_time(street_slot[s]) == 1)\n\n# All streets assigned distinct slots\nsolver.add(Distinct([street_slot[s] for s in streets]))\n\n# OPTION CHECKING\n# The condition: If Second Street cleaned earlier than Seventh Street\n# That is: street_slot['Second'] < street_slot['Seventh']\n# Then which street was cleaned on Tuesday afternoon (slot 3)\n\n# Tuesday afternoon slot is day=1 * 2 + 1 = 3\n\n# We will check each option by adding the condition and the option constraint and see which is satisfiable\n\noptions = ['First', 'Second', 'Third', 'Fifth', 'Eighth']\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, opt_street in enumerate(options):\n    solver.push()\n    # Add condition: Second before Seventh\n    solver.add(street_slot['Second'] < street_slot['Seventh'])\n    # Add constraint: The street cleaned on Tuesday afternoon (slot 3) is opt_street\n    solver.add(street_slot[opt_street] == 3)\n    if solver.check() == sat:\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A street cleaning crew works only Monday to Friday, and only during the day. It takes the crew an entire morning or an entire afternoon to clean a street. During one week the crew cleaned exactly eight streets—First, Second, Third, Fourth, Fifth, Sixth, Seventh, and Eighth streets. The following is known about the crew's schedule for the week: The crew cleaned no street on Friday morning. The crew cleaned no street on Wednesday afternoon. It cleaned Fourth Street on Tuesday morning. It cleaned Seventh Street on Thursday morning. It cleaned Fourth Street before Sixth Street and after Eighth Street. It cleaned Second, Fifth, and Eighth streets on afternoons.\n\nIf the crew cleaned Sixth Street on a morning and cleaned Second Street before Seventh Street, then what is the maximum number of streets whose cleaning times cannot be determined?\n\nOptions:\n(A) 1\n(B) 2\n(C) 3\n(D) 4\n(E) 5",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Days and timeslots\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']\ntimes = ['AM', 'PM']\nslots = [(d, t) for d in days for t in times]  # total 10 slots\n\n# Streets\nstreets = ['First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth']\n\n# Map each street to a slot index variable (0..9)\n# slot index: 0 = Mon AM, 1 = Mon PM, ..., 8 = Fri AM, 9 = Fri PM\nstreet_slot = {s: Int(s) for s in streets}\n\n# Create a solver\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each street's slot must be in 0..9\nfor s in streets:\n    solver.add(And(street_slot[s] >= 0, street_slot[s] < 10))\n\n# All streets are cleaned at different times (Distinct slots)\nsolver.add(Distinct([street_slot[s] for s in streets]))\n\n# Constraint: No street cleaned on Friday morning (slot 8)\nfor s in streets:\n    solver.add(street_slot[s] != 8)\n\n# Constraint: No street cleaned on Wednesday afternoon (Wed PM = slot 5)\nfor s in streets:\n    solver.add(street_slot[s] != 5)\n\n# Fourth Street on Tuesday morning (Tue AM = slot 2)\nsolver.add(street_slot['Fourth'] == 2)\n\n# Seventh Street on Thursday morning (Thu AM = slot 6)\nsolver.add(street_slot['Seventh'] == 6)\n\n# Fourth Street before Sixth Street and after Eighth Street\nsolver.add(street_slot['Eighth'] < street_slot['Fourth'])\nsolver.add(street_slot['Fourth'] < street_slot['Sixth'])\n\n# Second, Fifth, and Eighth streets on afternoons (PM slots)\n# PM slots are 1,3,5,7,9\npm_slots = [1,3,5,7,9]\nsolver.add(Or([street_slot['Second'] == ps for ps in pm_slots]))\nsolver.add(Or([street_slot['Fifth'] == ps for ps in pm_slots]))\nsolver.add(Or([street_slot['Eighth'] == ps for ps in pm_slots]))\n\n# Additional given conditions for the option:\n# Sixth Street on a morning (AM slots: 0,2,4,6,8)\nam_slots = [0,2,4,6,8]\nsolver.add(Or([street_slot['Sixth'] == am for am in am_slots]))\n\n# Second Street before Seventh Street\nsolver.add(street_slot['Second'] < street_slot['Seventh'])\n\n# OPTION CHECKING\n# We want to find the maximum number of streets whose cleaning times cannot be determined.\n# That means: for each street, check if its slot is uniquely determined by the constraints.\n# If not unique, it is \"cannot be determined\".\n\n# For each street, check uniqueness of its slot:\n# uniqueness means: if we fix all constraints, is there only one possible slot for that street?\n\nundetermined_count = 0\nfor s in streets:\n    # Get the assigned slot in one model (if exists)\n    if solver.check() != sat:\n        # No solution (should not happen)\n        print(\"'A'\")  # default print to comply, but no solution expected\n        exit()\n    m = solver.model()\n    assigned_slot = m[street_slot[s]].as_long()\n\n    # Check if there exists another solution with different slot for s\n    # Push context\n    solver.push()\n    # Add constraint that street s slot is different from assigned_slot\n    solver.add(street_slot[s] != assigned_slot)\n    if solver.check() == sat:\n        # There is another solution with different slot for s => slot not unique\n        undetermined_count += 1\n    # Pop context\n    solver.pop()\n\n# Check which option corresponds to undetermined_count\noptions = {1:'A', 2:'B', 3:'C', 4:'D', 5:'E'}\n\n# The question asks for maximum number of streets whose cleaning times cannot be determined\n# So print the corresponding letter\nif undetermined_count in options:\n    print(f\"'{options[undetermined_count]}'\")\nelse:\n    # If undetermined_count not in options, print closest or default\n    # But problem states one correct option, so this should not happen\n    print(\"'A'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A street cleaning crew works only Monday to Friday, and only during the day. It takes the crew an entire morning or an entire afternoon to clean a street. During one week the crew cleaned exactly eight streets—First, Second, Third, Fourth, Fifth, Sixth, Seventh, and Eighth streets. The following is known about the crew's schedule for the week: The crew cleaned no street on Friday morning. The crew cleaned no street on Wednesday afternoon. It cleaned Fourth Street on Tuesday morning. It cleaned Seventh Street on Thursday morning. It cleaned Fourth Street before Sixth Street and after Eighth Street. It cleaned Second, Fifth, and Eighth streets on afternoons.\n\nWhat is the maximum possible number of streets any one of which could be the one the crew cleaned on Friday afternoon?\n\nOptions:\n(A) 1\n(B) 2\n(C) 3\n(D) 4\n(E) 5",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Days and times\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\ntimes = ['Morning', 'Afternoon']\n\n# Streets\nstreets = ['First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth']\n\n# Map street names to indices\nstreet_idx = {s: i for i, s in enumerate(streets)}\n\n# Create a variable for each street representing the time slot it was cleaned\n# Time slots: 0 to 9 (5 days * 2 times per day)\n# slot 0 = Monday Morning, slot 1 = Monday Afternoon, ..., slot 9 = Friday Afternoon\nstreet_slots = [Int(s) for s in streets]\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each street cleaned exactly once in a unique time slot\nfor s in street_slots:\n    solver.add(And(s >= 0, s < 10))\n\n# All streets cleaned in distinct time slots\nsolver.add(Distinct(street_slots))\n\n# No street on Friday morning: slot 8 (Friday Morning) is free\n# So no street can be cleaned at slot 8\nfor s in street_slots:\n    solver.add(s != 8)\n\n# No street on Wednesday afternoon: slot 5 (Wednesday Afternoon) is free\nfor s in street_slots:\n    solver.add(s != 5)\n\n# Fourth Street on Tuesday morning: Tuesday morning is slot 2 (Monday=0,1; Tuesday=2,3)\nsolver.add(street_slots[street_idx['Fourth']] == 2)\n\n# Seventh Street on Thursday morning: Thursday morning is slot 6\nsolver.add(street_slots[street_idx['Seventh']] == 6)\n\n# Fourth Street before Sixth Street and after Eighth Street\nsolver.add(street_slots[street_idx['Fourth']] < street_slots[street_idx['Sixth']])\nsolver.add(street_slots[street_idx['Fourth']] > street_slots[street_idx['Eighth']])\n\n# Second, Fifth, and Eighth streets on afternoons (afternoon slots are odd: 1,3,5,7,9)\nsolver.add(street_slots[street_idx['Second']] % 2 == 1)\nsolver.add(street_slots[street_idx['Fifth']] % 2 == 1)\nsolver.add(street_slots[street_idx['Eighth']] % 2 == 1)\n\n# The question: What is the maximum possible number of streets any one of which could be the one cleaned on Friday afternoon?\n# Friday afternoon is slot 9\n# We want to find how many distinct streets can possibly be scheduled at slot 9 consistent with the constraints\n\ncount_possible = 0\nfor candidate_street in streets:\n    solver.push()\n    # Add constraint that candidate street is cleaned on Friday afternoon (slot 9)\n    solver.add(street_slots[street_idx[candidate_street]] == 9)\n    if solver.check() == sat:\n        count_possible += 1\n    solver.pop()\n\n# Find the option corresponding to count_possible\noptions = [1, 2, 3, 4, 5]\nletters = ['A', 'B', 'C', 'D', 'E']\nfor letter, opt in zip(letters, options):\n    if count_possible == opt:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A street cleaning crew works only Monday to Friday, and only during the day. It takes the crew an entire morning or an entire afternoon to clean a street. During one week the crew cleaned exactly eight streets—First, Second, Third, Fourth, Fifth, Sixth, Seventh, and Eighth streets. The following is known about the crew's schedule for the week: The crew cleaned no street on Friday morning. The crew cleaned no street on Wednesday afternoon. It cleaned Fourth Street on Tuesday morning. It cleaned Seventh Street on Thursday morning. It cleaned Fourth Street before Sixth Street and after Eighth Street. It cleaned Second, Fifth, and Eighth streets on afternoons.\n\nIf the crew cleaned Fifth, Sixth, and Seventh streets in numerical order, then what is the maximum number of different schedules any one of which the crew could have had for the entire week?\n\nOptions:\n(A) 1\n(B) 2\n(C) 3\n(D) 4\n(E) 5",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Days and times\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\ntimes = ['Morning', 'Afternoon']\n\n# Streets\nstreets = ['First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth']\n\n# Create a mapping from street to a variable representing its time slot (0 to 9)\n# Slots: Monday Morning=0, Monday Afternoon=1, Tuesday Morning=2, ..., Friday Afternoon=9\nstreet_slot = {s: Int(s) for s in streets}\n\n# Helper: total slots = 5 days * 2 times = 10\ntotal_slots = len(days) * len(times)\n\n# Map slot index to day and time\ndef slot_to_day_time(slot):\n    day = slot // 2\n    time = slot % 2\n    return day, time\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each street cleaned in exactly one slot in [0..9]\nfor s in streets:\n    solver.add(And(street_slot[s] >= 0, street_slot[s] < total_slots))\n\n# No two streets cleaned in the same slot (since only one street can be cleaned at a time)\nsolver.add(Distinct([street_slot[s] for s in streets]))\n\n# The crew cleaned no street on Friday morning (Friday morning = slot 8)\nfor s in streets:\n    solver.add(street_slot[s] != 8)\n\n# The crew cleaned no street on Wednesday afternoon (Wednesday afternoon = slot 5)\nfor s in streets:\n    solver.add(street_slot[s] != 5)\n\n# It cleaned Fourth Street on Tuesday morning (Tuesday morning = slot 2)\nsolver.add(street_slot['Fourth'] == 2)\n\n# It cleaned Seventh Street on Thursday morning (Thursday morning = slot 6)\nsolver.add(street_slot['Seventh'] == 6)\n\n# Fourth Street before Sixth Street and after Eighth Street\nsolver.add(street_slot['Eighth'] < street_slot['Fourth'])\nsolver.add(street_slot['Fourth'] < street_slot['Sixth'])\n\n# It cleaned Second, Fifth, and Eighth streets on afternoons\n# Afternoons are slots with time == 1, i.e., odd slots: 1,3,5,7,9\n# But slot 5 (Wednesday afternoon) is forbidden, so Second, Fifth, Eighth must be in {1,3,7,9}\nafternoon_slots = [1,3,7,9]\nsolver.add(Or([street_slot['Second'] == s for s in afternoon_slots]))\nsolver.add(Or([street_slot['Fifth'] == s for s in afternoon_slots]))\nsolver.add(Or([street_slot['Eighth'] == s for s in afternoon_slots]))\n\n# If the crew cleaned Fifth, Sixth, and Seventh streets in numerical order:\n# Fifth < Sixth < Seventh\nsolver.add(street_slot['Fifth'] < street_slot['Sixth'])\nsolver.add(street_slot['Sixth'] < street_slot['Seventh'])\n\n# OPTION CHECKING\noptions = ['A', 'B', 'C', 'D', 'E']\nmax_schedules = 0\n\n# Count number of possible schedules satisfying all constraints\n# We will enumerate up to 5 to decide which option is correct\nmodels = []\n\nwhile True:\n    if solver.check() == sat:\n        m = solver.model()\n        # Extract schedule as a tuple of slots assigned to streets in order\n        schedule = tuple(m[street_slot[s]].as_long() for s in streets)\n        models.append(schedule)\n        if len(models) > 5:\n            break\n        # Block this model to find another\n        solver.add(Or([street_slot[s] != m[street_slot[s]] for s in streets]))\n    else:\n        break\n\nmax_schedules = len(models)\n\n# Print the letter of the correct option (only one correct answer)\n# max_schedules corresponds to one of the options (1 to 5)\n# If max_schedules > 5, max_schedules = 5 for option E\nif max_schedules > 5:\n    max_schedules = 5\n\nprint(f\"'{options[max_schedules-1]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A street cleaning crew works only Monday to Friday, and only during the day. It takes the crew an entire morning or an entire afternoon to clean a street. During one week the crew cleaned exactly eight streets—First, Second, Third, Fourth, Fifth, Sixth, Seventh, and Eighth streets. The following is known about the crew's schedule for the week: The crew cleaned no street on Friday morning. The crew cleaned no street on Wednesday afternoon. It cleaned Fourth Street on Tuesday morning. It cleaned Seventh Street on Thursday morning. It cleaned Fourth Street before Sixth Street and after Eighth Street. It cleaned Second, Fifth, and Eighth streets on afternoons.\n\nSuppose the crew had cleaned Fourth Street on Tuesday afternoon instead of on Tuesday morning, but all other conditions remained the same. Which one of the following statements could be false?\n\nOptions:\n(A) The crew cleaned First Street before Second Street.\n(B) The crew cleaned Second Street before Fifth Street.\n(C) The crew cleaned Third Street before Second Street.\n(D) The crew cleaned Sixth Street before Fifth Street.\n(E) The crew cleaned Seventh Street before Second Street.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Days and times\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\ntimes = ['Morning', 'Afternoon']\n\n# Streets\nstreets = ['First', 'Second', 'Third', 'Fourth', 'Fifth', 'Sixth', 'Seventh', 'Eighth']\n\n# Map street names to indices\nstreet_idx = {street: i for i, street in enumerate(streets)}\n\n# Map day and time to a unique slot index (0 to 9)\n# Monday Morning = 0, Monday Afternoon = 1, ..., Friday Afternoon = 9\ndef slot_index(day, time):\n    return days.index(day) * 2 + times.index(time)\n\n# Create Z3 variables: for each street, an integer representing the slot it was cleaned in (0..9)\nstreet_slots = {}\nfor street in streets:\n    street_slots[street] = Int(street)\n    \n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each street cleaned exactly once in one of the 10 slots (0..9)\nfor street in streets:\n    solver.add(And(street_slots[street] >= 0, street_slots[street] < 10))\n\n# All streets cleaned at distinct times\nsolver.add(Distinct([street_slots[street] for street in streets]))\n\n# The crew cleaned no street on Friday morning (slot 8)\n# So no street is assigned slot 8\nfor street in streets:\n    solver.add(street_slots[street] != 8)\n\n# The crew cleaned no street on Wednesday afternoon (slot 5)\nfor street in streets:\n    solver.add(street_slots[street] != 5)\n\n# It cleaned Fourth Street on Tuesday afternoon instead of Tuesday morning (changed condition)\n# Tuesday morning = slot 2, Tuesday afternoon = slot 3\nsolver.add(street_slots['Fourth'] == 3)\n\n# It cleaned Seventh Street on Thursday morning (slot 6)\nsolver.add(street_slots['Seventh'] == 6)\n\n# It cleaned Fourth Street before Sixth Street\nsolver.add(street_slots['Fourth'] < street_slots['Sixth'])\n\n# It cleaned Fourth Street after Eighth Street\nsolver.add(street_slots['Fourth'] > street_slots['Eighth'])\n\n# It cleaned Second, Fifth, and Eighth streets on afternoons\n# Afternoons are slots with odd indices: 1,3,5,7,9\n# But 5 is excluded (Wednesday afternoon), so valid afternoon slots are 1,3,7,9\n# So these streets must be assigned to one of these slots\nvalid_afternoon_slots = [1,3,7,9]\nsolver.add(Or([street_slots['Second'] == s for s in valid_afternoon_slots]))\nsolver.add(Or([street_slots['Fifth'] == s for s in valid_afternoon_slots]))\nsolver.add(Or([street_slots['Eighth'] == s for s in valid_afternoon_slots]))\n\n# OPTION CHECKING\n\noptions = [\n    (\"A\", street_slots['First'] < street_slots['Second']),     # The crew cleaned First Street before Second Street.\n    (\"B\", street_slots['Second'] < street_slots['Fifth']),     # The crew cleaned Second Street before Fifth Street.\n    (\"C\", street_slots['Third'] < street_slots['Second']),     # The crew cleaned Third Street before Second Street.\n    (\"D\", street_slots['Sixth'] < street_slots['Fifth']),      # The crew cleaned Sixth Street before Fifth Street.\n    (\"E\", street_slots['Seventh'] < street_slots['Second'])    # The crew cleaned Seventh Street before Second Street.\n]\n\nfor letter, condition in options:\n    solver.push()\n    # Test if the negation of the condition is satisfiable\n    # If yes, then the condition could be false\n    solver.add(Not(condition))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "J, K, L, M, N, and O are square ski chalets of the same size, which are positioned in two straight rows as shown below: J K L row 1: ■ ■ ■ row 2: ■ ■ ■ M N O J is directly opposite M; K is directly opposite N; and L is directly opposite O. After a snowstorm, residents shovel a single continuous path that connects all of the chalets and meets the following conditions: The path is composed of five straight segments, each of which directly connects exactly two of the chalets. Each chalet is directly connected by a segment of the path to another chalet. No chalet is directly connected by segments of the path to more than two other chalets. No segment of the path crosses any other segment. One segment of the path directly connects chalets J and N, and another segment directly connects chalets K and L.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) One segment of the path directly connects chalets M and K.\n(B) One segment of the path directly connects chalets M and L.\n(C) One segment of the path directly connects chalets M and O.\n(D) One segment of the path directly connects chalets J and K and another segment directly connects chalets K and M.\n(E) One segment of the path directly connects chalets O and L and another segment directly connects chalets O and N.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchalets = ['J', 'K', 'L', 'M', 'N', 'O']\n# We'll represent edges by Bool variables: edge between chalet1 and chalet2\n# Only edges between distinct chalets\nedges = {}\nfor i in range(len(chalets)):\n    for j in range(i+1, len(chalets)):\n        c1 = chalets[i]\n        c2 = chalets[j]\n        edges[(c1,c2)] = Bool(f\"e_{c1}{c2}\")\n\n# Helper function to get edge variable regardless of order\ndef edge_var(a,b):\n    if (a,b) in edges:\n        return edges[(a,b)]\n    else:\n        return edges[(b,a)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Given fixed edges:\n# One segment connects J and N\nsolver.add(edge_var('J','N') == True)\n# One segment connects K and L\nsolver.add(edge_var('K','L') == True)\n\n# The path has exactly 5 segments\nsolver.add(Sum([If(edges[e],1,0) for e in edges]) == 5)\n\n# Each chalet is connected by a segment to another chalet\n# Each chalet has degree 1 or 2 (no chalet connected to more than 2 others)\nfor c in chalets:\n    connected_edges = []\n    for other in chalets:\n        if c != other:\n            connected_edges.append(edge_var(c,other))\n    deg = Sum([If(e,1,0) for e in connected_edges])\n    solver.add(deg >= 1)\n    solver.add(deg <= 2)\n\n# The path is a single continuous path connecting all chalets\n# Since there are 6 chalets and 5 edges, and each node degree is 1 or 2,\n# the graph must be a path (no cycles).\n# To ensure connectivity and no cycles, we can use a simple approach:\n# The graph must be connected and have no cycles.\n# For 6 nodes and 5 edges, connectedness implies path.\n\n# We can enforce connectivity by ensuring no partition of nodes is disconnected.\n# To simplify, we can use a reachability approach:\n# Model a spanning tree or path by DFS order or use a union-find approach.\n# Here, we use a simple connectivity check via reachability from J.\n\n# Create reachability Bool variables: reachable[c]\nreachable = {}\nfor c in chalets:\n    reachable[c] = Bool(f\"reachable_{c}\")\n\n# J is reachable from itself\nsolver.add(reachable['J'] == True)\n\n# For other chalets, reachable if connected to some reachable chalet by an edge\nfor c in chalets:\n    if c != 'J':\n        connected_to_reachable = []\n        for other in chalets:\n            if other != c:\n                connected_to_reachable.append(And(edge_var(c,other), reachable[other]))\n        # reachable[c] iff connected to at least one reachable chalet\n        solver.add(reachable[c] == Or(connected_to_reachable))\n\n# All chalets must be reachable\nfor c in chalets:\n    solver.add(reachable[c] == True)\n\n# No segments cross each other:\n# The chalets are arranged in two rows:\n# Row 1: J K L (positions 1,2,3)\n# Row 2: M N O (positions 1,2,3)\n# Positions:\npos = {\n    'J': (1, 1),\n    'K': (2, 1),\n    'L': (3, 1),\n    'M': (1, 2),\n    'N': (2, 2),\n    'O': (3, 2)\n}\n\n# Two segments cross if their line segments intersect in the plane\n# We check all pairs of edges that don't share a chalet\ndef segments_cross(a,b,c,d):\n    # segments: a-b and c-d\n    # Returns True if segments cross, False otherwise\n    # Using orientation method\n\n    def orientation(p,q,r):\n        # Returns orientation of ordered triplet (p,q,r)\n        # 0 -> colinear, 1 -> clockwise, 2 -> counterclockwise\n        val = (q[1]-p[1])*(r[0]-q[0]) - (q[0]-p[0])*(r[1]-q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    p1 = pos[a]\n    q1 = pos[b]\n    p2 = pos[c]\n    q2 = pos[d]\n\n    o1 = orientation(p1,q1,p2)\n    o2 = orientation(p1,q1,q2)\n    o3 = orientation(p2,q2,p1)\n    o4 = orientation(p2,q2,q1)\n\n    if (o1 != o2) and (o3 != o4):\n        return True\n    # Special colinear cases not needed as no three chalets are colinear except rows\n    return False\n\n# For every pair of edges that don't share a chalet, add constraint that they don't both exist if they cross\nedge_list = list(edges.keys())\nfor i in range(len(edge_list)):\n    for j in range(i+1,len(edge_list)):\n        e1 = edge_list[i]\n        e2 = edge_list[j]\n        # Check if edges share a chalet\n        if len(set(e1).intersection(set(e2))) == 0:\n            if segments_cross(e1[0], e1[1], e2[0], e2[1]):\n                # Both edges cannot be True simultaneously\n                solver.add(Or(Not(edges[e1]), Not(edges[e2])))\n\n# OPTION CHECKING\noptions = {\n    'A': [edge_var('M','K')],\n    'B': [edge_var('M','L')],\n    'C': [edge_var('M','O')],\n    'D': [edge_var('J','K'), edge_var('K','M')],\n    'E': [edge_var('O','L'), edge_var('O','N')]\n}\n\nfor opt in ['A','B','C','D','E']:\n    solver.push()\n    # Add option-specific edges to be True\n    for e in options[opt]:\n        solver.add(e == True)\n    if solver.check() == sat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "J, K, L, M, N, and O are square ski chalets of the same size, which are positioned in two straight rows as shown below: J K L row 1: ■ ■ ■ row 2: ■ ■ ■ M N O J is directly opposite M; K is directly opposite N; and L is directly opposite O. After a snowstorm, residents shovel a single continuous path that connects all of the chalets and meets the following conditions: The path is composed of five straight segments, each of which directly connects exactly two of the chalets. Each chalet is directly connected by a segment of the path to another chalet. No chalet is directly connected by segments of the path to more than two other chalets. No segment of the path crosses any other segment. One segment of the path directly connects chalets J and N, and another segment directly connects chalets K and L.\n\nIf one segment of the path directly connects chalets K and N, then the two chalets in which one of the following pairs must be directly connected to each other by a segment?\n\nOptions:\n(A) J and K\n(B) K and O\n(C) L and O\n(D) M and N\n(E) N and O",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchalets = ['J', 'K', 'L', 'M', 'N', 'O']\nindices = {chalet: i for i, chalet in enumerate(chalets)}\n\n# The path has 5 segments, each connects two chalets\n# We'll represent segments as pairs of chalets (undirected edges)\n# Each segment is represented by a tuple (a,b) with a < b for uniqueness\n\n# All possible edges between chalets (undirected)\nall_edges = []\nfor i in range(len(chalets)):\n    for j in range(i+1, len(chalets)):\n        all_edges.append((chalets[i], chalets[j]))\n\n# Create Bool variables for each possible edge: True if edge is in path\nedges_vars = {}\nfor (a,b) in all_edges:\n    edges_vars[(a,b)] = Bool(f\"{a}_{b}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) The path is composed of exactly 5 segments\nsolver.add(Sum([If(edges_vars[e], 1, 0) for e in edges_vars]) == 5)\n\n# 2) Each chalet is directly connected by a segment to another chalet\n#    and no chalet is connected to more than two others\nfor c in chalets:\n    # Collect edges connected to chalet c\n    connected_edges = []\n    for (a,b) in edges_vars:\n        if a == c or b == c:\n            connected_edges.append(edges_vars[(a,b)])\n    # Each chalet has degree 1 or 2 (since path is continuous and no chalet has more than two connections)\n    deg = Sum([If(e, 1, 0) for e in connected_edges])\n    solver.add(And(deg >= 1, deg <= 2))\n\n# 3) The path is continuous and connects all chalets (a path of length 6 nodes and 5 edges)\n#    We can enforce connectivity by ensuring no smaller disconnected subsets with edges chosen.\n\n# To enforce connectivity and path shape, use a graph connectivity approach:\n# We can use a DFS or Union-Find approach, but here we use a standard approach:\n# The path must be a single simple path covering all 6 nodes with 5 edges.\n\n# Additionally, in a path with 6 nodes, exactly two nodes have degree 1 (the ends),\n# and the other 4 nodes have degree 2.\n\ndegree_ones = []\ndegree_twos = []\nfor c in chalets:\n    connected_edges = []\n    for (a,b) in edges_vars:\n        if a == c or b == c:\n            connected_edges.append(edges_vars[(a,b)])\n    deg = Sum([If(e, 1, 0) for e in connected_edges])\n    degree_ones.append(If(deg == 1, 1, 0))\n    degree_twos.append(If(deg == 2, 1, 0))\nsolver.add(Sum(degree_ones) == 2)\nsolver.add(Sum(degree_twos) == 4)\n\n# 4) No segment crosses any other segment\n# The chalets are arranged in two rows:\n# row 1: J(0), K(1), L(2)\n# row 2: M(0), N(1), O(2)\n# J opposite M, K opposite N, L opposite O\n\n# Coordinates for chalets (x,y)\ncoords = {\n    'J': (0,1),\n    'K': (1,1),\n    'L': (2,1),\n    'M': (0,0),\n    'N': (1,0),\n    'O': (2,0),\n}\n\ndef segments_cross(a1, a2, b1, b2):\n    # Check if segments (a1,a2) and (b1,b2) cross\n    # Using orientation test and general segment intersection test\n\n    def orientation(p, q, r):\n        # returns orientation of ordered triplet (p,q,r):\n        # 0 -> colinear, 1 -> clockwise, 2 -> counterclockwise\n        val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    def on_segment(p, q, r):\n        # check if point q lies on segment pr\n        if min(p[0], r[0]) <= q[0] <= max(p[0], r[0]) and min(p[1], r[1]) <= q[1] <= max(p[1], r[1]):\n            return True\n        return False\n\n    p1 = coords[a1]\n    q1 = coords[a2]\n    p2 = coords[b1]\n    q2 = coords[b2]\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    # General case\n    if o1 != o2 and o3 != o4:\n        return True\n\n    # Special Cases\n    if o1 == 0 and on_segment(p1, p2, q1):\n        return True\n    if o2 == 0 and on_segment(p1, q2, q1):\n        return True\n    if o3 == 0 and on_segment(p2, p1, q2):\n        return True\n    if o4 == 0 and on_segment(p2, q1, q2):\n        return True\n\n    return False\n\n# For each pair of edges, if they are both chosen, they must not cross\nedges_list = list(edges_vars.keys())\nfor i in range(len(edges_list)):\n    for j in range(i+1, len(edges_list)):\n        e1 = edges_list[i]\n        e2 = edges_list[j]\n        # edges share a node => cannot cross, so skip\n        if len(set(e1) & set(e2)) > 0:\n            continue\n        # Check if edges cross\n        if segments_cross(e1[0], e1[1], e2[0], e2[1]):\n            # If both edges chosen, conflict\n            solver.add(Or(Not(edges_vars[e1]), Not(edges_vars[e2])))\n\n# 5) One segment directly connects J and N\nsolver.add(edges_vars[('J','N')] if ('J','N') in edges_vars else edges_vars[('N','J')])\n\n# 6) One segment directly connects K and L\nsolver.add(edges_vars[('K','L')] if ('K','L') in edges_vars else edges_vars[('L','K')])\n\n# OPTION CHECKING\n\n# The question: If one segment connects K and N, then which pair must be connected?\n\n# We'll test each option by adding edges_vars[option_edge] == True and edges_vars[('K','N')] == True\n\n# Map options to edges (normalize order)\noption_edges_map = {\n    'A': ('J','K'),\n    'B': ('K','O'),\n    'C': ('L','O'),\n    'D': ('M','N'),\n    'E': ('N','O'),\n}\n\nfor letter, (a,b) in option_edges_map.items():\n    solver.push()\n    # Add edge K-N\n    edge_kn = ('K','N') if ('K','N') in edges_vars else ('N','K')\n    solver.add(edges_vars[edge_kn])\n\n    # Add option edge\n    edge_option = (a,b) if (a,b) in edges_vars else (b,a)\n    solver.add(edges_vars[edge_option])\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "J, K, L, M, N, and O are square ski chalets of the same size, which are positioned in two straight rows as shown below: J K L row 1: ■ ■ ■ row 2: ■ ■ ■ M N O J is directly opposite M; K is directly opposite N; and L is directly opposite O. After a snowstorm, residents shovel a single continuous path that connects all of the chalets and meets the following conditions: The path is composed of five straight segments, each of which directly connects exactly two of the chalets. Each chalet is directly connected by a segment of the path to another chalet. No chalet is directly connected by segments of the path to more than two other chalets. No segment of the path crosses any other segment. One segment of the path directly connects chalets J and N, and another segment directly connects chalets K and L.\n\nIf one segment of the path directly connects chalets K and O, then which one of the following statements could be true?\n\nOptions:\n(A) Chalet J is directly connected to chalet M.\n(B) Chalet K is directly connected to chalet N.\n(C) Chalet L is directly connected to chalet O.\n(D) Chalet L is directly connected to exactly two chalets.\n(E) Chalet O is directly connected to exactly one chalet.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchalets = ['J', 'K', 'L', 'M', 'N', 'O']\nindices = {c: i for i, c in enumerate(chalets)}\n\n# There are 5 segments, each connects exactly two chalets\n# Represent each segment as a pair of chalets (ordered by index)\n# We'll represent the graph as adjacency lists: for each chalet, a list of connected chalets\n\n# Create adjacency matrix: adj[i][j] = Bool indicating if segment connects chalet i and j\nadj = [[Bool(f\"adj_{chalets[i]}_{chalets[j]}\") for j in range(len(chalets))] for i in range(len(chalets))]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) The path is composed of 5 straight segments, each connects exactly two chalets\n# So total number of True in adj matrix (upper triangle only) is 5\nedges = []\nfor i in range(len(chalets)):\n    for j in range(i+1, len(chalets)):\n        edges.append(adj[i][j])\nsolver.add(Sum([If(e, 1, 0) for e in edges]) == 5)\n\n# 2) Each segment connects exactly two chalets (already encoded by adjacency matrix)\n\n# 3) Each chalet is directly connected by a segment to another chalet (degree at least 1)\n# But from problem, path connects all chalets, so each chalet has degree at least 1\n# Also, no chalet is connected to more than two other chalets (degree <= 2)\nfor i in range(len(chalets)):\n    degree = []\n    for j in range(len(chalets)):\n        if i == j:\n            continue\n        # adjacency symmetric: adj[i][j] or adj[j][i]\n        if i < j:\n            degree.append(If(adj[i][j], 1, 0))\n        else:\n            degree.append(If(adj[j][i], 1, 0))\n    solver.add(And(Sum(degree) >= 1, Sum(degree) <= 2))\n\n# 4) No segment crosses any other segment\n# The chalets are arranged in two rows:\n# Row 1: J(0), K(1), L(2)\n# Row 2: M(3), N(4), O(5)\n# Positions:\n# J(0) opposite M(3)\n# K(1) opposite N(4)\n# L(2) opposite O(5)\n\n# Coordinates for checking crossing:\n# Row 1: y=1, x = 0,1,2 for J,K,L\n# Row 2: y=0, x = 0,1,2 for M,N,O\npos = {\n    'J': (0, 1),\n    'K': (1, 1),\n    'L': (2, 1),\n    'M': (0, 0),\n    'N': (1, 0),\n    'O': (2, 0)\n}\n\ndef segments_cross(p1, p2, p3, p4):\n    # Check if segments p1-p2 and p3-p4 cross\n    # p1,p2,p3,p4 are (x,y) tuples\n    def ccw(a,b,c):\n        return (c[1]-a[1])*(b[0]-a[0]) > (b[1]-a[1])*(c[0]-a[0])\n    return And(\n        Or(ccw(p1,p3,p4) != ccw(p2,p3,p4), ccw(p1,p2,p3) != ccw(p1,p2,p4))\n    )\n\n# For each pair of edges, if they share no chalet, their segments must not cross\nfor i1 in range(len(chalets)):\n    for j1 in range(i1+1, len(chalets)):\n        for i2 in range(len(chalets)):\n            for j2 in range(i2+1, len(chalets)):\n                # edges must be distinct and no shared endpoint\n                if len({i1,j1,i2,j2}) == 4:\n                    # If both edges exist, then their segments do not cross\n                    cross = segments_cross(pos[chalets[i1]], pos[chalets[j1]], pos[chalets[i2]], pos[chalets[j2]])\n                    solver.add(Or(Not(adj[i1][j1]), Not(adj[i2][j2]), Not(cross)))\n\n# 5) The path is continuous and connects all chalets\n# The graph formed by edges is a path with 6 nodes and 5 edges\n# So the graph is connected and has no cycles\n# We can check connectivity by ensuring there is a path from J to every other chalet\n# Also, since degree <= 2, and edges = 5, the graph is a path (chain)\n\n# Implement connectivity check using reachability via adjacency matrix\n# Use Floyd-Warshall or similar for reachability with Bool variables\n\n# Create reachability matrix reach[i][j]: Bool, true if node j reachable from i\nreach = [[Bool(f\"reach_{i}_{j}\") for j in range(len(chalets))] for i in range(len(chalets))]\n\n# Initialize reachability: each node reachable from itself\nfor i in range(len(chalets)):\n    solver.add(reach[i][i])\n\n# For each edge, add reachability in both directions\nfor i in range(len(chalets)):\n    for j in range(len(chalets)):\n        if i != j:\n            # If edge exists between i and j, then i reaches j and j reaches i\n            if i < j:\n                edge = adj[i][j]\n            else:\n                edge = adj[j][i]\n            solver.add(Implies(edge, And(reach[i][j], reach[j][i])))\n\n# Floyd-Warshall transitive closure constraints\nfor k in range(len(chalets)):\n    for i in range(len(chalets)):\n        for j in range(len(chalets)):\n            solver.add(Implies(And(reach[i][k], reach[k][j]), reach[i][j]))\n\n# All chalets reachable from J (index 0)\nfor i in range(len(chalets)):\n    solver.add(reach[0][i])\n\n# 6) One segment connects J and N\nsolver.add(adj[indices['J']][indices['N']] if indices['J'] < indices['N'] else adj[indices['N']][indices['J']])\n\n# 7) Another segment connects K and L\nsolver.add(adj[indices['K']][indices['L']] if indices['K'] < indices['L'] else adj[indices['L']][indices['K']])\n\n# 8) Given that one segment connects K and O\nsolver.add(adj[indices['K']][indices['O']] if indices['K'] < indices['O'] else adj[indices['O']][indices['K']])\n\n# OPTION CHECKING\n\noptions = [\n    ('A', (indices['J'], indices['M'])),  # Chalet J is directly connected to chalet M\n    ('B', (indices['K'], indices['N'])),  # Chalet K is directly connected to chalet N\n    ('C', (indices['L'], indices['O'])),  # Chalet L is directly connected to chalet O\n    ('D', 'L_two_connections'),           # Chalet L is directly connected to exactly two chalets\n    ('E', 'O_one_connection')              # Chalet O is directly connected to exactly one chalet\n]\n\nfor letter, cond in options:\n    solver.push()\n    if letter == 'D':\n        # L connected to exactly two chalets\n        degree_L = []\n        i = indices['L']\n        for j in range(len(chalets)):\n            if i == j:\n                continue\n            if i < j:\n                degree_L.append(If(adj[i][j], 1, 0))\n            else:\n                degree_L.append(If(adj[j][i], 1, 0))\n        solver.add(Sum(degree_L) == 2)\n    elif letter == 'E':\n        # O connected to exactly one chalet\n        degree_O = []\n        i = indices['O']\n        for j in range(len(chalets)):\n            if i == j:\n                continue\n            if i < j:\n                degree_O.append(If(adj[i][j], 1, 0))\n            else:\n                degree_O.append(If(adj[j][i], 1, 0))\n        solver.add(Sum(degree_O) == 1)\n    else:\n        # direct connection between two chalets\n        i, j = cond\n        if i < j:\n            solver.add(adj[i][j])\n        else:\n            solver.add(adj[j][i])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "J, K, L, M, N, and O are square ski chalets of the same size, which are positioned in two straight rows as shown below: J K L row 1: ■ ■ ■ row 2: ■ ■ ■ M N O J is directly opposite M; K is directly opposite N; and L is directly opposite O. After a snowstorm, residents shovel a single continuous path that connects all of the chalets and meets the following conditions: The path is composed of five straight segments, each of which directly connects exactly two of the chalets. Each chalet is directly connected by a segment of the path to another chalet. No chalet is directly connected by segments of the path to more than two other chalets. No segment of the path crosses any other segment. One segment of the path directly connects chalets J and N, and another segment directly connects chalets K and L.\n\nIf no segment of the path directly connects any chalet in row 1 with the chalet in row 2 that is directly opposite it, then each of the following statements must be true EXCEPT:\n\nOptions:\n(A) A segment of the path directly connects chalets M and N.\n(B) A segment of the path directly connects chalets N and O.\n(C) Chalet L is directly connected to exactly one other chalet.\n(D) Chalet N is directly connected to exactly two other chalets.\n(E) Chalet O is directly connected to exactly two other chalets.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchalets = ['J', 'K', 'L', 'M', 'N', 'O']\nrows = {\n    'row1': ['J', 'K', 'L'],\n    'row2': ['M', 'N', 'O']\n}\n\n# We will represent connections as a dictionary of Bool variables for each unordered pair of chalets\n# Since path segments connect exactly two chalets, and there are 6 chalets, possible edges are combinations of 2 chalets\nfrom itertools import combinations\n\nedges = list(combinations(chalets, 2))\nedge_vars = {}\nfor (c1, c2) in edges:\n    edge_vars[(c1, c2)] = Bool(f\"{c1}_{c2}\")\n\n# Helper function to get the edge variable for two chalets in any order\ndef edge_var(a, b):\n    if (a, b) in edge_vars:\n        return edge_vars[(a, b)]\n    else:\n        return edge_vars[(b, a)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1) The path is composed of 5 straight segments, each directly connecting exactly two chalets.\n# So exactly 5 edges are True\nsolver.add(Sum([If(edge_vars[e], 1, 0) for e in edges]) == 5)\n\n# 2) Each chalet is directly connected by a segment of the path to another chalet.\n# So each chalet has at least one edge connected to it\nfor c in chalets:\n    connected_edges = []\n    for (a, b) in edges:\n        if a == c or b == c:\n            connected_edges.append(edge_vars[(a, b)])\n    solver.add(Or(connected_edges))\n\n# 3) No chalet is directly connected by segments of the path to more than two other chalets.\n# So degree of each chalet <= 2\nfor c in chalets:\n    connected_edges = []\n    for (a, b) in edges:\n        if a == c or b == c:\n            connected_edges.append(If(edge_vars[(a, b)], 1, 0))\n    solver.add(Sum(connected_edges) <= 2)\n\n# 4) No segment of the path crosses any other segment.\n# The chalets are arranged in two rows:\n# row1: J K L\n# row2: M N O\n# J opposite M; K opposite N; L opposite O\n# We represent the positions as indices:\npos = {\n    'J': (0, 0),\n    'K': (1, 0),\n    'L': (2, 0),\n    'M': (0, 1),\n    'N': (1, 1),\n    'O': (2, 1)\n}\n\n# Two segments (a,b) and (c,d) cross if their line segments intersect,\n# but since the chalets are in two rows, we can check crossing by ordering:\n# For two edges (a,b) and (c,d), if all four points are distinct,\n# segments cross if one edge connects points that \"cross\" the other edge's points horizontally.\n# We check if edges cross:\ndef edges_cross(a, b, c, d):\n    # Get x coordinates\n    ax, ay = pos[a]\n    bx, by = pos[b]\n    cx, cy = pos[c]\n    dx, dy = pos[d]\n\n    # Ignore if any chalet is the same\n    s = set([a,b,c,d])\n    if len(s) < 4:\n        return False\n\n    # We check crossing by comparing projections on x axis and y axis\n    # For crossing, the segments must \"intersect\" in the plane\n    # Using orientation test for line segments intersection:\n\n    def orientation(p, q, r):\n        # returns orientation of ordered triplet (p,q,r)\n        # 0 -> colinear, 1 -> clockwise, 2 -> counterclockwise\n        val = (q[1] - p[1])*(r[0] - q[0]) - (q[0] - p[0])*(r[1] - q[1])\n        if val == 0:\n            return 0\n        elif val > 0:\n            return 1\n        else:\n            return 2\n\n    p1 = (ax, ay)\n    q1 = (bx, by)\n    p2 = (cx, cy)\n    q2 = (dx, dy)\n\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n    return False\n\n# For every pair of edges, if they cross, they cannot both be True\nfor i in range(len(edges)):\n    for j in range(i+1, len(edges)):\n        (a,b) = edges[i]\n        (c,d) = edges[j]\n        if edges_cross(a,b,c,d):\n            solver.add(Or(Not(edge_vars[(a,b)]), Not(edge_vars[(c,d)])))\n\n# 5) One segment directly connects chalets J and N\nsolver.add(edge_var('J', 'N'))\n\n# 6) Another segment directly connects chalets K and L\nsolver.add(edge_var('K', 'L'))\n\n# 7) No segment of the path directly connects any chalet in row 1 with the chalet in row 2 that is directly opposite it\n# That is, no edge connects (J,M), (K,N), or (L,O)\nsolver.add(Not(edge_var('J', 'M')))\nsolver.add(Not(edge_var('K', 'N')))\nsolver.add(Not(edge_var('L', 'O')))\n\n# OPTION CHECKING\n# We check which option is NOT necessarily true (EXCEPT)\n\n# Options:\n# (A) A segment of the path directly connects chalets M and N.\n# (B) A segment of the path directly connects chalets N and O.\n# (C) Chalet L is directly connected to exactly one other chalet.\n# (D) Chalet N is directly connected to exactly two other chalets.\n# (E) Chalet O is directly connected to exactly two other chalets.\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\n# Define helper to check degree of a chalet\ndef degree(chalet):\n    return Sum([If(edge_var(a,b), 1, 0) for (a,b) in edges if a == chalet or b == chalet])\n\n# We want to find the option that can be false, i.e. the option that is NOT necessarily true.\n\nfor i, opt in enumerate(options):\n    solver.push()\n    if opt == 'A':\n        # Check if \"M and N connected\" can be false\n        solver.add(Not(edge_var('M', 'N')))\n    elif opt == 'B':\n        # Check if \"N and O connected\" can be false\n        solver.add(Not(edge_var('N', 'O')))\n    elif opt == 'C':\n        # Check if \"L connected to exactly one chalet\" can be false\n        # So we check if degree(L) != 1\n        solver.add(degree('L') != 1)\n    elif opt == 'D':\n        # Check if \"N connected to exactly two chalets\" can be false\n        solver.add(degree('N') != 2)\n    elif opt == 'E':\n        # Check if \"O connected to exactly two chalets\" can be false\n        solver.add(degree('O') != 2)\n\n    if solver.check() == sat:\n        # Option can be false, so it is the EXCEPT option (not necessarily true)\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "John receives one grade for each of the following six courses: economics, geology, history, Italian, physics, and Russian. From highest to lowest, the possible grades are A, B, C, D, and E. E is the only failing grade. Two letter grades are consecutive if and only if they are adjacent in the alphabet. John's grades in geology and physics are consecutive. His grades in Italian and Russian are consecutive. He receives a higher grade in economics than in history. He receives a higher grade in geology than in physics.\n\nIf John receives the same grade in economics and Italian, and if he fails Russian, which one of the following must be true?\n\nOptions:\n(A) John's geology grade is a B.\n(B) John's history grade is a D.\n(C) John's history grade is an E.\n(D) John's physics grade is a B.\n(E) John's physics grade is a C.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncourses = ['economics', 'geology', 'history', 'italian', 'physics', 'russian']\ngrades = ['A', 'B', 'C', 'D', 'E']  # A highest (0), E lowest (4), E is failing\n\n# Create Int variables for each course grade (0 to 4)\ngrade_vars = {c: Int(c) for c in courses}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each grade variable must be between 0 (A) and 4 (E)\nfor c in courses:\n    solver.add(And(grade_vars[c] >= 0, grade_vars[c] <= 4))\n\n# Two letter grades are consecutive if and only if their numeric difference is 1\ndef consecutive(g1, g2):\n    return Or(g1 - g2 == 1, g2 - g1 == 1)\n\n# John's grades in geology and physics are consecutive\nsolver.add(consecutive(grade_vars['geology'], grade_vars['physics']))\n\n# John's grades in Italian and Russian are consecutive\nsolver.add(consecutive(grade_vars['italian'], grade_vars['russian']))\n\n# John receives a higher grade in economics than in history\nsolver.add(grade_vars['economics'] < grade_vars['history'])\n\n# He receives a higher grade in geology than in physics\nsolver.add(grade_vars['geology'] < grade_vars['physics'])\n\n# John receives the same grade in economics and Italian\nsolver.add(grade_vars['economics'] == grade_vars['italian'])\n\n# John fails Russian (grade E == 4)\nsolver.add(grade_vars['russian'] == 4)\n\n# OPTION CHECKING\n# Options:\n# (A) John's geology grade is a B. (grade 1)\n# (B) John's history grade is a D. (grade 3)\n# (C) John's history grade is an E. (grade 4)\n# (D) John's physics grade is a B. (grade 1)\n# (E) John's physics grade is a C. (grade 2)\n\noptions = [\n    grade_vars['geology'] == 1,\n    grade_vars['history'] == 3,\n    grade_vars['history'] == 4,\n    grade_vars['physics'] == 1,\n    grade_vars['physics'] == 2,\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "John receives one grade for each of the following six courses: economics, geology, history, Italian, physics, and Russian. From highest to lowest, the possible grades are A, B, C, D, and E. E is the only failing grade. Two letter grades are consecutive if and only if they are adjacent in the alphabet. John's grades in geology and physics are consecutive. His grades in Italian and Russian are consecutive. He receives a higher grade in economics than in history. He receives a higher grade in geology than in physics.\n\nIf John receives a higher grade in physics than in economics and receives a higher grade in history than in Italian, exactly how many of his grades can be determined?\n\nOptions:\n(A) 2\n(B) 3\n(C) 4\n(D) 5\n(E) 6",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncourses = ['economics', 'geology', 'history', 'italian', 'physics', 'russian']\ngrades = ['A', 'B', 'C', 'D', 'E']  # A=0 (highest), E=4 (lowest/failing)\n\n# Create Z3 Int variables for each course grade (0 to 4)\ngrade_vars = {c: Int(c) for c in courses}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each grade is between 0 (A) and 4 (E)\nfor c in courses:\n    solver.add(And(grade_vars[c] >= 0, grade_vars[c] < len(grades)))\n\n# Consecutive grades means absolute difference = 1\ndef consecutive(a, b):\n    return Or(grade_vars[a] == grade_vars[b] + 1, grade_vars[a] + 1 == grade_vars[b])\n\n# John's grades in geology and physics are consecutive\nsolver.add(consecutive('geology', 'physics'))\n\n# John's grades in Italian and Russian are consecutive\nsolver.add(consecutive('italian', 'russian'))\n\n# John receives a higher grade in economics than in history\nsolver.add(grade_vars['economics'] < grade_vars['history'])\n\n# John receives a higher grade in geology than in physics\nsolver.add(grade_vars['geology'] < grade_vars['physics'])\n\n# Additional conditions for the \"if\" part:\n# He receives a higher grade in physics than in economics\nsolver.add(grade_vars['physics'] < grade_vars['economics'])\n\n# He receives a higher grade in history than in Italian\nsolver.add(grade_vars['history'] < grade_vars['italian'])\n\n# OPTION CHECKING\n# We want to find how many grades can be determined uniquely under these constraints.\n# For each course, check if its grade is fixed (only one possible value).\n\n# First, check if the constraints are satisfiable\nif solver.check() == sat:\n    model = solver.model()\n    determined_count = 0\n    for c in courses:\n        val = model[grade_vars[c]].as_long()\n        # Check if any other value for this course is possible\n        solver.push()\n        solver.add(grade_vars[c] != val)\n        if solver.check() == unsat:\n            # No other value possible, grade is determined\n            determined_count += 1\n        solver.pop()\n    # Map determined_count to options\n    # Options: (A)2, (B)3, (C)4, (D)5, (E)6\n    options_map = {2:'A', 3:'B', 4:'C', 5:'D', 6:'E'}\n    # If determined_count not in options_map, no correct option\n    print(f\"'{options_map.get(determined_count, '?')}'\")\nelse:\n    # No solution under given conditions\n    print(\"'?'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "John receives one grade for each of the following six courses: economics, geology, history, Italian, physics, and Russian. From highest to lowest, the possible grades are A, B, C, D, and E. E is the only failing grade. Two letter grades are consecutive if and only if they are adjacent in the alphabet. John's grades in geology and physics are consecutive. His grades in Italian and Russian are consecutive. He receives a higher grade in economics than in history. He receives a higher grade in geology than in physics.\n\nAssume that John receives a lower grade in economics than in physics. He must have failed at least one course if which one of the following is also true?\n\nOptions:\n(A) He receives a lower grade in Italian than in economics.\n(B) He receives a lower grade in Italian than in physics.\n(C) He receives a lower grade in physics than in Italian.\n(D) He receives a lower grade in Russian than in economics.\n(E) He receives a lower grade in Russian than in history.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncourses = ['economics', 'geology', 'history', 'Italian', 'physics', 'Russian']\ngrades = ['A', 'B', 'C', 'D', 'E']  # A=0 (highest), E=4 (lowest/failing)\n\n# Create integer variables for each course grade (0 to 4)\ngrade_vars = {c: Int(c) for c in courses}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each grade must be between 0 and 4\nfor c in courses:\n    solver.add(And(grade_vars[c] >= 0, grade_vars[c] <= 4))\n\n# Consecutive grades mean absolute difference is 1\ndef consecutive(c1, c2):\n    return Or(grade_vars[c1] == grade_vars[c2] + 1, grade_vars[c1] == grade_vars[c2] - 1)\n\n# John's grades in geology and physics are consecutive\nsolver.add(consecutive('geology', 'physics'))\n\n# John's grades in Italian and Russian are consecutive\nsolver.add(consecutive('Italian', 'Russian'))\n\n# He receives a higher grade in economics than in history (lower number means higher grade)\nsolver.add(grade_vars['economics'] < grade_vars['history'])\n\n# He receives a higher grade in geology than in physics\nsolver.add(grade_vars['geology'] < grade_vars['physics'])\n\n# Assume John receives a lower grade in economics than in physics\nsolver.add(grade_vars['economics'] > grade_vars['physics'])\n\n# OPTION CHECKING\n# We want to find which option, when added, forces at least one failing grade (grade == 4)\n\noptions = {\n    'A': grade_vars['Italian'] > grade_vars['economics'],\n    'B': grade_vars['Italian'] > grade_vars['physics'],\n    'C': grade_vars['physics'] > grade_vars['Italian'],\n    'D': grade_vars['Russian'] > grade_vars['economics'],\n    'E': grade_vars['Russian'] > grade_vars['history'],\n}\n\n# Helper to check if there is a solution with no failing grades (no grade == 4)\ndef no_failing_grades():\n    return And([grade_vars[c] < 4 for c in courses])\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add the option-specific constraint\n    solver.add(options[letter])\n    # Check if it's possible to have no failing grades\n    solver.add(no_failing_grades())\n    if solver.check() == unsat:\n        # No solution without failing grades means must have failed at least one course\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A store sells shirts only in small, medium, and large sizes, and only in red, yellow, and blue colors. Casey buys exactly three shirts from the store. A shirt type consists of both a size and a color. Casey does not buy two shirts of the same type. Casey does not buy both a small shirt and a large shirt. No small red shirts are available. No large blue shirts are available.\n\nIf Casey buys a small blue shirt, which one of the following must be false?\n\nOptions:\n(A) Casey buys two blue shirts.\n(B) Casey buys two red shirts.\n(C) Casey buys two yellow shirts.\n(D) Casey buys two small shirts.\n(E) Casey buys two medium shirts.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsizes = ['small', 'medium', 'large']\ncolors = ['red', 'yellow', 'blue']\n\n# Map sizes and colors to indices\nsize_idx = {s: i for i, s in enumerate(sizes)}\ncolor_idx = {c: i for i, c in enumerate(colors)}\n\n# Shirt types: all combinations except those not available\n# No small red shirts, no large blue shirts\navailable_shirts = []\nfor s in sizes:\n    for c in colors:\n        if (s == 'small' and c == 'red') or (s == 'large' and c == 'blue'):\n            continue\n        available_shirts.append((s, c))\n\n# We will represent each shirt Casey buys as a pair of (size, color) indices\n# Casey buys exactly three shirts, no duplicates\n# Each shirt is a tuple of (size, color)\n# We create variables for the size and color of each shirt bought\nnum_shirts = 3\nshirts = []\nfor i in range(num_shirts):\n    size_var = Int(f'size_{i}')\n    color_var = Int(f'color_{i}')\n    shirts.append((size_var, color_var))\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each shirt must be an available shirt\n# We encode the available shirt combinations as allowed pairs\nallowed_pairs = [(size_idx[s], color_idx[c]) for (s, c) in available_shirts]\nallowed_pairs_set = set(allowed_pairs)\n\nfor (size_var, color_var) in shirts:\n    # size_var in [0..2], color_var in [0..2]\n    solver.add(And(size_var >= 0, size_var < len(sizes)))\n    solver.add(And(color_var >= 0, color_var < len(colors)))\n    # Must be one of the allowed pairs\n    allowed_conditions = [And(size_var == sp, color_var == cp) for (sp, cp) in allowed_pairs]\n    solver.add(Or(allowed_conditions))\n\n# No two shirts are the same type (no duplicates)\nfor i in range(num_shirts):\n    for j in range(i+1, num_shirts):\n        size_i, color_i = shirts[i]\n        size_j, color_j = shirts[j]\n        diff_size = size_i != size_j\n        diff_color = color_i != color_j\n        # Shirts differ in size or color\n        solver.add(Or(diff_size, diff_color))\n\n# Casey does not buy both a small shirt and a large shirt\n# So not (exists small shirt and exists large shirt)\nsmall_exists = Or([shirts[i][0] == size_idx['small'] for i in range(num_shirts)])\nlarge_exists = Or([shirts[i][0] == size_idx['large'] for i in range(num_shirts)])\nsolver.add(Not(And(small_exists, large_exists)))\n\n# Casey buys a small blue shirt\n# So at least one shirt is small blue\nsmall_blue = And(shirts[0][0] == size_idx['small'], shirts[0][1] == color_idx['blue'])\nsmall_blue_1 = And(shirts[1][0] == size_idx['small'], shirts[1][1] == color_idx['blue'])\nsmall_blue_2 = And(shirts[2][0] == size_idx['small'], shirts[2][1] == color_idx['blue'])\nsolver.add(Or([small_blue, small_blue_1, small_blue_2]))\n\n# OPTION CHECKING\n\n# We define helper functions to count how many shirts of a given color or size Casey buys\n\ndef count_color(color_i):\n    return Sum([If(shirts[i][1] == color_i, 1, 0) for i in range(num_shirts)])\n\ndef count_size(size_i):\n    return Sum([If(shirts[i][0] == size_i, 1, 0) for i in range(num_shirts)])\n\noptions = {\n    'A': lambda: count_color(color_idx['blue']) >= 2,\n    'B': lambda: count_color(color_idx['red']) >= 2,\n    'C': lambda: count_color(color_idx['yellow']) >= 2,\n    'D': lambda: count_size(size_idx['small']) >= 2,\n    'E': lambda: count_size(size_idx['medium']) >= 2,\n}\n\n# We want to find which option must be false.\n# So for each option, we check if it's possible that option is true along with all constraints.\n# The option that cannot be true is the one that must be false.\n\nfor option_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add the option's condition (the statement that Casey buys two shirts of that type)\n    solver.add(options[option_letter]())\n    if solver.check() == sat:\n        # Option can be true, so it is not necessarily false\n        solver.pop()\n    else:\n        # Option must be false\n        print(f\"'{option_letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A store sells shirts only in small, medium, and large sizes, and only in red, yellow, and blue colors. Casey buys exactly three shirts from the store. A shirt type consists of both a size and a color. Casey does not buy two shirts of the same type. Casey does not buy both a small shirt and a large shirt. No small red shirts are available. No large blue shirts are available.\n\nIf Casey does not buy a medium yellow shirt, which one of the following must be true?\n\nOptions:\n(A) Casey buys either a medium red shirt or a small blue shirt.\n(B) Casey buys either a medium red shirt or a medium blue shirt.\n(C) Casey buys either a large red shirt or a small blue shirt.\n(D) Casey buys either a large red shirt or a medium red shirt.\n(E) Casey buys either a large yellow shirt or a small yellow shirt.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsizes = ['small', 'medium', 'large']\ncolors = ['red', 'yellow', 'blue']\n\n# Map sizes and colors to indices\nsize_idx = {s: i for i, s in enumerate(sizes)}\ncolor_idx = {c: i for i, c in enumerate(colors)}\n\n# Define all possible shirt types as (size, color) pairs\nshirt_types = [(s, c) for s in sizes for c in colors]\n\n# Create variables for the three shirts Casey buys\n# Each shirt is represented as an integer index into shirt_types\nshirts = [Int(f'shirt_{i}') for i in range(3)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each shirt must be a valid shirt type index\nfor shirt in shirts:\n    solver.add(And(shirt >= 0, shirt < len(shirt_types)))\n\n# 2) Casey does not buy two shirts of the same type (all distinct)\nsolver.add(Distinct(shirts))\n\n# 3) Casey does not buy both a small shirt and a large shirt\n# We need to ensure that not both small and large sizes appear among the three shirts\n# Define predicates for small and large presence\ndef is_small(shirt_var):\n    return Or([shirt_var == i for i, (s, c) in enumerate(shirt_types) if s == 'small'])\n\ndef is_large(shirt_var):\n    return Or([shirt_var == i for i, (s, c) in enumerate(shirt_types) if s == 'large'])\n\n# Create boolean variables to indicate if small or large shirts are bought\nsmall_bought = Bool('small_bought')\nlarge_bought = Bool('large_bought')\n\n# small_bought is true if any shirt is small\nsolver.add(small_bought == Or([is_small(shirt) for shirt in shirts]))\n# large_bought is true if any shirt is large\nsolver.add(large_bought == Or([is_large(shirt) for shirt in shirts]))\n\n# Casey does not buy both small and large shirts\nsolver.add(Not(And(small_bought, large_bought)))\n\n# 4) No small red shirts are available\n# Remove all small red shirts from possible shirt types by forbidding them\nsmall_red_indices = [i for i, (s, c) in enumerate(shirt_types) if s == 'small' and c == 'red']\nfor shirt in shirts:\n    for idx in small_red_indices:\n        solver.add(shirt != idx)\n\n# 5) No large blue shirts are available\nlarge_blue_indices = [i for i, (s, c) in enumerate(shirt_types) if s == 'large' and c == 'blue']\nfor shirt in shirts:\n    for idx in large_blue_indices:\n        solver.add(shirt != idx)\n\n# 6) Casey does not buy a medium yellow shirt\nmedium_yellow_idx = next(i for i, (s, c) in enumerate(shirt_types) if s == 'medium' and c == 'yellow')\nfor shirt in shirts:\n    solver.add(shirt != medium_yellow_idx)\n\n# OPTION CHECKING\n\n# Define a helper function to check if an option must be true\n# For each option, check if there is any model where the option is false\n# If no such model exists, the option must be true\n\ndef option_must_be_true(option_expr):\n    solver.push()\n    # Add constraint that option is false\n    solver.add(Not(option_expr))\n    result = solver.check()\n    solver.pop()\n    return result == unsat\n\n# Define helper to get index of a shirt type by size and color\ndef shirt_type_idx(size, color):\n    return next(i for i, (s, c) in enumerate(shirt_types) if s == size and c == color)\n\n# (A) Casey buys either a medium red shirt or a small blue shirt.\nmedium_red_idx = shirt_type_idx('medium', 'red')\nsmall_blue_idx = shirt_type_idx('small', 'blue')\noption_A = Or([Or([shirt == medium_red_idx for shirt in shirts]),\n               Or([shirt == small_blue_idx for shirt in shirts])])\n\n# (B) Casey buys either a medium red shirt or a medium blue shirt.\nmedium_blue_idx = shirt_type_idx('medium', 'blue')\noption_B = Or([Or([shirt == medium_red_idx for shirt in shirts]),\n               Or([shirt == medium_blue_idx for shirt in shirts])])\n\n# (C) Casey buys either a large red shirt or a small blue shirt.\nlarge_red_idx = shirt_type_idx('large', 'red')\noption_C = Or([Or([shirt == large_red_idx for shirt in shirts]),\n               Or([shirt == small_blue_idx for shirt in shirts])])\n\n# (D) Casey buys either a large red shirt or a medium red shirt.\noption_D = Or([Or([shirt == large_red_idx for shirt in shirts]),\n               Or([shirt == medium_red_idx for shirt in shirts])])\n\n# (E) Casey buys either a large yellow shirt or a small yellow shirt.\nlarge_yellow_idx = shirt_type_idx('large', 'yellow')\nsmall_yellow_idx = shirt_type_idx('small', 'yellow')\noption_E = Or([Or([shirt == large_yellow_idx for shirt in shirts]),\n               Or([shirt == small_yellow_idx for shirt in shirts])])\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, option in enumerate(options):\n    if option_must_be_true(option):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A store sells shirts only in small, medium, and large sizes, and only in red, yellow, and blue colors. Casey buys exactly three shirts from the store. A shirt type consists of both a size and a color. Casey does not buy two shirts of the same type. Casey does not buy both a small shirt and a large shirt. No small red shirts are available. No large blue shirts are available.\n\nIf Casey buys exactly one medium shirt and does not buy two shirts of the same color, then she cannot buy which one of the following?\n\nOptions:\n(A) a medium red shirt\n(B) a medium yellow shirt\n(C) a medium blue shirt\n(D) a large red shirt\n(E) a large yellow shirt",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsizes = ['small', 'medium', 'large']\ncolors = ['red', 'yellow', 'blue']\n\n# Map sizes and colors to indices\nsize_idx = {s: i for i, s in enumerate(sizes)}\ncolor_idx = {c: i for i, c in enumerate(colors)}\n\n# Define all possible shirt types (size, color)\n# But some types are not available:\n# No small red shirts\n# No large blue shirts\navailable_shirts = []\nfor s in sizes:\n    for c in colors:\n        if (s == 'small' and c == 'red') or (s == 'large' and c == 'blue'):\n            continue\n        available_shirts.append((size_idx[s], color_idx[c]))\n\n# We will represent Casey's 3 shirts as 3 variables, each is an index into available_shirts\nnum_shirts = 3\nshirts = [Int(f'shirt_{i}') for i in range(num_shirts)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each shirt variable is an index into available_shirts\nfor sh in shirts:\n    solver.add(And(sh >= 0, sh < len(available_shirts)))\n\n# No two shirts of the same type (Distinct indices)\nsolver.add(Distinct(shirts))\n\n# Casey buys exactly one medium shirt\n# Count how many medium shirts in shirts == 1\nmedium_size = size_idx['medium']\nmedium_shirts_indices = [i for i, (s, c) in enumerate(available_shirts) if s == medium_size]\n\nmedium_count = Sum([If(shirts[j] == i, 1, 0) for j in range(num_shirts) for i in medium_shirts_indices])\nsolver.add(medium_count == 1)\n\n# Casey does not buy both a small shirt and a large shirt\n# So not (has_small and has_large)\nsmall_size = size_idx['small']\nlarge_size = size_idx['large']\nsmall_shirts_indices = [i for i, (s, c) in enumerate(available_shirts) if s == small_size]\nlarge_shirts_indices = [i for i, (s, c) in enumerate(available_shirts) if s == large_size]\n\nhas_small = Or([Or([shirts[j] == i for i in small_shirts_indices]) for j in range(num_shirts)])\nhas_large = Or([Or([shirts[j] == i for i in large_shirts_indices]) for j in range(num_shirts)])\nsolver.add(Not(And(has_small, has_large)))\n\n# Casey does not buy two shirts of the same color\n# So the colors of the 3 shirts are distinct\n# Extract color for each shirt variable\n# We create variables for colors of each shirt:\nshirt_colors = [Int(f'shirt_color_{i}') for i in range(num_shirts)]\nfor i in range(num_shirts):\n    # shirt_colors[i] == color of shirts[i]\n    # Define constraints to link shirts[i] to shirt_colors[i]\n    # Using If-Then-Else chain\n    conds = []\n    for idx, (s, c) in enumerate(available_shirts):\n        conds.append((shirts[i] == idx, c))\n    # Build the chain\n    color_expr = conds[-1][1]\n    for cond, val in reversed(conds[:-1]):\n        color_expr = If(cond, val, color_expr)\n    solver.add(shirt_colors[i] == color_expr)\n\nsolver.add(Distinct(shirt_colors))\n\n# OPTION CHECKING\noptions = [\n    ('A', (medium_size, color_idx['red'])),\n    ('B', (medium_size, color_idx['yellow'])),\n    ('C', (medium_size, color_idx['blue'])),\n    ('D', (size_idx['large'], color_idx['red'])),\n    ('E', (size_idx['large'], color_idx['yellow']))\n]\n\nfor letter, (opt_size, opt_color) in options:\n    solver.push()\n    # Add constraint that Casey buys the shirt of option type\n    # That means one of the shirts is (opt_size, opt_color)\n    # Find index of this shirt type in available_shirts\n    opt_shirt_indices = [i for i, (s, c) in enumerate(available_shirts) if s == opt_size and c == opt_color]\n    # If no such shirt available, then this option is impossible anyway\n    if not opt_shirt_indices:\n        # Option cannot be bought, so it cannot be in the set of shirts\n        # So this option is impossible to buy, so print it as answer\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    # Add constraint that one of shirts is opt_shirt_indices[0]\n    solver.add(Or([shirts[i] == opt_shirt_indices[0] for i in range(num_shirts)]))\n    # Check if this is possible\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A store sells shirts only in small, medium, and large sizes, and only in red, yellow, and blue colors. Casey buys exactly three shirts from the store. A shirt type consists of both a size and a color. Casey does not buy two shirts of the same type. Casey does not buy both a small shirt and a large shirt. No small red shirts are available. No large blue shirts are available.\n\nIf neither large red shirts nor small blue shirts are available, which one of the following must Casey buy?\n\nOptions:\n(A) a red shirt\n(B) a medium yellow shirt\n(C) either a large shirt or a small shirt\n(D) either a medium red shirt or a medium blue shirt\n(E) either a large yellow shirt or a medium blue shirt",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsizes = ['small', 'medium', 'large']\ncolors = ['red', 'yellow', 'blue']\n\n# Map sizes and colors to indices\nsize_idx = {s: i for i, s in enumerate(sizes)}\ncolor_idx = {c: i for i, c in enumerate(colors)}\n\n# Variables: Casey buys exactly 3 shirts, each shirt is a (size, color) pair\n# We create 3 shirts variables, each with size and color as Ints\nshirts = []\nfor i in range(3):\n    size_var = Int(f'size_{i}')\n    color_var = Int(f'color_{i}')\n    shirts.append((size_var, color_var))\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each size and color variable must be within valid range\nfor size_var, color_var in shirts:\n    solver.add(And(size_var >= 0, size_var < len(sizes)))\n    solver.add(And(color_var >= 0, color_var < len(colors)))\n\n# Casey does not buy two shirts of the same type\n# So all (size, color) pairs must be distinct\ndistinct_pairs = []\nfor size_var, color_var in shirts:\n    distinct_pairs.append((size_var, color_var))\nfor i in range(len(distinct_pairs)):\n    for j in range(i+1, len(distinct_pairs)):\n        s1, c1 = distinct_pairs[i]\n        s2, c2 = distinct_pairs[j]\n        solver.add(Or(s1 != s2, c1 != c2))\n\n# Casey does not buy both a small shirt and a large shirt\n# So not (exists small shirt and exists large shirt)\n# Let's define boolean variables for existence of small and large shirts\nsmall_exists = Bool('small_exists')\nlarge_exists = Bool('large_exists')\n\nsmall_shirt_conditions = [size_var == size_idx['small'] for size_var, _ in shirts]\nlarge_shirt_conditions = [size_var == size_idx['large'] for size_var, _ in shirts]\n\nsolver.add(small_exists == Or(small_shirt_conditions))\nsolver.add(large_exists == Or(large_shirt_conditions))\nsolver.add(Not(And(small_exists, large_exists)))\n\n# No small red shirts are available\n# So no shirt with size small and color red\nfor size_var, color_var in shirts:\n    solver.add(Not(And(size_var == size_idx['small'], color_var == color_idx['red'])))\n\n# No large blue shirts are available\n# So no shirt with size large and color blue\nfor size_var, color_var in shirts:\n    solver.add(Not(And(size_var == size_idx['large'], color_var == color_idx['blue'])))\n\n# Additional condition for the question:\n# If neither large red shirts nor small blue shirts are available\n# So no large red shirts and no small blue shirts\nfor size_var, color_var in shirts:\n    solver.add(Not(And(size_var == size_idx['large'], color_var == color_idx['red'])))\n    solver.add(Not(And(size_var == size_idx['small'], color_var == color_idx['blue'])))\n\n# OPTION CHECKING\n\n# Define helper function to add option-specific constraints and check satisfiability\ndef check_option(option_letter):\n    solver.push()\n    if option_letter == 'A':\n        # (A) a red shirt\n        # Casey must buy at least one red shirt\n        red_conditions = [color_var == color_idx['red'] for _, color_var in shirts]\n        solver.add(Or(red_conditions))\n    elif option_letter == 'B':\n        # (B) a medium yellow shirt\n        # Casey must buy a shirt that is medium and yellow\n        cond = False\n        cond = Or([And(size_var == size_idx['medium'], color_var == color_idx['yellow']) for size_var, color_var in shirts])\n        solver.add(cond)\n    elif option_letter == 'C':\n        # (C) either a large shirt or a small shirt\n        # Casey must buy at least one shirt that is either large or small\n        cond = Or([Or(size_var == size_idx['large'], size_var == size_idx['small']) for size_var, _ in shirts])\n        solver.add(cond)\n    elif option_letter == 'D':\n        # (D) either a medium red shirt or a medium blue shirt\n        cond = Or([And(size_var == size_idx['medium'], Or(color_var == color_idx['red'], color_var == color_idx['blue'])) for size_var, color_var in shirts])\n        solver.add(cond)\n    elif option_letter == 'E':\n        # (E) either a large yellow shirt or a medium blue shirt\n        cond = Or([And(size_var == size_idx['large'], color_var == color_idx['yellow']) for size_var, color_var in shirts] +\n                  [And(size_var == size_idx['medium'], color_var == color_idx['blue']) for size_var, color_var in shirts])\n        solver.add(cond)\n    else:\n        solver.pop()\n        return False\n\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\n# The correct option is the one that must be true in all models\n# So for each option, check if the negation is satisfiable\n# If negation is unsat, then the option must be true\n\nfor option in options:\n    solver.push()\n    # Add negation of option condition\n    if option == 'A':\n        red_conditions = [color_var == color_idx['red'] for _, color_var in shirts]\n        solver.add(Not(Or(red_conditions)))\n    elif option == 'B':\n        cond = Or([And(size_var == size_idx['medium'], color_var == color_idx['yellow']) for size_var, color_var in shirts])\n        solver.add(Not(cond))\n    elif option == 'C':\n        cond = Or([Or(size_var == size_idx['large'], size_var == size_idx['small']) for size_var, _ in shirts])\n        solver.add(Not(cond))\n    elif option == 'D':\n        cond = Or([And(size_var == size_idx['medium'], Or(color_var == color_idx['red'], color_var == color_idx['blue'])) for size_var, color_var in shirts])\n        solver.add(Not(cond))\n    elif option == 'E':\n        cond = Or([And(size_var == size_idx['large'], color_var == color_idx['yellow']) for size_var, color_var in shirts] +\n                  [And(size_var == size_idx['medium'], color_var == color_idx['blue']) for size_var, color_var in shirts])\n        solver.add(Not(cond))\n\n    if solver.check() == unsat:\n        print(f\"'{option}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A hobbyist is stocking her aquarium with exactly three fish of different types and with exactly two species of plants. The only fish under consideration are a G, an H, a J, a K, and an L, and the only kinds of plants under consideration are of the species W, X, Y, and Z. She will observe the following conditions: If she selects the G, she can select neither the H nor a Y. She cannot select the H unless she selects the K. She cannot select the J unless she selects a W. If she selects the K, she must select an X.\n\nWhich one of the following is an acceptable selection of fish and plants for the aquarium? Fish Plants\n\nOptions:\n(A) G, H, K W, Y\n(B) G, J, K W, X\n(C) G, J, L X, Z\n(D) H, J, L W, Z\n(E) H, K, L Y, Z",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Fish and plants lists\nfish = ['G', 'H', 'J', 'K', 'L']\nplants = ['W', 'X', 'Y', 'Z']\n\n# Create Z3 boolean variables for each fish and plant (True if selected)\nfish_vars = {f: Bool(f) for f in fish}\nplant_vars = {p: Bool(p) for p in plants}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly three fish selected\nsolver.add(Sum([If(fish_vars[f], 1, 0) for f in fish]) == 3)\n\n# Exactly two plants selected\nsolver.add(Sum([If(plant_vars[p], 1, 0) for p in plants]) == 2)\n\n# If G is selected, cannot select H nor Y\nsolver.add(Implies(fish_vars['G'], Not(fish_vars['H'])))\nsolver.add(Implies(fish_vars['G'], Not(plant_vars['Y'])))\n\n# Cannot select H unless K is selected\nsolver.add(Implies(fish_vars['H'], fish_vars['K']))\n\n# Cannot select J unless W is selected\nsolver.add(Implies(fish_vars['J'], plant_vars['W']))\n\n# If K is selected, must select X\nsolver.add(Implies(fish_vars['K'], plant_vars['X']))\n\n# OPTION CHECKING\noptions = [\n    (['G', 'H', 'K'], ['W', 'Y']),  # A\n    (['G', 'J', 'K'], ['W', 'X']),  # B\n    (['G', 'J', 'L'], ['X', 'Z']),  # C\n    (['H', 'J', 'L'], ['W', 'Z']),  # D\n    (['H', 'K', 'L'], ['Y', 'Z'])   # E\n]\n\nfor i, (f_sel, p_sel) in enumerate(options):\n    solver.push()\n    # Add constraints for selected fish\n    for f in fish:\n        if f in f_sel:\n            solver.add(fish_vars[f] == True)\n        else:\n            solver.add(fish_vars[f] == False)\n    # Add constraints for selected plants\n    for p in plants:\n        if p in p_sel:\n            solver.add(plant_vars[p] == True)\n        else:\n            solver.add(plant_vars[p] == False)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A hobbyist is stocking her aquarium with exactly three fish of different types and with exactly two species of plants. The only fish under consideration are a G, an H, a J, a K, and an L, and the only kinds of plants under consideration are of the species W, X, Y, and Z. She will observe the following conditions: If she selects the G, she can select neither the H nor a Y. She cannot select the H unless she selects the K. She cannot select the J unless she selects a W. If she selects the K, she must select an X.\n\nIf the hobbyist selects the H, which one of the following must also be true?\n\nOptions:\n(A) She selects at least one W.\n(B) She selects at least one X.\n(C) She selects the J, but no Y's.\n(D) She selects the K, but no X's.\n(E) She selects at least one X, but no Y's.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Fish and plants sets\nfish = ['G', 'H', 'J', 'K', 'L']\nplants = ['W', 'X', 'Y', 'Z']\n\n# Create Bool variables for each fish and plant indicating selection\nfish_sel = {f: Bool(f) for f in fish}\nplant_sel = {p: Bool(p) for p in plants}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly three fish selected\nsolver.add(Sum([If(fish_sel[f], 1, 0) for f in fish]) == 3)\n\n# Exactly two plants selected\nsolver.add(Sum([If(plant_sel[p], 1, 0) for p in plants]) == 2)\n\n# If she selects G, she can select neither H nor Y\nsolver.add(Implies(fish_sel['G'], Not(fish_sel['H'])))\nsolver.add(Implies(fish_sel['G'], Not(plant_sel['Y'])))\n\n# She cannot select H unless she selects K\nsolver.add(Implies(fish_sel['H'], fish_sel['K']))\n\n# She cannot select J unless she selects W\nsolver.add(Implies(fish_sel['J'], plant_sel['W']))\n\n# If she selects K, she must select X\nsolver.add(Implies(fish_sel['K'], plant_sel['X']))\n\n# OPTION CHECKING\n# Options:\n# (A) She selects at least one W.\n# (B) She selects at least one X.\n# (C) She selects the J, but no Y's.\n# (D) She selects the K, but no X's.\n# (E) She selects at least one X, but no Y's.\n\noptions = {\n    'A': plant_sel['W'],\n    'B': plant_sel['X'],\n    'C': And(fish_sel['J'], Not(plant_sel['Y'])),\n    'D': And(fish_sel['K'], Not(plant_sel['X'])),\n    'E': And(plant_sel['X'], Not(plant_sel['Y'])),\n}\n\n# We know H is selected\nsolver.add(fish_sel['H'])\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Check if option must be true when H is selected\n    # To check if option must be true, check if negation is unsat\n    solver.add(Not(options[opt]))\n    if solver.check() == unsat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A hobbyist is stocking her aquarium with exactly three fish of different types and with exactly two species of plants. The only fish under consideration are a G, an H, a J, a K, and an L, and the only kinds of plants under consideration are of the species W, X, Y, and Z. She will observe the following conditions: If she selects the G, she can select neither the H nor a Y. She cannot select the H unless she selects the K. She cannot select the J unless she selects a W. If she selects the K, she must select an X.\n\nIf the hobbyist selects both X's and Z's, which one of the following could be the group of fish she selects?\n\nOptions:\n(A) G, H, K\n(B) G, J, K\n(C) G, K, L\n(D) H, J, L\n(E) J, K, L",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Fish and plants indices\nfish = ['G', 'H', 'J', 'K', 'L']\nplants = ['W', 'X', 'Y', 'Z']\n\n# Variables: 1 if selected, 0 if not\nfish_vars = {f: Int(f) for f in fish}\nplant_vars = {p: Int(p) for p in plants}\n\nsolver = Solver()\n\n# Each fish variable is 0 or 1\nfor f in fish:\n    solver.add(Or(fish_vars[f] == 0, fish_vars[f] == 1))\n\n# Each plant variable is 0 or 1\nfor p in plants:\n    solver.add(Or(plant_vars[p] == 0, plant_vars[p] == 1))\n\n# Exactly three fish selected\nsolver.add(Sum([fish_vars[f] for f in fish]) == 3)\n\n# Exactly two plants selected\nsolver.add(Sum([plant_vars[p] for p in plants]) == 2)\n\n# Conditions:\n# If G selected, then neither H nor Y selected\nsolver.add(Implies(fish_vars['G'] == 1, And(fish_vars['H'] == 0, plant_vars['Y'] == 0)))\n\n# Cannot select H unless K selected\nsolver.add(Implies(fish_vars['H'] == 1, fish_vars['K'] == 1))\n\n# Cannot select J unless W selected\nsolver.add(Implies(fish_vars['J'] == 1, plant_vars['W'] == 1))\n\n# If K selected, must select X\nsolver.add(Implies(fish_vars['K'] == 1, plant_vars['X'] == 1))\n\n# Given: X and Z selected\nsolver.add(plant_vars['X'] == 1)\nsolver.add(plant_vars['Z'] == 1)\n\n# Check each option\noptions = [\n    ['G', 'H', 'K'],  # A\n    ['G', 'J', 'K'],  # B\n    ['G', 'K', 'L'],  # C\n    ['H', 'J', 'L'],  # D\n    ['J', 'K', 'L']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraint that fish selected are exactly those in option\n    for f in fish:\n        if f in option:\n            solver.add(fish_vars[f] == 1)\n        else:\n            solver.add(fish_vars[f] == 0)\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A hobbyist is stocking her aquarium with exactly three fish of different types and with exactly two species of plants. The only fish under consideration are a G, an H, a J, a K, and an L, and the only kinds of plants under consideration are of the species W, X, Y, and Z. She will observe the following conditions: If she selects the G, she can select neither the H nor a Y. She cannot select the H unless she selects the K. She cannot select the J unless she selects a W. If she selects the K, she must select an X.\n\nThe hobbyist could select any of the following groups of fish for the aquarium EXCEPT\n\nOptions:\n(A) G, K, L\n(B) H, J, K\n(C) H, J, L\n(D) H, K, L\n(E) J, K, L",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfish = ['G', 'H', 'J', 'K', 'L']\nplants = ['W', 'X', 'Y', 'Z']\n\n# Variables for fish selection: Bool for each fish (True if selected)\nfish_vars = {f: Bool(f) for f in fish}\n\n# Variables for plant selection: Bool for each plant (True if selected)\nplant_vars = {p: Bool(p) for p in plants}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly three fish selected\nsolver.add(Sum([If(fish_vars[f], 1, 0) for f in fish]) == 3)\n\n# Exactly two plant species selected\nsolver.add(Sum([If(plant_vars[p], 1, 0) for p in plants]) == 2)\n\n# If G selected, then neither H nor Y selected\nsolver.add(Implies(fish_vars['G'], Not(fish_vars['H'])))\nsolver.add(Implies(fish_vars['G'], Not(plant_vars['Y'])))\n\n# Cannot select H unless K is selected\nsolver.add(Implies(fish_vars['H'], fish_vars['K']))\n\n# Cannot select J unless W selected\nsolver.add(Implies(fish_vars['J'], plant_vars['W']))\n\n# If K selected, must select X\nsolver.add(Implies(fish_vars['K'], plant_vars['X']))\n\n# OPTION CHECKING\noptions = [\n    ['G', 'K', 'L'],  # A\n    ['H', 'J', 'K'],  # B\n    ['H', 'J', 'L'],  # C\n    ['H', 'K', 'L'],  # D\n    ['J', 'K', 'L'],  # E\n]\n\nfor i, group in enumerate(options):\n    solver.push()\n    # Add constraints that exactly these fish are selected\n    # All fish in group selected\n    for f in fish:\n        if f in group:\n            solver.add(fish_vars[f] == True)\n        else:\n            solver.add(fish_vars[f] == False)\n    # Check if model is satisfiable with these fish\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A hobbyist is stocking her aquarium with exactly three fish of different types and with exactly two species of plants. The only fish under consideration are a G, an H, a J, a K, and an L, and the only kinds of plants under consideration are of the species W, X, Y, and Z. She will observe the following conditions: If she selects the G, she can select neither the H nor a Y. She cannot select the H unless she selects the K. She cannot select the J unless she selects a W. If she selects the K, she must select an X.\n\nIf the hobbyist selects a Y, which one of the following must be the group of fish she selects?\n\nOptions:\n(A) G, H, K\n(B) H, J, K\n(C) H, J, L\n(D) H, K, L\n(E) J, K, L",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Fish and plants indices\nfish = ['G', 'H', 'J', 'K', 'L']\nplants = ['W', 'X', 'Y', 'Z']\n\n# Create boolean variables for each fish and plant indicating selection\nfish_vars = {f: Bool(f) for f in fish}\nplant_vars = {p: Bool(p) for p in plants}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly three fish selected\nsolver.add(Sum([If(fish_vars[f], 1, 0) for f in fish]) == 3)\n\n# Exactly two plants selected\nsolver.add(Sum([If(plant_vars[p], 1, 0) for p in plants]) == 2)\n\n# If G is selected, then neither H nor Y can be selected\nsolver.add(Implies(fish_vars['G'], Not(fish_vars['H'])))\nsolver.add(Implies(fish_vars['G'], Not(plant_vars['Y'])))\n\n# Cannot select H unless K is selected\nsolver.add(Implies(fish_vars['H'], fish_vars['K']))\n\n# Cannot select J unless W is selected\nsolver.add(Implies(fish_vars['J'], plant_vars['W']))\n\n# If K is selected, must select X\nsolver.add(Implies(fish_vars['K'], plant_vars['X']))\n\n# The hobbyist selects Y (plant Y is selected)\nsolver.add(plant_vars['Y'])\n\n# OPTION CHECKING\n\noptions = [\n    ['G', 'H', 'K'],\n    ['H', 'J', 'K'],\n    ['H', 'J', 'L'],\n    ['H', 'K', 'L'],\n    ['J', 'K', 'L']\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraint that the fish selected are exactly those in option\n    # That means all fish in option are selected\n    for f in fish:\n        if f in option:\n            solver.add(fish_vars[f])\n        else:\n            solver.add(Not(fish_vars[f]))\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A hobbyist is stocking her aquarium with exactly three fish of different types and with exactly two species of plants. The only fish under consideration are a G, an H, a J, a K, and an L, and the only kinds of plants under consideration are of the species W, X, Y, and Z. She will observe the following conditions: If she selects the G, she can select neither the H nor a Y. She cannot select the H unless she selects the K. She cannot select the J unless she selects a W. If she selects the K, she must select an X.\n\nThe hobbyist could select any of the following plant combinations EXCEPT\n\nOptions:\n(A) W and X\n(B) W and Y\n(C) W and Z\n(D) X and Y\n(E) X and Z",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Fish and plants lists\nfish = ['G', 'H', 'J', 'K', 'L']\nplants = ['W', 'X', 'Y', 'Z']\n\n# Create Z3 boolean variables for fish selection\nfish_vars = {f: Bool(f) for f in fish}\n\n# Create Z3 boolean variables for plant selection\nplant_vars = {p: Bool(p) for p in plants}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly three fish selected\nsolver.add(Sum([If(fish_vars[f], 1, 0) for f in fish]) == 3)\n\n# Exactly two plants selected\nsolver.add(Sum([If(plant_vars[p], 1, 0) for p in plants]) == 2)\n\n# If G selected, then neither H nor Y selected\n# G => not H and not Y\nsolver.add(Implies(fish_vars['G'], And(Not(fish_vars['H']), Not(plant_vars['Y']))))\n\n# Cannot select H unless K selected\n# H => K\nsolver.add(Implies(fish_vars['H'], fish_vars['K']))\n\n# Cannot select J unless W selected\n# J => W\nsolver.add(Implies(fish_vars['J'], plant_vars['W']))\n\n# If K selected, must select X\n# K => X\nsolver.add(Implies(fish_vars['K'], plant_vars['X']))\n\n# OPTION CHECKING\noptions = [\n    ('A', ['W', 'X']),\n    ('B', ['W', 'Y']),\n    ('C', ['W', 'Z']),\n    ('D', ['X', 'Y']),\n    ('E', ['X', 'Z'])\n]\n\nfor letter, plant_combo in options:\n    solver.push()\n    # Add constraint that plants selected are exactly the option's plants\n    # First, enforce these two plants are selected\n    for p in plants:\n        if p in plant_combo:\n            solver.add(plant_vars[p] == True)\n        else:\n            solver.add(plant_vars[p] == False)\n    # Check if model is satisfiable with these plants\n    if solver.check() == sat:\n        # This plant combo is possible, so not the answer\n        solver.pop()\n    else:\n        # Not satisfiable, print option letter and break\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A committee ranks five towns—Palmdale, Quietville, Riverdale, Seaside, Tidetown—from first (best) to fifth (worst) on each of three criteria: climate, location, friendliness. For each of the three criteria, none of the five towns receives the same ranking as any other town does. In climate, Tidetown is ranked third, and Seaside fourth. In location, Quietville is ranked second, Riverdale third, Palmdale fourth. In friendliness, Tidetown's ranking is better than Palmdale's, Quietville is ranked fourth and Seaside fifth. Riverdale receives a better ranking in climate than in friendliness. Quietville's three ranking are all different from each other.\n\nWhich of the following is a town that CANNOT be ranked fifth on any one of the three criteria?\n\nOptions:\n(A) Palmdale\n(B) Quietville\n(C) Riverdale\n(D) Seaside\n(E) Tidetown",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntowns = ['Palmdale', 'Quietville', 'Riverdale', 'Seaside', 'Tidetown']\ncriteria = ['climate', 'location', 'friendliness']\n\n# Create variables: rank[town][criterion] = Int variable representing rank 1..5\nrank = {}\nfor t in towns:\n    rank[t] = {}\n    for c in criteria:\n        rank[t][c] = Int(f\"rank_{t}_{c}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each criterion: rankings are from 1 to 5\nfor c in criteria:\n    for t in towns:\n        solver.add(And(rank[t][c] >= 1, rank[t][c] <= 5))\n\n# 2. For each criterion, all towns have distinct rankings\nfor c in criteria:\n    solver.add(Distinct([rank[t][c] for t in towns]))\n\n# 3. In climate:\n# Tidetown is ranked 3\nsolver.add(rank['Tidetown']['climate'] == 3)\n# Seaside is ranked 4\nsolver.add(rank['Seaside']['climate'] == 4)\n\n# 4. In location:\n# Quietville is ranked 2\nsolver.add(rank['Quietville']['location'] == 2)\n# Riverdale is ranked 3\nsolver.add(rank['Riverdale']['location'] == 3)\n# Palmdale is ranked 4\nsolver.add(rank['Palmdale']['location'] == 4)\n\n# 5. In friendliness:\n# Tidetown's ranking is better than Palmdale's (lower number is better)\nsolver.add(rank['Tidetown']['friendliness'] < rank['Palmdale']['friendliness'])\n# Quietville is ranked 4\nsolver.add(rank['Quietville']['friendliness'] == 4)\n# Seaside is ranked 5\nsolver.add(rank['Seaside']['friendliness'] == 5)\n\n# 6. Riverdale receives a better ranking in climate than in friendliness\nsolver.add(rank['Riverdale']['climate'] < rank['Riverdale']['friendliness'])\n\n# 7. Quietville's three rankings are all different from each other\nsolver.add(Distinct([rank['Quietville'][c] for c in criteria]))\n\n# OPTION CHECKING\n\noptions = ['Palmdale', 'Quietville', 'Riverdale', 'Seaside', 'Tidetown']\n\n# We want to find the town that CANNOT be ranked fifth on ANY of the three criteria.\n# For each option, check if there is a solution where that town is ranked 5 in at least one criterion.\n# If no such solution exists, that town cannot be ranked fifth on any criterion, so print its letter.\n\nfor i, town in enumerate(options):\n    solver.push()\n    # Add constraint: town is ranked 5 in at least one criterion\n    fifth_in_any = Or([rank[town][c] == 5 for c in criteria])\n    solver.add(fifth_in_any)\n    if solver.check() == unsat:\n        # No solution where town is ranked 5 in any criterion\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A committee ranks five towns—Palmdale, Quietville, Riverdale, Seaside, Tidetown—from first (best) to fifth (worst) on each of three criteria: climate, location, friendliness. For each of the three criteria, none of the five towns receives the same ranking as any other town does. In climate, Tidetown is ranked third, and Seaside fourth. In location, Quietville is ranked second, Riverdale third, Palmdale fourth. In friendliness, Tidetown's ranking is better than Palmdale's, Quietville is ranked fourth and Seaside fifth. Riverdale receives a better ranking in climate than in friendliness. Quietville's three ranking are all different from each other.\n\nWhich of the following could be true?\n\nOptions:\n(A) Palmdale is ranked first in both climate and friendliness.\n(B) Quietville is ranked second in both climate and location.\n(C) Riverdale is ranked first in climate and third in both location and friendliness.\n(D) Seaside is ranked fifth in friendliness and fourth in both climate and location.\n(E) Tidetown is ranked third in both climate and friendliness.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntowns = ['Palmdale', 'Quietville', 'Riverdale', 'Seaside', 'Tidetown']\ncriteria = ['climate', 'location', 'friendliness']\n\n# Create Z3 Int variables for each town's rank in each criterion (1 to 5)\nrank = {}\nfor c in criteria:\n    for t in towns:\n        rank[(t, c)] = Int(f'rank_{t}_{c}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Rankings are between 1 and 5\nfor c in criteria:\n    for t in towns:\n        solver.add(And(rank[(t, c)] >= 1, rank[(t, c)] <= 5))\n\n# For each criterion, all towns have distinct ranks\nfor c in criteria:\n    solver.add(Distinct([rank[(t, c)] for t in towns]))\n\n# Given fixed rankings:\n# Climate: Tidetown is 3rd, Seaside is 4th\nsolver.add(rank[('Tidetown', 'climate')] == 3)\nsolver.add(rank[('Seaside', 'climate')] == 4)\n\n# Location: Quietville 2nd, Riverdale 3rd, Palmdale 4th\nsolver.add(rank[('Quietville', 'location')] == 2)\nsolver.add(rank[('Riverdale', 'location')] == 3)\nsolver.add(rank[('Palmdale', 'location')] == 4)\n\n# Friendliness: Quietville 4th, Seaside 5th\nsolver.add(rank[('Quietville', 'friendliness')] == 4)\nsolver.add(rank[('Seaside', 'friendliness')] == 5)\n\n# Tidetown's friendliness rank is better (lower) than Palmdale's\nsolver.add(rank[('Tidetown', 'friendliness')] < rank[('Palmdale', 'friendliness')])\n\n# Riverdale better in climate than friendliness\nsolver.add(rank[('Riverdale', 'climate')] < rank[('Riverdale', 'friendliness')])\n\n# Quietville's three rankings all different\nsolver.add(Distinct([rank[('Quietville', c)] for c in criteria]))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Palmdale is ranked first in both climate and friendliness.\n    And(rank[('Palmdale', 'climate')] == 1, rank[('Palmdale', 'friendliness')] == 1),\n    \n    # (B) Quietville is ranked second in both climate and location.\n    And(rank[('Quietville', 'climate')] == 2, rank[('Quietville', 'location')] == 2),\n    \n    # (C) Riverdale is ranked first in climate and third in both location and friendliness.\n    And(rank[('Riverdale', 'climate')] == 1,\n        rank[('Riverdale', 'location')] == 3,\n        rank[('Riverdale', 'friendliness')] == 3),\n    \n    # (D) Seaside is ranked fifth in friendliness and fourth in both climate and location.\n    And(rank[('Seaside', 'friendliness')] == 5,\n        rank[('Seaside', 'climate')] == 4,\n        rank[('Seaside', 'location')] == 4),\n    \n    # (E) Tidetown is ranked third in both climate and friendliness.\n    And(rank[('Tidetown', 'climate')] == 3,\n        rank[('Tidetown', 'friendliness')] == 3)\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A committee ranks five towns—Palmdale, Quietville, Riverdale, Seaside, Tidetown—from first (best) to fifth (worst) on each of three criteria: climate, location, friendliness. For each of the three criteria, none of the five towns receives the same ranking as any other town does. In climate, Tidetown is ranked third, and Seaside fourth. In location, Quietville is ranked second, Riverdale third, Palmdale fourth. In friendliness, Tidetown's ranking is better than Palmdale's, Quietville is ranked fourth and Seaside fifth. Riverdale receives a better ranking in climate than in friendliness. Quietville's three ranking are all different from each other.\n\nIf Quietville is ranked first in climate, then it must be true that\n\nOptions:\n(A) Palmdale is ranked second in climate\n(B) Palmdale is ranked third in friendliness\n(C) Riverdale is ranked second in friendliness\n(D) Riverdale is ranked third in friendliness\n(E) Tidetown is ranked fifth in location",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntowns = ['Palmdale', 'Quietville', 'Riverdale', 'Seaside', 'Tidetown']\ncriteria = ['climate', 'location', 'friendliness']\n\n# Create variables: rank[town][criterion] = rank (1 to 5)\nrank = {}\nfor t in towns:\n    rank[t] = {}\n    for c in criteria:\n        rank[t][c] = Int(f\"rank_{t}_{c}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank is between 1 and 5\nfor t in towns:\n    for c in criteria:\n        solver.add(And(rank[t][c] >= 1, rank[t][c] <= 5))\n\n# For each criterion, all towns have distinct ranks\nfor c in criteria:\n    solver.add(Distinct([rank[t][c] for t in towns]))\n\n# Given fixed ranks\nsolver.add(rank['Tidetown']['climate'] == 3)\nsolver.add(rank['Seaside']['climate'] == 4)\n\nsolver.add(rank['Quietville']['location'] == 2)\nsolver.add(rank['Riverdale']['location'] == 3)\nsolver.add(rank['Palmdale']['location'] == 4)\n\nsolver.add(rank['Quietville']['friendliness'] == 4)\nsolver.add(rank['Seaside']['friendliness'] == 5)\n\n# Tidetown's friendliness ranking better than Palmdale's\nsolver.add(rank['Tidetown']['friendliness'] < rank['Palmdale']['friendliness'])\n\n# Riverdale receives better ranking in climate than in friendliness\nsolver.add(rank['Riverdale']['climate'] < rank['Riverdale']['friendliness'])\n\n# Quietville's three rankings are all different\nsolver.add(Distinct([rank['Quietville'][c] for c in criteria]))\n\n# OPTION CHECKING\n# Condition: Quietville is ranked first in climate\nsolver.push()\nsolver.add(rank['Quietville']['climate'] == 1)\n\noptions = [\n    rank['Palmdale']['climate'] == 2,        # A\n    rank['Palmdale']['friendliness'] == 3,   # B\n    rank['Riverdale']['friendliness'] == 2,  # C\n    rank['Riverdale']['friendliness'] == 3,  # D\n    rank['Tidetown']['location'] == 5        # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()\nsolver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A committee ranks five towns—Palmdale, Quietville, Riverdale, Seaside, Tidetown—from first (best) to fifth (worst) on each of three criteria: climate, location, friendliness. For each of the three criteria, none of the five towns receives the same ranking as any other town does. In climate, Tidetown is ranked third, and Seaside fourth. In location, Quietville is ranked second, Riverdale third, Palmdale fourth. In friendliness, Tidetown's ranking is better than Palmdale's, Quietville is ranked fourth and Seaside fifth. Riverdale receives a better ranking in climate than in friendliness. Quietville's three ranking are all different from each other.\n\nIf Palmdale is ranked second in climate, then which one of the following can be true?\n\nOptions:\n(A) Palmdale is ranked second in friendliness.\n(B) Quietville is ranked first in climate.\n(C) Riverdale is ranked first in friendliness.\n(D) Riverdale is ranked fifth in climate.\n(E) Tidetown is ranked third in friendliness.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntowns = ['Palmdale', 'Quietville', 'Riverdale', 'Seaside', 'Tidetown']\ncriteria = ['climate', 'location', 'friendliness']\n\n# Create indices for towns and criteria\ntown_idx = {town: i for i, town in enumerate(towns)}\ncrit_idx = {crit: i for i, crit in enumerate(criteria)}\n\n# For each town and criterion, create a Z3 Int variable representing the rank (1 to 5)\nrank = {}\nfor t in towns:\n    for c in criteria:\n        rank[(t, c)] = Int(f\"rank_{t}_{c}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank is between 1 and 5\nfor t in towns:\n    for c in criteria:\n        solver.add(And(rank[(t, c)] >= 1, rank[(t, c)] <= 5))\n\n# For each criterion, all towns have distinct ranks\nfor c in criteria:\n    solver.add(Distinct([rank[(t, c)] for t in towns]))\n\n# Given fixed ranks:\n# Climate: Tidetown is 3rd, Seaside is 4th\nsolver.add(rank[('Tidetown', 'climate')] == 3)\nsolver.add(rank[('Seaside', 'climate')] == 4)\n\n# Location: Quietville is 2nd, Riverdale 3rd, Palmdale 4th\nsolver.add(rank[('Quietville', 'location')] == 2)\nsolver.add(rank[('Riverdale', 'location')] == 3)\nsolver.add(rank[('Palmdale', 'location')] == 4)\n\n# Friendliness: Quietville is 4th, Seaside is 5th\nsolver.add(rank[('Quietville', 'friendliness')] == 4)\nsolver.add(rank[('Seaside', 'friendliness')] == 5)\n\n# Tidetown's friendliness ranking is better than Palmdale's (lower number is better)\nsolver.add(rank[('Tidetown', 'friendliness')] < rank[('Palmdale', 'friendliness')])\n\n# Riverdale receives a better ranking in climate than in friendliness\nsolver.add(rank[('Riverdale', 'climate')] < rank[('Riverdale', 'friendliness')])\n\n# Quietville's three rankings are all different\nsolver.add(Distinct([rank[('Quietville', c)] for c in criteria]))\n\n# Additional given condition for the question: Palmdale is ranked 2nd in climate\nsolver.add(rank[('Palmdale', 'climate')] == 2)\n\n# OPTION CHECKING\n# Options:\n# (A) Palmdale is ranked second in friendliness.\n# (B) Quietville is ranked first in climate.\n# (C) Riverdale is ranked first in friendliness.\n# (D) Riverdale is ranked fifth in climate.\n# (E) Tidetown is ranked third in friendliness.\n\noptions = [\n    rank[('Palmdale', 'friendliness')] == 2,\n    rank[('Quietville', 'climate')] == 1,\n    rank[('Riverdale', 'friendliness')] == 1,\n    rank[('Riverdale', 'climate')] == 5,\n    rank[('Tidetown', 'friendliness')] == 3\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A committee ranks five towns—Palmdale, Quietville, Riverdale, Seaside, Tidetown—from first (best) to fifth (worst) on each of three criteria: climate, location, friendliness. For each of the three criteria, none of the five towns receives the same ranking as any other town does. In climate, Tidetown is ranked third, and Seaside fourth. In location, Quietville is ranked second, Riverdale third, Palmdale fourth. In friendliness, Tidetown's ranking is better than Palmdale's, Quietville is ranked fourth and Seaside fifth. Riverdale receives a better ranking in climate than in friendliness. Quietville's three ranking are all different from each other.\n\nIf Tidetown is ranked first in location and Riverdale is ranked second in friendliness, then it is possible to deduce with certainty all three rankings for exactly how many of the towns?\n\nOptions:\n(A) One\n(B) Two\n(C) Three\n(D) Four\n(E) Five",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntowns = ['Palmdale', 'Quietville', 'Riverdale', 'Seaside', 'Tidetown']\ncriteria = ['climate', 'location', 'friendliness']\n\n# Create variables: rank[town][criterion] = rank (1 to 5)\nrank = dict()\nfor t in towns:\n    rank[t] = dict()\n    for c in criteria:\n        rank[t][c] = Int(f\"rank_{t}_{c}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank is between 1 and 5\nfor t in towns:\n    for c in criteria:\n        solver.add(And(rank[t][c] >= 1, rank[t][c] <= 5))\n\n# For each criterion, all towns have distinct ranks\nfor c in criteria:\n    solver.add(Distinct([rank[t][c] for t in towns]))\n\n# Given fixed ranks:\n# Climate: Tidetown=3, Seaside=4\nsolver.add(rank['Tidetown']['climate'] == 3)\nsolver.add(rank['Seaside']['climate'] == 4)\n\n# Location: Quietville=2, Riverdale=3, Palmdale=4\nsolver.add(rank['Quietville']['location'] == 2)\nsolver.add(rank['Riverdale']['location'] == 3)\nsolver.add(rank['Palmdale']['location'] == 4)\n\n# Friendliness: Quietville=4, Seaside=5\nsolver.add(rank['Quietville']['friendliness'] == 4)\nsolver.add(rank['Seaside']['friendliness'] == 5)\n\n# Friendliness: Tidetown's ranking better (lower) than Palmdale's\nsolver.add(rank['Tidetown']['friendliness'] < rank['Palmdale']['friendliness'])\n\n# Riverdale better in climate than in friendliness\nsolver.add(rank['Riverdale']['climate'] < rank['Riverdale']['friendliness'])\n\n# Quietville's three rankings all different\nsolver.add(Distinct([rank['Quietville'][c] for c in criteria]))\n\n# Additional given for the question:\n# Tidetown is ranked 1 in location\nsolver.add(rank['Tidetown']['location'] == 1)\n\n# Riverdale is ranked 2 in friendliness\nsolver.add(rank['Riverdale']['friendliness'] == 2)\n\n# OPTION CHECKING\n# Options: number of towns whose all three rankings are deducible with certainty\n\noptions = [1, 2, 3, 4, 5]\n\n# We want to find how many towns have all three ranks fixed by the constraints\n# To do this, for each town, check if the three ranks are uniquely determined\n\ndef is_unique(town):\n    # Check if the triple of ranks for this town is unique under the constraints\n    # Get model for current constraints\n    if solver.check() != sat:\n        return False\n    m = solver.model()\n    # Extract current ranks for the town\n    current_ranks = [m.eval(rank[town][c]).as_long() for c in criteria]\n\n    # Add constraint that at least one rank differs\n    diff_constraints = []\n    for i, c in enumerate(criteria):\n        diff_constraints.append(rank[town][c] != current_ranks[i])\n    solver.push()\n    solver.add(Or(diff_constraints))\n    res = solver.check()\n    solver.pop()\n    # If no other solution with different ranks, then unique\n    return res == unsat\n\n# Count how many towns have unique triple ranks\nunique_count = 0\nfor t in towns:\n    if is_unique(t):\n        unique_count += 1\n\n# Print the letter corresponding to the unique_count\n# Mapping: 1->A, 2->B, 3->C, 4->D, 5->E\nanswer_letter = chr(ord('A') + unique_count - 1)\nprint(f\"'{answer_letter}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A committee ranks five towns—Palmdale, Quietville, Riverdale, Seaside, Tidetown—from first (best) to fifth (worst) on each of three criteria: climate, location, friendliness. For each of the three criteria, none of the five towns receives the same ranking as any other town does. In climate, Tidetown is ranked third, and Seaside fourth. In location, Quietville is ranked second, Riverdale third, Palmdale fourth. In friendliness, Tidetown's ranking is better than Palmdale's, Quietville is ranked fourth and Seaside fifth. Riverdale receives a better ranking in climate than in friendliness. Quietville's three ranking are all different from each other.\n\nWhich one of the following statements CANNOT be true?\n\nOptions:\n(A) Palmdale is ranked first in climate.\n(B) Quietville is ranked fifth in climate.\n(C) Riverdale is ranked third in friendliness.\n(D) Seaside is ranked first in location.\n(E) Tidetown is ranked second in friendliness.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntowns = ['Palmdale', 'Quietville', 'Riverdale', 'Seaside', 'Tidetown']\ncriteria = ['climate', 'location', 'friendliness']\n\n# Create variables: rank[town][criterion] = Int rank 1..5\nrank = {}\nfor t in towns:\n    rank[t] = {}\n    for c in criteria:\n        rank[t][c] = Int(f'rank_{t}_{c}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Ranks are between 1 and 5\nfor t in towns:\n    for c in criteria:\n        solver.add(And(rank[t][c] >= 1, rank[t][c] <= 5))\n\n# 2. For each criterion, all towns have distinct ranks\nfor c in criteria:\n    solver.add(Distinct([rank[t][c] for t in towns]))\n\n# 3. Given specific ranks:\n# Climate: Tidetown=3, Seaside=4\nsolver.add(rank['Tidetown']['climate'] == 3)\nsolver.add(rank['Seaside']['climate'] == 4)\n\n# Location: Quietville=2, Riverdale=3, Palmdale=4\nsolver.add(rank['Quietville']['location'] == 2)\nsolver.add(rank['Riverdale']['location'] == 3)\nsolver.add(rank['Palmdale']['location'] == 4)\n\n# Friendliness: Quietville=4, Seaside=5\nsolver.add(rank['Quietville']['friendliness'] == 4)\nsolver.add(rank['Seaside']['friendliness'] == 5)\n\n# Tidetown's friendliness rank better than Palmdale's (lower number is better)\nsolver.add(rank['Tidetown']['friendliness'] < rank['Palmdale']['friendliness'])\n\n# Riverdale's climate rank better than friendliness rank\nsolver.add(rank['Riverdale']['climate'] < rank['Riverdale']['friendliness'])\n\n# Quietville's three rankings are all different from each other\nsolver.add(Distinct([rank['Quietville'][c] for c in criteria]))\n\n# OPTION CHECKING\noptions = [\n    ('A', rank['Palmdale']['climate'] == 1),\n    ('B', rank['Quietville']['climate'] == 5),\n    ('C', rank['Riverdale']['friendliness'] == 3),\n    ('D', rank['Seaside']['location'] == 1),\n    ('E', rank['Tidetown']['friendliness'] == 2)\n]\n\nfor letter, option_constraint in options:\n    solver.push()\n    # Add option-specific constraint\n    solver.add(option_constraint)\n    # Check satisfiability\n    if solver.check() == unsat:\n        # This option cannot be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Petworld has exactly fourteen animals (three gerbils, three hamsters, three lizards, five snakes) that are kept in four separate cages (W, X, Y, Z) according to the following conditions: Each cage contains exactly two, four, or six animals. Any cage containing a gerbil also contains at least one hamster; any cage containing a hamster also contains at least one gerbil. Any cage containing a lizard also contains at least one snake; any cage containing a snake also contains at least one lizard. Neither cage Y nor cage Z contains a gerbil. Neither cage W nor cage X contains a lizard.\n\nWhich one of the following could be a complete and accurate list of the animals kept in cages W and Y?\n\nOptions:\n(A) W: one gerbil and one hamster Y: two lizards and two snakes\n(B) W: one gerbil and two hamsters Y: one lizard and three snakes\n(C) W: two gerbils and two hamsters Y: one lizard and four snakes\n(D) W: two gerbils and two hamsters Y: three lizards and one snake\n(E) W: two gerbils and two lizards Y: two hamsters and two snakes",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Animals and cages\nanimals = ['gerbil', 'hamster', 'lizard', 'snake']\ncages = ['W', 'X', 'Y', 'Z']\n\n# Total counts of each animal\ntotal_animals = {'gerbil': 3, 'hamster': 3, 'lizard': 3, 'snake': 5}\n\n# Each cage can have a count of each animal: integer variables\n# cage_animals[cage][animal] = number of that animal in that cage\ncage_animals = {}\nfor c in cages:\n    cage_animals[c] = {}\n    for a in animals:\n        cage_animals[c][a] = Int(f'{c}_{a}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each cage contains exactly 2, 4, or 6 animals\nfor c in cages:\n    total_in_cage = Sum([cage_animals[c][a] for a in animals])\n    solver.add(Or(total_in_cage == 2, total_in_cage == 4, total_in_cage == 6))\n\n# 2. Total animals sum to the given counts\nfor a in animals:\n    total_for_a = Sum([cage_animals[c][a] for c in cages])\n    solver.add(total_for_a == total_animals[a])\n\n# 3. All counts are >=0 and integers (already Int)\nfor c in cages:\n    for a in animals:\n        solver.add(cage_animals[c][a] >= 0)\n\n# 4. Any cage containing a gerbil also contains at least one hamster\n# 5. Any cage containing a hamster also contains at least one gerbil\nfor c in cages:\n    g = cage_animals[c]['gerbil']\n    h = cage_animals[c]['hamster']\n    solver.add(Implies(g > 0, h >= 1))\n    solver.add(Implies(h > 0, g >= 1))\n\n# 6. Any cage containing a lizard also contains at least one snake\n# 7. Any cage containing a snake also contains at least one lizard\nfor c in cages:\n    l = cage_animals[c]['lizard']\n    s = cage_animals[c]['snake']\n    solver.add(Implies(l > 0, s >= 1))\n    solver.add(Implies(s > 0, l >= 1))\n\n# 8. Neither cage Y nor cage Z contains a gerbil\nsolver.add(cage_animals['Y']['gerbil'] == 0)\nsolver.add(cage_animals['Z']['gerbil'] == 0)\n\n# 9. Neither cage W nor cage X contains a lizard\nsolver.add(cage_animals['W']['lizard'] == 0)\nsolver.add(cage_animals['X']['lizard'] == 0)\n\n# OPTION CHECKING\n\noptions = [\n    # (W_gerbils, W_hamsters, W_lizards, W_snakes, Y_gerbils, Y_hamsters, Y_lizards, Y_snakes)\n    # Option A: W: 1 gerbil, 1 hamster; Y: 2 lizards, 2 snakes\n    {'W': {'gerbil': 1, 'hamster': 1, 'lizard': 0, 'snake': 0},\n     'Y': {'gerbil': 0, 'hamster': 0, 'lizard': 2, 'snake': 2}},\n    # Option B: W: 1 gerbil, 2 hamsters; Y: 1 lizard, 3 snakes\n    {'W': {'gerbil': 1, 'hamster': 2, 'lizard': 0, 'snake': 0},\n     'Y': {'gerbil': 0, 'hamster': 0, 'lizard': 1, 'snake': 3}},\n    # Option C: W: 2 gerbils, 2 hamsters; Y: 1 lizard, 4 snakes\n    {'W': {'gerbil': 2, 'hamster': 2, 'lizard': 0, 'snake': 0},\n     'Y': {'gerbil': 0, 'hamster': 0, 'lizard': 1, 'snake': 4}},\n    # Option D: W: 2 gerbils, 2 hamsters; Y: 3 lizards, 1 snake\n    {'W': {'gerbil': 2, 'hamster': 2, 'lizard': 0, 'snake': 0},\n     'Y': {'gerbil': 0, 'hamster': 0, 'lizard': 3, 'snake': 1}},\n    # Option E: W: 2 gerbils, 2 lizards; Y: 2 hamsters, 2 snakes\n    {'W': {'gerbil': 2, 'hamster': 0, 'lizard': 2, 'snake': 0},\n     'Y': {'gerbil': 0, 'hamster': 2, 'lizard': 0, 'snake': 2}}\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Fix W cage animals as per option\n    for a in animals:\n        solver.add(cage_animals['W'][a] == option['W'][a])\n    # Fix Y cage animals as per option\n    for a in animals:\n        solver.add(cage_animals['Y'][a] == option['Y'][a])\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Petworld has exactly fourteen animals (three gerbils, three hamsters, three lizards, five snakes) that are kept in four separate cages (W, X, Y, Z) according to the following conditions: Each cage contains exactly two, four, or six animals. Any cage containing a gerbil also contains at least one hamster; any cage containing a hamster also contains at least one gerbil. Any cage containing a lizard also contains at least one snake; any cage containing a snake also contains at least one lizard. Neither cage Y nor cage Z contains a gerbil. Neither cage W nor cage X contains a lizard.\n\nIf there are exactly two hamsters in cage W and the number of gerbils in cage X is equal to the number of snakes in cage Y, then the number of snakes in cage Z must be exactly\n\nOptions:\n(A) one\n(B) two\n(C) three\n(D) four\n(E) five",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Animals and cages\nanimals = ['gerbil', 'hamster', 'lizard', 'snake']\ncages = ['W', 'X', 'Y', 'Z']\n\n# Total animals per type\ntotal_animals = {\n    'gerbil': 3,\n    'hamster': 3,\n    'lizard': 3,\n    'snake': 5\n}\n\n# Cage capacities allowed\nallowed_cage_sizes = [2, 4, 6]\n\n# Create variables: number of each animal in each cage\n# Variables are Ints >=0\nG = {c: Int(f'G_{c}') for c in cages}  # gerbils\nH = {c: Int(f'H_{c}') for c in cages}  # hamsters\nL = {c: Int(f'L_{c}') for c in cages}  # lizards\nS = {c: Int(f'S_{c}') for c in cages}  # snakes\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each animal count in cage >=0\nfor c in cages:\n    solver.add(G[c] >= 0, H[c] >= 0, L[c] >= 0, S[c] >= 0)\n\n# 2) Total animals per type sum to total given\nsolver.add(Sum([G[c] for c in cages]) == total_animals['gerbil'])\nsolver.add(Sum([H[c] for c in cages]) == total_animals['hamster'])\nsolver.add(Sum([L[c] for c in cages]) == total_animals['lizard'])\nsolver.add(Sum([S[c] for c in cages]) == total_animals['snake'])\n\n# 3) Each cage contains exactly 2,4, or 6 animals\nfor c in cages:\n    total_in_cage = G[c] + H[c] + L[c] + S[c]\n    solver.add(Or([total_in_cage == size for size in allowed_cage_sizes]))\n\n# 4) Any cage containing a gerbil also contains at least one hamster; and vice versa\nfor c in cages:\n    # If gerbils > 0 then hamsters >= 1\n    solver.add(Implies(G[c] > 0, H[c] >= 1))\n    # If hamsters > 0 then gerbils >= 1\n    solver.add(Implies(H[c] > 0, G[c] >= 1))\n\n# 5) Any cage containing a lizard also contains at least one snake; and vice versa\nfor c in cages:\n    solver.add(Implies(L[c] > 0, S[c] >= 1))\n    solver.add(Implies(S[c] > 0, L[c] >= 1))\n\n# 6) Neither cage Y nor Z contains a gerbil\nsolver.add(G['Y'] == 0)\nsolver.add(G['Z'] == 0)\n\n# 7) Neither cage W nor X contains a lizard\nsolver.add(L['W'] == 0)\nsolver.add(L['X'] == 0)\n\n# 8) Given conditions:\n# Exactly two hamsters in cage W\nsolver.add(H['W'] == 2)\n\n# Number of gerbils in cage X equals number of snakes in cage Y\nsolver.add(G['X'] == S['Y'])\n\n# OPTION CHECKING\noptions = {\n    'A': 1,\n    'B': 2,\n    'C': 3,\n    'D': 4,\n    'E': 5\n}\n\nfor letter, snakes_in_Z in options.items():\n    solver.push()\n    solver.add(S['Z'] == snakes_in_Z)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Petworld has exactly fourteen animals (three gerbils, three hamsters, three lizards, five snakes) that are kept in four separate cages (W, X, Y, Z) according to the following conditions: Each cage contains exactly two, four, or six animals. Any cage containing a gerbil also contains at least one hamster; any cage containing a hamster also contains at least one gerbil. Any cage containing a lizard also contains at least one snake; any cage containing a snake also contains at least one lizard. Neither cage Y nor cage Z contains a gerbil. Neither cage W nor cage X contains a lizard.\n\nIf cage Z contains exactly twice as many lizards as cage Y, which one of the following can be true?\n\nOptions:\n(A) Cage Y contains exactly two lizards.\n(B) Cage Y contains exactly two snakes.\n(C) Cage Y contains exactly four animals.\n(D) Cage Z contains exactly three snakes.\n(E) Cage Z contains exactly two animals.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncages = ['W', 'X', 'Y', 'Z']\nanimal_types = ['gerbil', 'hamster', 'lizard', 'snake']\n\n# Total animals per type\ntotal_animals = {'gerbil': 3, 'hamster': 3, 'lizard': 3, 'snake': 5}\n\n# Allowed cage sizes\nallowed_sizes = [2, 4, 6]\n\n# Create variables: number of each animal type in each cage\nanimals = {}\nfor c in cages:\n    for a in animal_types:\n        animals[(c, a)] = Int(f'{c}_{a}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each count >= 0\nfor c in cages:\n    for a in animal_types:\n        solver.add(animals[(c, a)] >= 0)\n\n# Sum of each animal type across cages equals total\nfor a in animal_types:\n    solver.add(Sum([animals[(c, a)] for c in cages]) == total_animals[a])\n\n# Each cage contains exactly 2, 4, or 6 animals\nfor c in cages:\n    total_in_cage = Sum([animals[(c, a)] for a in animal_types])\n    solver.add(Or([total_in_cage == size for size in allowed_sizes]))\n\n# Any cage containing a gerbil also contains at least one hamster\n# and any cage containing a hamster also contains at least one gerbil\nfor c in cages:\n    gerbils = animals[(c, 'gerbil')]\n    hamsters = animals[(c, 'hamster')]\n    # If gerbils > 0 then hamsters > 0\n    solver.add(Implies(gerbils > 0, hamsters > 0))\n    # If hamsters > 0 then gerbils > 0\n    solver.add(Implies(hamsters > 0, gerbils > 0))\n\n# Any cage containing a lizard also contains at least one snake\n# and any cage containing a snake also contains at least one lizard\nfor c in cages:\n    lizards = animals[(c, 'lizard')]\n    snakes = animals[(c, 'snake')]\n    # If lizards > 0 then snakes > 0\n    solver.add(Implies(lizards > 0, snakes > 0))\n    # If snakes > 0 then lizards > 0\n    solver.add(Implies(snakes > 0, lizards > 0))\n\n# Neither cage Y nor cage Z contains a gerbil\nsolver.add(animals[('Y', 'gerbil')] == 0)\nsolver.add(animals[('Z', 'gerbil')] == 0)\n\n# Neither cage W nor cage X contains a lizard\nsolver.add(animals[('W', 'lizard')] == 0)\nsolver.add(animals[('X', 'lizard')] == 0)\n\n# Cage Z contains exactly twice as many lizards as cage Y\nsolver.add(animals[('Z', 'lizard')] == 2 * animals[('Y', 'lizard')])\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Cage Y contains exactly two lizards.\n    (animals[('Y', 'lizard')] == 2),\n    # (B) Cage Y contains exactly two snakes.\n    (animals[('Y', 'snake')] == 2),\n    # (C) Cage Y contains exactly four animals.\n    (Sum([animals[('Y', a)] for a in animal_types]) == 4),\n    # (D) Cage Z contains exactly three snakes.\n    (animals[('Z', 'snake')] == 3),\n    # (E) Cage Z contains exactly two animals.\n    (Sum([animals[('Z', a)] for a in animal_types]) == 2),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Petworld has exactly fourteen animals (three gerbils, three hamsters, three lizards, five snakes) that are kept in four separate cages (W, X, Y, Z) according to the following conditions: Each cage contains exactly two, four, or six animals. Any cage containing a gerbil also contains at least one hamster; any cage containing a hamster also contains at least one gerbil. Any cage containing a lizard also contains at least one snake; any cage containing a snake also contains at least one lizard. Neither cage Y nor cage Z contains a gerbil. Neither cage W nor cage X contains a lizard.\n\nIf the number of animals in cage W is equal to the number of animals in cage Z, then which one of the following can be true?\n\nOptions:\n(A) Cage W contains exactly six animals.\n(B) Cage X contains exactly six animals.\n(C) Cage Y contains exactly one snake.\n(D) Cage Y contains exactly three snakes.\n(E) Cage Z contains exactly four snakes.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncages = ['W', 'X', 'Y', 'Z']\nanimals = ['gerbil', 'hamster', 'lizard', 'snake']\n\n# Total animals per species\ntotal_animals = {'gerbil': 3, 'hamster': 3, 'lizard': 3, 'snake': 5}\n\n# Allowed cage sizes\nallowed_sizes = [2, 4, 6]\n\n# For each cage and each animal, define how many animals of that type are in that cage\n# Variables: cage_animal_counts[cage][animal] = Int variable >= 0\ncage_animal_counts = {}\nfor c in cages:\n    cage_animal_counts[c] = {}\n    for a in animals:\n        cage_animal_counts[c][a] = Int(f'{c}_{a}')\n        \nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each cage contains exactly 2, 4, or 6 animals\nfor c in cages:\n    total_in_cage = Sum([cage_animal_counts[c][a] for a in animals])\n    solver.add(Or([total_in_cage == size for size in allowed_sizes]))\n\n# 2) Total animals per species sum to their total counts\nfor a in animals:\n    total_of_a = Sum([cage_animal_counts[c][a] for c in cages])\n    solver.add(total_of_a == total_animals[a])\n\n# 3) All counts are >= 0\nfor c in cages:\n    for a in animals:\n        solver.add(cage_animal_counts[c][a] >= 0)\n\n# 4) If a cage contains gerbil(s), it must contain at least one hamster; and vice versa\n# For each cage c:\n# (gerbil > 0) => (hamster >= 1)\n# (hamster > 0) => (gerbil >= 1)\nfor c in cages:\n    gerb = cage_animal_counts[c]['gerbil']\n    ham = cage_animal_counts[c]['hamster']\n    solver.add(Implies(gerb > 0, ham >= 1))\n    solver.add(Implies(ham > 0, gerb >= 1))\n\n# 5) If a cage contains lizard(s), it must contain at least one snake; and vice versa\nfor c in cages:\n    liz = cage_animal_counts[c]['lizard']\n    snk = cage_animal_counts[c]['snake']\n    solver.add(Implies(liz > 0, snk >= 1))\n    solver.add(Implies(snk > 0, liz >= 1))\n\n# 6) Neither cage Y nor cage Z contains a gerbil\nsolver.add(cage_animal_counts['Y']['gerbil'] == 0)\nsolver.add(cage_animal_counts['Z']['gerbil'] == 0)\n\n# 7) Neither cage W nor cage X contains a lizard\nsolver.add(cage_animal_counts['W']['lizard'] == 0)\nsolver.add(cage_animal_counts['X']['lizard'] == 0)\n\n# 8) The number of animals in cage W equals the number in cage Z\ntotal_W = Sum([cage_animal_counts['W'][a] for a in animals])\ntotal_Z = Sum([cage_animal_counts['Z'][a] for a in animals])\nsolver.add(total_W == total_Z)\n\n# OPTION CHECKING\n\n# (A) Cage W contains exactly six animals.\nsolver.push()\nsolver.add(total_W == 6)\nif solver.check() == sat:\n    print(\"'A'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (B) Cage X contains exactly six animals.\nsolver.push()\ntotal_X = Sum([cage_animal_counts['X'][a] for a in animals])\nsolver.add(total_X == 6)\nif solver.check() == sat:\n    print(\"'B'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (C) Cage Y contains exactly one snake.\nsolver.push()\nsolver.add(cage_animal_counts['Y']['snake'] == 1)\nif solver.check() == sat:\n    print(\"'C'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (D) Cage Y contains exactly three snakes.\nsolver.push()\nsolver.add(cage_animal_counts['Y']['snake'] == 3)\nif solver.check() == sat:\n    print(\"'D'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (E) Cage Z contains exactly four snakes.\nsolver.push()\nsolver.add(cage_animal_counts['Z']['snake'] == 4)\nif solver.check() == sat:\n    print(\"'E'\")\n    solver.pop()\nelse:\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Petworld has exactly fourteen animals (three gerbils, three hamsters, three lizards, five snakes) that are kept in four separate cages (W, X, Y, Z) according to the following conditions: Each cage contains exactly two, four, or six animals. Any cage containing a gerbil also contains at least one hamster; any cage containing a hamster also contains at least one gerbil. Any cage containing a lizard also contains at least one snake; any cage containing a snake also contains at least one lizard. Neither cage Y nor cage Z contains a gerbil. Neither cage W nor cage X contains a lizard.\n\nIf cage Y contains six animals, which one of the following must be true?\n\nOptions:\n(A) Cage W contains two gerbils.\n(B) Cage X contains four animals.\n(C) Cage Z contains two snakes.\n(D) The number of snakes in cage Y is equal to the number of lizards in cage Y.\n(E) The number of snakes in cage Z is equal to the number of lizards in cage Z.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Animals: gerbils (G), hamsters (H), lizards (L), snakes (S)\n# Cages: W, X, Y, Z\n\ncages = ['W', 'X', 'Y', 'Z']\nanimal_types = ['G', 'H', 'L', 'S']\n\n# Total animals per type\ntotal_animals = {'G': 3, 'H': 3, 'L': 3, 'S': 5}\n\n# Allowed cage sizes\nallowed_sizes = [2, 4, 6]\n\n# Create variables: number of each animal type in each cage\n# Variables are Ints >=0\nanimals = {}\nfor c in cages:\n    for a in animal_types:\n        animals[(c, a)] = Int(f'{c}_{a}')\n        \n# Create variable for total animals in each cage\ntotal_in_cage = {}\nfor c in cages:\n    total_in_cage[c] = Int(f'total_{c}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each cage contains exactly 2,4, or 6 animals\nfor c in cages:\n    solver.add(Or([total_in_cage[c] == size for size in allowed_sizes]))\n\n# Total animals in each cage = sum of animals in that cage\nfor c in cages:\n    sum_animals = Sum([animals[(c,a)] for a in animal_types])\n    solver.add(total_in_cage[c] == sum_animals)\n\n# Number of each animal type across all cages = total animals of that type\nfor a in animal_types:\n    sum_type = Sum([animals[(c,a)] for c in cages])\n    solver.add(sum_type == total_animals[a])\n\n# All animal counts >= 0\nfor c in cages:\n    for a in animal_types:\n        solver.add(animals[(c,a)] >= 0)\n\n# Each animal count is integer (already Int)\n\n# Constraints on gerbils and hamsters per cage\n# Any cage with gerbil >=1 => hamster >=1\n# Any cage with hamster >=1 => gerbil >=1\nfor c in cages:\n    g = animals[(c,'G')]\n    h = animals[(c,'H')]\n    # If gerbil>0 then hamster>0\n    solver.add(Implies(g > 0, h > 0))\n    # If hamster>0 then gerbil>0\n    solver.add(Implies(h > 0, g > 0))\n\n# Constraints on lizards and snakes per cage\n# Any cage with lizard >=1 => snake >=1\n# Any cage with snake >=1 => lizard >=1\nfor c in cages:\n    l = animals[(c,'L')]\n    s = animals[(c,'S')]\n    solver.add(Implies(l > 0, s > 0))\n    solver.add(Implies(s > 0, l > 0))\n\n# Neither cage Y nor Z contains a gerbil\nsolver.add(animals[('Y','G')] == 0)\nsolver.add(animals[('Z','G')] == 0)\n\n# Neither cage W nor X contains a lizard\nsolver.add(animals[('W','L')] == 0)\nsolver.add(animals[('X','L')] == 0)\n\n# Given condition: Cage Y contains 6 animals\nsolver.add(total_in_cage['Y'] == 6)\n\n# OPTION CHECKING\n# Options:\n# (A) Cage W contains two gerbils.\n# (B) Cage X contains four animals.\n# (C) Cage Z contains two snakes.\n# (D) The number of snakes in cage Y equals the number of lizards in cage Y.\n# (E) The number of snakes in cage Z equals the number of lizards in cage Z.\n\noptions = []\n\n# Option A: Cage W contains exactly 2 gerbils\noptA = (animals[('W','G')] == 2)\noptions.append(optA)\n\n# Option B: Cage X contains 4 animals\noptB = (total_in_cage['X'] == 4)\noptions.append(optB)\n\n# Option C: Cage Z contains 2 snakes\noptC = (animals[('Z','S')] == 2)\noptions.append(optC)\n\n# Option D: Number of snakes in Y equals number of lizards in Y\noptD = (animals[('Y','S')] == animals[('Y','L')])\noptions.append(optD)\n\n# Option E: Number of snakes in Z equals number of lizards in Z\noptE = (animals[('Z','S')] == animals[('Z','L')])\noptions.append(optE)\n\n# We test each option by adding its negation and checking for unsat\n# The option whose negation causes unsat is the one that must be true\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(Not(opt))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A soft drink manufacturer surveyed consumer preferences for exactly seven proposed names for its new soda: Jazz, Kola, Luck, Mist, Nipi, Oboy, and Ping. The manufacturer ranked the seven names according to the number of votes they received. The name that received the most votes was ranked first. Every name received a different number of votes. Some of the survey results are as follows: Jazz received more votes than Oboy. Oboy received more votes than Kola. Kola received more votes than Mist. Nipi did not receive the fewest votes. Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy.\n\nWhich one of the following could be an accurate list of the seven names in rank order from first through seventh?\n\nOptions:\n(A) Jazz, Luck, Ping, Nipi, Kola, Oboy, Mist\n(B) Jazz, Luck, Ping, Oboy, Kola, Mist, Nipi\n(C) Luck, Ping, Jazz, Nipi, Oboy, Kola, Mist\n(D) Luck, Ping, Nipi, Oboy, Jazz, Kola, Mist\n(E) Ping, Luck, Jazz, Oboy, Nipi, Kola, Mist",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nnames = ['Jazz', 'Kola', 'Luck', 'Mist', 'Nipi', 'Oboy', 'Ping']\nname_vars = {name: Int(name) for name in names}  # rank variables: 1 (most votes) to 7 (fewest votes)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each name has a rank between 1 and 7\nfor name in names:\n    solver.add(And(name_vars[name] >= 1, name_vars[name] <= 7))\n\n# All ranks are distinct\nsolver.add(Distinct([name_vars[name] for name in names]))\n\n# Given conditions:\n\n# Jazz received more votes than Oboy -> Jazz ranked higher (smaller number) than Oboy\nsolver.add(name_vars['Jazz'] < name_vars['Oboy'])\n\n# Oboy received more votes than Kola\nsolver.add(name_vars['Oboy'] < name_vars['Kola'])\n\n# Kola received more votes than Mist\nsolver.add(name_vars['Kola'] < name_vars['Mist'])\n\n# Nipi did not receive the fewest votes -> Nipi's rank is not 7\nsolver.add(name_vars['Nipi'] != 7)\n\n# Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy\n# Ping ranked lower than Luck (Ping has more votes than Nipi and Oboy)\nsolver.add(name_vars['Ping'] > name_vars['Luck'])  # Ping fewer votes than Luck means Ping ranked higher number (worse)\nsolver.add(name_vars['Ping'] < name_vars['Nipi'])  # Ping more votes than Nipi means Ping ranked better (smaller number)\nsolver.add(name_vars['Ping'] < name_vars['Oboy'])  # Ping more votes than Oboy means Ping ranked better (smaller number)\n\n# OPTION CHECKING\n\noptions = [\n    ['Jazz', 'Luck', 'Ping', 'Nipi', 'Kola', 'Oboy', 'Mist'],  # A\n    ['Jazz', 'Luck', 'Ping', 'Oboy', 'Kola', 'Mist', 'Nipi'],  # B\n    ['Luck', 'Ping', 'Jazz', 'Nipi', 'Oboy', 'Kola', 'Mist'],  # C\n    ['Luck', 'Ping', 'Nipi', 'Oboy', 'Jazz', 'Kola', 'Mist'],  # D\n    ['Ping', 'Luck', 'Jazz', 'Oboy', 'Nipi', 'Kola', 'Mist']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that the ranking matches the option order\n    # option[0] rank = 1, option[1] rank = 2, ..., option[6] rank = 7\n    for rank, name in enumerate(option, start=1):\n        solver.add(name_vars[name] == rank)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A soft drink manufacturer surveyed consumer preferences for exactly seven proposed names for its new soda: Jazz, Kola, Luck, Mist, Nipi, Oboy, and Ping. The manufacturer ranked the seven names according to the number of votes they received. The name that received the most votes was ranked first. Every name received a different number of votes. Some of the survey results are as follows: Jazz received more votes than Oboy. Oboy received more votes than Kola. Kola received more votes than Mist. Nipi did not receive the fewest votes. Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy.\n\nWhich one of the following statements must be true?\n\nOptions:\n(A) Jazz received more votes than Nipi.\n(B) Kola received more votes than Nipi.\n(C) Luck received more votes than Jazz.\n(D) Nipi received more votes than Oboy.\n(E) Ping received more votes than Kola.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nnames = ['Jazz', 'Kola', 'Luck', 'Mist', 'Nipi', 'Oboy', 'Ping']\nname_indices = {name: i for i, name in enumerate(names)}\n\n# Create Z3 Int variables for ranks: 1 (most votes) to 7 (fewest votes)\n# Lower rank means more votes\nranks = {name: Int(name) for name in names}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank is between 1 and 7\nfor name in names:\n    solver.add(And(ranks[name] >= 1, ranks[name] <= 7))\n\n# All ranks are distinct (different number of votes)\nsolver.add(Distinct([ranks[name] for name in names]))\n\n# Given conditions:\n\n# Jazz received more votes than Oboy -> rank Jazz < rank Oboy\nsolver.add(ranks['Jazz'] < ranks['Oboy'])\n\n# Oboy received more votes than Kola -> rank Oboy < rank Kola\nsolver.add(ranks['Oboy'] < ranks['Kola'])\n\n# Kola received more votes than Mist -> rank Kola < rank Mist\nsolver.add(ranks['Kola'] < ranks['Mist'])\n\n# Nipi did not receive the fewest votes -> rank Nipi != 7\nsolver.add(ranks['Nipi'] != 7)\n\n# Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy\n# Ping fewer votes than Luck -> rank Ping > rank Luck\nsolver.add(ranks['Ping'] > ranks['Luck'])\n\n# Ping more votes than Nipi -> rank Ping < rank Nipi\nsolver.add(ranks['Ping'] < ranks['Nipi'])\n\n# Ping more votes than Oboy -> rank Ping < rank Oboy\nsolver.add(ranks['Ping'] < ranks['Oboy'])\n\n# OPTION CHECKING\n\noptions = [\n    ('A', ranks['Jazz'] < ranks['Nipi']),   # Jazz received more votes than Nipi\n    ('B', ranks['Kola'] < ranks['Nipi']),   # Kola received more votes than Nipi\n    ('C', ranks['Luck'] < ranks['Jazz']),   # Luck received more votes than Jazz\n    ('D', ranks['Nipi'] < ranks['Oboy']),   # Nipi received more votes than Oboy\n    ('E', ranks['Ping'] < ranks['Kola'])    # Ping received more votes than Kola\n]\n\nfor letter, condition in options:\n    solver.push()\n    # Add negation of the option condition to check if it can be false\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A soft drink manufacturer surveyed consumer preferences for exactly seven proposed names for its new soda: Jazz, Kola, Luck, Mist, Nipi, Oboy, and Ping. The manufacturer ranked the seven names according to the number of votes they received. The name that received the most votes was ranked first. Every name received a different number of votes. Some of the survey results are as follows: Jazz received more votes than Oboy. Oboy received more votes than Kola. Kola received more votes than Mist. Nipi did not receive the fewest votes. Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy.\n\nIf the ranks of Ping, Oboy, and Kola were consecutive, then which one of the following statements would have to be false?\n\nOptions:\n(A) Jazz received more votes than Luck.\n(B) Jazz received more votes than Ping.\n(C) Nipi received more votes than Oboy.\n(D) Nipi received more votes than Mist.\n(E) Oboy received more votes than Nipi.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nnames = ['Jazz', 'Kola', 'Luck', 'Mist', 'Nipi', 'Oboy', 'Ping']\nn = len(names)\nname_idx = {name: i for i, name in enumerate(names)}\n\n# Create Int variables for ranks: rank[name] = rank of the name (0 is highest votes)\nrank = {name: Int(name) for name in names}\n\nsolver = Solver()\n\n# Each rank is between 0 and 6 (0 is most votes, 6 is fewest votes)\nfor name in names:\n    solver.add(And(rank[name] >= 0, rank[name] < n))\n\n# All ranks are distinct\nsolver.add(Distinct([rank[name] for name in names]))\n\n# CONSTRAINTS from the problem\n\n# Jazz received more votes than Oboy -> rank Jazz < rank Oboy\nsolver.add(rank['Jazz'] < rank['Oboy'])\n\n# Oboy received more votes than Kola -> rank Oboy < rank Kola\nsolver.add(rank['Oboy'] < rank['Kola'])\n\n# Kola received more votes than Mist -> rank Kola < rank Mist\nsolver.add(rank['Kola'] < rank['Mist'])\n\n# Nipi did not receive the fewest votes -> rank Nipi != 6\nsolver.add(rank['Nipi'] != 6)\n\n# Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy\n# \"Ping received fewer votes than Luck\" -> rank Ping > rank Luck\nsolver.add(rank['Ping'] > rank['Luck'])\n# \"Ping received more votes than Nipi\" -> rank Ping < rank Nipi\nsolver.add(rank['Ping'] < rank['Nipi'])\n# \"Ping received more votes than Oboy\" -> rank Ping < rank Oboy\nsolver.add(rank['Ping'] < rank['Oboy'])\n\n# Additional constraint: The ranks of Ping, Oboy, and Kola were consecutive\n# The ranks of these three names form a consecutive sequence of three integers\nranks_pok = [rank['Ping'], rank['Oboy'], rank['Kola']]\nsorted_ranks = [Int('sr0'), Int('sr1'), Int('sr2')]\nfor sr in sorted_ranks:\n    solver.add(And(sr >= 0, sr < n))\nsolver.add(Distinct(sorted_ranks))\nsolver.add(Sum(sorted_ranks) == Sum(ranks_pok))\nsolver.add(Or([\n    And(sorted_ranks[0] == rank['Ping'], sorted_ranks[1] == rank['Oboy'], sorted_ranks[2] == rank['Kola']),\n    And(sorted_ranks[0] == rank['Ping'], sorted_ranks[1] == rank['Kola'], sorted_ranks[2] == rank['Oboy']),\n    And(sorted_ranks[0] == rank['Oboy'], sorted_ranks[1] == rank['Ping'], sorted_ranks[2] == rank['Kola']),\n    And(sorted_ranks[0] == rank['Oboy'], sorted_ranks[1] == rank['Kola'], sorted_ranks[2] == rank['Ping']),\n    And(sorted_ranks[0] == rank['Kola'], sorted_ranks[1] == rank['Ping'], sorted_ranks[2] == rank['Oboy']),\n    And(sorted_ranks[0] == rank['Kola'], sorted_ranks[1] == rank['Oboy'], sorted_ranks[2] == rank['Ping']),\n]))\n# They are consecutive integers\nsolver.add(sorted_ranks[1] == sorted_ranks[0] + 1)\nsolver.add(sorted_ranks[2] == sorted_ranks[1] + 1)\n\n# OPTIONS\noptions = {\n    'A': rank['Jazz'] < rank['Luck'],      # Jazz more votes than Luck\n    'B': rank['Jazz'] < rank['Ping'],      # Jazz more votes than Ping\n    'C': rank['Nipi'] < rank['Oboy'],      # Nipi more votes than Oboy\n    'D': rank['Nipi'] < rank['Mist'],      # Nipi more votes than Mist\n    'E': rank['Oboy'] < rank['Nipi'],      # Oboy more votes than Nipi\n}\n\n# OPTION CHECKING\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add the negation of the option (to check if option must be false)\n    solver.add(Not(options[letter]))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true always\n        # So option cannot be false, so continue to next\n        solver.pop()\n        continue\n    else:\n        # Negation satisfiable means option can be false\n        # So option does not have to be false always, continue\n        solver.pop()\n\n# Now check which option must be false (i.e. option always false)\n# We do this by checking if the option itself is unsat under constraints\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == unsat:\n        # Option cannot be true, so it must be false always\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A soft drink manufacturer surveyed consumer preferences for exactly seven proposed names for its new soda: Jazz, Kola, Luck, Mist, Nipi, Oboy, and Ping. The manufacturer ranked the seven names according to the number of votes they received. The name that received the most votes was ranked first. Every name received a different number of votes. Some of the survey results are as follows: Jazz received more votes than Oboy. Oboy received more votes than Kola. Kola received more votes than Mist. Nipi did not receive the fewest votes. Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy.\n\nWhat is the total number of the soft drink names whose exact ranks can be deduced from the partial survey results?\n\nOptions:\n(A) one\n(B) two\n(C) three\n(D) four\n(E) five",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nnames = ['Jazz', 'Kola', 'Luck', 'Mist', 'Nipi', 'Oboy', 'Ping']\nn = len(names)\n\n# Create a rank variable for each name: 1 (most votes) to 7 (least votes)\nrank = {name: Int(name) for name in names}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank is between 1 and 7\nfor name in names:\n    solver.add(And(rank[name] >= 1, rank[name] <= n))\n\n# All ranks are distinct (different number of votes)\nsolver.add(Distinct([rank[name] for name in names]))\n\n# Given inequalities:\n\n# Jazz received more votes than Oboy => Jazz rank < Oboy rank\nsolver.add(rank['Jazz'] < rank['Oboy'])\n\n# Oboy received more votes than Kola => Oboy rank < Kola rank\nsolver.add(rank['Oboy'] < rank['Kola'])\n\n# Kola received more votes than Mist => Kola rank < Mist rank\nsolver.add(rank['Kola'] < rank['Mist'])\n\n# Nipi did not receive the fewest votes => rank[Nipi] != 7\nsolver.add(rank['Nipi'] != 7)\n\n# Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy\n# Ping rank > Luck rank\nsolver.add(rank['Ping'] > rank['Luck'])\n\n# Ping rank < Nipi rank\nsolver.add(rank['Ping'] < rank['Nipi'])\n\n# Ping rank < Oboy rank\nsolver.add(rank['Ping'] < rank['Oboy'])\n\n# OPTION CHECKING\n\n# We want to find how many names have their exact rank deduced from the constraints.\n# For each name, check if its rank is uniquely determined.\n\ndef is_unique_rank(name):\n    # Check if there exist two different solutions with different ranks for this name\n    # We'll find one solution, then add constraint rank[name] != that rank and check if still satisfiable\n    if solver.check() != sat:\n        return False\n    model = solver.model()\n    rank_val = model[rank[name]].as_long()\n    solver.push()\n    solver.add(rank[name] != rank_val)\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\ncount_unique = 0\nfor name in names:\n    if is_unique_rank(name):\n        count_unique += 1\n\n# Map count_unique to option letter\n# Options:\n# (A) one\n# (B) two\n# (C) three\n# (D) four\n# (E) five\n\noption_map = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E'}\n\n# Print the letter of the correct option in quotes\nprint(f\"'{option_map[count_unique]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A soft drink manufacturer surveyed consumer preferences for exactly seven proposed names for its new soda: Jazz, Kola, Luck, Mist, Nipi, Oboy, and Ping. The manufacturer ranked the seven names according to the number of votes they received. The name that received the most votes was ranked first. Every name received a different number of votes. Some of the survey results are as follows: Jazz received more votes than Oboy. Oboy received more votes than Kola. Kola received more votes than Mist. Nipi did not receive the fewest votes. Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy.\n\nIf Ping received more votes than Jazz, then what is the maximum possible number of names whose ranks can be determined?\n\nOptions:\n(A) two\n(B) three\n(C) four\n(D) five\n(E) six",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nnames = ['Jazz', 'Kola', 'Luck', 'Mist', 'Nipi', 'Oboy', 'Ping']\nname_vars = {n: Int(n) for n in names}  # rank variables: 1 (most votes) to 7 (fewest votes)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank is between 1 and 7\nfor n in names:\n    solver.add(And(name_vars[n] >= 1, name_vars[n] <= 7))\n\n# All ranks are distinct\nsolver.add(Distinct([name_vars[n] for n in names]))\n\n# Given constraints:\n# Jazz received more votes than Oboy: Jazz rank < Oboy rank\nsolver.add(name_vars['Jazz'] < name_vars['Oboy'])\n\n# Oboy received more votes than Kola: Oboy rank < Kola rank\nsolver.add(name_vars['Oboy'] < name_vars['Kola'])\n\n# Kola received more votes than Mist: Kola rank < Mist rank\nsolver.add(name_vars['Kola'] < name_vars['Mist'])\n\n# Nipi did not receive the fewest votes: Nipi rank != 7\nsolver.add(name_vars['Nipi'] != 7)\n\n# Ping received fewer votes than Luck but more votes than Nipi and more votes than Oboy:\n# Ping rank > Luck rank (fewer votes means higher rank number)\nsolver.add(name_vars['Ping'] > name_vars['Luck'])\n\n# Ping rank < Nipi rank (more votes than Nipi)\nsolver.add(name_vars['Ping'] < name_vars['Nipi'])\n\n# Ping rank < Oboy rank (more votes than Oboy)\nsolver.add(name_vars['Ping'] < name_vars['Oboy'])\n\n# Additional condition for the question:\n# If Ping received more votes than Jazz, then what is the maximum possible number of names whose ranks can be determined?\n# Ping received more votes than Jazz means Ping rank < Jazz rank\nsolver.add(name_vars['Ping'] < name_vars['Jazz'])\n\n# OPTION CHECKING\n# We want to find the maximum number of names whose ranks can be uniquely determined under these constraints.\n# For each name, check if its rank is uniquely determined by the constraints.\n\ndef is_rank_unique(name):\n    # Check if the rank of 'name' is uniquely determined\n    # Get the rank from a model\n    if solver.check() != sat:\n        return False\n    m = solver.model()\n    rank_val = m[name_vars[name]].as_long()\n    # Add constraint that rank is different from rank_val and check if still satisfiable\n    solver.push()\n    solver.add(name_vars[name] != rank_val)\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\n# Count how many names have unique ranks\nunique_count = 0\nfor n in names:\n    if is_rank_unique(n):\n        unique_count += 1\n\n# Map unique_count to options\n# Options:\n# (A) two\n# (B) three\n# (C) four\n# (D) five\n# (E) six\n\noption_map = {2:'A', 3:'B', 4:'C', 5:'D', 6:'E'}\n\n# Find the maximum option letter for unique_count\n# If unique_count < 2 or > 6, no option matches, but problem states max is among these\nmax_unique = unique_count\n# If unique_count > 6, cap at 6\nif max_unique > 6:\n    max_unique = 6\n# If unique_count < 2, no option, but problem likely expects at least 2\nif max_unique < 2:\n    max_unique = 2\n\nprint(f\"'{option_map[max_unique]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Eight benches—J, K, L, T, U, X, Y, and Z are arranged along the perimeter of a park as shown below: The following is true: J, K, and L are green; T and U are red; X, Y, and Z are pink. The green benches stand next to one another along the park's perimeter. The pink benches stand next to one another along the park's perimeter. No green bench stands next to a pink bench. The bench on the southeast corner is T. J stands at the center of the park's north side. If T stands next to X, then T does not also stand next to L.\n\nWhich one of the following benches could be on the northeast corner of the park?\n\nOptions:\n(A) Z\n(B) Y\n(C) X\n(D) T\n(E) L",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbenches = ['J', 'K', 'L', 'T', 'U', 'X', 'Y', 'Z']\ncolors = ['green', 'red', 'pink']\n\n# Map benches to indices for position variables\nbench_indices = {b: i for i, b in enumerate(benches)}\n\n# Each bench has a position from 0 to 7 around the park perimeter clockwise\n# Let's define the order of positions as:\n# 0: NW corner\n# 1: North side center\n# 2: NE corner\n# 3: East side center\n# 4: SE corner\n# 5: South side center\n# 6: SW corner\n# 7: West side center\n\n# Positions around the park perimeter (clockwise)\npositions = list(range(8))\n\n# Variables: position of each bench\npos = {b: Int(b) for b in benches}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each bench position is between 0 and 7\nfor b in benches:\n    solver.add(And(pos[b] >= 0, pos[b] <= 7))\n\n# All benches have distinct positions\nsolver.add(Distinct([pos[b] for b in benches]))\n\n# Fixed positions from the problem:\n# The bench on the southeast corner is T\n# SE corner is position 4\nsolver.add(pos['T'] == 4)\n\n# J stands at the center of the park's north side\n# North side center is position 1\nsolver.add(pos['J'] == 1)\n\n# Colors of benches\ngreen_benches = ['J', 'K', 'L']\nred_benches = ['T', 'U']\npink_benches = ['X', 'Y', 'Z']\n\n# Define helper function to check adjacency on circular perimeter\ndef adjacent(p1, p2):\n    return Or(p1 == (p2 + 1) % 8, p1 == (p2 - 1) % 8)\n\n# The green benches stand next to one another along the park's perimeter\n# Meaning the three green benches form a contiguous block of length 3 on the circle\n# Similarly for pink benches (3 benches contiguous)\n# No green bench stands next to a pink bench\n\n# We encode that the green benches occupy three consecutive positions on the circle\n# Similarly for pink benches\n\n# Helper function to check if a set of positions are consecutive on circle\ndef consecutive_positions(pos_list):\n    # sort positions mod 8\n    sorted_pos = sorted(pos_list)\n    # Because circle, check for wrap around possibility\n    # We check if positions form a block of length 3 in circle\n    # Either the difference between max and min is 2 (normal case)\n    # Or the positions wrap around: e.g. positions 7,0,1\n    diff = sorted_pos[-1] - sorted_pos[0]\n    cond1 = diff == 2\n    cond2 = And(sorted_pos[0] == 0, sorted_pos[1] == 1, sorted_pos[2] == 7)\n    cond3 = And(sorted_pos[0] == 6, sorted_pos[1] == 7, sorted_pos[2] == 0)\n    # Actually cond2 and cond3 are just wrap around cases\n    # We can generalize wrap around check:\n    # Check if positions are consecutive mod 8:\n    # For positions p0, p1, p2 sorted mod 8:\n    # They are consecutive if (p1 == (p0 + 1) mod 8) and (p2 == (p1 + 1) mod 8)\n    p0 = sorted_pos[0]\n    p1 = sorted_pos[1]\n    p2 = sorted_pos[2]\n    cond_wrap = And(p1 == (p0 + 1) % 8, p2 == (p1 + 1) % 8)\n    return cond_wrap\n\n# We cannot directly sort Z3 variables, so we encode the consecutive condition differently:\n# For three variables g1,g2,g3 representing positions of green benches:\n# They form a consecutive block if there exists an offset o such that\n# their positions are {o, (o+1)%8, (o+2)%8} in some order\n\n# So for green benches:\ng_pos = [pos[b] for b in green_benches]\np_pos = [pos[b] for b in pink_benches]\n\n# Define a function to enforce that a set of three positions correspond to the set {o, o+1, o+2} mod 8\ndef consecutive_block(positions):\n    o = Int('offset_' + '_'.join([str(p) for p in positions]))\n    solver.add(And(o >= 0, o <= 7))\n    # The positions must be distinct and equal to {o, o+1 mod8, o+2 mod8} in any order\n    block = [o, (o + 1) % 8, (o + 2) % 8]\n    # positions is a list of Int variables\n    # We add a constraint that positions is a permutation of block\n    # We create boolean variables for each position equals each block element\n    eqs = []\n    for i in range(3):\n        eqs.append(Or([positions[i] == block[j] for j in range(3)]))\n    solver.add(And(eqs))\n    # Each block element appears exactly once in positions\n    for j in range(3):\n        count = Sum([If(positions[i] == block[j], 1, 0) for i in range(3)])\n        solver.add(count == 1)\n\nconsecutive_block(g_pos)\nconsecutive_block(p_pos)\n\n# No green bench stands next to a pink bench\n# So no green bench is adjacent to any pink bench\nfor g in green_benches:\n    for p in pink_benches:\n        solver.add(Not(adjacent(pos[g], pos[p])))\n\n# If T stands next to X, then T does not also stand next to L\n# T is fixed at position 4\n# So if adjacent(T,X) then not adjacent(T,L)\nadj_TX = adjacent(pos['T'], pos['X'])\nadj_TL = adjacent(pos['T'], pos['L'])\nsolver.add(Implies(adj_TX, Not(adj_TL)))\n\n# OPTION CHECKING\n\n# We want to find which bench could be at the northeast corner (position 2)\n\noptions = ['Z', 'Y', 'X', 'T', 'L']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(pos[opt] == 2)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Eight benches—J, K, L, T, U, X, Y, and Z are arranged along the perimeter of a park as shown below: The following is true: J, K, and L are green; T and U are red; X, Y, and Z are pink. The green benches stand next to one another along the park's perimeter. The pink benches stand next to one another along the park's perimeter. No green bench stands next to a pink bench. The bench on the southeast corner is T. J stands at the center of the park's north side. If T stands next to X, then T does not also stand next to L.\n\nWhich one of the following benches must be next to J?\n\nOptions:\n(A) K\n(B) L\n(C) T\n(D) U\n(E) X",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbenches = ['J', 'K', 'L', 'T', 'U', 'X', 'Y', 'Z']\ncolors = ['green', 'red', 'pink']\ncolor_map = {'green': 0, 'red': 1, 'pink': 2}\nbench_colors = {'J': 'green', 'K': 'green', 'L': 'green', 'T': 'red', 'U': 'red', 'X': 'pink', 'Y': 'pink', 'Z': 'pink'}\n\n# Positions around the park perimeter indexed 0 to 7 clockwise starting at NW corner\n# We'll assign indices for benches to positions\n# The park perimeter order is assumed to be clockwise: positions 0 to 7\npositions = list(range(8))\n\n# Variables: pos_bench[b] = position index of bench b\npos_bench = {b: Int(b) for b in benches}\n\n# Also create an array to map position to bench (for adjacency checks)\n# We'll create a function pos_to_bench: position -> bench index (0 to 7)\nbench_index = {b: i for i, b in enumerate(benches)}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each bench occupies a unique position 0..7\nfor b in benches:\n    solver.add(And(pos_bench[b] >= 0, pos_bench[b] < 8))\nsolver.add(Distinct([pos_bench[b] for b in benches]))\n\n# The bench on the southeast corner is T\n# We need to identify which position is southeast corner.\n# The problem states the arrangement is along the perimeter of a park in order J, K, L, T, U, X, Y, Z.\n# But it doesn't give explicit order, so we must deduce.\n\n# Given: J stands at center of north side.\n# Since there are 8 benches, and J is at center north side, and benches are on corners and sides,\n# likely positions:\n# 0: NW corner\n# 1: N side center\n# 2: NE corner\n# 3: E side center\n# 4: SE corner\n# 5: S side center\n# 6: SW corner\n# 7: W side center\n# So position 4 is southeast corner, position 1 is center north side.\n\nsolver.add(pos_bench['T'] == 4)  # T is southeast corner\nsolver.add(pos_bench['J'] == 1)  # J is center north side\n\n# The green benches stand next to one another (contiguous block)\ngreen_benches = [b for b, c in bench_colors.items() if c == 'green']\ngreen_positions = [pos_bench[b] for b in green_benches]\n\n# The pink benches stand next to one another (contiguous block)\npink_benches = [b for b, c in bench_colors.items() if c == 'pink']\npink_positions = [pos_bench[b] for b in pink_benches]\n\n# No green bench stands next to a pink bench\n# Adjacency on circle: positions are adjacent if (pos1 - pos2) mod 8 == 1 or 7\n\ndef adjacent(p1, p2):\n    return Or((p1 - p2) % 8 == 1, (p1 - p2) % 8 == 7)\n\n# Helper function to enforce contiguous block on circle for a set of positions\ndef contiguous_block(positions):\n    # There exists a start position s so that all positions are consecutive on circle\n    # The length of positions is n\n    n = len(positions)\n    # For some s in 0..7, positions are s, s+1 mod 8, ..., s+n-1 mod 8\n    s = Int('start_' + '_'.join([str(p) for p in positions]))\n    constraints = [And(s >= 0, s < 8)]\n    for p in positions:\n        # p in {s, s+1 mod 8, ..., s+n-1 mod 8}\n        # So (p - s) mod 8 < n\n        diff = (p - s) % 8\n        constraints.append(And(diff >= 0, diff < n))\n    # All positions distinct\n    constraints.append(Distinct(positions))\n    return And(constraints)\n\nsolver.add(contiguous_block(green_positions))\nsolver.add(contiguous_block(pink_positions))\n\n# No green bench stands next to a pink bench\nfor g in green_positions:\n    for p in pink_positions:\n        solver.add(Not(adjacent(g, p)))\n\n# If T stands next to X, then T does not also stand next to L.\n# T is at 4, so check adjacency conditions\n# We encode the implication: If adjacent(T, X) then not adjacent(T, L)\npos_T = pos_bench['T']\npos_X = pos_bench['X']\npos_L = pos_bench['L']\nsolver.add(Implies(adjacent(pos_T, pos_X), Not(adjacent(pos_T, pos_L))))\n\n# OPTION CHECKING\n# Which bench must be next to J (position 1)?\n\n# Adjacent positions to 1 are 0 and 2\nadjacent_to_J = [0, 2]\n\n# For each option, check if bench must be adjacent to J\noptions = ['K', 'L', 'T', 'U', 'X']\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraint that option bench is NOT adjacent to J\n    pos_option = pos_bench[option]\n    not_adjacent_to_J = And(pos_option != adjacent_to_J[0], pos_option != adjacent_to_J[1])\n    solver.add(not_adjacent_to_J)\n    if solver.check() == unsat:\n        # If unsat, option must be adjacent to J\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Eight benches—J, K, L, T, U, X, Y, and Z are arranged along the perimeter of a park as shown below: The following is true: J, K, and L are green; T and U are red; X, Y, and Z are pink. The green benches stand next to one another along the park's perimeter. The pink benches stand next to one another along the park's perimeter. No green bench stands next to a pink bench. The bench on the southeast corner is T. J stands at the center of the park's north side. If T stands next to X, then T does not also stand next to L.\n\nIf Y is in the middle of the west side of the park, then the two benches in which one of the following pairs CANNOT be two of the corner benches?\n\nOptions:\n(A) K and X\n(B) K and Z\n(C) L and U\n(D) L and X\n(E) L and Z",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbenches = ['J', 'K', 'L', 'T', 'U', 'X', 'Y', 'Z']\nbench_indices = {b: i for i, b in enumerate(benches)}\n\n# Positions along the perimeter (0 to 7)\n# We assign indices clockwise starting from north-west corner (arbitrary)\n# But we will model positions as integers 0..7 representing positions around the park perimeter\n# We will assign variables for the position of each bench (0..7)\n# Constraints will fix some benches to certain positions\n\n# Create Z3 Int variables for positions of each bench\npos = {b: Int(b) for b in benches}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each bench position is from 0 to 7\nfor b in benches:\n    solver.add(And(pos[b] >= 0, pos[b] <= 7))\n\n# All benches have distinct positions\nsolver.add(Distinct([pos[b] for b in benches]))\n\n# Fixed positions from problem statement:\n\n# The bench on the southeast corner is T\n# We need to define which positions correspond to corners and sides\n# There are 8 benches along the perimeter, so presumably 4 corners and 4 sides\n# We can assign positions as:\n# 0: NW corner\n# 1: N side center\n# 2: NE corner\n# 3: E side center\n# 4: SE corner\n# 5: S side center\n# 6: SW corner\n# 7: W side center\n\n# So corners are positions: 0, 2, 4, 6\n# Sides are positions: 1, 3, 5, 7\n\n# Assign T to SE corner (position 4)\nsolver.add(pos['T'] == 4)\n\n# J stands at center of the park's north side (position 1)\nsolver.add(pos['J'] == 1)\n\n# Y is in the middle of the west side of the park (position 7)\nsolver.add(pos['Y'] == 7)\n\n# Colors:\n# Green: J, K, L\n# Red: T, U\n# Pink: X, Y, Z\n\ngreen = ['J', 'K', 'L']\nred = ['T', 'U']\npink = ['X', 'Y', 'Z']\n\n# The green benches stand next to one another along the park's perimeter.\n# The pink benches stand next to one another along the park's perimeter.\n# No green bench stands next to a pink bench.\n\n# Define adjacency function on positions (mod 8)\ndef adjacent(p1, p2):\n    return Or(p1 == (p2 + 1) % 8, p1 == (p2 - 1) % 8)\n\n# Green benches stand next to one another along the perimeter (continuous block of 3)\n# Since there are 3 green benches, their positions must be 3 consecutive positions in the circle\ngreen_pos = [pos[b] for b in green]\n# Sort green positions in circle order is tricky; instead, we check that the set of green positions form a consecutive block of size 3\n# We can try all possible triples of consecutive positions for green benches\n\ngreen_blocks = []\nfor start in range(8):\n    block = [(start + i) % 8 for i in range(3)]\n    green_blocks.append(block)\n\n# Add constraint that green_pos is one of these blocks (order does not matter)\n# So green_pos as a set equals one of green_blocks sets\ngreen_pos_set = SetSort(IntSort())  # We cannot use sets directly in Z3, so we check by or of conditions\n\n# We'll encode the green block condition as:\n# There exists a start such that the set of green positions equals the block positions\n\n# To do this, we create a boolean variable for each possible block start\ngreen_block_bools = []\nfor block in green_blocks:\n    conds = []\n    for gp in green_pos:\n        # gp in block\n        conds.append(Or([gp == p for p in block]))\n    # all green_pos are in block\n    all_in_block = And(conds)\n    # block has exactly 3 positions, green_pos has 3 benches, so all green_pos in block and all positions in block are assigned to green benches\n    # To ensure the green_pos exactly equals the block, we also check that no other bench outside green benches occupies block positions\n    # But since all benches distinct, and green benches are exactly 3, it's enough to check all green_pos in block\n    green_block_bools.append(all_in_block)\n\nsolver.add(Or(green_block_bools))\n\n# Similarly for pink benches (X, Y, Z) - 3 pink benches in consecutive block\npink_pos = [pos[b] for b in pink]\npink_blocks = []\nfor start in range(8):\n    block = [(start + i) % 8 for i in range(3)]\n    pink_blocks.append(block)\n\npink_block_bools = []\nfor block in pink_blocks:\n    conds = []\n    for pp in pink_pos:\n        conds.append(Or([pp == p for p in block]))\n    all_in_block = And(conds)\n    pink_block_bools.append(all_in_block)\n\nsolver.add(Or(pink_block_bools))\n\n# No green bench stands next to a pink bench\n# For every green bench and pink bench, their positions are not adjacent\nfor g in green:\n    for p in pink:\n        solver.add(Not(adjacent(pos[g], pos[p])))\n\n# If T stands next to X, then T does not also stand next to L.\n# T is at position 4 fixed\n# So if adjacent(T, X) then not adjacent(T, L)\nadj_T_X = adjacent(pos['T'], pos['X'])\nadj_T_L = adjacent(pos['T'], pos['L'])\nsolver.add(Implies(adj_T_X, Not(adj_T_L)))\n\n# Y is in the middle of west side (position 7) already added\n\n# We want to find which pair CANNOT be two of the corner benches if Y is at 7\n\n# Corner benches are at positions 0, 2, 4, 6\ncorners = [0, 2, 4, 6]\n\n# Option pairs:\noptions = {\n    'A': ('K', 'X'),\n    'B': ('K', 'Z'),\n    'C': ('L', 'U'),\n    'D': ('L', 'X'),\n    'E': ('L', 'Z'),\n}\n\n# We will check for each option if it is possible for both benches in the pair to be corners\n# If not possible, print that option letter\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    b1, b2 = options[opt]\n    solver.push()\n    # Add constraints that b1 and b2 are corner benches\n    solver.add(Or([pos[b1] == c for c in corners]))\n    solver.add(Or([pos[b2] == c for c in corners]))\n    # They must be distinct corners\n    solver.add(pos[b1] != pos[b2])\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{opt}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A lake contains exactly five islands—J, K, L, M, O—which are unconnected by bridges. Contractors will build a network of bridges that satisfies the following specifications: Each bridge directly connects exactly two islands with each other, and no two bridges intersect. No more than one bridge directly connects any two islands. No island has more than three bridges that directly connect it with other islands. J, K, and L are each directly connected by bridge with one or both of M and O. J is directly connected by bridge with exactly two islands. K is directly connected by bridge with exactly one island. A bridge directly connects J with O, and a bridge directly connects M with O.\n\nWhich one of the following could be true about the completed network of bridges?\n\nOptions:\n(A) J is directly connected by bridge both with L and with M.\n(B) K is directly connected by bridge both with M and with O.\n(C) L is directly connected by bridge both with J and with M.\n(D) M is directly connected by bridge with J, with K, and with L.\n(E) O is directly connected by bridge with K, with L, and with M.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nislands = ['J', 'K', 'L', 'M', 'O']\nn = len(islands)\n\n# Create a matrix of Bool variables: bridge[i][j] = True if there is a bridge between islands[i] and islands[j]\n# Since bridges are undirected, only consider i < j\nbridge = {}\nfor i in range(n):\n    for j in range(i+1, n):\n        bridge[(i,j)] = Bool(f\"bridge_{islands[i]}_{islands[j]}\")\n\ndef connected(i, j):\n    # Return the Bool variable representing if i and j are connected by a bridge\n    if i < j:\n        return bridge[(i,j)]\n    else:\n        return bridge[(j,i)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# No two bridges intersect: \n# This is a geometric constraint that is not modeled here explicitly.\n# We rely on problem statement and options about possible bridges.\n\n# No more than one bridge directly connects any two islands: \n# Already ensured by single Bool variable per pair.\n\n# No island has more than three bridges that directly connect it with other islands.\nfor i in range(n):\n    connected_bridges = []\n    for j in range(n):\n        if i != j:\n            connected_bridges.append(If(connected(i,j), 1, 0))\n    solver.add(Sum(connected_bridges) <= 3)\n\n# J, K, and L are each directly connected by bridge with one or both of M and O.\n# J, K, L indices:\nidx_J = islands.index('J')\nidx_K = islands.index('K')\nidx_L = islands.index('L')\nidx_M = islands.index('M')\nidx_O = islands.index('O')\n\n# For each of J, K, L: connected to M or O at least one\nfor x in [idx_J, idx_K, idx_L]:\n    connected_to_M = connected(x, idx_M)\n    connected_to_O = connected(x, idx_O)\n    solver.add(Or(connected_to_M, connected_to_O))\n\n# J is directly connected by bridge with exactly two islands.\nconnected_J = []\nfor j in range(n):\n    if j != idx_J:\n        connected_J.append(If(connected(idx_J,j), 1, 0))\nsolver.add(Sum(connected_J) == 2)\n\n# K is directly connected by bridge with exactly one island.\nconnected_K = []\nfor j in range(n):\n    if j != idx_K:\n        connected_K.append(If(connected(idx_K,j), 1, 0))\nsolver.add(Sum(connected_K) == 1)\n\n# A bridge directly connects J with O\nsolver.add(connected(idx_J, idx_O))\n\n# A bridge directly connects M with O\nsolver.add(connected(idx_M, idx_O))\n\n# OPTION CHECKING\noptions = [\n    # (A) J is directly connected by bridge both with L and with M.\n    And(connected(idx_J, idx_L), connected(idx_J, idx_M)),\n    # (B) K is directly connected by bridge both with M and with O.\n    And(connected(idx_K, idx_M), connected(idx_K, idx_O)),\n    # (C) L is directly connected by bridge both with J and with M.\n    And(connected(idx_L, idx_J), connected(idx_L, idx_M)),\n    # (D) M is directly connected by bridge with J, with K, and with L.\n    And(connected(idx_M, idx_J), connected(idx_M, idx_K), connected(idx_M, idx_L)),\n    # (E) O is directly connected by bridge with K, with L, and with M.\n    And(connected(idx_O, idx_K), connected(idx_O, idx_L), connected(idx_O, idx_M))\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A lake contains exactly five islands—J, K, L, M, O—which are unconnected by bridges. Contractors will build a network of bridges that satisfies the following specifications: Each bridge directly connects exactly two islands with each other, and no two bridges intersect. No more than one bridge directly connects any two islands. No island has more than three bridges that directly connect it with other islands. J, K, and L are each directly connected by bridge with one or both of M and O. J is directly connected by bridge with exactly two islands. K is directly connected by bridge with exactly one island. A bridge directly connects J with O, and a bridge directly connects M with O.\n\nIf a bridge directly connects K with O, then which one of the following could be true?\n\nOptions:\n(A) No bridge directly connects L with M.\n(B) A bridge directly connects J with L.\n(C) A bridge directly connects L with O.\n(D) There are exactly three bridges directly connecting L with other islands.\n(E) There are exactly two bridges directly connecting O with other islands.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nislands = ['J', 'K', 'L', 'M', 'O']\nnum_islands = len(islands)\n\n# Create an index mapping for convenience\nindex = {islands[i]: i for i in range(num_islands)}\n\n# Bridges represented as symmetric adjacency matrix of booleans\n# bridge[i][j] == True means a bridge directly connects islands i and j\nbridge = [[Bool(f\"bridge_{i}_{j}\") for j in range(num_islands)] for i in range(num_islands)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. No bridge connects an island to itself\nfor i in range(num_islands):\n    solver.add(bridge[i][i] == False)\n\n# 2. Symmetry: bridge[i][j] == bridge[j][i]\nfor i in range(num_islands):\n    for j in range(i+1, num_islands):\n        solver.add(bridge[i][j] == bridge[j][i])\n\n# 3. No two bridges connect the same pair (already ensured by boolean matrix)\n\n# 4. No island has more than three bridges\nfor i in range(num_islands):\n    connected_bridges = []\n    for j in range(num_islands):\n        if i != j:\n            connected_bridges.append(If(bridge[i][j], 1, 0))\n    solver.add(Sum(connected_bridges) <= 3)\n\n# 5. J, K, and L are each directly connected by bridge with one or both of M and O\n# That means for each of J,K,L, bridge to M or bridge to O is True (or both)\nfor isl in ['J', 'K', 'L']:\n    j = index[isl]\n    m = index['M']\n    o = index['O']\n    solver.add(Or(bridge[j][m], bridge[j][o]))\n\n# 6. J is directly connected by bridge with exactly two islands\nj = index['J']\nj_connections = [If(bridge[j][k], 1, 0) for k in range(num_islands) if k != j]\nsolver.add(Sum(j_connections) == 2)\n\n# 7. K is directly connected by bridge with exactly one island\nk = index['K']\nk_connections = [If(bridge[k][x], 1, 0) for x in range(num_islands) if x != k]\nsolver.add(Sum(k_connections) == 1)\n\n# 8. A bridge directly connects J with O\nsolver.add(bridge[index['J']][index['O']] == True)\n\n# 9. A bridge directly connects M with O\nsolver.add(bridge[index['M']][index['O']] == True)\n\n# 10. If a bridge directly connects K with O (condition for the question)\n# We will add this condition for option checking\nk_o_bridge = bridge[index['K']][index['O']]\n\n# OPTION CHECKING\n\n# Define each option as a constraint that could be true if K-O bridge exists\n\noptions = []\n\n# (A) No bridge directly connects L with M.\nl = index['L']\nm = index['M']\noptions.append(Not(bridge[l][m]))\n\n# (B) A bridge directly connects J with L.\nj = index['J']\nl = index['L']\noptions.append(bridge[j][l])\n\n# (C) A bridge directly connects L with O.\nl = index['L']\no = index['O']\noptions.append(bridge[l][o])\n\n# (D) There are exactly three bridges directly connecting L with other islands.\nl = index['L']\nl_connections = [If(bridge[l][x], 1, 0) for x in range(num_islands) if x != l]\noptions.append(Sum(l_connections) == 3)\n\n# (E) There are exactly two bridges directly connecting O with other islands.\no = index['O']\no_connections = [If(bridge[o][x], 1, 0) for x in range(num_islands) if x != o]\noptions.append(Sum(o_connections) == 2)\n\n# Check each option with the condition that K-O bridge exists\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(k_o_bridge == True)\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A lake contains exactly five islands—J, K, L, M, O—which are unconnected by bridges. Contractors will build a network of bridges that satisfies the following specifications: Each bridge directly connects exactly two islands with each other, and no two bridges intersect. No more than one bridge directly connects any two islands. No island has more than three bridges that directly connect it with other islands. J, K, and L are each directly connected by bridge with one or both of M and O. J is directly connected by bridge with exactly two islands. K is directly connected by bridge with exactly one island. A bridge directly connects J with O, and a bridge directly connects M with O.\n\nIf a bridge directly connects L with M and a bridge directly connects L with O, then which one of the following must be true?\n\nOptions:\n(A) A bridge directly connects J with M.\n(B) A bridge directly connects K with M.\n(C) A bridge directly connects K with O.\n(D) There are exactly two bridges directly connecting L with other islands.\n(E) There are exactly two bridges directly connecting M with other islands.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nislands = ['J', 'K', 'L', 'M', 'O']\nnum_islands = len(islands)\nindex = {islands[i]: i for i in range(num_islands)}\n\n# Create Z3 Bool variables for each possible bridge (undirected, so only pairs i<j)\nbridges = {}\nfor i in range(num_islands):\n    for j in range(i+1, num_islands):\n        bridges[(i, j)] = Bool(f\"b_{islands[i]}_{islands[j]}\")\n\n# Helper function: get bridge variable for unordered pair\ndef bridge_var(a, b):\n    i, j = index[a], index[b]\n    if i < j:\n        return bridges[(i, j)]\n    else:\n        return bridges[(j, i)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1) No two bridges intersect - not explicitly modeled since no coordinates given,\n# assume this is guaranteed by the plan and no contradictory edges.\n\n# 2) No more than one bridge connects any two islands - modeled by Bool var per pair.\n\n# 3) No island has more than three bridges\nfor isl in islands:\n    idx = index[isl]\n    connected_bridges = []\n    for i in range(num_islands):\n        if i == idx:\n            continue\n        connected_bridges.append(bridge_var(isl, islands[i]))\n    solver.add(Sum([If(b, 1, 0) for b in connected_bridges]) <= 3)\n\n# 4) J, K, L are each directly connected by bridge with one or both of M and O.\n# That means for each of J,K,L at least one of the bridges (isl, M) or (isl, O) exists\nfor isl in ['J', 'K', 'L']:\n    b1 = bridge_var(isl, 'M')\n    b2 = bridge_var(isl, 'O')\n    solver.add(Or([b1, b2]))\n\n# 5) J is directly connected by bridge with exactly two islands.\nidx_J = index['J']\nJ_bridges = []\nfor i in range(num_islands):\n    if i != idx_J:\n        J_bridges.append(bridges[(min(idx_J,i), max(idx_J,i))])\nsolver.add(Sum([If(b, 1, 0) for b in J_bridges]) == 2)\n\n# 6) K is directly connected by bridge with exactly one island.\nidx_K = index['K']\nK_bridges = []\nfor i in range(num_islands):\n    if i != idx_K:\n        K_bridges.append(bridges[(min(idx_K,i), max(idx_K,i))])\nsolver.add(Sum([If(b, 1, 0) for b in K_bridges]) == 1)\n\n# 7) A bridge directly connects J with O\nsolver.add(bridge_var('J', 'O'))\n\n# 8) A bridge directly connects M with O\nsolver.add(bridge_var('M', 'O'))\n\n# 9) If a bridge directly connects L with M and a bridge directly connects L with O,\n# then which one of the following must be true?\n# We will check each option under assumptions L-M and L-O bridges exist.\n\n# Add assumptions for the question:\nsolver.add(bridge_var('L', 'M'))\nsolver.add(bridge_var('L', 'O'))\n\noptions = {\n    'A': bridge_var('J', 'M'),\n    'B': bridge_var('K', 'M'),\n    'C': bridge_var('K', 'O'),\n    'D': Sum([If(bridge_var('L', isl), 1, 0) for isl in islands if isl != 'L']) == 2,\n    'E': Sum([If(bridge_var('M', isl), 1, 0) for isl in islands if isl != 'M']) == 2,\n}\n\n# OPTION CHECKING\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        # cond must be true under assumptions\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A lake contains exactly five islands—J, K, L, M, O—which are unconnected by bridges. Contractors will build a network of bridges that satisfies the following specifications: Each bridge directly connects exactly two islands with each other, and no two bridges intersect. No more than one bridge directly connects any two islands. No island has more than three bridges that directly connect it with other islands. J, K, and L are each directly connected by bridge with one or both of M and O. J is directly connected by bridge with exactly two islands. K is directly connected by bridge with exactly one island. A bridge directly connects J with O, and a bridge directly connects M with O.\n\nIf no island that is directly connected by bridge with M is also directly connected by bridge with O, then there must be a bridge directly connecting\n\nOptions:\n(A) J with L\n(B) J with M\n(C) K with O\n(D) L with M\n(E) L with O",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nislands = ['J', 'K', 'L', 'M', 'O']\nisland_indices = {name: i for i, name in enumerate(islands)}\n\n# We represent bridges as a symmetric adjacency matrix of booleans\n# bridge[i][j] = True if there is a bridge between islands[i] and islands[j], else False\nbridge = [[Bool(f\"bridge_{i}_{j}\") for j in range(len(islands))] for i in range(len(islands))]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Bridges connect exactly two islands, no loops\nfor i in range(len(islands)):\n    solver.add(bridge[i][i] == False)\n\n# 2. Symmetry: bridge[i][j] == bridge[j][i]\nfor i in range(len(islands)):\n    for j in range(i+1, len(islands)):\n        solver.add(bridge[i][j] == bridge[j][i])\n\n# 3. No more than one bridge between any two islands (already ensured by boolean variable)\n\n# 4. No island has more than three bridges\nfor i in range(len(islands)):\n    connected_bridges = [If(bridge[i][j], 1, 0) for j in range(len(islands))]\n    solver.add(Sum(connected_bridges) <= 3)\n\n# 5. J, K, and L are each directly connected by bridge with one or both of M and O.\n# That means for each of J,K,L: bridge with M or bridge with O or both\nJ = island_indices['J']\nK = island_indices['K']\nL = island_indices['L']\nM = island_indices['M']\nO = island_indices['O']\n\nsolver.add(Or(bridge[J][M], bridge[J][O]))\nsolver.add(Or(bridge[K][M], bridge[K][O]))\nsolver.add(Or(bridge[L][M], bridge[L][O]))\n\n# 6. J is directly connected by bridge with exactly two islands.\nJ_connections = [bridge[J][i] for i in range(len(islands))]\nsolver.add(Sum([If(b, 1, 0) for b in J_connections]) == 2)\n\n# 7. K is directly connected by bridge with exactly one island.\nK_connections = [bridge[K][i] for i in range(len(islands))]\nsolver.add(Sum([If(b, 1, 0) for b in K_connections]) == 1)\n\n# 8. A bridge directly connects J with O\nsolver.add(bridge[J][O] == True)\n\n# 9. A bridge directly connects M with O\nsolver.add(bridge[M][O] == True)\n\n# 10. No two bridges intersect (this is a geometric constraint; since no coordinates are given\n# and no other info, we assume this means no contradictory edges; the problem does not provide\n# additional info to encode this, so we omit explicit constraints here)\n\n# OPTION CHECKING\n\n# Additional condition for the question:\n# \"If no island that is directly connected by bridge with M is also directly connected by bridge with O,\n# then there must be a bridge directly connecting ____.\"\n\n# Let's define the condition: no island connected to M is also connected to O\n# For all islands X: if bridge[M][X] then not bridge[O][X]\n\ndef condition_no_shared_neighbors():\n    conds = []\n    for x in range(len(islands)):\n        if x != M and x != O:\n            cond = Implies(bridge[M][x], Not(bridge[O][x]))\n            conds.append(cond)\n    return And(conds)\n\n# We test each option by adding the condition_no_shared_neighbors and negation of the option bridge\n# If unsat, option is correct\n\noptions = {\n    'A': (island_indices['J'], island_indices['L']),\n    'B': (island_indices['J'], island_indices['M']),\n    'C': (island_indices['K'], island_indices['O']),\n    'D': (island_indices['L'], island_indices['M']),\n    'E': (island_indices['L'], island_indices['O']),\n}\n\nfor letter, (a, b) in options.items():\n    solver.push()\n    # Add the condition: no island connected to M is connected to O\n    solver.add(condition_no_shared_neighbors())\n    # Add negation of the option: no bridge between a and b\n    solver.add(bridge[a][b] == False)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of five students—Hubert, Lori, Paul, Regina, and Sharon—will visit exactly one of three cities—Montreal, Toronto, or Vancouver—for the month of March, according to the following conditions: Sharon visits a different city than Paul. Hubert visits the same city as Regina. Lori visits Montreal or else Toronto. If Paul visits Vancouver, Hubert visits Vancouver with him. Each student visits one of the cities with at least one of the other four students.\n\nWhich one of the following could be true for March?\n\nOptions:\n(A) Hubert, Lori, and Paul visit Toronto, and Regina and Sharon visit Vancouver.\n(B) Hubert, Lori, Paul, and Regina visit Montreal, and Sharon visits Vancouver.\n(C) Hubert, Paul, and Regina visit Toronto, and Lori and Sharon visit Montreal.\n(D) Hubert, Regina, and Sharon visit Montreal, and Lori and Paul visit Vancouver.\n(E) Lori, Paul, and Sharon visit Montreal, and Hubert and Regina visit Toronto.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Hubert', 'Lori', 'Paul', 'Regina', 'Sharon']\ncities = ['Montreal', 'Toronto', 'Vancouver']\ncity_indices = {city: idx for idx, city in enumerate(cities)}\n\n# Create Z3 variables for each student representing the city they visit\nvisit = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student visits exactly one city (value in 0..2)\nfor s in students:\n    solver.add(And(visit[s] >= 0, visit[s] < len(cities)))\n\n# Sharon visits a different city than Paul\nsolver.add(visit['Sharon'] != visit['Paul'])\n\n# Hubert visits the same city as Regina\nsolver.add(visit['Hubert'] == visit['Regina'])\n\n# Lori visits Montreal or else Toronto (i.e. Montreal or Toronto)\nsolver.add(Or(visit['Lori'] == city_indices['Montreal'], visit['Lori'] == city_indices['Toronto']))\n\n# If Paul visits Vancouver, Hubert visits Vancouver with him\npaul_vancouver = (visit['Paul'] == city_indices['Vancouver'])\nhubert_vancouver = (visit['Hubert'] == city_indices['Vancouver'])\nsolver.add(Implies(paul_vancouver, hubert_vancouver))\n\n# Each student visits one of the cities with at least one of the other four students\n# For each student s, there exists another student t != s such that visit[s] == visit[t]\nfor s in students:\n    others = [t for t in students if t != s]\n    same_city_with_other = Or([visit[s] == visit[t] for t in others])\n    solver.add(same_city_with_other)\n\n# OPTION CHECKING\noptions = [\n    # (A) Hubert, Lori, and Paul visit Toronto, Regina and Sharon visit Vancouver\n    [('Hubert', 'Toronto'), ('Lori', 'Toronto'), ('Paul', 'Toronto'), ('Regina', 'Vancouver'), ('Sharon', 'Vancouver')],\n    # (B) Hubert, Lori, Paul, and Regina visit Montreal, Sharon visits Vancouver\n    [('Hubert', 'Montreal'), ('Lori', 'Montreal'), ('Paul', 'Montreal'), ('Regina', 'Montreal'), ('Sharon', 'Vancouver')],\n    # (C) Hubert, Paul, and Regina visit Toronto, Lori and Sharon visit Montreal\n    [('Hubert', 'Toronto'), ('Paul', 'Toronto'), ('Regina', 'Toronto'), ('Lori', 'Montreal'), ('Sharon', 'Montreal')],\n    # (D) Hubert, Regina, and Sharon visit Montreal, Lori and Paul visit Vancouver\n    [('Hubert', 'Montreal'), ('Regina', 'Montreal'), ('Sharon', 'Montreal'), ('Lori', 'Vancouver'), ('Paul', 'Vancouver')],\n    # (E) Lori, Paul, and Sharon visit Montreal, Hubert and Regina visit Toronto\n    [('Lori', 'Montreal'), ('Paul', 'Montreal'), ('Sharon', 'Montreal'), ('Hubert', 'Toronto'), ('Regina', 'Toronto')],\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this option\n    for (student, city) in option:\n        solver.add(visit[student] == city_indices[city])\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of five students—Hubert, Lori, Paul, Regina, and Sharon—will visit exactly one of three cities—Montreal, Toronto, or Vancouver—for the month of March, according to the following conditions: Sharon visits a different city than Paul. Hubert visits the same city as Regina. Lori visits Montreal or else Toronto. If Paul visits Vancouver, Hubert visits Vancouver with him. Each student visits one of the cities with at least one of the other four students.\n\nIf Hubert and Sharon visit a city together, which one of the following could be true in March?\n\nOptions:\n(A) Hubert visits the same city as Paul.\n(B) Lori visits the same city as Regina.\n(C) Paul visits the same city as Regina.\n(D) Paul visits Toronto.\n(E) Paul visits Vancouver.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Hubert', 'Lori', 'Paul', 'Regina', 'Sharon']\ncities = ['Montreal', 'Toronto', 'Vancouver']\n\n# Create Z3 Int variables for each student representing their city index\ncity_vars = {student: Int(student) for student in students}\n\nsolver = Solver()\n\n# Each student visits exactly one city (0, 1, or 2)\nfor student in students:\n    solver.add(And(city_vars[student] >= 0, city_vars[student] < len(cities)))\n\n# CONSTRAINTS\n\n# Sharon visits a different city than Paul\nsolver.add(city_vars['Sharon'] != city_vars['Paul'])\n\n# Hubert visits the same city as Regina\nsolver.add(city_vars['Hubert'] == city_vars['Regina'])\n\n# Lori visits Montreal or Toronto (city 0 or 1)\nsolver.add(Or(city_vars['Lori'] == 0, city_vars['Lori'] == 1))\n\n# If Paul visits Vancouver (city 2), Hubert visits Vancouver too\nsolver.add(Implies(city_vars['Paul'] == 2, city_vars['Hubert'] == 2))\n\n# Each student visits a city with at least one other student\n# For each student, there exists another student with the same city\nfor s1 in students:\n    others = [s2 for s2 in students if s2 != s1]\n    same_city_others = [city_vars[s2] == city_vars[s1] for s2 in others]\n    solver.add(Or(same_city_others))\n\n# Additional condition: Hubert and Sharon visit a city together\nsolver.add(city_vars['Hubert'] == city_vars['Sharon'])\n\n# OPTION CHECKING\noptions = [\n    city_vars['Hubert'] == city_vars['Paul'],    # (A)\n    city_vars['Lori'] == city_vars['Regina'],    # (B)\n    city_vars['Paul'] == city_vars['Regina'],    # (C)\n    city_vars['Paul'] == 1,                       # (D) Paul visits Toronto\n    city_vars['Paul'] == 2                        # (E) Paul visits Vancouver\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of five students—Hubert, Lori, Paul, Regina, and Sharon—will visit exactly one of three cities—Montreal, Toronto, or Vancouver—for the month of March, according to the following conditions: Sharon visits a different city than Paul. Hubert visits the same city as Regina. Lori visits Montreal or else Toronto. If Paul visits Vancouver, Hubert visits Vancouver with him. Each student visits one of the cities with at least one of the other four students.\n\nIf Sharon visits Vancouver, which one of the following must be true for March?\n\nOptions:\n(A) Hubert visits Montreal.\n(B) Lori visits Montreal.\n(C) Paul visits Toronto.\n(D) Lori visits the same city as Paul.\n(E) Lori visits the same city as Regina.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Hubert', 'Lori', 'Paul', 'Regina', 'Sharon']\ncities = ['Montreal', 'Toronto', 'Vancouver']\n\n# Create Z3 Int variables for each student representing the city index\nvisit = {s: Int(s) for s in students}\n\n# Map city names to indices for clarity\nMONTREAL = cities.index('Montreal')\nTORONTO = cities.index('Toronto')\nVANCOUVER = cities.index('Vancouver')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student visits exactly one city (value in valid range)\nfor s in students:\n    solver.add(And(visit[s] >= 0, visit[s] < len(cities)))\n\n# Sharon visits a different city than Paul\nsolver.add(visit['Sharon'] != visit['Paul'])\n\n# Hubert visits the same city as Regina\nsolver.add(visit['Hubert'] == visit['Regina'])\n\n# Lori visits Montreal or else Toronto\nsolver.add(Or(visit['Lori'] == MONTREAL, visit['Lori'] == TORONTO))\n\n# If Paul visits Vancouver, Hubert visits Vancouver with him\nsolver.add(Implies(visit['Paul'] == VANCOUVER, visit['Hubert'] == VANCOUVER))\n\n# Each student visits one of the cities with at least one of the other four students\n# For each student, there exists another student visiting the same city\nfor s1 in students:\n    others = [s2 for s2 in students if s2 != s1]\n    same_city_with_others = Or([visit[s1] == visit[s2] for s2 in others])\n    solver.add(same_city_with_others)\n\n# Additional constraint: Sharon visits Vancouver (condition of the question)\nsolver.add(visit['Sharon'] == VANCOUVER)\n\n# OPTION CHECKING\n# Define option constraints as functions returning Z3 BoolRef expressions\n\ndef option_A():\n    return visit['Hubert'] == MONTREAL\n\ndef option_B():\n    return visit['Lori'] == MONTREAL\n\ndef option_C():\n    return visit['Paul'] == TORONTO\n\ndef option_D():\n    return visit['Lori'] == visit['Paul']\n\ndef option_E():\n    return visit['Lori'] == visit['Regina']\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\n# Check each option: add the negation of the option and see if model is still satisfiable\n# If negation is unsat, option must be true\n\nfor i, opt_func in enumerate(options):\n    solver.push()\n    # Add negation of option to see if it contradicts constraints\n    solver.add(Not(opt_func()))\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of five students—Hubert, Lori, Paul, Regina, and Sharon—will visit exactly one of three cities—Montreal, Toronto, or Vancouver—for the month of March, according to the following conditions: Sharon visits a different city than Paul. Hubert visits the same city as Regina. Lori visits Montreal or else Toronto. If Paul visits Vancouver, Hubert visits Vancouver with him. Each student visits one of the cities with at least one of the other four students.\n\nWhich one of the following could be false in March?\n\nOptions:\n(A) Sharon must visit Montreal if Paul visits Vancouver.\n(B) Regina must visit Vancouver if Paul visits Vancouver.\n(C) Regina visits a city with exactly two of the other four students.\n(D) Lori visits a city with exactly one of the other four students.\n(E) Lori visits a city with Paul or else with Sharon.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Hubert', 'Lori', 'Paul', 'Regina', 'Sharon']\ncities = ['Montreal', 'Toronto', 'Vancouver']\n\n# Map students to Z3 Int variables representing city indices\ncity_vars = {s: Int(s) for s in students}\n\n# Create solver instance\nsolver = Solver()\n\n# Each student visits exactly one city (index between 0 and 2)\nfor s in students:\n    solver.add(And(city_vars[s] >= 0, city_vars[s] < len(cities)))\n\n# CONSTRAINTS\n\n# 1) Sharon visits a different city than Paul\nsolver.add(city_vars['Sharon'] != city_vars['Paul'])\n\n# 2) Hubert visits the same city as Regina\nsolver.add(city_vars['Hubert'] == city_vars['Regina'])\n\n# 3) Lori visits Montreal or else Toronto\nsolver.add(Or(city_vars['Lori'] == cities.index('Montreal'), city_vars['Lori'] == cities.index('Toronto')))\n\n# 4) If Paul visits Vancouver, Hubert visits Vancouver with him\npaul_vancouver = city_vars['Paul'] == cities.index('Vancouver')\nhubert_vancouver = city_vars['Hubert'] == cities.index('Vancouver')\nsolver.add(Implies(paul_vancouver, hubert_vancouver))\n\n# 5) Each student visits one of the cities with at least one of the other four students\n# For each student, there exists at least one other student with the same city\nfor s in students:\n    others = [o for o in students if o != s]\n    same_city_with_others = Or([city_vars[s] == city_vars[o] for o in others])\n    solver.add(same_city_with_others)\n\n# OPTION CHECKING\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\n# Define helper functions to check each option's statement could be false\n\n# (A) Sharon must visit Montreal if Paul visits Vancouver.\n# To check if (A) could be false, check if Paul visits Vancouver and Sharon does NOT visit Montreal is possible.\ndef check_A_false():\n    solver.push()\n    solver.add(city_vars['Paul'] == cities.index('Vancouver'))\n    solver.add(city_vars['Sharon'] != cities.index('Montreal'))\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\n# (B) Regina must visit Vancouver if Paul visits Vancouver.\n# To check if (B) could be false, check if Paul visits Vancouver and Regina does NOT visit Vancouver is possible.\ndef check_B_false():\n    solver.push()\n    solver.add(city_vars['Paul'] == cities.index('Vancouver'))\n    solver.add(city_vars['Regina'] != cities.index('Vancouver'))\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\n# (C) Regina visits a city with exactly two of the other four students.\n# That means total 3 students in Regina's city (Regina + 2 others)\n# To check if (C) could be false, check if Regina's city has NOT exactly 3 students total\ndef check_C_false():\n    solver.push()\n    # Count number of students in Regina's city\n    reg_city = city_vars['Regina']\n    count_in_reg_city = Sum([If(city_vars[s] == reg_city, 1, 0) for s in students])\n    # Check count_in_reg_city != 3\n    solver.add(count_in_reg_city != 3)\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\n# (D) Lori visits a city with exactly one of the other four students.\n# That means total 2 students in Lori's city (Lori + 1 other)\n# To check if (D) could be false, check if Lori's city has NOT exactly 2 students total\ndef check_D_false():\n    solver.push()\n    lori_city = city_vars['Lori']\n    count_in_lori_city = Sum([If(city_vars[s] == lori_city, 1, 0) for s in students])\n    solver.add(count_in_lori_city != 2)\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\n# (E) Lori visits a city with Paul or else with Sharon.\n# To check if (E) could be false, check if Lori's city is different from Paul's city AND different from Sharon's city\ndef check_E_false():\n    solver.push()\n    solver.add(city_vars['Lori'] != city_vars['Paul'])\n    solver.add(city_vars['Lori'] != city_vars['Sharon'])\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\nchecks = [check_A_false, check_B_false, check_C_false, check_D_false, check_E_false]\n\nfor i, check in enumerate(checks):\n    if check():\n        print(f\"'{options[i]}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of five students—Hubert, Lori, Paul, Regina, and Sharon—will visit exactly one of three cities—Montreal, Toronto, or Vancouver—for the month of March, according to the following conditions: Sharon visits a different city than Paul. Hubert visits the same city as Regina. Lori visits Montreal or else Toronto. If Paul visits Vancouver, Hubert visits Vancouver with him. Each student visits one of the cities with at least one of the other four students.\n\nIf Regina visits Toronto, which one of the following could be true in March?\n\nOptions:\n(A) Lori visits Toronto.\n(B) Lori visits Vancouver.\n(C) Paul visits Toronto.\n(D) Paul visits Vancouver.\n(E) Sharon visits Vancouver.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Hubert', 'Lori', 'Paul', 'Regina', 'Sharon']\ncities = ['Montreal', 'Toronto', 'Vancouver']\n\n# Map city names to indices for Z3 variables\ncity_idx = {city: i for i, city in enumerate(cities)}\n\n# Create Z3 Int variables for each student to represent their city\ncity_vars = {student: Int(student) for student in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student visits exactly one city (value in valid range)\nfor student in students:\n    solver.add(And(city_vars[student] >= 0, city_vars[student] < len(cities)))\n\n# Each student visits one of the cities with at least one other student\n# This means no student is alone in their city\nfor student in students:\n    others = [city_vars[other] == city_vars[student] for other in students if other != student]\n    solver.add(Or(others))\n\n# Sharon visits a different city than Paul\nsolver.add(city_vars['Sharon'] != city_vars['Paul'])\n\n# Hubert visits the same city as Regina\nsolver.add(city_vars['Hubert'] == city_vars['Regina'])\n\n# Lori visits Montreal or else Toronto (Lori does not visit Vancouver)\nsolver.add(Or(city_vars['Lori'] == city_idx['Montreal'], city_vars['Lori'] == city_idx['Toronto']))\n\n# If Paul visits Vancouver, Hubert visits Vancouver with him\npaul_vancouver = city_vars['Paul'] == city_idx['Vancouver']\nhubert_vancouver = city_vars['Hubert'] == city_idx['Vancouver']\nsolver.add(Implies(paul_vancouver, hubert_vancouver))\n\n# Regina visits Toronto (given condition)\nsolver.add(city_vars['Regina'] == city_idx['Toronto'])\n\n# OPTION CHECKING\noptions = {\n    'A': city_vars['Lori'] == city_idx['Toronto'],\n    'B': city_vars['Lori'] == city_idx['Vancouver'],\n    'C': city_vars['Paul'] == city_idx['Toronto'],\n    'D': city_vars['Paul'] == city_idx['Vancouver'],\n    'E': city_vars['Sharon'] == city_idx['Vancouver'],\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of five students—Hubert, Lori, Paul, Regina, and Sharon—will visit exactly one of three cities—Montreal, Toronto, or Vancouver—for the month of March, according to the following conditions: Sharon visits a different city than Paul. Hubert visits the same city as Regina. Lori visits Montreal or else Toronto. If Paul visits Vancouver, Hubert visits Vancouver with him. Each student visits one of the cities with at least one of the other four students.\n\nWhich one of the following must be true for March?\n\nOptions:\n(A) If any of the students visits Montreal, Lori visits Montreal.\n(B) If any of the students visits Montreal, exactly two of them do.\n(C) If any of the students visits Toronto, exactly three of them do.\n(D) If any of the students visits Vancouver, Paul visits Vancouver.\n(E) If any of the students visits Vancouver, exactly three of them do.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Hubert', 'Lori', 'Paul', 'Regina', 'Sharon']\ncities = ['Montreal', 'Toronto', 'Vancouver']\n\n# Map city names to indices\nMONTREAL = cities.index('Montreal')\nTORONTO = cities.index('Toronto')\nVANCOUVER = cities.index('Vancouver')\n\n# Create Z3 Int variables for each student's city\ncity_visit = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student visits exactly one city (value in 0..2)\nfor s in students:\n    solver.add(And(city_visit[s] >= 0, city_visit[s] < len(cities)))\n\n# Constraint: Sharon visits a different city than Paul\nsolver.add(city_visit['Sharon'] != city_visit['Paul'])\n\n# Constraint: Hubert visits the same city as Regina\nsolver.add(city_visit['Hubert'] == city_visit['Regina'])\n\n# Constraint: Lori visits Montreal or else Toronto\nsolver.add(Or(city_visit['Lori'] == MONTREAL, city_visit['Lori'] == TORONTO))\n\n# Constraint: If Paul visits Vancouver, Hubert visits Vancouver with him\nsolver.add(Implies(city_visit['Paul'] == VANCOUVER, city_visit['Hubert'] == VANCOUVER))\n\n# Constraint: Each student visits one of the cities with at least one of the other four students\n# For each student s, there exists another student t != s with city_visit[s] == city_visit[t]\nfor s in students:\n    others = [t for t in students if t != s]\n    same_city_with_other = Or([city_visit[s] == city_visit[t] for t in others])\n    solver.add(same_city_with_other)\n\n# OPTION CHECKING\n# Define a function to check if an option must be true\ndef option_must_be_true(option_constraint):\n    # Check if negation of option_constraint is satisfiable with base constraints\n    solver.push()\n    solver.add(Not(option_constraint))\n    result = solver.check()\n    solver.pop()\n    return result == unsat\n\n# Option (A): If any student visits Montreal, Lori visits Montreal.\n# That is: if Montreal is visited by any student, then Lori visits Montreal.\nmontreal_visited = Or([city_visit[s] == MONTREAL for s in students])\noption_A = Implies(montreal_visited, city_visit['Lori'] == MONTREAL)\n\n# Option (B): If any student visits Montreal, exactly two of them do.\n# Count how many visit Montreal\nmontreal_counts = [If(city_visit[s] == MONTREAL, 1, 0) for s in students]\nsum_montreal = Sum(montreal_counts)\noption_B = Implies(montreal_visited, sum_montreal == 2)\n\n# Option (C): If any student visits Toronto, exactly three of them do.\ntoronto_visited = Or([city_visit[s] == TORONTO for s in students])\ntoronto_counts = [If(city_visit[s] == TORONTO, 1, 0) for s in students]\nsum_toronto = Sum(toronto_counts)\noption_C = Implies(toronto_visited, sum_toronto == 3)\n\n# Option (D): If any student visits Vancouver, Paul visits Vancouver.\nvancouver_visited = Or([city_visit[s] == VANCOUVER for s in students])\noption_D = Implies(vancouver_visited, city_visit['Paul'] == VANCOUVER)\n\n# Option (E): If any student visits Vancouver, exactly three of them do.\nvancouver_counts = [If(city_visit[s] == VANCOUVER, 1, 0) for s in students]\nsum_vancouver = Sum(vancouver_counts)\noption_E = Implies(vancouver_visited, sum_vancouver == 3)\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, opt in enumerate(options):\n    if option_must_be_true(opt):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A college offers one course in each of three subjects—mathematics, nutrition, and oceanography—in the fall and again in the spring. Students' book orders for these course offerings are kept in six folders, numbered 1 through 6, from which labels identifying the folders' contents are missing. The following is known: Each folder contains only the orders for one of the six course offerings. Folder 1 contains orders for the same subject as folder 2 does. The orders in folder 3 are for a different subject than are the orders in folder 4. The fall mathematics orders are in folder 1 or else folder 4. The spring oceanography orders are in folder 1 or else folder 4. The spring nutrition orders are not in folder 5.\n\nWhich one of the following could be the list of the contents of the folders, in order from folder 1 to folder 6 ?\n\nOptions:\n(A) fall mathematics, spring mathematics, fall oceanography, fall nutrition, spring nutrition, spring oceanography\n(B) fall oceanography, spring nutrition, fall nutrition, fall mathematics, spring mathematics, spring oceanography\n(C) spring mathematics, fall mathematics, spring nutrition, fall oceanography, fall nutrition, spring oceanography\n(D) spring oceanography, fall oceanography, fall nutrition, fall mathematics, spring mathematics, spring nutrition\n(E) spring oceanography, fall oceanography, spring mathematics, fall mathematics, fall nutrition, spring nutrition",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsubjects = ['mathematics', 'nutrition', 'oceanography']\nseasons = ['fall', 'spring']\n\n# Map course offerings to indices for easy reference\ncourses = []\nfor season in seasons:\n    for subject in subjects:\n        courses.append(f\"{season} {subject}\")\n\n# Create Int variables for each folder representing the index of the course it contains\nfolders = [Int(f\"folder{i}\") for i in range(1, 7)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each folder contains exactly one of the six courses (0 to 5)\nfor folder in folders:\n    solver.add(And(folder >= 0, folder < len(courses)))\n\n# All folders contain different courses (Distinct)\nsolver.add(Distinct(folders))\n\n# Folder 1 contains orders for the same subject as folder 2 does.\n# Extract subjects for folder 1 and folder 2\ndef subject_of(folder_var):\n    # The subject index is (course_index % 3)\n    return folder_var % 3\n\nsolver.add(subject_of(folders[0]) == subject_of(folders[1]))\n\n# The orders in folder 3 are for a different subject than are the orders in folder 4.\nsolver.add(subject_of(folders[2]) != subject_of(folders[3]))\n\n# The fall mathematics orders are in folder 1 or else folder 4.\nfall_math_index = courses.index('fall mathematics')\nsolver.add(Or(folders[0] == fall_math_index, folders[3] == fall_math_index))\n\n# The spring oceanography orders are in folder 1 or else folder 4.\nspring_ocean_index = courses.index('spring oceanography')\nsolver.add(Or(folders[0] == spring_ocean_index, folders[3] == spring_ocean_index))\n\n# The spring nutrition orders are not in folder 5.\nspring_nutrition_index = courses.index('spring nutrition')\nsolver.add(folders[4] != spring_nutrition_index)\n\n# OPTION CHECKING\noptions = [\n    ['fall mathematics', 'spring mathematics', 'fall oceanography', 'fall nutrition', 'spring nutrition', 'spring oceanography'],\n    ['fall oceanography', 'spring nutrition', 'fall nutrition', 'fall mathematics', 'spring mathematics', 'spring oceanography'],\n    ['spring mathematics', 'fall mathematics', 'spring nutrition', 'fall oceanography', 'fall nutrition', 'spring oceanography'],\n    ['spring oceanography', 'fall oceanography', 'fall nutrition', 'fall mathematics', 'spring mathematics', 'spring nutrition'],\n    ['spring oceanography', 'fall oceanography', 'spring mathematics', 'fall mathematics', 'fall nutrition', 'spring nutrition']\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that folders match the option courses in order\n    for idx, course_name in enumerate(option):\n        solver.add(folders[idx] == courses.index(course_name))\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A college offers one course in each of three subjects—mathematics, nutrition, and oceanography—in the fall and again in the spring. Students' book orders for these course offerings are kept in six folders, numbered 1 through 6, from which labels identifying the folders' contents are missing. The following is known: Each folder contains only the orders for one of the six course offerings. Folder 1 contains orders for the same subject as folder 2 does. The orders in folder 3 are for a different subject than are the orders in folder 4. The fall mathematics orders are in folder 1 or else folder 4. The spring oceanography orders are in folder 1 or else folder 4. The spring nutrition orders are not in folder 5.\n\nWhich one of the following statements must be false?\n\nOptions:\n(A) The spring mathematics orders are in folder 3.\n(B) The fall nutrition orders are in folder 3.\n(C) The spring oceanography orders are in folder 1.\n(D) The spring nutrition orders are in folder 6.\n(E) The fall oceanography orders are in folder 5.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nsubjects = ['Mathematics', 'Nutrition', 'Oceanography']\nseasons = ['Fall', 'Spring']\nfolders = [1, 2, 3, 4, 5, 6]\n\n# Map each course offering (subject + season) to a Z3 Int variable representing the folder number\n# The value of each variable is in [1..6]\n\ncourse_vars = {}\nfor subject in subjects:\n    for season in seasons:\n        course_vars[(subject, season)] = Int(f'{season}_{subject}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each course offering is in exactly one folder between 1 and 6\nfor var in course_vars.values():\n    solver.add(And(var >= 1, var <= 6))\n\n# All folders contain exactly one course offering\n# So all folder assignments are distinct\nsolver.add(Distinct([course_vars[c] for c in course_vars]))\n\n# Folder 1 contains orders for the same subject as folder 2 does.\n# This means the subjects of the courses in folder 1 and folder 2 are the same.\n\n# We need to express that the subjects of the courses assigned to folder 1 and folder 2 are the same.\n\n# Since each course is assigned a folder, we can invert the mapping:\n# For each folder, which course is assigned?\n\n# Let's create helper functions to check if a course is in a folder.\n\ndef course_in_folder(course, folder):\n    return course_vars[course] == folder\n\n# We want to express:\n# The subject of the course in folder 1 == subject of the course in folder 2\n\n# There is exactly one course assigned to folder 1 and exactly one assigned to folder 2.\n# So let's find which courses can be in folder 1 and which in folder 2.\n\n# For folder 1, one of the six courses is assigned:\n# Exactly one course is in folder 1:\nsolver.add(Or([course_in_folder(c,1) for c in course_vars]))\nsolver.add(Or([course_in_folder(c,2) for c in course_vars]))\n\n# For folder 1 and 2, the subjects must be the same:\n# So for all pairs of courses (c1, c2) where c1 is in folder 1 and c2 is in folder 2,\n# if folder1_course_subject != folder2_course_subject then that pair cannot happen.\n\n# So we add constraint:\n# For all pairs (c1, c2):\n# If course_vars[c1]==1 and course_vars[c2]==2 then subject(c1) == subject(c2)\n\nsubject_index = {s:i for i,s in enumerate(subjects)}\n\n# Create helper to get subject index\ndef subject_of(course):\n    return subject_index[course[0]]\n\npairs = []\nfor c1 in course_vars:\n    for c2 in course_vars:\n        cond = And(course_vars[c1] == 1, course_vars[c2] == 2)\n        same_subject = subject_of(c1) == subject_of(c2)\n        # If cond then same_subject must be true\n        solver.add(Implies(cond, same_subject))\n\n# The orders in folder 3 are for a different subject than are the orders in folder 4.\n# Similar logic as above, but subjects must differ\n\nsolver.add(Or([course_in_folder(c,3) for c in course_vars]))\nsolver.add(Or([course_in_folder(c,4) for c in course_vars]))\n\nfor c3 in course_vars:\n    for c4 in course_vars:\n        cond = And(course_vars[c3] == 3, course_vars[c4] == 4)\n        diff_subject = subject_of(c3) != subject_of(c4)\n        solver.add(Implies(cond, diff_subject))\n\n# The fall mathematics orders are in folder 1 or else folder 4.\nsolver.add(Or(course_vars[('Mathematics', 'Fall')] == 1, course_vars[('Mathematics', 'Fall')] == 4))\n\n# The spring oceanography orders are in folder 1 or else folder 4.\nsolver.add(Or(course_vars[('Oceanography', 'Spring')] == 1, course_vars[('Oceanography', 'Spring')] == 4))\n\n# The spring nutrition orders are not in folder 5.\nsolver.add(course_vars[('Nutrition', 'Spring')] != 5)\n\n# OPTION CHECKING\n\n# Options:\n# (A) The spring mathematics orders are in folder 3.\n# (B) The fall nutrition orders are in folder 3.\n# (C) The spring oceanography orders are in folder 1.\n# (D) The spring nutrition orders are in folder 6.\n# (E) The fall oceanography orders are in folder 5.\n\noptions = [\n    ('A', course_vars[('Mathematics', 'Spring')] == 3),\n    ('B', course_vars[('Nutrition', 'Fall')] == 3),\n    ('C', course_vars[('Oceanography', 'Spring')] == 1),\n    ('D', course_vars[('Nutrition', 'Spring')] == 6),\n    ('E', course_vars[('Oceanography', 'Fall')] == 5)\n]\n\n# We want to find which option must be false.\n# So for each option, we check if it can be true.\n# If it cannot be true, it must be false (must be false means impossible).\n\nfor letter, cond in options:\n    solver.push()\n    solver.add(cond)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A college offers one course in each of three subjects—mathematics, nutrition, and oceanography—in the fall and again in the spring. Students' book orders for these course offerings are kept in six folders, numbered 1 through 6, from which labels identifying the folders' contents are missing. The following is known: Each folder contains only the orders for one of the six course offerings. Folder 1 contains orders for the same subject as folder 2 does. The orders in folder 3 are for a different subject than are the orders in folder 4. The fall mathematics orders are in folder 1 or else folder 4. The spring oceanography orders are in folder 1 or else folder 4. The spring nutrition orders are not in folder 5.\n\nIf the fall oceanography orders are in folder 2, then which one of the following statements could be true?\n\nOptions:\n(A) The spring mathematics orders are in folder 4.\n(B) The spring mathematics orders are in folder 6.\n(C) The fall nutrition orders are in folder 1.\n(D) The spring nutrition orders are in neither folder 3 nor folder 6.\n(E) Neither the spring nor the fall nutrition orders are in folder 3.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsubjects = ['Mathematics', 'Nutrition', 'Oceanography']\nsemesters = ['Fall', 'Spring']\nfolders = [1, 2, 3, 4, 5, 6]\n\n# Create variables: folder_subject_semester[folder] = subject index for that folder's orders\n# Since each folder contains orders for exactly one course offering (subject + semester),\n# we assign to each folder a course offering index from 0 to 5:\n# course_offerings = [(Fall, Mathematics), (Fall, Nutrition), (Fall, Oceanography),\n#                     (Spring, Mathematics), (Spring, Nutrition), (Spring, Oceanography)]\ncourse_offerings = []\nfor sem in semesters:\n    for sub in subjects:\n        course_offerings.append((sem, sub))\n\n# Map each folder to a course offering index (0 to 5)\nfolder_course = {}\nfor f in folders:\n    folder_course[f] = Int(f'folder_{f}_course')\n    \n# Helper: get semester and subject for a course offering index\ndef sem_of(i):\n    return course_offerings[i][0]\ndef sub_of(i):\n    return course_offerings[i][1]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each folder contains exactly one course offering (value 0..5)\nfor f in folders:\n    solver.add(And(folder_course[f] >= 0, folder_course[f] < 6))\n\n# All folders contain different course offerings (Distinct)\nsolver.add(Distinct([folder_course[f] for f in folders]))\n\n# Folder 1 contains orders for the same subject as folder 2 does.\n# So subjects of folder_course[1] and folder_course[2] must be equal.\n# Extract subjects for folder 1 and 2:\n# We encode subject equality by checking the subject index in course_offerings.\n# subject index: Mathematics=0, Nutrition=1, Oceanography=2\nsub_index = {'Mathematics':0, 'Nutrition':1, 'Oceanography':2}\n\n# Create functions to get subject index from course offering index\n# Since course_offerings fixed, we create arrays for subject and semester index\nsubject_indices = [sub_index[sub_of(i)] for i in range(6)]\nsemester_indices = [0 if sem_of(i) == 'Fall' else 1 for i in range(6)]\n\n# We create IntVal arrays for subject and semester per course offering index\n# Use Z3 arrays for subject and semester lookup\nsubject_array = Array('subject_array', IntSort(), IntSort())\nsemester_array = Array('semester_array', IntSort(), IntSort())\n# Initialize arrays with fixed values using Store\nsubject_array = Store(subject_array, 0, subject_indices[0])\nsubject_array = Store(subject_array, 1, subject_indices[1])\nsubject_array = Store(subject_array, 2, subject_indices[2])\nsubject_array = Store(subject_array, 3, subject_indices[3])\nsubject_array = Store(subject_array, 4, subject_indices[4])\nsubject_array = Store(subject_array, 5, subject_indices[5])\n\nsemester_array = Store(semester_array, 0, semester_indices[0])\nsemester_array = Store(semester_array, 1, semester_indices[1])\nsemester_array = Store(semester_array, 2, semester_indices[2])\nsemester_array = Store(semester_array, 3, semester_indices[3])\nsemester_array = Store(semester_array, 4, semester_indices[4])\nsemester_array = Store(semester_array, 5, semester_indices[5])\n\n# Constraint: folder 1 and folder 2 have same subject\nsolver.add(subject_array[folder_course[1]] == subject_array[folder_course[2]])\n\n# The orders in folder 3 are for a different subject than are the orders in folder 4.\nsolver.add(subject_array[folder_course[3]] != subject_array[folder_course[4]])\n\n# The fall mathematics orders are in folder 1 or else folder 4.\n# Fall mathematics index is course_offerings index where sem='Fall' and sub='Mathematics'\nfall_math_index = course_offerings.index(('Fall', 'Mathematics'))\nsolver.add(Or(folder_course[1] == fall_math_index, folder_course[4] == fall_math_index))\n\n# The spring oceanography orders are in folder 1 or else folder 4.\nspring_ocean_index = course_offerings.index(('Spring', 'Oceanography'))\nsolver.add(Or(folder_course[1] == spring_ocean_index, folder_course[4] == spring_ocean_index))\n\n# The spring nutrition orders are not in folder 5.\nspring_nutrition_index = course_offerings.index(('Spring', 'Nutrition'))\nsolver.add(folder_course[5] != spring_nutrition_index)\n\n# Additional given condition: If the fall oceanography orders are in folder 2\nfall_ocean_index = course_offerings.index(('Fall', 'Oceanography'))\nsolver.add(folder_course[2] == fall_ocean_index)\n\n# OPTION CHECKING\n# Options:\n# (A) The spring mathematics orders are in folder 4.\n# (B) The spring mathematics orders are in folder 6.\n# (C) The fall nutrition orders are in folder 1.\n# (D) The spring nutrition orders are in neither folder 3 nor folder 6.\n# (E) Neither the spring nor the fall nutrition orders are in folder 3.\n\nspring_math_index = course_offerings.index(('Spring', 'Mathematics'))\nfall_nutrition_index = course_offerings.index(('Fall', 'Nutrition'))\n\nspring_nutrition_index = course_offerings.index(('Spring', 'Nutrition'))\n\noptions = [\n    folder_course[4] == spring_math_index,  # A\n    folder_course[6] == spring_math_index,  # B\n    folder_course[1] == fall_nutrition_index,  # C\n    And(folder_course[3] != spring_nutrition_index, folder_course[6] != spring_nutrition_index),  # D\n    And(folder_course[3] != spring_nutrition_index, folder_course[3] != fall_nutrition_index)  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A college offers one course in each of three subjects—mathematics, nutrition, and oceanography—in the fall and again in the spring. Students' book orders for these course offerings are kept in six folders, numbered 1 through 6, from which labels identifying the folders' contents are missing. The following is known: Each folder contains only the orders for one of the six course offerings. Folder 1 contains orders for the same subject as folder 2 does. The orders in folder 3 are for a different subject than are the orders in folder 4. The fall mathematics orders are in folder 1 or else folder 4. The spring oceanography orders are in folder 1 or else folder 4. The spring nutrition orders are not in folder 5.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) The spring mathematics orders are in folder 1.\n(B) The fall oceanography orders are in folder 1.\n(C) The fall nutrition orders are in folder 4, and the fall oceanography orders are in folder 6.\n(D) The fall oceanography orders are in folder 2, and the spring oceanography orders are in folder 1.\n(E) The spring oceanography orders are in folder 1, and neither the spring nor the fall nutrition orders are in folder 3.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Subjects and terms\nsubjects = ['Math', 'Nutrition', 'Oceanography']\nterms = ['Fall', 'Spring']\n\n# Courses: each combination of subject and term\ncourses = [(subj, term) for subj in subjects for term in terms]  # 6 courses\n\n# Folders numbered 1 to 6 (indices 0 to 5 for Z3)\nfolder_indices = range(6)\n\n# Map courses to indices for convenience\ncourse_indices = {course: i for i, course in enumerate(courses)}\n\n# Create variables: folder_course[i] = index of course in folder i (i from 0 to 5)\nfolder_course = [Int(f'folder_{i+1}_course') for i in folder_indices]\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each folder contains exactly one course (value in 0..5)\nfor fc in folder_course:\n    solver.add(And(fc >= 0, fc < 6))\n\n# All folders have distinct courses (no two folders have the same course)\nsolver.add(Distinct(folder_course))\n\n# Folder 1 and Folder 2 contain orders for the same subject\n# Extract subject index (0=Math,1=Nutrition,2=Oceanography) from course index\ndef subject_of(course_var):\n    # course_var in 0..5, each 2 courses per subject\n    # courses arranged as (Math,Fall),(Math,Spring),(Nutrition,Fall),(Nutrition,Spring),(Oceanography,Fall),(Oceanography,Spring)\n    # So subject = course_var // 2\n    return course_var / 2\n\n# Since Z3 doesn't support division for Ints returning Int, use integer division by shifting\n# subject_of = course_var // 2\ndef subject_of_z3(course_var):\n    return course_var / 2  # This returns a Real, so better to use Div for Int division\ndef subject_of_int(course_var):\n    return course_var / 2  # We'll use Div(course_var,2) for integer division\n\nfor i in [0,1]:  # Folder 1 and 2 are indices 0 and 1\n    pass\n\n# Use integer division Div(course_var,2) to get subject index\nsolver.add( (folder_course[0] / 2) == (folder_course[1] / 2) )\n\n# Folder 3 and Folder 4 contain orders for different subjects\nsolver.add( (folder_course[2] / 2) != (folder_course[3] / 2) )\n\n# Fall mathematics orders are in folder 1 or folder 4\n# Fall Math course index = courses.index(('Math','Fall')) = 0\nfall_math = course_indices[('Math','Fall')]\nsolver.add(Or(folder_course[0] == fall_math, folder_course[3] == fall_math))\n\n# Spring oceanography orders are in folder 1 or folder 4\nspring_ocean = course_indices[('Oceanography','Spring')]\nsolver.add(Or(folder_course[0] == spring_ocean, folder_course[3] == spring_ocean))\n\n# Spring nutrition orders are not in folder 5\nspring_nutrition = course_indices[('Nutrition','Spring')]\nsolver.add(folder_course[4] != spring_nutrition)\n\n# OPTION CHECKING\n\n# Define helper function to check an option\ndef check_option(option_constraints):\n    solver.push()\n    for c in option_constraints:\n        solver.add(c)\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\n# Option A: The spring mathematics orders are in folder 1.\nspring_math = course_indices[('Math','Spring')]\noption_A = [folder_course[0] == spring_math]\n\n# Option B: The fall oceanography orders are in folder 1.\nfall_ocean = course_indices[('Oceanography','Fall')]\noption_B = [folder_course[0] == fall_ocean]\n\n# Option C: The fall nutrition orders are in folder 4, and the fall oceanography orders are in folder 6.\nfall_nutrition = course_indices[('Nutrition','Fall')]\noption_C = [folder_course[3] == fall_nutrition, folder_course[5] == fall_ocean]\n\n# Option D: The fall oceanography orders are in folder 2, and the spring oceanography orders are in folder 1.\noption_D = [folder_course[1] == fall_ocean, folder_course[0] == spring_ocean]\n\n# Option E: The spring oceanography orders are in folder 1, and neither the spring nor the fall nutrition orders are in folder 3.\noption_E = [folder_course[0] == spring_ocean,\n            folder_course[2] != spring_nutrition,\n            folder_course[2] != fall_nutrition]\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, opt in enumerate(options):\n    if check_option(opt):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A college offers one course in each of three subjects—mathematics, nutrition, and oceanography—in the fall and again in the spring. Students' book orders for these course offerings are kept in six folders, numbered 1 through 6, from which labels identifying the folders' contents are missing. The following is known: Each folder contains only the orders for one of the six course offerings. Folder 1 contains orders for the same subject as folder 2 does. The orders in folder 3 are for a different subject than are the orders in folder 4. The fall mathematics orders are in folder 1 or else folder 4. The spring oceanography orders are in folder 1 or else folder 4. The spring nutrition orders are not in folder 5.\n\nIf the fall oceanography orders are in folder 2, then for exactly how many of the remaining five folders can it be deduced which course offering's orders are in that folder?\n\nOptions:\n(A) one\n(B) two\n(C) three\n(D) four\n(E) five",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Subjects\nsubjects = ['Mathematics', 'Nutrition', 'Oceanography']\n# Terms\nterms = ['Fall', 'Spring']\n\n# Course offerings: list of (term, subject) pairs\ncourse_offerings = [(t, s) for t in terms for s in subjects]\n\n# Map each course offering to an index for easy reference\ncourse_index = {co: i for i, co in enumerate(course_offerings)}\n\n# Folders 1 through 6\nfolders = [1, 2, 3, 4, 5, 6]\n\n# Create variables: folder_contents[f] = index of course offering in folder f\nfolder_contents = {}\nfor f in folders:\n    folder_contents[f] = Int(f'folder_{f}')\n    \n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each folder contains exactly one course offering (0 to 5)\nfor f in folders:\n    solver.add(And(folder_contents[f] >= 0, folder_contents[f] < len(course_offerings)))\n\n# All folders have distinct course offerings (all six different)\nsolver.add(Distinct([folder_contents[f] for f in folders]))\n\n# Folder 1 contains orders for the same subject as folder 2 does\n# Extract subject indices for folder 1 and 2\nfolder1_subj = Int('folder1_subj')\nfolder2_subj = Int('folder2_subj')\n\nsolver.add(folder1_subj == Sum([If(folder_contents[1] == course_index[(t, s)], s_idx, 0) for t in terms for s_idx, s in enumerate(subjects)]))\nsolver.add(folder2_subj == Sum([If(folder_contents[2] == course_index[(t, s)], s_idx, 0) for t in terms for s_idx, s in enumerate(subjects)]))\n# But above sums won't work properly because s_idx is 0,1,2 and summing conditional 0 or s_idx won't work directly.\n# Instead, define function to get subject index from course offering index:\n# We'll create a function mapping course index to subject index:\n\n# Create arrays for subject index per course offering\nsubject_of_course = [subjects.index(co[1]) for co in course_offerings]\n\n# Create helper function: subject_of_folder_f = subject_of_course[folder_contents[f]]\n# We can define subject_of_folder_f as Int variable and constrain it accordingly\n\nsubject_of_folder = {}\nfor f in folders:\n    subject_of_folder[f] = Int(f'subject_of_folder_{f}')\n    # subject_of_folder[f] == subject_of_course[folder_contents[f]]\n    # Implement as a table constraint:\n    conds = [folder_contents[f] == i for i in range(len(course_offerings))]\n    subj_vals = [subject_of_course[i] for i in range(len(course_offerings))]\n    solver.add(subject_of_folder[f] == Sum([If(conds[i], subj_vals[i], 0) for i in range(len(course_offerings))]))\n\n# Folder 1 and folder 2 have same subject\nsolver.add(subject_of_folder[1] == subject_of_folder[2])\n\n# The orders in folder 3 are for a different subject than are the orders in folder 4\nsolver.add(subject_of_folder[3] != subject_of_folder[4])\n\n# The fall mathematics orders are in folder 1 or else folder 4\nfall_math_idx = course_index[('Fall', 'Mathematics')]\nsolver.add(Or(folder_contents[1] == fall_math_idx, folder_contents[4] == fall_math_idx))\n\n# The spring oceanography orders are in folder 1 or else folder 4\nspring_ocean_idx = course_index[('Spring', 'Oceanography')]\nsolver.add(Or(folder_contents[1] == spring_ocean_idx, folder_contents[4] == spring_ocean_idx))\n\n# The spring nutrition orders are not in folder 5\nspring_nutrition_idx = course_index[('Spring', 'Nutrition')]\nsolver.add(folder_contents[5] != spring_nutrition_idx)\n\n# The question condition: If the fall oceanography orders are in folder 2\nfall_ocean_idx = course_index[('Fall', 'Oceanography')]\nsolver.push()\nsolver.add(folder_contents[2] == fall_ocean_idx)\n\n# OPTION CHECKING\n\n# We want to find for how many of the remaining five folders (folders except 2)\n# can it be deduced which course offering's orders are in that folder.\n\n# That means: For each folder f in {1,3,4,5,6}, check if the course offering in folder f is uniquely determined\n# under the constraints and folder_contents[2] == fall_ocean_idx.\n\n# To check uniqueness for a folder f:\n# 1. Find one model (solution) -> get value v = folder_contents[f]\n# 2. Add constraint folder_contents[f] != v and check if still satisfiable.\n#    - If unsat, then folder f's content is uniquely determined (only one possible value)\n#    - If sat, then not uniquely determined.\n\nunique_count = 0\nfolders_to_check = [1,3,4,5,6]\n\nif solver.check() == sat:\n    model = solver.model()\n    for f in folders_to_check:\n        val = model[folder_contents[f]].as_long()\n        solver.push()\n        solver.add(folder_contents[f] != val)\n        res = solver.check()\n        if res == unsat:\n            unique_count += 1\n        solver.pop()\n\nsolver.pop()\n\n# Map unique_count to options\n# (A) one -> 1\n# (B) two -> 2\n# (C) three ->3\n# (D) four ->4\n# (E) five ->5\n\noption_map = {\n    1: 'A',\n    2: 'B',\n    3: 'C',\n    4: 'D',\n    5: 'E'\n}\n\nprint(f\"'{option_map[unique_count]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Greenburg has exactly five subway lines: Ll, L2, L3, L4, and L5. Along each of the lines, trains run in both directions, stopping at every station. Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel, and the reverse in the other direction. L2 connects Tonka with Semplain, and with no other station. L3 connects Rincon with Urstine, and with no other station. L4 runs from Quetzal through exactly one other station, Greene, to Rincon. L5 connects Quetzal with Tonka, and with no other station.\n\nHow many different stations are there that a traveler starting at Rincon could reach by using the subway lines without making any intermediate stops?\n\nOptions:\n(A) two\n(B) three\n(C) four\n(D) five\n(E) six",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Stations\nstations = ['Rincon', 'Tonka', 'French', 'Semplain', 'Urstine', 'Quetzal', 'Park', 'Greene']\nstation_idx = {s: i for i, s in enumerate(stations)}\n\n# Lines and their connections (pairs of stations connected directly)\n# Ll is a loop of 7 stations: Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon\n# L2 connects Tonka with Semplain only\n# L3 connects Rincon with Urstine only\n# L4 runs Quetzal-Greene-Rincon (Greene is the only other station on L4)\n# L5 connects Quetzal with Tonka only\n\n# Define adjacency list by line (undirected edges)\n# Ll connections (loop)\nLl_connections = [\n    ('Rincon', 'Tonka'),\n    ('Tonka', 'French'),\n    ('French', 'Semplain'),\n    ('Semplain', 'Urstine'),\n    ('Urstine', 'Quetzal'),\n    ('Quetzal', 'Park'),\n    ('Park', 'Rincon')\n]\n\n# Other lines connections\nL2_connections = [('Tonka', 'Semplain')]\nL3_connections = [('Rincon', 'Urstine')]\nL4_connections = [('Quetzal', 'Greene'), ('Greene', 'Rincon')]\nL5_connections = [('Quetzal', 'Tonka')]\n\n# Combine all connections, since trains run both directions and stop at every station\n# We want to know which stations are directly reachable from Rincon without intermediate stops\n# So direct connections from Rincon on any line count\n\n# CONSTRAINTS\n# We want to find stations reachable from Rincon by a single train without intermediate stops\n# That means stations directly connected to Rincon on any line\n\n# Collect all edges\nall_connections = Ll_connections + L2_connections + L3_connections + L4_connections + L5_connections\n\n# Build adjacency map (undirected)\nadjacency = {s: set() for s in stations}\nfor (a, b) in all_connections:\n    adjacency[a].add(b)\n    adjacency[b].add(a)\n\n# Stations reachable from Rincon without intermediate stops are adjacency[Rincon]\nreachable_from_rincon = adjacency['Rincon']\n\n# Count how many stations are reachable from Rincon (excluding Rincon itself)\ncount_reachable = len(reachable_from_rincon)\n\n# OPTION CHECKING\noptions = [2, 3, 4, 5, 6]\n\nfor i, opt in enumerate(options):\n    solver = Solver()\n    # Check if count_reachable == opt\n    # We know count_reachable is fixed from the data, so just check equality\n    if count_reachable == opt:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Greenburg has exactly five subway lines: Ll, L2, L3, L4, and L5. Along each of the lines, trains run in both directions, stopping at every station. Ll runs in a loop connecting exactly seven stations, their order being Rincon-Tonka-French-Semplain-Urstine-Quetzal-Park-Rincon in one direction of travel, and the reverse in the other direction. L2 connects Tonka with Semplain, and with no other station. L3 connects Rincon with Urstine, and with no other station. L4 runs from Quetzal through exactly one other station, Greene, to Rincon. L5 connects Quetzal with Tonka, and with no other station.\n\nIf a sixth subway line is to be constructed so that all of the stations would have two or more lines reaching them, the stations connected by the new subway line must include at least\n\nOptions:\n(A) French, Greene, and Park\n(B) French, Greene, and Quetzal\n(C) French, Greene, and Rincon\n(D) Park, Tonka, and Urstine\n(E) Park, Semplain, and Tonka",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Stations\nstations = ['Rincon', 'Tonka', 'French', 'Semplain', 'Urstine', 'Quetzal', 'Park', 'Greene']\n\n# Map station names to indices for easy reference\nstation_idx = {name: i for i, name in enumerate(stations)}\n\n# Existing lines and their stations\n\n# L1 loop (7 stations in order)\nL1_order = ['Rincon', 'Tonka', 'French', 'Semplain', 'Urstine', 'Quetzal', 'Park']\n\n# L2 connects Tonka - Semplain only\nL2 = [('Tonka', 'Semplain')]\n\n# L3 connects Rincon - Urstine only\nL3 = [('Rincon', 'Urstine')]\n\n# L4 connects Quetzal - Greene - Rincon (through Greene)\nL4 = [('Quetzal', 'Greene'), ('Greene', 'Rincon')]\n\n# L5 connects Quetzal - Tonka only\nL5 = [('Quetzal', 'Tonka')]\n\n# Build adjacency sets for each station to count lines reaching them\n\n# For each station, record which lines serve it (by presence on that line)\n# L1 serves all stations in L1_order (7 stations)\n# L2 serves Tonka, Semplain\n# L3 serves Rincon, Urstine\n# L4 serves Quetzal, Greene, Rincon\n# L5 serves Quetzal, Tonka\n\n# Stations served by lines:\nlines_serving = {s: set() for s in stations}\n\nfor s in L1_order:\n    lines_serving[s].add('L1')\n\nfor s in ['Tonka', 'Semplain']:\n    lines_serving[s].add('L2')\n\nfor s in ['Rincon', 'Urstine']:\n    lines_serving[s].add('L3')\n\nfor s in ['Quetzal', 'Greene', 'Rincon']:\n    lines_serving[s].add('L4')\n\nfor s in ['Quetzal', 'Tonka']:\n    lines_serving[s].add('L5')\n\n# Now, count how many lines serve each station currently\n# We want to find stations with fewer than 2 lines serving them (need the new line to cover these)\n\n# Stations with less than 2 lines:\nstations_needing = [s for s in stations if len(lines_serving[s]) < 2]\n\n# The new line must connect stations so that all stations have at least two lines.\n# So the new line must include all stations that currently have only 1 line serving them,\n# or else those stations would remain with only 1 line.\n\n# Let's check which stations have less than 2 lines:\n\n# Print for debugging:\n# for s in stations:\n#     print(f\"{s}: lines = {lines_serving[s]}, count = {len(lines_serving[s])}\")\n\n# From above:\n# Rincon: L1, L3, L4 => 3 lines (ok)\n# Tonka: L1, L2, L5 => 3 lines (ok)\n# French: L1 only (1 line)\n# Semplain: L1, L2 => 2 lines (ok)\n# Urstine: L1, L3 => 2 lines (ok)\n# Quetzal: L1, L4, L5 => 3 lines (ok)\n# Park: L1 only (1 line)\n# Greene: L4 only (1 line)\n\n# So stations with only 1 line currently: French, Park, Greene\n\n# The new line must include these stations, or else they remain at 1 line.\n\n# The options are sets of stations that the new line must include at least.\n\n# We want to test which option includes all stations that currently have only 1 line.\n\n# Options:\noptions = {\n    'A': ['French', 'Greene', 'Park'],\n    'B': ['French', 'Greene', 'Quetzal'],\n    'C': ['French', 'Greene', 'Rincon'],\n    'D': ['Park', 'Tonka', 'Urstine'],\n    'E': ['Park', 'Semplain', 'Tonka']\n}\n\n# The new line must include French, Greene, Park to cover all 1-line stations.\n# So option A matches exactly the stations that have only 1 line.\n\n# Let's verify with Z3 that only option A can satisfy the condition that all stations have at least two lines after adding the new line.\n\n# MODELING:\n\nsolver = Solver()\n\n# Represent stations as indices for convenience\nnum_stations = len(stations)\n\n# The new line connects some subset of stations.\n\n# We model the new line as a set of stations connected by the line.\n\n# Since the problem states \"stations connected by the new subway line must include at least\" the stations in the option,\n# we will test each option by adding constraints that the new line includes those stations.\n\n# The critical condition: after adding the new line, all stations have at least two lines serving them.\n\n# For each station, count lines serving it after adding the new line:\n# lines_serving_new = lines_serving + 1 if station in new line else 0\n\n# We'll model the new line as a Bool variable per station: True if new line includes station.\n\nnew_line = [Bool(f\"new_{s}\") for s in stations]\n\n# The new line must connect at least the stations in the option being tested.\n\n# We will check each option separately.\n\ndef check_option(option_stations):\n    solver.push()\n    # constraint: new line includes all stations in option_stations\n    for s in option_stations:\n        solver.add(new_line[station_idx[s]] == True)\n\n    # For stations not in option_stations, new_line can be True or False\n\n    # For each station, total lines after adding new line:\n    # total_lines = existing lines count + (1 if new line includes station else 0)\n    # We must have total_lines >= 2 for all stations\n\n    for s in stations:\n        existing_count = len(lines_serving[s])\n        new_line_includes = new_line[station_idx[s]]\n        total_lines = If(new_line_includes, existing_count + 1, existing_count)\n        solver.add(total_lines >= 2)\n\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\nfor letter, sts in options.items():\n    if check_option(sts):\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Prior to this year's annual promotion review, the staff of a law firm consisted of partners Harrison and Rafael, associate Olivos, and assistants Ganz, Johnson, Lowry, Stefano, Turner, and Wilford. During each annual review, each assistant and associate is considered for promotion to the next higher rank, and at least one person is promoted from each of the two lower ranks. An assistant is promoted to associate when a majority of higherranking staff votes for promotion. An associate is promoted to partner when a majority of partners vote for promotion. Everyone eligible votes on every promotion. No one joins or leaves the firm. Olivos never votes for promoting Ganz, Johnson, or Turner. Rafael never votes for promoting Lowry or Stefano. Harrison never votes for promoting Johnson or Wilford.\n\nIf Rafael votes for promoting only Ganz, Olivos, and Wilford, and if Harrison votes for promoting only Lowry, Olivos, and Stefano, then which one of the following could be the complete roster of associates resulting from this year's review?\n\nOptions:\n(A) Ganz, Lowry, Wilford\n(B) Johnson, Lowry, Stefano\n(C) Lowry, Stefano, Turner\n(D) Lowry, Stefano, Wilford\n(E) Olivos, Turner, Wilford",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Staff members by rank before promotion\npartners = ['Harrison', 'Rafael']\nassociates = ['Olivos']\nassistants = ['Ganz', 'Johnson', 'Lowry', 'Stefano', 'Turner', 'Wilford']\n\n# After promotion, some assistants may become associates, and associate may become partner\n# We'll model promotions as booleans:\n# promoted_to_associate[assistant] = True if assistant promoted to associate\n# promoted_to_partner[associate] = True if associate promoted to partner\n\n# The final associates after promotion:\n# start with Olivos (associate)\n# add assistants promoted to associate\n# remove associates promoted to partner\n\n# Create Z3 Bool variables for promotions\npromoted_to_associate = {a: Bool(a) for a in assistants}\npromoted_to_partner = {a: Bool(a) for a in associates}\n\n# Voting variables:\n# Each eligible voter votes for each candidate for promotion\n# For assistants to associate promotion:\n# Eligible voters are all partners and associates (before promotion)\n# For associate to partner promotion:\n# Eligible voters are all partners (before promotion)\n\n# Voters for assistant promotions: partners + associates before promotion\nassistant_promotion_voters = partners + associates\n# Voters for associate promotions: partners only\nassociate_promotion_voters = partners\n\n# Voting variables for assistant promotions:\n# vote_assistant[voter][candidate] = Bool\nvote_assistant = {}\nfor voter in assistant_promotion_voters:\n    vote_assistant[voter] = {}\n    for candidate in assistants:\n        vote_assistant[voter][candidate] = Bool(f'vote_assistant_{voter}_{candidate}')\n\n# Voting variables for associate promotions:\n# vote_associate[voter][candidate] = Bool\nvote_associate = {}\nfor voter in associate_promotion_voters:\n    vote_associate[voter] = {}\n    for candidate in associates:\n        vote_associate[voter][candidate] = Bool(f'vote_associate_{voter}_{candidate}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1) At least one person promoted from each of the two lower ranks\n# At least one assistant promoted to associate\nsolver.add(Or([promoted_to_associate[a] for a in assistants]))\n# At least one associate promoted to partner\nsolver.add(Or([promoted_to_partner[a] for a in associates]))\n\n# 2) Promotion rules:\n# Assistant promoted to associate if majority of higher-ranking staff votes for promotion\n# Higher ranking staff for assistants = partners + associates (before promotion)\n# Number of voters for assistant promotions = len(assistant_promotion_voters)\nnum_assistant_voters = len(assistant_promotion_voters)\n\nfor a in assistants:\n    # Count votes for promotion for assistant a\n    votes = [vote_assistant[v][a] for v in assistant_promotion_voters]\n    # Number of votes for promotion must be > half if promoted, else <= half\n    # sum of votes > half means promoted\n    # We model sum of votes as integer\n    votes_int = [If(vote, 1, 0) for vote in votes]\n    sum_votes = Sum(votes_int)\n    majority = num_assistant_voters // 2 + 1\n    # promoted_to_associate[a] == (sum_votes >= majority)\n    solver.add(promoted_to_associate[a] == (sum_votes >= majority))\n\n# Associate promoted to partner if majority of partners vote for promotion\nnum_partner_voters = len(partners)\nfor a in associates:\n    votes = [vote_associate[v][a] for v in partners]\n    votes_int = [If(vote, 1, 0) for vote in votes]\n    sum_votes = Sum(votes_int)\n    majority = num_partner_voters // 2 + 1\n    solver.add(promoted_to_partner[a] == (sum_votes >= majority))\n\n# 3) Voting restrictions:\n# Olivos never votes for promoting Ganz, Johnson, or Turner.\nsolver.add(vote_assistant['Olivos']['Ganz'] == False)\nsolver.add(vote_assistant['Olivos']['Johnson'] == False)\nsolver.add(vote_assistant['Olivos']['Turner'] == False)\n\n# Rafael never votes for promoting Lowry or Stefano.\nsolver.add(vote_assistant['Rafael']['Lowry'] == False)\nsolver.add(vote_assistant['Rafael']['Stefano'] == False)\n\n# Harrison never votes for promoting Johnson or Wilford.\nsolver.add(vote_assistant['Harrison']['Johnson'] == False)\nsolver.add(vote_assistant['Harrison']['Wilford'] == False)\n\n# 4) Rafael votes for promoting only Ganz, Olivos, and Wilford\n# Rafael is partner, votes for assistants and associates promotions\n# Rafael votes for assistants: Ganz, Wilford only (Olivos is associate, so Rafael votes for Olivos promotion)\n# Rafael votes for associates: Olivos only (Olivos is only associate)\n# Rafael votes only for Ganz, Olivos, Wilford means:\n# For assistants:\nfor a in assistants:\n    if a in ['Ganz', 'Wilford']:\n        # Rafael votes for these assistants\n        solver.add(vote_assistant['Rafael'][a] == True)\n    else:\n        solver.add(vote_assistant['Rafael'][a] == False)\n# For associates:\nfor a in associates:\n    if a == 'Olivos':\n        solver.add(vote_associate['Rafael'][a] == True)\n    else:\n        solver.add(vote_associate['Rafael'][a] == False)\n\n# 5) Harrison votes for promoting only Lowry, Olivos, and Stefano\n# Harrison votes for assistants and associates\n# For assistants:\nfor a in assistants:\n    if a in ['Lowry', 'Stefano']:\n        solver.add(vote_assistant['Harrison'][a] == True)\n    else:\n        solver.add(vote_assistant['Harrison'][a] == False)\n# For associates:\nfor a in associates:\n    if a == 'Olivos':\n        solver.add(vote_associate['Harrison'][a] == True)\n    else:\n        solver.add(vote_associate['Harrison'][a] == False)\n\n# 6) Everyone eligible votes on every promotion\n# This means all vote_assistant and vote_associate variables are assigned True or False (already done by Bool)\n# No further constraint needed\n\n# 7) No one joins or leaves the firm (ranks fixed except promotions)\n# Already accounted for\n\n# OPTION CHECKING\n# The question: which could be the complete roster of associates after promotion?\n\n# Final associates after promotion:\n# Olivos starts as associate\n# Add assistants promoted to associate\n# Remove associates promoted to partner\n\n# So final associates = (associates - promoted_to_partner) + promoted_to_associate assistants\n\n# We will check each option:\n\noptions = {\n    'A': ['Ganz', 'Lowry', 'Wilford'],\n    'B': ['Johnson', 'Lowry', 'Stefano'],\n    'C': ['Lowry', 'Stefano', 'Turner'],\n    'D': ['Lowry', 'Stefano', 'Wilford'],\n    'E': ['Olivos', 'Turner', 'Wilford']\n}\n\nfor letter, roster in options.items():\n    solver.push()\n    # Build constraints for final associates == roster\n\n    # For each assistant, promoted_to_associate[a] == True if a in roster, else False\n    for a in assistants:\n        in_roster = a in roster\n        # If a in roster, then promoted_to_associate[a] must be True\n        # but if a in roster but was associate promoted to partner, can't be associate\n        # So we must check associates promoted to partner removed from associates\n\n        # We'll handle associates promoted to partner below\n\n    # For associates:\n    # Olivos is associate initially\n    # Olivos promoted_to_partner may remove Olivos from associates\n\n    # Final associates = (associates - promoted_to_partner) + promoted_to_associate assistants\n    # So for each person in roster:\n    # if person == 'Olivos':\n    #   Olivos not promoted_to_partner\n    # if person in assistants:\n    #   promoted_to_associate[person] == True\n    # For any person not in roster:\n    # if person == 'Olivos':\n    #   Olivos promoted_to_partner == True\n    # if person in assistants:\n    #   promoted_to_associate[person] == False\n\n    # First, check that all persons in roster are associates after promotion\n    for person in roster:\n        if person == 'Olivos':\n            solver.add(promoted_to_partner['Olivos'] == False)\n        elif person in assistants:\n            solver.add(promoted_to_associate[person] == True)\n        else:\n            # Person not in assistants or Olivos (should not happen)\n            solver.add(False)  # invalid roster\n\n    # Now, for all associates not in roster, they must not be associates after promotion\n    # associates not in roster:\n    for a in associates:\n        if a not in roster:\n            solver.add(promoted_to_partner[a] == True)\n    # assistants not in roster:\n    for a in assistants:\n        if a not in roster:\n            solver.add(promoted_to_associate[a] == False)\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.\n\nIf G is played second, which one of the following tapes must be played third?\n\nOptions:\n(A) the news\n(B) H\n(C) L\n(D) O\n(E) S",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nslots = range(1, 8)  # Time slots 1 through 7\ntapes = ['G', 'H', 'L', 'O', 'P', 'S', 'News']  # 6 songs + 1 news\ntape_indices = {t: i for i, t in enumerate(tapes)}\n\n# Create a variable for each tape representing its assigned slot\nslot_of = {t: Int(t) for t in tapes}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each tape is assigned to a slot between 1 and 7\nfor t in tapes:\n    solver.add(And(slot_of[t] >= 1, slot_of[t] <= 7))\n\n# All tapes assigned to distinct slots\nsolver.add(Distinct([slot_of[t] for t in tapes]))\n\n# L must be played immediately before O: slot_of[O] == slot_of[L] + 1\nsolver.add(slot_of['O'] == slot_of['L'] + 1)\n\n# The news tape must be played at some time after L: slot_of['News'] > slot_of['L']\nsolver.add(slot_of['News'] > slot_of['L'])\n\n# Exactly two time slots between G and P, regardless of order:\n# |slot_of[G] - slot_of[P]| == 3 (because 2 slots between means difference of 3)\ndiff_GP = slot_of['G'] - slot_of['P']\nsolver.add(Or(diff_GP == 3, diff_GP == -3))\n\n# G is played second: slot_of['G'] == 2\nsolver.add(slot_of['G'] == 2)\n\n# OPTION CHECKING\n# We want to find which tape must be played third: slot == 3\n\noptions = ['News', 'H', 'L', 'O', 'S']\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor opt, letter in zip(options, option_letters):\n    solver.push()\n    # Add constraint that tape opt is played third\n    solver.add(slot_of[opt] == 3)\n    # Check if model is satisfiable with this constraint\n    if solver.check() == sat:\n        # Now check if any other tape can be third, i.e. if this is the only possible tape\n        # We try to find a model where some other tape is third\n        solver2 = Solver()\n        # Add all previous constraints except the one that tape opt is third\n        for c in solver.assertions():\n            solver2.add(c)\n        # Add constraint that some other tape (not opt) is third\n        others = [t for t in tapes if t != opt]\n        solver2.add(Or([slot_of[t] == 3 for t in others]))\n        if solver2.check() == unsat:\n            # No other tape can be third, so opt must be third\n            print(f\"'{letter}'\")\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.\n\nThe news tape can be played in any one of the following time slots EXCEPT the\n\nOptions:\n(A) second\n(B) third\n(C) fourth\n(D) fifth\n(E) sixth",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nslots = list(range(1, 8))  # Slots 1 through 7\ntapes = ['G', 'H', 'L', 'O', 'P', 'S', 'News']\ntape_indices = {t: i for i, t in enumerate(tapes)}  # Map tape to index\n\n# Create Int variables for each tape's slot assignment\nslot_vars = {t: Int(t) for t in tapes}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each tape assigned to a slot between 1 and 7\nfor t in tapes:\n    solver.add(And(slot_vars[t] >= 1, slot_vars[t] <= 7))\n\n# All tapes assigned to distinct slots\nsolver.add(Distinct([slot_vars[t] for t in tapes]))\n\n# L must be immediately before O: L + 1 == O\nsolver.add(slot_vars['L'] + 1 == slot_vars['O'])\n\n# News tape must be played after L: News > L\nsolver.add(slot_vars['News'] > slot_vars['L'])\n\n# Exactly two slots between G and P regardless of order:\n# |G - P| == 3 (because two slots between means difference of 3)\ndiff_GP = Abs(slot_vars['G'] - slot_vars['P'])\nsolver.add(diff_GP == 3)\n\n# OPTION CHECKING\n# The news tape can be played in any one of the following time slots EXCEPT the:\n# (A) second, (B) third, (C) fourth, (D) fifth, (E) sixth\n\noptions = [2, 3, 4, 5, 6]\n\nfor i, candidate_slot in enumerate(options):\n    solver.push()\n    # Add constraint that News tape is in candidate_slot\n    solver.add(slot_vars['News'] == candidate_slot)\n    check_result = solver.check()\n    if check_result == unsat:\n        # This candidate slot is impossible for News tape\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.\n\nIf H and S are to be scheduled as far from each other as possible, then the first, the second, and the third time slots could be filled, respectively, by\n\nOptions:\n(A) G, H, and L\n(B) S, G, and the news\n(C) H, G, and L\n(D) H, L, and O\n(E) L, O, and S",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Time slots: 1 through 7\nslots = list(range(1, 8))\n\n# Tapes: G, H, L, O, P, S and News\ntapes = ['G', 'H', 'L', 'O', 'P', 'S', 'News']\n\n# Create a dictionary mapping each tape to a Z3 Int variable representing its time slot\npos = {}\nfor t in tapes:\n    pos[t] = Int(t)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each tape is assigned a unique time slot between 1 and 7\nfor t in tapes:\n    solver.add(And(pos[t] >= 1, pos[t] <= 7))\nsolver.add(Distinct([pos[t] for t in tapes]))\n\n# L must be played immediately before O: pos[O] = pos[L] + 1\nsolver.add(pos['O'] == pos['L'] + 1)\n\n# The news tape must be played after L: pos['News'] > pos['L']\nsolver.add(pos['News'] > pos['L'])\n\n# There must be exactly two time slots between G and P, regardless of order\ndiff_GP = Abs(pos['G'] - pos['P'])\nsolver.add(diff_GP == 3)\n\n# H and S are to be scheduled as far from each other as possible.\n# The maximum distance is 6 (since slots are 1-7).\n# So the absolute difference between H and S must be 6\nsolver.add(Or(pos['H'] - pos['S'] == 6, pos['S'] - pos['H'] == 6))\n\n# OPTION CHECKING\n\n# Define the options as lists of tapes for slots 1, 2, and 3 respectively\noptions = [\n    ['G', 'H', 'L'],    # A\n    ['S', 'G', 'News'], # B\n    ['H', 'G', 'L'],    # C\n    ['H', 'L', 'O'],    # D\n    ['L', 'O', 'S']     # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for the first three slots matching the option\n    solver.add(pos[option[0]] == 1)\n    solver.add(pos[option[1]] == 2)\n    solver.add(pos[option[2]] == 3)\n\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.\n\nIf P is played fifth, L must be played\n\nOptions:\n(A) first\n(B) second\n(C) third\n(D) fourth\n(E) sixth",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nslots = range(1, 8)  # Time slots 1 through 7\ntapes = ['G', 'H', 'L', 'O', 'P', 'S', 'N']  # N = News tape\n\n# Create Int variables for each tape representing its time slot\npositions = {tape: Int(tape) for tape in tapes}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each tape assigned to a slot between 1 and 7\nfor tape in tapes:\n    solver.add(And(positions[tape] >= 1, positions[tape] <= 7))\n\n# All tapes assigned to distinct slots\nsolver.add(Distinct([positions[tape] for tape in tapes]))\n\n# L must be immediately before O: O = L + 1\nsolver.add(positions['O'] == positions['L'] + 1)\n\n# News tape must be played after L: N > L\nsolver.add(positions['N'] > positions['L'])\n\n# Exactly two time slots between G and P, regardless of order:\n# abs(G - P) == 3\ndiff_GP = positions['G'] - positions['P']\nsolver.add(Or(diff_GP == 3, diff_GP == -3))\n\n# OPTION CHECKING\noptions = ['A', 'B', 'C', 'D', 'E']\npositions_P_fifth = positions['P'] == 5\npositions_L_options = [positions['L'] == i for i in [1, 2, 3, 4, 6]]\n\nfor i, pos_L in enumerate(positions_L_options):\n    solver.push()\n    solver.add(positions_P_fifth)\n    solver.add(pos_L)\n    if solver.check() == sat:\n        print(f\"'{options[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.\n\nWhich one of the following is the latest time slot in which L can be played?\n\nOptions:\n(A) the third\n(B) the fourth\n(C) the fifth\n(D) the sixth\n(E) the seventh",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nslots = range(1, 8)  # Time slots 1 through 7\ntapes = ['G', 'H', 'L', 'O', 'P', 'S', 'N']  # N = News tape\n\n# Create Int variables representing the slot assigned to each tape\nslot_vars = {tape: Int(tape) for tape in tapes}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each tape must be assigned a slot between 1 and 7\nfor tape in tapes:\n    solver.add(And(slot_vars[tape] >= 1, slot_vars[tape] <= 7))\n\n# All tapes must be assigned distinct slots\nsolver.add(Distinct([slot_vars[tape] for tape in tapes]))\n\n# L must be played immediately before O: slot_O = slot_L + 1\nsolver.add(slot_vars['O'] == slot_vars['L'] + 1)\n\n# The news tape must be played after L: slot_N > slot_L\nsolver.add(slot_vars['N'] > slot_vars['L'])\n\n# There must be exactly two time slots between G and P:\n# |slot_G - slot_P| = 3 (two slots between means difference of 3)\ndiff_GP = Abs(slot_vars['G'] - slot_vars['P'])\nsolver.add(diff_GP == 3)\n\n# OPTION CHECKING\n# We want to find the latest possible slot for L.\n# We'll check from latest to earliest if L can be at that slot.\n\n# Map option letters to slot numbers for L\noption_slots = {\n    'A': 3,\n    'B': 4,\n    'C': 5,\n    'D': 6,\n    'E': 7\n}\n\nfor letter in ['E', 'D', 'C', 'B', 'A']:\n    solver.push()\n    solver.add(slot_vars['L'] == option_slots[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven consecutive time slots for a broadcast, numbered in chronological order 1 through 7, will be filled by six song tapes—G, H, L, O, P, S—and exactly one news tape. Each tape is to be assigned to a different time slot, and no tape is longer than any other tape. The broadcast is subject to the following restrictions: L must be played immediately before O. The news tape must be played at some time after L. There must be exactly two time slots between G and P, regardless of whether G comes before P or whether G comes after P.\n\nThe time slot in which O must be played is completely determined if G is assigned to which one of the following time slots?\n\nOptions:\n(A) the first\n(B) the third\n(C) the fourth\n(D) the fifth\n(E) the sixth",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntapes = ['G', 'H', 'L', 'O', 'P', 'S', 'N']  # N represents the news tape\nslots = range(1, 8)  # Time slots 1 through 7\n\n# Create Z3 Int variables for each tape representing its assigned time slot\npositions = {tape: Int(tape) for tape in tapes}\n\nsolver = Solver()\n\n# Each tape must be assigned a slot between 1 and 7\nfor tape in tapes:\n    solver.add(And(positions[tape] >= 1, positions[tape] <= 7))\n\n# All tapes assigned to distinct slots\nsolver.add(Distinct([positions[tape] for tape in tapes]))\n\n# CONSTRAINTS\n# 1. L must be played immediately before O\nsolver.add(positions['L'] + 1 == positions['O'])\n\n# 2. The news tape must be played after L\nsolver.add(positions['N'] > positions['L'])\n\n# 3. Exactly two time slots between G and P (abs difference is 3)\ndiff_GP = positions['G'] - positions['P']\nsolver.add(Or(diff_GP == 3, diff_GP == -3))\n\n# OPTION CHECKING\noptions = ['A', 'B', 'C', 'D', 'E']\noption_slots = [1, 3, 4, 5, 6]\n\nfor i, opt_slot in enumerate(option_slots):\n    solver.push()\n    solver.add(positions['G'] == opt_slot)\n\n    # Check if O's position is uniquely determined\n    # Find all possible O positions under current constraints\n    # Approach:\n    # 1. Check if solver is sat\n    # 2. Get one model's O position\n    # 3. Add constraint O != that position and check again\n    # 4. If unsat, O position is unique; else not unique\n\n    if solver.check() == sat:\n        model = solver.model()\n        O_pos = model[positions['O']].as_long()\n\n        solver.add(positions['O'] != O_pos)\n        if solver.check() == unsat:\n            print(f\"'{options[i]}'\")\n            solver.pop()\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Doctor Yamata works only on Mondays, Tuesdays, Wednesdays, Fridays, and Saturdays. She performs four different activities—lecturing, operating, treating patients, and conducting research. Each working day she performs exactly one activity in the morning and exactly one activity in the afternoon. During each week her work schedule must satisfy the following restrictions: She performs operations on exactly three mornings. If she operates on Monday, she does not operate on Tuesday. She lectures in the afternoon on exactly two consecutive calendar days. She treats patients on exactly one morning and exactly three afternoons. She conducts research on exactly one morning. On Saturday she neither lectures nor performs operations.\n\nWhich one of the following statements must be true?\n\nOptions:\n(A) There is one day on which the doctor treats patients both in the morning and in the afternoon.\n(B) The doctor conducts research on one of the days on which she lectures.\n(C) The doctor conducts research on one of the days on which she treats patients.\n(D) The doctor lectures on one of the days on which she treats patients.\n(E) The doctor lectures on one of the days on which she operates.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\ndays = ['Mon', 'Tue', 'Wed', 'Fri', 'Sat']\nactivities = ['Lecturing', 'Operating', 'Treating', 'Research']\nnum_days = len(days)\nnum_activities = len(activities)\n\n# Map activities to indices\nLecturing = activities.index('Lecturing')\nOperating = activities.index('Operating')\nTreating = activities.index('Treating')\nResearch = activities.index('Research')\n\n# Create variables for morning and afternoon activities for each day\nmorning = [Int(f'morning_{d}') for d in days]\nafternoon = [Int(f'afternoon_{d}') for d in days]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each morning and afternoon activity must be a valid activity index\nfor i in range(num_days):\n    solver.add(And(morning[i] >= 0, morning[i] < num_activities))\n    solver.add(And(afternoon[i] >= 0, afternoon[i] < num_activities))\n\n# Doctor works only on these days, so these variables represent all working days\n\n# Each day exactly one activity in morning and one in afternoon\n# Already ensured by variables being single-valued\n\n# She performs operations on exactly three mornings\noperating_mornings = [If(morning[i] == Operating, 1, 0) for i in range(num_days)]\nsolver.add(Sum(operating_mornings) == 3)\n\n# If she operates on Monday, she does not operate on Tuesday\nmonday_operate = morning[days.index('Mon')] == Operating\ntuesday_operate = morning[days.index('Tue')] == Operating\nsolver.add(Implies(monday_operate, Not(tuesday_operate)))\n\n# She lectures in the afternoon on exactly two consecutive calendar days\nlecturing_afternoon = [If(afternoon[i] == Lecturing, 1, 0) for i in range(num_days)]\nsolver.add(Sum(lecturing_afternoon) == 2)\n\n# Find pairs of consecutive days where lectures occur in afternoon\nconsecutive_lectures = []\nfor i in range(num_days - 1):\n    pair = And(afternoon[i] == Lecturing, afternoon[i+1] == Lecturing)\n    consecutive_lectures.append(pair)\nsolver.add(Or(consecutive_lectures))\n\n# She treats patients on exactly one morning and exactly three afternoons\ntreating_morning = [If(morning[i] == Treating, 1, 0) for i in range(num_days)]\ntreating_afternoon = [If(afternoon[i] == Treating, 1, 0) for i in range(num_days)]\nsolver.add(Sum(treating_morning) == 1)\nsolver.add(Sum(treating_afternoon) == 3)\n\n# She conducts research on exactly one morning\nresearch_morning = [If(morning[i] == Research, 1, 0) for i in range(num_days)]\nsolver.add(Sum(research_morning) == 1)\n\n# On Saturday she neither lectures nor performs operations (morning and afternoon)\nsat_index = days.index('Sat')\nsolver.add(morning[sat_index] != Lecturing)\nsolver.add(morning[sat_index] != Operating)\nsolver.add(afternoon[sat_index] != Lecturing)\nsolver.add(afternoon[sat_index] != Operating)\n\n# OPTION CHECKING\n\noptions = [\n    # (A) There is one day on which the doctor treats patients both in the morning and in the afternoon.\n    lambda: Or([And(morning[i] == Treating, afternoon[i] == Treating) for i in range(num_days)]),\n\n    # (B) The doctor conducts research on one of the days on which she lectures.\n    # i.e. there exists a day where research (morning) and lecturing (morning or afternoon) occur on the same day\n    lambda: Or([And(morning[i] == Research,\n                    Or(morning[i] == Lecturing, afternoon[i] == Lecturing)) for i in range(num_days)]),\n\n    # (C) The doctor conducts research on one of the days on which she treats patients.\n    # i.e. there exists a day where research (morning) and treating (morning or afternoon) occur on the same day\n    lambda: Or([And(morning[i] == Research,\n                    Or(morning[i] == Treating, afternoon[i] == Treating)) for i in range(num_days)]),\n\n    # (D) The doctor lectures on one of the days on which she treats patients.\n    # i.e. there exists a day where lecturing (morning or afternoon) and treating (morning or afternoon) occur on same day\n    lambda: Or([And(Or(morning[i] == Lecturing, afternoon[i] == Lecturing),\n                    Or(morning[i] == Treating, afternoon[i] == Treating)) for i in range(num_days)]),\n\n    # (E) The doctor lectures on one of the days on which she operates.\n    # i.e. there exists a day where lecturing (morning or afternoon) and operating (morning or afternoon) occur on same day\n    lambda: Or([And(Or(morning[i] == Lecturing, afternoon[i] == Lecturing),\n                    Or(morning[i] == Operating, afternoon[i] == Operating)) for i in range(num_days)]),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option()))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of seven judges voted for or else against granting Datalog Corporation's petition. Each judge is categorized as conservative, moderate, or liberal, and no judge is assigned more than one of those labels. Two judges are conservatives, two are moderates, and three are liberals. The following is known about how the judges voted: If the two conservatives and at least one liberal voted the same way as each other, then both moderates voted that way. If the three liberals voted the same way as each other, then no conservative voted that way. At least two of the judges voted for Datalog, and at least two voted against Datalog. At least one conservative voted against Datalog.\n\nIf the two moderates did not vote the same way as each other, then which one of the following could be true?\n\nOptions:\n(A) No conservative and exactly two liberals voted for Datalog.\n(B) Exactly one conservative and exactly one liberal voted for Datalog.\n(C) Exactly one conservative and all three liberals voted for Datalog.\n(D) Exactly two conservatives and exactly one liberal voted for Datalog.\n(E) Exactly two conservatives and exactly two liberals voted for Datalog.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\njudges = ['C1', 'C2', 'M1', 'M2', 'L1', 'L2', 'L3']\n\n# Categories\nconservatives = ['C1', 'C2']\nmoderates = ['M1', 'M2']\nliberals = ['L1', 'L2', 'L3']\n\n# Votes: 1 for 'For', 0 for 'Against'\nvotes = {j: Int(j) for j in judges}\n\nsolver = Solver()\n\n# Each vote is either 0 or 1\nfor j in judges:\n    solver.add(Or(votes[j] == 0, votes[j] == 1))\n\n# At least two voted for Datalog\nsolver.add(Sum([votes[j] for j in judges]) >= 2)\n\n# At least two voted against Datalog\nsolver.add(Sum([votes[j] for j in judges]) <= 5)  # since total 7, at least two against means at most 5 for\n\n# At least one conservative voted against Datalog\nconservative_votes = [votes[c] for c in conservatives]\nsolver.add(Or([votes[c] == 0 for c in conservatives]))\n\n# Condition 1:\n# If the two conservatives and at least one liberal voted the same way as each other,\n# then both moderates voted that way.\n\n# Helper: Check if two conservatives voted the same way\ncons_same = And(votes['C1'] == votes['C2'])\n\n# Helper: Check if at least one liberal voted the same way as conservatives\nlib_same = Or([votes[l] == votes['C1'] for l in liberals])\n\n# If cons_same and lib_same then both moderates voted that way\ncond1 = Implies(And(cons_same, lib_same),\n                And(votes['M1'] == votes['C1'], votes['M2'] == votes['C1']))\nsolver.add(cond1)\n\n# Condition 2:\n# If the three liberals voted the same way as each other,\n# then no conservative voted that way.\n\nlibs_same = And(votes['L1'] == votes['L2'], votes['L2'] == votes['L3'])\n\n# If libs_same then for all conservatives, vote != libs vote\ncond2 = Implies(libs_same,\n                And([votes[c] != votes['L1'] for c in conservatives]))\nsolver.add(cond2)\n\n# The question: If the two moderates did not vote the same way as each other,\n# which one of the options could be true?\n\n# Add that the two moderates did not vote the same way\nsolver.add(votes['M1'] != votes['M2'])\n\noptions = {\n    'A': And(Sum([votes[c] for c in conservatives]) == 0,\n             Sum([votes[l] for l in liberals]) == 2),\n    'B': And(Sum([votes[c] for c in conservatives]) == 1,\n             Sum([votes[l] for l in liberals]) == 1),\n    'C': And(Sum([votes[c] for c in conservatives]) == 1,\n             Sum([votes[l] for l in liberals]) == 3),\n    'D': And(Sum([votes[c] for c in conservatives]) == 2,\n             Sum([votes[l] for l in liberals]) == 1),\n    'E': And(Sum([votes[c] for c in conservatives]) == 2,\n             Sum([votes[l] for l in liberals]) == 2),\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each of seven judges voted for or else against granting Datalog Corporation's petition. Each judge is categorized as conservative, moderate, or liberal, and no judge is assigned more than one of those labels. Two judges are conservatives, two are moderates, and three are liberals. The following is known about how the judges voted: If the two conservatives and at least one liberal voted the same way as each other, then both moderates voted that way. If the three liberals voted the same way as each other, then no conservative voted that way. At least two of the judges voted for Datalog, and at least two voted against Datalog. At least one conservative voted against Datalog.\n\nWhich one of the following must be true?\n\nOptions:\n(A) At least one conservative voted for Datalog.\n(B) At least one liberal voted against Datalog.\n(C) At least one liberal voted for Datalog.\n(D) At least one moderate voted against Datalog.\n(E) At least one moderate voted for Datalog.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\njudges = ['J1', 'J2', 'J3', 'J4', 'J5', 'J6', 'J7']\n# Categories: 0=Conservative, 1=Moderate, 2=Liberal\ncategories = dict()\ncategories['J1'] = 0\ncategories['J2'] = 0\ncategories['J3'] = 1\ncategories['J4'] = 1\ncategories['J5'] = 2\ncategories['J6'] = 2\ncategories['J7'] = 2\n\n# Votes: 0=Against, 1=For\nvotes = dict()\nfor j in judges:\n    votes[j] = Int(f'vote_{j}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Votes are either 0 or 1\nfor j in judges:\n    solver.add(Or(votes[j] == 0, votes[j] == 1))\n\n# Exactly two conservatives, two moderates, three liberals (given by categories, so no constraint needed)\n\n# At least two voted for (1)\nsolver.add(Sum([votes[j] for j in judges]) >= 2)\n\n# At least two voted against (0)\nvotes_against = [If(votes[j] == 0, 1, 0) for j in judges]\nsolver.add(Sum(votes_against) >= 2)\n\n# At least one conservative voted against (0)\nconservatives = [j for j in judges if categories[j] == 0]\nconservative_votes_against = [If(votes[j] == 0, 1, 0) for j in conservatives]\nsolver.add(Sum(conservative_votes_against) >= 1)\n\n# Helper sets for convenience\nmoderates = [j for j in judges if categories[j] == 1]\nliberals = [j for j in judges if categories[j] == 2]\n\n# If the two conservatives and at least one liberal voted the same way as each other,\n# then both moderates voted that way.\n\n# Check if conservatives have same vote\ncons_votes = [votes[j] for j in conservatives]\ncons_same = And(cons_votes[0] == cons_votes[1])\n\n# Check if at least one liberal voted same as conservatives\nlib_vote = votes[liberals[0]]\nlib_vote2 = votes[liberals[1]]\nlib_vote3 = votes[liberals[2]]\n\n# Create conditions for each liberal voting same as conservatives\nlib_same_conditions = [\n    lib_vote == cons_votes[0],\n    lib_vote2 == cons_votes[0],\n    lib_vote3 == cons_votes[0]\n]\n\n# At least one liberal voted same as conservatives\nat_least_one_lib_same = Or(lib_same_conditions)\n\n# If cons_same and at_least_one_lib_same then both moderates voted that way\nboth_moderates_same_as_cons = And([votes[m] == cons_votes[0] for m in moderates])\n\nsolver.add(Implies(And(cons_same, at_least_one_lib_same), both_moderates_same_as_cons))\n\n# If the three liberals voted the same way as each other,\n# then no conservative voted that way.\n\nlib_votes = [votes[j] for j in liberals]\nlibers_same = And(lib_votes[0] == lib_votes[1], lib_votes[1] == lib_votes[2])\n\n# No conservative voted that way: for each conservative, vote != liberals' vote\nno_cons_vote_libers = And([votes[j] != lib_votes[0] for j in conservatives])\n\nsolver.add(Implies(libers_same, no_cons_vote_libers))\n\n# OPTION CHECKING\n# Each option is a statement that must be true in all models satisfying constraints\n\noptions = {\n    'A': Or([votes[j] == 1 for j in conservatives]),  # At least one conservative voted for\n    'B': Or([votes[j] == 0 for j in liberals]),      # At least one liberal voted against\n    'C': Or([votes[j] == 1 for j in liberals]),      # At least one liberal voted for\n    'D': Or([votes[j] == 0 for j in moderates]),     # At least one moderate voted against\n    'E': Or([votes[j] == 1 for j in moderates])      # At least one moderate voted for\n}\n\n# For each option, check if its negation is consistent with constraints\n# The correct option must be true in all models, so negation must be unsat\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(Not(options[opt]))\n    if solver.check() == unsat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of seven judges voted for or else against granting Datalog Corporation's petition. Each judge is categorized as conservative, moderate, or liberal, and no judge is assigned more than one of those labels. Two judges are conservatives, two are moderates, and three are liberals. The following is known about how the judges voted: If the two conservatives and at least one liberal voted the same way as each other, then both moderates voted that way. If the three liberals voted the same way as each other, then no conservative voted that way. At least two of the judges voted for Datalog, and at least two voted against Datalog. At least one conservative voted against Datalog.\n\nIf the three liberals all voted the same way as each other, which one of the following must be true?\n\nOptions:\n(A) Both moderates voted for Datalog.\n(B) Both moderates voted against Datalog.\n(C) One conservative voted for Datalog and one conservative voted against Datalog.\n(D) One moderate voted for Datalog and one moderate voted against Datalog.\n(E) All three liberals voted for Datalog.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Judges and their categories\njudges = ['C1', 'C2', 'M1', 'M2', 'L1', 'L2', 'L3']\nconservatives = ['C1', 'C2']\nmoderates = ['M1', 'M2']\nliberals = ['L1', 'L2', 'L3']\n\n# Votes: 1 means For, 0 means Against\nvote = {j: Int(j) for j in judges}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each vote is either 0 or 1\nfor j in judges:\n    solver.add(Or(vote[j] == 0, vote[j] == 1))\n\n# Exactly two conservatives\n# Already given by judges list and categories\n\n# Exactly two moderates\n# Already given\n\n# Exactly three liberals\n# Already given\n\n# At least two voted For (1)\nsolver.add(Sum([vote[j] for j in judges]) >= 2)\n\n# At least two voted Against (0)\nsolver.add(Sum([If(vote[j] == 0, 1, 0) for j in judges]) >= 2)\n\n# At least one conservative voted Against (0)\nsolver.add(Or([vote[c] == 0 for c in conservatives]))\n\n# The key conditions:\n\n# Condition 1:\n# If the two conservatives and at least one liberal voted the same way as each other,\n# then both moderates voted that way.\n\n# This means:\n# For each possible vote value (0 or 1), if both conservatives voted that way and\n# at least one liberal voted that way, then both moderates voted that way.\n\nfor val in [0,1]:\n    cons_same = And([vote[c] == val for c in conservatives])\n    at_least_one_lib = Or([vote[l] == val for l in liberals])\n    both_mod_same = And([vote[m] == val for m in moderates])\n    cond1 = Implies(And(cons_same, at_least_one_lib), both_mod_same)\n    solver.add(cond1)\n\n# Condition 2:\n# If the three liberals voted the same way as each other,\n# then no conservative voted that way.\n\n# Means:\n# If L1, L2, L3 all voted val, then for all conservatives c, vote[c] != val\n\nfor val in [0,1]:\n    libs_same = And([vote[l] == val for l in liberals])\n    no_cons_same = And([vote[c] != val for c in conservatives])\n    cond2 = Implies(libs_same, no_cons_same)\n    solver.add(cond2)\n\n# The question is: If the three liberals all voted the same way as each other,\n# which one of the following must be true?\n\n# We'll test each option under the assumption that liberals vote the same way.\n\n# Prepare assumption: liberals all vote the same way\nlibs_same_vote = Or(\n    And([vote[l] == 0 for l in liberals]),\n    And([vote[l] == 1 for l in liberals])\n)\n\n# OPTIONS:\n# (A) Both moderates voted for Datalog.\noptA = And([vote[m] == 1 for m in moderates])\n\n# (B) Both moderates voted against Datalog.\noptB = And([vote[m] == 0 for m in moderates])\n\n# (C) One conservative voted for Datalog and one conservative voted against Datalog.\noptC = And(\n    Or([vote[c] == 1 for c in conservatives]),\n    Or([vote[c] == 0 for c in conservatives]),\n    # To ensure exactly one each, we add:\n    Sum([If(vote[c] == 1, 1, 0) for c in conservatives]) == 1\n)\n\n# (D) One moderate voted for Datalog and one moderate voted against Datalog.\noptD = And(\n    Or([vote[m] == 1 for m in moderates]),\n    Or([vote[m] == 0 for m in moderates]),\n    Sum([If(vote[m] == 1, 1, 0) for m in moderates]) == 1\n)\n\n# (E) All three liberals voted for Datalog.\noptE = And([vote[l] == 1 for l in liberals])\n\noptions = [optA, optB, optC, optD, optE]\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Assume liberals all voted same way\n    solver.add(libs_same_vote)\n    # Add negation of option to test if option must be true\n    solver.add(Not(opt))\n    if solver.check() == unsat:\n        # Option must be true\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of seven judges voted for or else against granting Datalog Corporation's petition. Each judge is categorized as conservative, moderate, or liberal, and no judge is assigned more than one of those labels. Two judges are conservatives, two are moderates, and three are liberals. The following is known about how the judges voted: If the two conservatives and at least one liberal voted the same way as each other, then both moderates voted that way. If the three liberals voted the same way as each other, then no conservative voted that way. At least two of the judges voted for Datalog, and at least two voted against Datalog. At least one conservative voted against Datalog.\n\nIf exactly two judges voted against Datalog, then which one of the following must be true?\n\nOptions:\n(A) Both moderates voted for Datalog.\n(B) Exactly one conservative voted for Datalog.\n(C) No conservative voted for Datalog.\n(D) Exactly two liberals voted for Datalog.\n(E) Exactly three liberals voted for Datalog.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Judges: 7 judges indexed 0..6\n# Categories: Conservative (C), Moderate (M), Liberal (L)\n# Voting: 1 for 'for Datalog', 0 for 'against Datalog'\n\njudges = range(7)\ncategories = ['C', 'C', 'M', 'M', 'L', 'L', 'L']  # fixed assignment by index\n\n# Voting variables: 1 if judge votes for, 0 if against\nvote = [Int(f'vote_{j}') for j in judges]\n\n# Create solver\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each vote is 0 or 1\nfor v in vote:\n    solver.add(Or(v == 0, v == 1))\n\n# Count votes for and against\ntotal_for = Sum(vote)\ntotal_against = 7 - total_for\n\n# At least two voted for, at least two voted against\nsolver.add(total_for >= 2)\nsolver.add(total_against >= 2)\n\n# At least one conservative voted against\ncons_indices = [i for i, cat in enumerate(categories) if cat == 'C']\nmod_indices = [i for i, cat in enumerate(categories) if cat == 'M']\nlib_indices = [i for i, cat in enumerate(categories) if cat == 'L']\n\n# At least one conservative voted against (i.e. vote == 0)\ncons_vote_against = [vote[i] == 0 for i in cons_indices]\nsolver.add(Or(cons_vote_against))\n\n# First conditional:\n# If the two conservatives and at least one liberal voted the same way as each other,\n# then both moderates voted that way.\n\n# To model \"two conservatives and at least one liberal voted the same way\":\n# There exists a value v0 in {0,1} such that:\n#   all conservatives vote v0\n#   and at least one liberal votes v0\n\n# We try both v0 = 0 and v0 = 1, so we define two conditions and combine with Or.\n\n# Condition for v0 = 0\ncons_all_0 = And([vote[i] == 0 for i in cons_indices])\nlib_at_least_one_0 = Or([vote[i] == 0 for i in lib_indices])\ncond0 = And(cons_all_0, lib_at_least_one_0)\n\n# Condition for v0 = 1\ncons_all_1 = And([vote[i] == 1 for i in cons_indices])\nlib_at_least_one_1 = Or([vote[i] == 1 for i in lib_indices])\ncond1 = And(cons_all_1, lib_at_least_one_1)\n\n# If cond0 or cond1 then both moderates voted that way\n# So (cond0 or cond1) => (both moderates voted that way)\n# That is: Not(cond0 or cond1) or (both moderates voted that way)\n# Both moderates voted that way means: vote[mod_indices[0]] == v0 and vote[mod_indices[1]] == v0\n# But v0 is 0 for cond0 and 1 for cond1, so we split:\n\n# For cond0: if cond0 then both mod vote 0\nmod_both_0 = And(vote[mod_indices[0]] == 0, vote[mod_indices[1]] == 0)\nimp_cond0 = Or(Not(cond0), mod_both_0)\n\n# For cond1: if cond1 then both mod vote 1\nmod_both_1 = And(vote[mod_indices[0]] == 1, vote[mod_indices[1]] == 1)\nimp_cond1 = Or(Not(cond1), mod_both_1)\n\nsolver.add(imp_cond0)\nsolver.add(imp_cond1)\n\n# Second conditional:\n# If the three liberals voted the same way as each other,\n# then no conservative voted that way.\n\n# Three liberals vote the same way means:\nlib_votes = [vote[i] for i in lib_indices]\nlib_same = And(lib_votes[0] == lib_votes[1], lib_votes[1] == lib_votes[2])\n\n# If lib_same then for each conservative vote != lib_votes[0]\ncons_not_lib_vote = And([vote[i] != lib_votes[0] for i in cons_indices])\n\nsolver.add(Or(Not(lib_same), cons_not_lib_vote))\n\n# Now, OPTION CHECKING\n# We test each option assuming exactly two judges voted against Datalog (i.e. total_against == 2)\n\noptions = [\n    # (A) Both moderates voted for Datalog.\n    And(vote[mod_indices[0]] == 1, vote[mod_indices[1]] == 1),\n\n    # (B) Exactly one conservative voted for Datalog.\n    Sum([vote[i] for i in cons_indices]) == 1,\n\n    # (C) No conservative voted for Datalog.\n    Sum([vote[i] for i in cons_indices]) == 0,\n\n    # (D) Exactly two liberals voted for Datalog.\n    Sum([vote[i] for i in lib_indices]) == 2,\n\n    # (E) Exactly three liberals voted for Datalog.\n    Sum([vote[i] for i in lib_indices]) == 3,\n]\n\n# Add constraint: exactly two against votes\nsolver.add(total_against == 2)\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add negation of option to see if option must be true\n    solver.add(Not(opt))\n    if solver.check() == unsat:\n        # Option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of seven judges voted for or else against granting Datalog Corporation's petition. Each judge is categorized as conservative, moderate, or liberal, and no judge is assigned more than one of those labels. Two judges are conservatives, two are moderates, and three are liberals. The following is known about how the judges voted: If the two conservatives and at least one liberal voted the same way as each other, then both moderates voted that way. If the three liberals voted the same way as each other, then no conservative voted that way. At least two of the judges voted for Datalog, and at least two voted against Datalog. At least one conservative voted against Datalog.\n\nEach of the following could be a complete and accurate list of those judges who voted for Datalog EXCEPT\n\nOptions:\n(A) two liberals\n(B) one conservative, one liberal\n(C) two moderates, three liberals\n(D) one conservative, two moderates, two liberals\n(E) one conservative, two moderates, three liberals",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\njudges = ['J1', 'J2', 'J3', 'J4', 'J5', 'J6', 'J7']\n\n# Categories: 0=Conservative, 1=Moderate, 2=Liberal\ncategories = {\n    'J1': 0,\n    'J2': 0,\n    'J3': 1,\n    'J4': 1,\n    'J5': 2,\n    'J6': 2,\n    'J7': 2\n}\n\n# Voting: 1=For, 0=Against\nvotes = {j: Int(j) for j in judges}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each vote is either 0 or 1\nfor j in judges:\n    solver.add(Or(votes[j] == 0, votes[j] == 1))\n\n# Counts of categories\nconservatives = [j for j in judges if categories[j] == 0]  # 2 judges\nmoderates = [j for j in judges if categories[j] == 1]      # 2 judges\nliberals = [j for j in judges if categories[j] == 2]       # 3 judges\n\n# At least two judges voted for and at least two voted against\nsolver.add(Sum([votes[j] for j in judges]) >= 2)\nsolver.add(Sum([votes[j] for j in judges]) <= 5)  # 7-2=5 at most for\n\n# At least one conservative voted against (vote == 0)\ncons_votes = [votes[j] for j in conservatives]\nsolver.add(Or([v == 0 for v in cons_votes]))\n\n# Constraint 1:\n# If the two conservatives and at least one liberal voted the same way as each other,\n# then both moderates voted that way.\n\n# Two conservatives vote the same way:\ncons_same = And(cons_votes[0] == cons_votes[1])\n\n# At least one liberal votes the same way as conservatives:\nlib_votes = [votes[j] for j in liberals]\nlib_same_with_cons = Or([v == cons_votes[0] for v in lib_votes])\n\n# If cons_same and lib_same_with_cons then both moderates voted that way\nmod_votes = [votes[j] for j in moderates]\nmod_both_same = And(mod_votes[0] == cons_votes[0], mod_votes[1] == cons_votes[0])\n\nconstraint1 = Implies(And(cons_same, lib_same_with_cons), mod_both_same)\nsolver.add(constraint1)\n\n# Constraint 2:\n# If the three liberals voted the same way as each other, then no conservative voted that way.\n\nlib_same = And(lib_votes[0] == lib_votes[1], lib_votes[1] == lib_votes[2])\n# No conservative voted that way means for all conservatives v != lib_votes[0]\nno_cons_same_as_lib = And([v != lib_votes[0] for v in cons_votes])\n\nconstraint2 = Implies(lib_same, no_cons_same_as_lib)\nsolver.add(constraint2)\n\n# OPTION CHECKING\noptions = {\n    'A': ['L1', 'L2'],  # two liberals\n    'B': ['C1', 'L1'],  # one conservative, one liberal\n    'C': ['M1', 'M2', 'L1', 'L2', 'L3'],  # two moderates, three liberals\n    'D': ['C1', 'M1', 'M2', 'L1', 'L2'],  # one conservative, two moderates, two liberals\n    'E': ['C1', 'M1', 'M2', 'L1', 'L2', 'L3'],  # one conservative, two moderates, three liberals\n}\n\n# Map category labels to actual judge names\n# Conservative judges: J1, J2\n# Moderate judges: J3, J4\n# Liberal judges: J5, J6, J7\n\nlabel_to_judge = {\n    'C1': conservatives[0],\n    'C2': conservatives[1],\n    'M1': moderates[0],\n    'M2': moderates[1],\n    'L1': liberals[0],\n    'L2': liberals[1],\n    'L3': liberals[2]\n}\n\nfor letter, group in options.items():\n    solver.push()\n    # Set votes according to the option: those in group vote For (1), others Against (0)\n    for j in judges:\n        if j in [label_to_judge[l] for l in group]:\n            solver.add(votes[j] == 1)\n        else:\n            solver.add(votes[j] == 0)\n    # Check if model is satisfiable with this voting pattern\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of seven judges voted for or else against granting Datalog Corporation's petition. Each judge is categorized as conservative, moderate, or liberal, and no judge is assigned more than one of those labels. Two judges are conservatives, two are moderates, and three are liberals. The following is known about how the judges voted: If the two conservatives and at least one liberal voted the same way as each other, then both moderates voted that way. If the three liberals voted the same way as each other, then no conservative voted that way. At least two of the judges voted for Datalog, and at least two voted against Datalog. At least one conservative voted against Datalog.\n\nIf the two conservatives voted the same way as each other, but the liberals did not all vote the same way as each other, then each of the following must be true EXCEPT:\n\nOptions:\n(A) Both conservatives voted against Datalog.\n(B) Both moderates voted for Datalog.\n(C) At least one liberal voted against Datalog.\n(D) Exactly two liberals voted for Datalog.\n(E) Exactly five of the judges voted against Datalog.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\njudges = ['C1', 'C2', 'M1', 'M2', 'L1', 'L2', 'L3']\nconservatives = ['C1', 'C2']\nmoderates = ['M1', 'M2']\nliberals = ['L1', 'L2', 'L3']\n\n# Voting: 1 for 'for', 0 for 'against'\nvote = {j: Int(j) for j in judges}\n\n# Each vote is either 0 or 1\nvotes_domain = [And(vote[j] >= 0, vote[j] <= 1) for j in judges]\n\nsolver = Solver()\nsolver.add(votes_domain)\n\n# Helper functions\ndef all_same(lst):\n    return Or([And([vote[j] == v for j in lst]) for v in [0,1]])\n\ndef all_same_value(lst, val):\n    return And([vote[j] == val for j in lst])\n\ndef at_least_one(lst, val):\n    return Or([vote[j] == val for j in lst])\n\n# Given constraints:\n\n# 1) If the two conservatives and at least one liberal voted the same way as each other,\n# then both moderates voted that way.\n# Express: If (C1 == C2 == v) and (at least one liberal votes v), then both moderates vote v.\nfor v in [0,1]:\n    cond = And(vote['C1'] == v, vote['C2'] == v, at_least_one(liberals, v))\n    then_clause = all_same_value(moderates, v)\n    solver.add(Implies(cond, then_clause))\n\n# 2) If the three liberals voted the same way as each other, then no conservative voted that way.\n# Express: If L1 == L2 == L3 == v then C1 != v and C2 != v\nfor v in [0,1]:\n    cond = all_same_value(liberals, v)\n    then_clause = And(vote['C1'] != v, vote['C2'] != v)\n    solver.add(Implies(cond, then_clause))\n\n# 3) At least two voted for Datalog (vote == 1)\nsolver.add(Sum([vote[j] for j in judges]) >= 2)\n\n# 4) At least two voted against Datalog (vote == 0)\nsolver.add(Sum([If(vote[j] == 0, 1, 0) for j in judges]) >= 2)\n\n# 5) At least one conservative voted against Datalog\nsolver.add(Or([vote[c] == 0 for c in conservatives]))\n\n# Additional given condition for the question:\n# If the two conservatives voted the same way as each other, but the liberals did not all vote the same way,\n# then each of the following must be true EXCEPT:\n\n# So we add the condition:\ncond_c_same = vote['C1'] == vote['C2']\ncond_l_not_all_same = Not(all_same(liberals))\n\n# We add these two conditions as assumptions to test each option.\n\n# OPTION CHECKING\n\noptions = {\n    'A': And(vote['C1'] == 0, vote['C2'] == 0),  # Both conservatives voted against Datalog\n    'B': And(vote['M1'] == 1, vote['M2'] == 1),  # Both moderates voted for Datalog\n    'C': at_least_one(liberals, 0),               # At least one liberal voted against Datalog\n    'D': Sum([vote[l] for l in liberals]) == 2,  # Exactly two liberals voted for Datalog\n    'E': Sum([If(vote[j] == 0, 1, 0) for j in judges]) == 5  # Exactly five judges voted against\n}\n\n# We want to find which one does NOT have to be true, i.e. which option is NOT necessarily true under the condition:\n# cond_c_same and cond_l_not_all_same and all other puzzle constraints\n\nfor letter in ['A','B','C','D','E']:\n    solver.push()\n    # Add condition for the question\n    solver.add(cond_c_same)\n    solver.add(cond_l_not_all_same)\n    # Add negation of the option to test if it can be false\n    solver.add(Not(options[letter]))\n    # Check if this is satisfiable\n    if solver.check() == sat:\n        # If satisfiable, this option does NOT have to be true (EXCEPT)\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "An official is assigning five runners—Larry, Ned, Olivia, Patricia, and Sonja—to parallel lanes numbered consecutively 1 through 5. The official will also assign each runner to represent a different charity—F, G, H, J, and K—not necessarily in order of the runner's names as given. The following ordering restrictions apply: The runner representing K is assigned to lane 4. Patricia is assigned to the only lane between the lanes of the runners representing F and G. There are exactly two lanes between Olivia's lane and the lane of the runner representing G. Sonja is assigned to a higher-numbered lane than the lane to which Ned is assigned.\n\nIf Ned is the runner representing J, then it must be true that\n\nOptions:\n(A) the runner representing G is assigned to lane 1\n(B) the runner representing H is assigned to lane 2\n(C) Larry is the runner representing K\n(D) Olivia is the runner representing F\n(E) Patricia is the runner representing H",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nrunners = ['Larry', 'Ned', 'Olivia', 'Patricia', 'Sonja']\ncharities = ['F', 'G', 'H', 'J', 'K']\nlanes = [1, 2, 3, 4, 5]\n\n# Create Z3 variables for lanes and charities assignments\n# lane[r] = lane number assigned to runner r (1 to 5)\nlane = {r: Int(r) for r in runners}\n# charity[r] = charity index assigned to runner r (0 to 4)\ncharity = {r: Int(r + '_charity') for r in runners}\n\n# Map charity letters to indices for easy reference\ncharity_idx = {c: i for i, c in enumerate(charities)}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each runner assigned to a valid lane number 1-5\nfor r in runners:\n    solver.add(And(lane[r] >= 1, lane[r] <= 5))\n\n# All lanes assigned are distinct\nsolver.add(Distinct([lane[r] for r in runners]))\n\n# Each runner assigned to a valid charity index 0-4\nfor r in runners:\n    solver.add(And(charity[r] >= 0, charity[r] < 5))\n\n# All charities assigned are distinct\nsolver.add(Distinct([charity[r] for r in runners]))\n\n# The runner representing K is assigned to lane 4\n# Find runner r with charity[r] == charity_idx['K'], then lane[r] == 4\nfor r in runners:\n    # Create boolean variable indicating if r represents K\n    is_K = charity[r] == charity_idx['K']\n    solver.add(Implies(is_K, lane[r] == 4))\n\n# Patricia is assigned to the only lane between the lanes of the runners representing F and G\n# That means Patricia's lane is exactly one more than min lane of F and G and one less than max lane of F and G\n# Let rF be runner with charity F, rG runner with charity G\n# We'll create constraints that for runners representing F and G, Patricia's lane is exactly between them with one lane gap on each side\n# We do this by enumerating all runners and linking charity to runner\n\n# Find runners representing F and G\n# We'll create variables rF and rG for runners representing F and G\n# Instead, we create a list of constraints that enforce Patricia's lane is between the lanes of F and G with exactly one lane between them\n\n# We'll express:\n# abs(lane_F - lane_G) == 2\n# Patricia's lane is min(lane_F, lane_G) + 1\n\n# First, create integer variables lane_F and lane_G for lanes of runners representing F and G\nlane_F = Int('lane_F')\nlane_G = Int('lane_G')\n\n# Link lane_F and lane_G to the lanes of runners representing F and G\n# For each runner r:\n# If charity[r] == F then lane_F == lane[r]\n# If charity[r] == G then lane_G == lane[r]\n\n# We enforce that exactly one runner represents F and one represents G, so lane_F and lane_G are well-defined\nf_constraints = []\ng_constraints = []\nfor r in runners:\n    f_constraints.append(Implies(charity[r] == charity_idx['F'], lane_F == lane[r]))\n    g_constraints.append(Implies(charity[r] == charity_idx['G'], lane_G == lane[r]))\n\nsolver.add(f_constraints)\nsolver.add(g_constraints)\n\n# The difference between lane_F and lane_G is 2\nsolver.add(Or(lane_F - lane_G == 2, lane_G - lane_F == 2))\n\n# Patricia's lane is exactly between lane_F and lane_G\n# That means Patricia's lane is min(lane_F, lane_G) + 1\nmin_lane_FG = Int('min_lane_FG')\nsolver.add(min_lane_FG == If(lane_F < lane_G, lane_F, lane_G))\nsolver.add(lane['Patricia'] == min_lane_FG + 1)\n\n# There are exactly two lanes between Olivia's lane and the lane of the runner representing G\n# So abs(lane['Olivia'] - lane_G) == 3\nsolver.add(Or(lane['Olivia'] - lane_G == 3, lane_G - lane['Olivia'] == 3))\n\n# Sonja is assigned to a higher-numbered lane than Ned\nsolver.add(lane['Sonja'] > lane['Ned'])\n\n# Ned is the runner representing J\nsolver.add(charity['Ned'] == charity_idx['J'])\n\n# OPTION CHECKING\n# Options:\n# (A) the runner representing G is assigned to lane 1\n# (B) the runner representing H is assigned to lane 2\n# (C) Larry is the runner representing K\n# (D) Olivia is the runner representing F\n# (E) Patricia is the runner representing H\n\noptions = [\n    # (A)\n    lambda: Or([And(charity[r] == charity_idx['G'], lane[r] == 1) for r in runners]),\n    # (B)\n    lambda: Or([And(charity[r] == charity_idx['H'], lane[r] == 2) for r in runners]),\n    # (C)\n    lambda: charity['Larry'] == charity_idx['K'],\n    # (D)\n    lambda: charity['Olivia'] == charity_idx['F'],\n    # (E)\n    lambda: charity['Patricia'] == charity_idx['H'],\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option()))\n    if solver.check() == unsat:\n        # If adding Not(option) makes problem unsat, option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "An official is assigning five runners—Larry, Ned, Olivia, Patricia, and Sonja—to parallel lanes numbered consecutively 1 through 5. The official will also assign each runner to represent a different charity—F, G, H, J, and K—not necessarily in order of the runner's names as given. The following ordering restrictions apply: The runner representing K is assigned to lane 4. Patricia is assigned to the only lane between the lanes of the runners representing F and G. There are exactly two lanes between Olivia's lane and the lane of the runner representing G. Sonja is assigned to a higher-numbered lane than the lane to which Ned is assigned.\n\nIf Larry represents J, which one of the following could be the assignment of runners to lanes?\n\nOptions:\n(A) Larry Olivia Ned Patricia Sonja\n(B) Larry Ned Olivia Sonja Patricia\n(C) Larry Sonja Patricia Ned Olivia\n(D) Ned Olivia Larry Patricia Sonja\n(E) Ned Sonja Olivia Patricia Larry",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Runners and charities\nrunners = ['Larry', 'Ned', 'Olivia', 'Patricia', 'Sonja']\ncharities = ['F', 'G', 'H', 'J', 'K']\nlanes = list(range(1, 6))  # lanes 1 to 5\n\n# Create Z3 Int variables for each runner's lane and charity\nrunner_lane = {r: Int(f\"lane_{r}\") for r in runners}\nrunner_charity = {r: Int(f\"charity_{r}\") for r in runners}\n\n# Map charities to indices for Z3\ncharity_indices = {c: i for i, c in enumerate(charities)}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each runner's lane is between 1 and 5\nfor r in runners:\n    solver.add(And(runner_lane[r] >= 1, runner_lane[r] <= 5))\n\n# Each runner's charity is between 0 and 4 (indices)\nfor r in runners:\n    solver.add(And(runner_charity[r] >= 0, runner_charity[r] < 5))\n\n# All lanes are distinct (each lane assigned to exactly one runner)\nsolver.add(Distinct([runner_lane[r] for r in runners]))\n\n# All charities are distinct (each charity assigned to exactly one runner)\nsolver.add(Distinct([runner_charity[r] for r in runners]))\n\n# The runner representing K is assigned to lane 4\n# Find runner r with charity K (index charity_indices['K']) and lane 4\nfor r in runners:\n    is_K = runner_charity[r] == charity_indices['K']\n    lane_4 = runner_lane[r] == 4\n    # Add constraint: if runner r represents K then lane is 4\n    solver.add(Implies(is_K, lane_4))\n# Also ensure only one runner has charity K and lane 4 (already ensured by Distinct)\n\n# Patricia is assigned to the only lane between the lanes of the runners representing F and G\n# Let F_runner and G_runner be the runners representing F and G\n# The lane of Patricia is exactly one more than the minimum lane of F and G, and one less than the maximum lane of F and G\n# So Patricia's lane is between F and G lanes with exactly one lane between them\n# Also, the lanes of F and G differ by exactly 2 (since Patricia is the only lane between them)\n# We don't know which runner represents F or G, but we know Patricia's lane is between them\n\n# Find runners representing F and G\nF_runner = None\nG_runner = None\nfor r in runners:\n    # We will add constraints later for runners representing F and G\n    pass\n\n# We don't know F_runner and G_runner directly, so we create integer variables for their lanes\n# Actually, we can express constraints using the runner_charity variables and lanes\n\n# The runners representing F and G are distinct\n# Find the lanes of runners representing F and G\n# For all runners r, if runner_charity[r] == charity_indices['F'], then runner_lane[r] is lane_F\n# Similarly for G\nlane_F = Int('lane_F')\nlane_G = Int('lane_G')\n\n# Add constraints linking lane_F and lane_G to runners representing F and G\n# For each runner r, if runner_charity[r] == charity_indices['F'] then runner_lane[r] == lane_F\n# Similarly for G\nfor r in runners:\n    solver.add(Implies(runner_charity[r] == charity_indices['F'], runner_lane[r] == lane_F))\n    solver.add(Implies(runner_charity[r] == charity_indices['G'], runner_lane[r] == lane_G))\n\n# F_runner and G_runner are distinct, so lane_F != lane_G\nsolver.add(lane_F != lane_G)\n\n# Patricia's lane is exactly one lane between lane_F and lane_G\n# So Patricia's lane is the average of lane_F and lane_G (since lanes are integers, difference must be 2)\n# So abs(lane_F - lane_G) == 2\nsolver.add(Or(lane_F - lane_G == 2, lane_G - lane_F == 2))\n\n# Patricia's lane is between lane_F and lane_G\n# So Patricia's lane == min(lane_F, lane_G) + 1\nmin_lane_FG = Int('min_lane_FG')\nsolver.add(min_lane_FG == If(lane_F < lane_G, lane_F, lane_G))\n\nsolver.add(runner_lane['Patricia'] == min_lane_FG + 1)\n\n# There are exactly two lanes between Olivia's lane and the lane of the runner representing G\n# The difference between Olivia's lane and lane_G is exactly 3 (two lanes between means difference of 3)\nsolver.add(Or(runner_lane['Olivia'] - lane_G == 3, lane_G - runner_lane['Olivia'] == 3))\n\n# Sonja is assigned to a higher-numbered lane than the lane to which Ned is assigned\nsolver.add(runner_lane['Sonja'] > runner_lane['Ned'])\n\n# Larry represents J\nsolver.add(runner_charity['Larry'] == charity_indices['J'])\n\n# OPTION CHECKING\n# Options given as lists of runners in lane order 1 to 5\noptions = [\n    ['Larry', 'Olivia', 'Ned', 'Patricia', 'Sonja'],  # A\n    ['Larry', 'Ned', 'Olivia', 'Sonja', 'Patricia'],  # B\n    ['Larry', 'Sonja', 'Patricia', 'Ned', 'Olivia'],  # C\n    ['Ned', 'Olivia', 'Larry', 'Patricia', 'Sonja'],  # D\n    ['Ned', 'Sonja', 'Olivia', 'Patricia', 'Larry'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n\n    # Add constraints that lanes correspond to the option order:\n    # lane 1 = option[0], lane 2 = option[1], ..., lane 5 = option[4]\n    for lane_num, runner_name in enumerate(option, 1):\n        solver.add(runner_lane[runner_name] == lane_num)\n\n    # Check satisfiability with these lane assignments\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A gymnastics instructor is planning a weekly schedule, Monday through Friday, of individual coaching sessions for each of six students—H, I, K, O, U, and Z. The instructor will coach exactly one student each day, except for one day when the instructor will coach two students in separate but consecutive sessions. The following restrictions apply: H's session must take place at some time before Z's session. I's session is on Thursday. K's session is always scheduled for the day immediately before or the day immediately after the day for which O's session is scheduled. Neither Monday nor Wednesday can be a day for which two students are scheduled.\n\nWhich one of the following is a pair of students whose sessions can both be scheduled for Tuesday, not necessarily in the order given?\n\nOptions:\n(A) H and U\n(B) H and Z\n(C) K and O\n(D) O and U\n(E) U and Z",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['H', 'I', 'K', 'O', 'U', 'Z']\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']\n\n# Map days to indices 0..4\nday_indices = {d: i for i, d in enumerate(days)}\n\n# Variables:\n# session_day[s]: the day index (0..4) when student s has session\nsession_day = {s: Int(s) for s in students}\n\n# One day has two sessions (two students), others have one session each:\n# We model the double session day as a day with exactly two students assigned\n\n# We will create a variable double_day in 0..4 indicating the day with two sessions\ndouble_day = Int('double_day')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student's session day between 0..4\nfor s in students:\n    solver.add(And(session_day[s] >= 0, session_day[s] <= 4))\n\n# double_day between 0..4\nsolver.add(And(double_day >= 0, double_day <= 4))\n\n# Neither Monday (0) nor Wednesday (2) can be double session day\nsolver.add(double_day != 0)\nsolver.add(double_day != 2)\n\n# Exactly one day has two sessions, so total sessions = 6,\n# total days = 5, so one day has 2 sessions, others 1 session each\n\n# Count how many students assigned to each day\n# For each day d, count number of students with session_day == d\n# We create Bool variables for each student and day\nassigned = {}\nfor s in students:\n    for d in range(5):\n        assigned[(s,d)] = Bool(f'assigned_{s}_{d}')\n        solver.add(assigned[(s,d)] == (session_day[s] == d))\n\n# For each day d, sum assigned students\nday_counts = []\nfor d in range(5):\n    count = Sum([If(assigned[(s,d)], 1, 0) for s in students])\n    day_counts.append(count)\n\n# One day has count 2 (double_day), others 1\nfor d in range(5):\n    is_double = (d == double_day)\n    # If d == double_day then count == 2 else count == 1\n    solver.add(If(d == double_day, day_counts[d] == 2, day_counts[d] == 1))\n\n# H's session before Z's session\nsolver.add(session_day['H'] < session_day['Z'])\n\n# I's session is on Thursday (3)\nsolver.add(session_day['I'] == 3)\n\n# K's session immediately before or after O's session\ndiff_KO = session_day['K'] - session_day['O']\nsolver.add(Or(diff_KO == 1, diff_KO == -1))\n\n# OPTION CHECKING\noptions = [\n    ('H', 'U'),\n    ('H', 'Z'),\n    ('K', 'O'),\n    ('O', 'U'),\n    ('U', 'Z')\n]\n\nfor i, (s1, s2) in enumerate(options):\n    solver.push()\n    # Both s1 and s2 sessions are on Tuesday (1)\n    solver.add(session_day[s1] == 1)\n    solver.add(session_day[s2] == 1)\n    # Check if satisfiable\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A gymnastics instructor is planning a weekly schedule, Monday through Friday, of individual coaching sessions for each of six students—H, I, K, O, U, and Z. The instructor will coach exactly one student each day, except for one day when the instructor will coach two students in separate but consecutive sessions. The following restrictions apply: H's session must take place at some time before Z's session. I's session is on Thursday. K's session is always scheduled for the day immediately before or the day immediately after the day for which O's session is scheduled. Neither Monday nor Wednesday can be a day for which two students are scheduled.\n\nIf H's session is scheduled as the next session after U's session, which one of the following could be true about H's session and U's session?\n\nOptions:\n(A) U's session is scheduled for Monday, and H's session is scheduled for Tuesday.\n(B) U's session is scheduled for Thursday, and H's session is scheduled for Friday.\n(C) They are both scheduled for Tuesday.\n(D) They are both scheduled for Thursday.\n(E) They are both scheduled for Friday.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']\nstudents = ['H', 'I', 'K', 'O', 'U', 'Z']\n\n# Create Int variables for each student representing their session day (0=Mon,...,4=Fri)\nsession = {s: Int(s) for s in students}\n\n# Create Int variable for the day with two sessions (0=Mon,...,4=Fri)\ndouble_day = Int('double_day')\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each session day must be between 0 and 4\nfor s in students:\n    solver.add(And(session[s] >= 0, session[s] < 5))\n\n# double_day must be between 0 and 4\nsolver.add(And(double_day >= 0, double_day < 5))\n\n# Exactly one day has two students: so one day is double_day, all others have one student\n# Count how many students are scheduled on each day: sum over students of (session[s] == d)\n# The day double_day has 2 students, all others have 1 student\n\nfor d in range(5):\n    count = Sum([If(session[s] == d, 1, 0) for s in students])\n    # If d == double_day then count == 2 else count == 1\n    solver.add(If(d == double_day, count == 2, count == 1))\n\n# Neither Monday (0) nor Wednesday (2) can be double_day\nsolver.add(double_day != 0)\nsolver.add(double_day != 2)\n\n# I's session is on Thursday (3)\nsolver.add(session['I'] == 3)\n\n# H's session must be before Z's session\nsolver.add(session['H'] < session['Z'])\n\n# K's session is immediately before or after O's session\ndiff_KO = session['K'] - session['O']\nsolver.add(Or(diff_KO == 1, diff_KO == -1))\n\n# H's session is scheduled as the next session after U's session\n# This means H's session day is the same as U's session day if double session day,\n# but H's session is immediately after U's session in the schedule of sessions\n# Since one day has two sessions (consecutive), and all others have one session,\n# the ordering of sessions is days 0..4, but one day has two sessions in a row.\n\n# To model the order of sessions, define a function session_order(s):\n# Each student is assigned an order number from 0 to 6 (7 sessions total: 6 students, but one day has 2 sessions)\n\n# We will create Int variables for session_order of each student\n\nsession_order = {s: Int('order_' + s) for s in students}\n\n# The total number of sessions is 7 (5 days + 1 extra session on one day)\n\n# session_order[s] in [0..6]\nfor s in students:\n    solver.add(And(session_order[s] >= 0, session_order[s] < 7))\n\n# The sessions are scheduled in order by day, but on the double session day there are two consecutive sessions\n\n# We need to assign session_order consistent with session day and double_day\n\n# For each student s:\n\n# If session[s] < double_day: session_order[s] = session[s]\n# If session[s] == double_day: session_order[s] in {double_day, double_day +1} (two sessions on that day)\n# If session[s] > double_day: session_order[s] = session[s] + 1 (because of the extra session on double_day)\n\n# We don't know which two students are on double_day, but we know two students share double_day\n\n# So for students on double_day, their session_order are double_day and double_day +1 (two consecutive orders)\n\n# For students before double_day, session_order = session[s]\n# For students after double_day, session_order = session[s] + 1\n\n# Add constraints for session_order based on session[s] and double_day\n\nfor s in students:\n    cond_before = session[s] < double_day\n    cond_on = session[s] == double_day\n    cond_after = session[s] > double_day\n\n    # Create variables for session_order[s] for on double_day must be either double_day or double_day+1\n    # For before double_day, session_order[s] == session[s]\n    # For after double_day, session_order[s] == session[s] + 1\n\n    solver.add(If(cond_before, session_order[s] == session[s],\n                  If(cond_on, Or(session_order[s] == double_day, session_order[s] == double_day + 1),\n                     session_order[s] == session[s] + 1)))\n\n# The two students on double_day must have distinct session_order values double_day and double_day +1\n\ndouble_day_students = [s for s in students]\n\n# We don't know which two students are on double_day, but exactly two students have session[s] == double_day\n\n# Add constraint: Exactly two students have session[s] == double_day\n\ncount_double_day = Sum([If(session[s] == double_day, 1, 0) for s in students])\nsolver.add(count_double_day == 2)\n\n# The two students on double_day have session_order double_day and double_day +1\n\n# Collect students on double_day\n# We cannot directly do this in Z3, so we just add that the session_orders of students on double_day are distinct and in {double_day, double_day +1}\n\n# session_order values for students on double_day must be two distinct values: double_day and double_day+1\n\n# Extract session_order for students on double_day\ndouble_day_session_orders = [If(session[s] == double_day, session_order[s], -1) for s in students]\n\n# Filter to only those >= 0 (i.e. those on double_day)\n# Since we can't filter in Z3 easily, we do:\n\n# The two session_orders on double_day are double_day and double_day +1\n\n# For each student s:\n\n# If session[s] == double_day then session_order[s] in {double_day, double_day+1}\n# Already constrained above\n\n# The session_orders of students on double_day are distinct\n\n# Add Distinct for session_orders of students on double_day\n\n# Create list of session_orders for students on double_day\n\ndouble_day_session_orders_vars = [session_order[s] for s in students]\n\n# For students not on double_day, session_order[s] != double_day and != double_day +1\n\nfor s in students:\n    solver.add(If(session[s] == double_day,\n                  Or(session_order[s] == double_day, session_order[s] == double_day + 1),\n                  And(session_order[s] != double_day, session_order[s] != double_day + 1)))\n\n# Now, the two students on double_day have session_order double_day and double_day +1 distinct\n\n# So the set of session_order values equal to double_day or double_day +1 has size 2\n\n# Enforce that exactly two students have session_order in {double_day, double_day+1}\n\ncount_double_order = Sum([If(Or(session_order[s] == double_day, session_order[s] == double_day + 1), 1, 0) for s in students])\nsolver.add(count_double_order == 2)\n\n# Those two session_orders are distinct\n\n# Collect session_order values that are double_day or double_day +1\n\n# Create Bool variables for each student indicating if session_order is double_day or double_day+1\n\nis_double_day_order = [Or(session_order[s] == double_day, session_order[s] == double_day + 1) for s in students]\n\n# The two session_orders that are double_day or double_day +1 must be distinct\n\n# Extract those session_orders\n\ndouble_orders = [session_order[s] for s in students if True]  # all session_order vars\n\n# We can't filter easily, so add:\n\n# For all pairs of students s1, s2, if both have session_order in {double_day, double_day+1}, then session_order[s1] != session_order[s2] if s1 != s2\n\nfor i in range(len(students)):\n    for j in range(i + 1, len(students)):\n        s1 = students[i]\n        s2 = students[j]\n        cond = And(Or(session_order[s1] == double_day, session_order[s1] == double_day + 1),\n                   Or(session_order[s2] == double_day, session_order[s2] == double_day + 1))\n        solver.add(Implies(cond, session_order[s1] != session_order[s2]))\n\n# All session_orders must be distinct (7 sessions total for 6 students - but 7 sessions total because one day has 2 sessions)\n\nsolver.add(Distinct([session_order[s] for s in students]))\n\n# H's session is scheduled as the next session after U's session\n\nsolver.add(session_order['H'] == session_order['U'] + 1)\n\n# OPTION CHECKING\n\noptions = {\n    'A': And(session['U'] == 0, session['H'] == 1),\n    'B': And(session['U'] == 3, session['H'] == 4),\n    'C': And(session['U'] == 1, session['H'] == 1),\n    'D': And(session['U'] == 3, session['H'] == 3),\n    'E': And(session['U'] == 4, session['H'] == 4),\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.\n\nWhich one of the following could be a complete and accurate list of lights that are on together?\n\nOptions:\n(A) 1, 3, 5, 7\n(B) 2, 4, 6, 8\n(C) 2, 3, 5, 6, 8\n(D) 3, 4, 6, 7, 8\n(E) 1, 2, 4, 5, 6, 8",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlights = range(1, 9)  # Lights 1 through 8\n\n# Create a Bool variable for each light: True means on, False means off\nlight_vars = {}\nfor l in lights:\n    light_vars[l] = Bool(f\"light_{l}\")\n\n# Define sides with their lights (three lights per side)\nnorth = [1, 2, 3]\neast = [3, 4, 5]\nsouth = [5, 6, 7]\nwest = [7, 8, 1]\n\nsides = [north, east, south, west]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1) At least one of any three consecutively numbered lights is off.\n# The lights are numbered 1 to 8 circularly, so triples are:\n# (1,2,3), (2,3,4), (3,4,5), (4,5,6), (5,6,7), (6,7,8), (7,8,1), (8,1,2)\ntriples = [(1,2,3), (2,3,4), (3,4,5), (4,5,6), (5,6,7), (6,7,8), (7,8,1), (8,1,2)]\nfor t in triples:\n    # At least one is off means Not(all three are on)\n    all_on = And([light_vars[i] for i in t])\n    solver.add(Not(all_on))\n\n# 2) Light 8 is on.\nsolver.add(light_vars[8] == True)\n\n# 3) Neither light 2 nor light 7 is on when light 1 is on.\n# if light 1 is on then light 2 is off and light 7 is off\nsolver.add(Implies(light_vars[1], And(Not(light_vars[2]), Not(light_vars[7]))))\n\n# 4) At least one of the three lights on each side is on.\nfor side in sides:\n    solver.add(Or([light_vars[l] for l in side]))\n\n# 5) If any side has exactly one of its three lights on, then that light is its center light.\n# For each side, count how many are on. If count == 1 then the center light is on.\nfor side in sides:\n    center = side[1]\n    on_lights = [If(light_vars[l], 1, 0) for l in side]\n    sum_on = Sum(on_lights)\n    solver.add(Implies(sum_on == 1, light_vars[center]))\n\n# 6) Two of the lights on the north side are on.\nnorth_on = [If(light_vars[l], 1, 0) for l in north]\nsolver.add(Sum(north_on) == 2)\n\n# OPTION CHECKING\noptions = {\n    'A': [1, 3, 5, 7],\n    'B': [2, 4, 6, 8],\n    'C': [2, 3, 5, 6, 8],\n    'D': [3, 4, 6, 7, 8],\n    'E': [1, 2, 4, 5, 6, 8],\n}\n\nfor letter, on_list in options.items():\n    solver.push()\n    # Add constraints that these lights are on and others are off\n    for l in lights:\n        if l in on_list:\n            solver.add(light_vars[l] == True)\n        else:\n            solver.add(light_vars[l] == False)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.\n\nWhich one of the following lights must be on?\n\nOptions:\n(A) light 2\n(B) light 3\n(C) light 4\n(D) light 5\n(E) light 6",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlights = [Int(f\"l{i}\") for i in range(1, 9)]  # lights 1 through 8\n# Each light is either 0 (off) or 1 (on)\nlight_indices = list(range(8))\n\n# Helper function for indexing lights circularly\ndef idx(i):\n    return i % 8\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each light is either 0 or 1\nfor l in lights:\n    solver.add(Or(l == 0, l == 1))\n\n# 1) At least one of any three consecutively numbered lights is off.\n# For each triple (i, i+1, i+2), at least one is off.\nfor i in range(8):\n    triple = [lights[idx(i)], lights[idx(i+1)], lights[idx(i+2)]]\n    # At least one off means sum < 3\n    sum_triple = Sum(triple)\n    solver.add(sum_triple <= 2)\n\n# 2) Light 8 is on\nsolver.add(lights[7] == 1)\n\n# 3) Neither light 2 nor light 7 is on when light 1 is on.\n# If light 1 is on, then light 2 and light 7 are off.\nsolver.add(Implies(lights[0] == 1, And(lights[1] == 0, lights[6] == 0)))\n\n# 4) At least one of the three lights on each side is on.\n# Sides: North (1,2,3), East (3,4,5), South (5,6,7), West (7,8,1)\n# Indices zero-based: North (0,1,2), East (2,3,4), South (4,5,6), West (6,7,0)\nsides = [\n    [0, 1, 2],  # North\n    [2, 3, 4],  # East\n    [4, 5, 6],  # South\n    [6, 7, 0],  # West\n]\n\nfor side in sides:\n    side_lights = [lights[i] for i in side]\n    solver.add(Sum(side_lights) >= 1)\n\n# 5) If any side has exactly one of its three lights on, then that light is its center light.\n# Center lights are the middle indices in each side:\n# North center: 2 (light 3)\n# East center: 3 (light 4)\n# South center: 5 (light 6)\n# West center: 7 (light 8)\nside_centers = [1, 3, 5, 7]  # zero-based indices of center lights for each side\n\nfor side, center in zip(sides, side_centers):\n    side_lights = [lights[i] for i in side]\n    sum_side = Sum(side_lights)\n    # If exactly one light is on in the side\n    # then the center light is on and the others off\n    cond = sum_side == 1\n    center_on = lights[center] == 1\n    others_off = And([lights[i] == 0 for i in side if i != center])\n    solver.add(Implies(cond, And(center_on, others_off)))\n\n# 6) Two of the lights on the north side are on.\nnorth_side = [lights[i] for i in sides[0]]\nsolver.add(Sum(north_side) == 2)\n\n# OPTION CHECKING\n# Options: (A) 2, (B) 3, (C) 4, (D) 5, (E) 6\noption_lights = [1, 2, 3, 4, 5]  # zero-based indices for lights 2 to 6\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\nfor i, light_idx in enumerate(option_lights):\n    solver.push()\n    # Check if the light must be on: add constraint that it is off, check if unsat\n    solver.add(lights[light_idx] == 0)\n    if solver.check() == unsat:\n        # This means light must be on\n        print(f\"'{options[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.\n\nIf light 1 is off, which one of the following is a light that must also be off?\n\nOptions:\n(A) light 3\n(B) light 4\n(C) light 5\n(D) light 6\n(E) light 7",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlights = [Int(f'light{i}') for i in range(1, 9)]  # lights 1 to 8\n# light variables: 0 = off, 1 = on\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each light is either on (1) or off (0)\nfor l in lights:\n    solver.add(Or(l == 0, l == 1))\n\n# Light 8 is on\nsolver.add(lights[7] == 1)  # light 8 is lights[7]\n\n# At least one of any three consecutively numbered lights is off\n# The lights are numbered 1 to 8 circularly, so triples: (1,2,3), (2,3,4), ..., (6,7,8), (7,8,1), (8,1,2)\ntriples = [\n    (0,1,2),\n    (1,2,3),\n    (2,3,4),\n    (3,4,5),\n    (4,5,6),\n    (5,6,7),\n    (6,7,0),\n    (7,0,1)\n]\nfor (a,b,c) in triples:\n    # at least one off means not all three on\n    solver.add(Or(lights[a] == 0, lights[b] == 0, lights[c] == 0))\n\n# Neither light 2 nor light 7 is on when light 1 is on\n# If light 1 is on then light 2 is off and light 7 is off\nsolver.add(Implies(lights[0] == 1, And(lights[1] == 0, lights[6] == 0)))\n\n# At least one of the three lights on each side is on\n# Sides:\n# North: lights 1,2,3 -> indices 0,1,2\n# East: lights 3,4,5 -> indices 2,3,4\n# South: lights 5,6,7 -> indices 4,5,6\n# West: lights 7,8,1 -> indices 6,7,0\nsides = [\n    (0,1,2),  # North\n    (2,3,4),  # East\n    (4,5,6),  # South\n    (6,7,0)   # West\n]\nfor (a,b,c) in sides:\n    solver.add(Or(lights[a] == 1, lights[b] == 1, lights[c] == 1))\n\n# If any side has exactly one of its three lights on, then that light is its center light\n# Center lights: North=2 (index 1), East=4 (index 3), South=6 (index 5), West=8 (index 7)\ncenter_lights = [1,3,5,7]\nfor i, (a,b,c) in enumerate(sides):\n    on_count = Sum([lights[a], lights[b], lights[c]])\n    # If exactly one on, then that one is center light\n    # So if on_count == 1 then lights[center_lights[i]] == 1 and the other two == 0\n    cond = on_count == 1\n    center = lights[center_lights[i]]\n    others = [lights[x] for x in (a,b,c) if x != center_lights[i]]\n    solver.add(Implies(cond, And(center == 1, others[0] == 0, others[1] == 0)))\n\n# Two of the lights on the north side are on\nnorth_lights = [lights[i] for i in (0,1,2)]\nsolver.add(Sum(north_lights) == 2)\n\n# OPTION CHECKING\n# If light 1 is off (lights[0] == 0), which light must also be off?\n# Options:\n# (A) light 3 -> lights[2]\n# (B) light 4 -> lights[3]\n# (C) light 5 -> lights[4]\n# (D) light 6 -> lights[5]\n# (E) light 7 -> lights[6]\n\noptions = [2, 3, 4, 5, 6]  # indices of lights for options A to E\n\nfor i, opt_light_index in enumerate(options):\n    solver.push()\n    # Add light 1 is off\n    solver.add(lights[0] == 0)\n    # Check if option light can be on\n    solver.add(lights[opt_light_index] == 1)\n    if solver.check() == unsat:\n        # This means that if light 1 is off, this light cannot be on, so must be off\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.\n\nWhich one of the following statements must be true?\n\nOptions:\n(A) If light 2 is on, then light 6 is off.\n(B) If light 3 is on, then light 2 is on.\n(C) If light 4 is on, then light 3 is off.\n(D) If light 5 is off, then light 4 is on.\n(E) If light 6 is off, then light 1 is on.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlights = [Int(f'L{i}') for i in range(1, 9)]  # L1 to L8 variables (0=off,1=on)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each light is either on (1) or off (0)\nfor l in lights:\n    solver.add(Or(l == 0, l == 1))\n\n# At least one of any three consecutively numbered lights is off\n# Consecutive triples: (1,2,3), (2,3,4), (3,4,5), (4,5,6), (5,6,7), (6,7,8), (7,8,1), (8,1,2)\ntriples = [\n    (0,1,2),\n    (1,2,3),\n    (2,3,4),\n    (3,4,5),\n    (4,5,6),\n    (5,6,7),\n    (6,7,0),\n    (7,0,1)\n]\nfor (i,j,k) in triples:\n    # At least one off means not all three are on\n    solver.add(Or(lights[i] == 0, lights[j] == 0, lights[k] == 0))\n\n# Light 8 is on\nsolver.add(lights[7] == 1)\n\n# Neither light 2 nor light 7 is on when light 1 is on\n# If L1=1 then L2=0 and L7=0\nsolver.add(Implies(lights[0] == 1, And(lights[1] == 0, lights[6] == 0)))\n\n# At least one of the three lights on each side is on\n# Sides (lights indices):\n# North: 1,2,3 -> lights[0], lights[1], lights[2]\n# East: 4,5,6 -> lights[3], lights[4], lights[5]\n# South: 7,8,1 -> lights[6], lights[7], lights[0]\n# West: 2,3,4 -> lights[1], lights[2], lights[3]\n# But note the problem states \"square parking lot\" with 8 lights around perimeter.\n# Usually 8 lights means 2 per side or 3 per side?\n# The problem says \"Three lights on each side\"\n# We have 8 lights, numbered 1-8 around perimeter.\n# The diagram is not given, but from the problem:\n# North side: lights 1,2,3\n# East side: lights 4,5,6\n# South side: lights 7,8,1\n# West side: lights 2,3,4\n# Wait, the problem states \"Two of the lights on the north side are on.\"\n# So north side is lights 1,2,3\n# East side is 4,5,6\n# South side is 7,8,1 (wrap around)\n# West side is 2,3,4\n# But 1 appears twice? 2 appears twice? That's consistent with a square with lights at corners and sides.\n# Let's define sides as given in problem:\nnorth = [lights[0], lights[1], lights[2]]  # 1,2,3\neast = [lights[3], lights[4], lights[5]]   # 4,5,6\nsouth = [lights[6], lights[7], lights[0]]  # 7,8,1\nwest = [lights[1], lights[2], lights[3]]   # 2,3,4\n\nsides = [north, east, south, west]\n\nfor side in sides:\n    solver.add(Or([l == 1 for l in side]))\n\n# If any side has exactly one of its three lights on, then that light is its center light\n# Center lights are the middle one in each side:\n# North center: 2 (lights[1])\n# East center: 5 (lights[4])\n# South center: 8 (lights[7])\n# West center: 3 (lights[2])\ncenters = [lights[1], lights[4], lights[7], lights[2]]\n\nfor side, center in zip(sides, centers):\n    # sum of side lights\n    side_sum = Sum(side)\n    # If sum == 1 then center == 1\n    solver.add(Implies(side_sum == 1, center == 1))\n\n# Two of the lights on the north side are on\nsolver.add(Sum(north) == 2)\n\n# OPTION CHECKING\noptions = [\n    # (A) If light 2 is on, then light 6 is off.\n    Implies(lights[1] == 1, lights[5] == 0),\n\n    # (B) If light 3 is on, then light 2 is on.\n    Implies(lights[2] == 1, lights[1] == 1),\n\n    # (C) If light 4 is on, then light 3 is off.\n    Implies(lights[3] == 1, lights[2] == 0),\n\n    # (D) If light 5 is off, then light 4 is on.\n    Implies(lights[4] == 0, lights[3] == 1),\n\n    # (E) If light 6 is off, then light 1 is on.\n    Implies(lights[5] == 0, lights[0] == 1),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.\n\nIf light 5 is on, which one of the following could be true?\n\nOptions:\n(A) Light 1 is off and light 6 is off.\n(B) Light 1 is on and light 7 is on.\n(C) Light 2 is off and light 4 is on.\n(D) Light 2 is off and light 6 is off.\n(E) Light 6 is on and light 7 is on.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlights = list(range(1, 9))  # Lights 1 through 8\n\n# Create a dictionary of Z3 Bool variables for each light\nlight_vars = {i: Bool(f\"light_{i}\") for i in lights}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. At least one of any three consecutively numbered lights is off.\n# Since lights are on a square perimeter, numbering wraps around: 1-2-3, 2-3-4, ..., 7-8-1, 8-1-2\nfor i in range(1, 9):\n    # Calculate the three consecutive lights with wrap-around\n    l1 = i\n    l2 = i + 1 if i + 1 <= 8 else i + 1 - 8\n    l3 = i + 2 if i + 2 <= 8 else i + 2 - 8\n    # At least one is off means not all three are on\n    # So: Not (l1 on and l2 on and l3 on)\n    solver.add(Not(And(light_vars[l1], light_vars[l2], light_vars[l3])))\n\n# 2. Light 8 is on.\nsolver.add(light_vars[8] == True)\n\n# 3. Neither light 2 nor light 7 is on when light 1 is on.\n# If light 1 is on, then light 2 is off and light 7 is off\nsolver.add(Implies(light_vars[1], And(Not(light_vars[2]), Not(light_vars[7]))))\n\n# 4. At least one of the three lights on each side is on.\n# The sides are:\n# North: 1,2,3\n# East: 3,4,5\n# South: 5,6,7\n# West: 7,8,1\n# Add constraints that at least one light on each side is on\nnorth = [light_vars[1], light_vars[2], light_vars[3]]\neast = [light_vars[3], light_vars[4], light_vars[5]]\nsouth = [light_vars[5], light_vars[6], light_vars[7]]\nwest = [light_vars[7], light_vars[8], light_vars[1]]\n\nfor side in [north, east, south, west]:\n    solver.add(Or(side))\n\n# 5. If any side has exactly one of its three lights on, then that light is its center light.\n# Center lights are: 2 (north), 4 (east), 6 (south), 8 (west)\n# For each side:\n# If exactly one light is on, then that light must be the center light\ndef exactly_one_on(side_vars):\n    return PbEq([(v,1) for v in side_vars], 1)\n\n# North side\nnorth_center = light_vars[2]\nsolver.add(Implies(exactly_one_on(north), north_center))\n# East side\neast_center = light_vars[4]\nsolver.add(Implies(exactly_one_on(east), east_center))\n# South side\nsouth_center = light_vars[6]\nsolver.add(Implies(exactly_one_on(south), south_center))\n# West side\nwest_center = light_vars[8]\nsolver.add(Implies(exactly_one_on(west), west_center))\n\n# 6. Two of the lights on the north side are on.\n# North side: 1,2,3\nsolver.add(PbEq([(light_vars[1],1), (light_vars[2],1), (light_vars[3],1)], 2))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Light 1 is off and light 6 is off.\n    And(Not(light_vars[1]), Not(light_vars[6])),\n    # (B) Light 1 is on and light 7 is on.\n    And(light_vars[1], light_vars[7]),\n    # (C) Light 2 is off and light 4 is on.\n    And(Not(light_vars[2]), light_vars[4]),\n    # (D) Light 2 is off and light 6 is off.\n    And(Not(light_vars[2]), Not(light_vars[6])),\n    # (E) Light 6 is on and light 7 is on.\n    And(light_vars[6], light_vars[7]),\n]\n\n# Add the premise: Light 5 is on.\nsolver.add(light_vars[5] == True)\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A square parking lot has exactly eight lights—numbered 1 through 8—situated along its perimeter as diagramed below. The lot must always be illuminated in such a way that the following specifications are met: At least one of any three consecutively numbered lights is off. Light 8 is on. Neither light 2 nor light 7 is on when light 1 is on. At least one of the three lights on each side is on. If any side has exactly one of its three lights on, then that light is its center light. Two of the lights on the north side are on.\n\nSuppose that it is no longer part of the specifications that two lights on the north side be on. If all of the other original specifications remain the same, and if exactly one light on the north side is on, which one of the following statements could be false?\n\nOptions:\n(A) Light 1 is off.\n(B) Light 2 is on.\n(C) Light 3 is off.\n(D) Light 4 is on.\n(E) Light 5 is on.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlights = list(range(1, 9))  # Lights 1 through 8\n\n# Create Z3 Bool variables for each light: True = on, False = off\nlight_vars = {l: Bool(f\"L{l}\") for l in lights}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) At least one of any three consecutively numbered lights is off.\n# Since lights are numbered 1 to 8 around the perimeter, with wrap-around:\n# For i in 1..8, consider lights i, i+1, i+2 modulo 8 (with 8+1=1, 8+2=2)\nfor i in range(1, 9):\n    l1 = light_vars[i]\n    l2 = light_vars[(i % 8) + 1]\n    l3 = light_vars[((i + 1) % 8) + 1]\n    # At least one off means not all three are on\n    three_on = And(l1, l2, l3)\n    solver.add(Not(three_on))\n\n# 2) Light 8 is on.\nsolver.add(light_vars[8])\n\n# 3) Neither light 2 nor light 7 is on when light 1 is on.\n# If light 1 is on, then light 2 is off and light 7 is off\nsolver.add(Implies(light_vars[1], And(Not(light_vars[2]), Not(light_vars[7]))))\n\n# 4) At least one of the three lights on each side is on.\n# The square's sides and their lights:\n# North side: lights 1, 2, 3\n# East side: lights 3, 4, 5\n# South side: lights 5, 6, 7\n# West side: lights 7, 8, 1\n# Each side must have at least one light on\nsolver.add(Or(light_vars[1], light_vars[2], light_vars[3]))  # North\nsolver.add(Or(light_vars[3], light_vars[4], light_vars[5]))  # East\nsolver.add(Or(light_vars[5], light_vars[6], light_vars[7]))  # South\nsolver.add(Or(light_vars[7], light_vars[8], light_vars[1]))  # West\n\n# 5) If any side has exactly one of its three lights on, then that light is its center light.\n# Center lights: North=2, East=4, South=6, West=8\n# For each side:\n# If sum of on lights = 1, then the center light is on\ndef exactly_one_side(lights_side):\n    on_count = Sum([If(light_vars[l], 1, 0) for l in lights_side])\n    center_light = lights_side[1]  # The center light is the middle of the three\n    return Implies(on_count == 1, light_vars[center_light])\n\nsolver.add(exactly_one_side([1,2,3]))  # North\nsolver.add(exactly_one_side([3,4,5]))  # East\nsolver.add(exactly_one_side([5,6,7]))  # South\nsolver.add(exactly_one_side([7,8,1]))  # West\n\n# 6) Two of the lights on the north side are on.\n# This is removed for the question scenario, so do NOT add this constraint here.\n\n# QUESTION:\n# Suppose it is no longer part of the specifications that two lights on the north side be on.\n# All other original specifications remain.\n# If exactly one light on the north side is on, which of the following statements could be false?\n\n# The options:\n# (A) Light 1 is off.\n# (B) Light 2 is on.\n# (C) Light 3 is off.\n# (D) Light 4 is on.\n# (E) Light 5 is on.\n\n# We want to check for each option whether it could be false under the conditions:\n# - Exactly one light on the north side is on\n# - All other constraints hold\n\n# Add the condition: exactly one light on the north side is on\nnorth_lights = [1, 2, 3]\nnorth_on_count = Sum([If(light_vars[l], 1, 0) for l in north_lights])\nsolver.add(north_on_count == 1)\n\noptions = {\n    'A': Not(light_vars[1]),  # Light 1 is off\n    'B': light_vars[2],       # Light 2 is on\n    'C': Not(light_vars[3]),  # Light 3 is off\n    'D': light_vars[4],       # Light 4 is on\n    'E': light_vars[5],       # Light 5 is on\n}\n\n# We want to find which option COULD BE FALSE.\n# That means: Is it possible to satisfy all constraints AND the north side exactly one on,\n# and the negation of the option statement? (i.e., option statement is false)\n# For example, for option A: could Light 1 be on? (negation of \"Light 1 is off\" is \"Light 1 is on\")\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add negation of the option statement\n    solver.add(Not(options[letter]))\n    if solver.check() == sat:\n        # If satisfiable, then the option statement could be false\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Seven children are to be seated in seven chairs arranged in a row that runs from west to east. All seven children will face north. Four of the children are boys: Frank, Harry, Ivan, and Joel. Three are girls: Ruby, Sylvia, and Thelma. The children are assigned to chairs according to the following conditions: Exactly one child sits in each chair. No boy sits next to another boy. Ivan sits next to and east of the fourth child in the row. Sylvia sits east of Ivan. Frank sits next to Ruby.\n\nWhich one of the following statements must be false?\n\nOptions:\n(A) Both Harry and Joel sit east of Frank.\n(B) Both Harry and Ruby sit east of Frank.\n(C) Both Harry and Joel sit west of Frank.\n(D) Both Harry and Ruby sit west of Frank.\n(E) Both Joel and Ruby sit east of Frank.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Frank', 'Harry', 'Ivan', 'Joel', 'Ruby', 'Sylvia', 'Thelma']\nboys = ['Frank', 'Harry', 'Ivan', 'Joel']\ngirls = ['Ruby', 'Sylvia', 'Thelma']\n\n# Positions: 0 (west end) to 6 (east end)\npositions = {child: Int(child) for child in children}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each child sits in exactly one chair between 0 and 6\nfor child in children:\n    solver.add(And(positions[child] >= 0, positions[child] <= 6))\n\n# All positions are distinct\nsolver.add(Distinct([positions[child] for child in children]))\n\n# No boy sits next to another boy\n# For every pair of boys, their positions must not be adjacent\nfor i in range(len(boys)):\n    for j in range(i + 1, len(boys)):\n        pos_i = positions[boys[i]]\n        pos_j = positions[boys[j]]\n        diff = Abs(pos_i - pos_j)\n        solver.add(diff != 1)\n\n# Ivan sits next to and east of the fourth child in the row\n# First, find the child who is fourth in the row (position 3)\n# Define a helper: for each child, a Bool indicating if that child is in position 3\nfourth_child = {child: Bool(child + \"_is_4th\") for child in children}\nfor child in children:\n    solver.add(fourth_child[child] == (positions[child] == 3))\n# Exactly one child is in position 3\nsolver.add(Sum([If(fourth_child[child], 1, 0) for child in children]) == 1)\n# Ivan sits next to and east of the fourth child: Ivan's position = 4\n# and the fourth child's position = 3\n# So find which child is in position 3 and impose Ivan at 4\nsolver.add(positions['Ivan'] == 4)\n\n# Sylvia sits east of Ivan\nsolver.add(positions['Sylvia'] > positions['Ivan'])\n\n# Frank sits next to Ruby\ndiff_frank_ruby = Abs(positions['Frank'] - positions['Ruby'])\nsolver.add(diff_frank_ruby == 1)\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Both Harry and Joel sit east of Frank.\n    And(positions['Harry'] > positions['Frank'], positions['Joel'] > positions['Frank']),\n    # (B) Both Harry and Ruby sit east of Frank.\n    And(positions['Harry'] > positions['Frank'], positions['Ruby'] > positions['Frank']),\n    # (C) Both Harry and Joel sit west of Frank.\n    And(positions['Harry'] < positions['Frank'], positions['Joel'] < positions['Frank']),\n    # (D) Both Harry and Ruby sit west of Frank.\n    And(positions['Harry'] < positions['Frank'], positions['Ruby'] < positions['Frank']),\n    # (E) Both Joel and Ruby sit east of Frank.\n    And(positions['Joel'] > positions['Frank'], positions['Ruby'] > positions['Frank']),\n]\n\n# We want to find which option must be false, i.e., which option is unsatisfiable when added to constraints\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven children are to be seated in seven chairs arranged in a row that runs from west to east. All seven children will face north. Four of the children are boys: Frank, Harry, Ivan, and Joel. Three are girls: Ruby, Sylvia, and Thelma. The children are assigned to chairs according to the following conditions: Exactly one child sits in each chair. No boy sits next to another boy. Ivan sits next to and east of the fourth child in the row. Sylvia sits east of Ivan. Frank sits next to Ruby.\n\nIf Thelma sits next to Ivan, and if Frank sits next to Thelma, which one of the following statements could be false?\n\nOptions:\n(A) Both Frank and Ivan sit east of Ruby.\n(B) Both Frank and Ruby sit west of Thelma.\n(C) Both Frank and Sylvia sit east of Ruby.\n(D) Both Frank and Thelma sit west of Sylvia.\n(E) Both Frank and Ruby sit west of Joel.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Frank', 'Harry', 'Ivan', 'Joel', 'Ruby', 'Sylvia', 'Thelma']\nboys = ['Frank', 'Harry', 'Ivan', 'Joel']\ngirls = ['Ruby', 'Sylvia', 'Thelma']\n\n# Create position variables for each child: position 0 (west end) to 6 (east end)\npos = {child: Int(child) for child in children}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Positions range from 0 to 6\nfor child in children:\n    solver.add(And(pos[child] >= 0, pos[child] <= 6))\n\n# All positions are distinct\nsolver.add(Distinct([pos[child] for child in children]))\n\n# No boy sits next to another boy\n# For every pair of boys, their positions are not adjacent\nfor i in range(len(boys)):\n    for j in range(i + 1, len(boys)):\n        diff = Abs(pos[boys[i]] - pos[boys[j]])\n        solver.add(diff != 1)\n\n# Ivan sits next to and east of the fourth child in the row\n# The fourth child is at position 3 (0-based)\n# So the child at position 3 is some child C, and Ivan is at position 4\n# We model this by saying: There exists a child C such that pos[C] == 3 and pos[Ivan] == 4\n# Also, Ivan sits next to that child (positions differ by 1) and Ivan is east (pos[Ivan] > pos[C])\n# So pos[Ivan] == 4 and pos[C] == 3\n# We enforce that pos[Ivan] == 4\nsolver.add(pos['Ivan'] == 4)\n\n# The child in position 3 is the \"fourth child in the row\"\n# So we find the child C with pos[C] == 3\n# Exactly one child at position 3\nchild_at_3 = [pos[child] == 3 for child in children]\nsolver.add(Or(child_at_3))  # At least one child at position 3\n# Exactly one child at position 3 (enforced by Distinct and position constraints)\n\n# Sylvia sits east of Ivan\nsolver.add(pos['Sylvia'] > pos['Ivan'])\n\n# Frank sits next to Ruby\nsolver.add(Or(pos['Frank'] - pos['Ruby'] == 1, pos['Ruby'] - pos['Frank'] == 1))\n\n# Additional conditions given in the question\n# Thelma sits next to Ivan\nsolver.add(Or(pos['Thelma'] - pos['Ivan'] == 1, pos['Ivan'] - pos['Thelma'] == 1))\n\n# Frank sits next to Thelma\nsolver.add(Or(pos['Frank'] - pos['Thelma'] == 1, pos['Thelma'] - pos['Frank'] == 1))\n\n# OPTION CHECKING\noptions = {\n    'A': And(pos['Frank'] > pos['Ruby'], pos['Ivan'] > pos['Ruby']),\n    'B': And(pos['Frank'] < pos['Thelma'], pos['Ruby'] < pos['Thelma']),\n    'C': And(pos['Frank'] > pos['Ruby'], pos['Sylvia'] > pos['Ruby']),\n    'D': And(pos['Frank'] < pos['Sylvia'], pos['Thelma'] < pos['Sylvia']),\n    'E': And(pos['Frank'] < pos['Joel'], pos['Ruby'] < pos['Joel']),\n}\n\n# We want to find which option could be false\n# So for each option, check if the negation is satisfiable with the constraints\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(Not(options[letter]))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Seven children are to be seated in seven chairs arranged in a row that runs from west to east. All seven children will face north. Four of the children are boys: Frank, Harry, Ivan, and Joel. Three are girls: Ruby, Sylvia, and Thelma. The children are assigned to chairs according to the following conditions: Exactly one child sits in each chair. No boy sits next to another boy. Ivan sits next to and east of the fourth child in the row. Sylvia sits east of Ivan. Frank sits next to Ruby.\n\nIf Frank does not sit next to any child who sits next to Ivan, which one of the following statements could be true?\n\nOptions:\n(A) Harry sits west of Frank.\n(B) Joel sits west of Ivan.\n(C) Ruby sits west of Frank.\n(D) Thelma sits west of Frank.\n(E) Thelma sits west of Ruby.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Frank', 'Harry', 'Ivan', 'Joel', 'Ruby', 'Sylvia', 'Thelma']\nboys = ['Frank', 'Harry', 'Ivan', 'Joel']\ngirls = ['Ruby', 'Sylvia', 'Thelma']\nnum_chairs = 7\n\n# Create Z3 Int variables representing the chair position (0 to 6) of each child\npositions = {child: Int(child) for child in children}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each child sits in exactly one chair: positions between 0 and 6\nfor child in children:\n    solver.add(And(positions[child] >= 0, positions[child] < num_chairs))\n\n# All positions are distinct (one child per chair)\nsolver.add(Distinct([positions[child] for child in children]))\n\n# No boy sits next to another boy\n# For each pair of boys, their positions are not adjacent\nfor i in range(len(boys)):\n    for j in range(i + 1, len(boys)):\n        b1 = boys[i]\n        b2 = boys[j]\n        pos_diff = Abs(positions[b1] - positions[b2])\n        solver.add(pos_diff != 1)\n\n# Ivan sits next to and east of the fourth child in the row\n# The fourth chair is at index 3 (0-based)\n# Ivan sits next to chair 3, and his position is greater than 3\nsolver.add(Or(\n    positions['Ivan'] == 2,  # 2 is next to 3\n    positions['Ivan'] == 4   # 4 is next to 3\n))\nsolver.add(positions['Ivan'] > 3)\n\n# Sylvia sits east of Ivan\nsolver.add(positions['Sylvia'] > positions['Ivan'])\n\n# Frank sits next to Ruby\nsolver.add(Or(positions['Frank'] == positions['Ruby'] + 1,\n              positions['Frank'] == positions['Ruby'] - 1))\n\n# Frank does not sit next to any child who sits next to Ivan\n# Find children who sit next to Ivan: their positions differ by 1 from Ivan's\n# Frank does not sit next to any of these children: positions differ by 1 from Frank's\n# So for any child C with abs(positions[C] - positions[ Ivan ]) ==1, abs(positions[C] - positions[Frank]) !=1\n# This must hold for all children except Frank and Ivan\n\nfor child in children:\n    if child != 'Frank' and child != 'Ivan':\n        is_next_to_ivan = Abs(positions[child] - positions['Ivan']) == 1\n        is_next_to_frank = Abs(positions[child] - positions['Frank']) == 1\n        # If child is next to Ivan, then child is not next to Frank\n        solver.add(Implies(is_next_to_ivan, Not(is_next_to_frank)))\n\n# OPTION CHECKING\n# We test each option by adding the option-specific constraint and checking satisfiability\n\noptions = {\n    'A': positions['Harry'] < positions['Frank'],   # Harry sits west of Frank\n    'B': positions['Joel'] < positions['Ivan'],    # Joel sits west of Ivan\n    'C': positions['Ruby'] < positions['Frank'],   # Ruby sits west of Frank\n    'D': positions['Thelma'] < positions['Frank'], # Thelma sits west of Frank\n    'E': positions['Thelma'] < positions['Ruby'],  # Thelma sits west of Ruby\n}\n\nfor letter, constraint in options.items():\n    solver.push()\n    solver.add(constraint)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Seven children are to be seated in seven chairs arranged in a row that runs from west to east. All seven children will face north. Four of the children are boys: Frank, Harry, Ivan, and Joel. Three are girls: Ruby, Sylvia, and Thelma. The children are assigned to chairs according to the following conditions: Exactly one child sits in each chair. No boy sits next to another boy. Ivan sits next to and east of the fourth child in the row. Sylvia sits east of Ivan. Frank sits next to Ruby.\n\nIf Frank sits east of Ruby, which one of the following pairs of children CANNOT sit next to each other?\n\nOptions:\n(A) Frank and Thelma\n(B) Harry and Ruby\n(C) Harry and Sylvia\n(D) Ivan and Ruby\n(E) Joel and Ruby",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Frank', 'Harry', 'Ivan', 'Joel', 'Ruby', 'Sylvia', 'Thelma']\nboys = ['Frank', 'Harry', 'Ivan', 'Joel']\ngirls = ['Ruby', 'Sylvia', 'Thelma']\n\nnum_chairs = 7\nchairs = list(range(num_chairs))  # 0 to 6, west to east\n\n# Create a variable for each child representing their chair position (0 to 6)\npositions = {child: Int(child) for child in children}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each child sits in exactly one chair within range\nfor child in children:\n    solver.add(And(positions[child] >= 0, positions[child] < num_chairs))\n\n# All children sit in distinct chairs\nsolver.add(Distinct([positions[child] for child in children]))\n\n# No boy sits next to another boy\nfor i in range(num_chairs - 1):\n    # If chair i and i+1 both have boys, that's forbidden\n    # So for each adjacent pair of chairs, at most one boy is seated\n    # We'll encode that by forbidding any pair of boys in adjacent chairs\n    for b1 in boys:\n        for b2 in boys:\n            if b1 != b2:\n                cond = And(positions[b1] == i, positions[b2] == i + 1)\n                solver.add(Not(cond))\n\n# Ivan sits next to and east of the fourth child in the row\n# The fourth chair is chair number 3 (0-based)\n# So the child in chair 3 is some child X\n# Ivan sits next to that child and east of that child: Ivan's chair = 4, child's chair = 3\n# So Ivan must be in chair 4, and some child is in chair 3\n# The \"fourth child\" means the child in chair 3\n# So Ivan sits next to and east of the child in chair 3\n# Ivan's chair = child's chair + 1 = 4\nsolver.add(positions['Ivan'] == 4)\n\n# Sylvia sits east of Ivan\nsolver.add(positions['Sylvia'] > positions['Ivan'])\n\n# Frank sits next to Ruby\nsolver.add(Or(positions['Frank'] == positions['Ruby'] + 1,\n              positions['Frank'] == positions['Ruby'] - 1))\n\n# Additional given condition for the question: Frank sits east of Ruby\nsolver.add(positions['Frank'] > positions['Ruby'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': ('Frank', 'Thelma'),\n    'B': ('Harry', 'Ruby'),\n    'C': ('Harry', 'Sylvia'),\n    'D': ('Ivan', 'Ruby'),\n    'E': ('Joel', 'Ruby')\n}\n\nfor letter, (c1, c2) in options.items():\n    solver.push()\n    # Add constraint that c1 and c2 sit next to each other\n    solver.add(Or(positions[c1] == positions[c2] + 1,\n                  positions[c1] == positions[c2] - 1))\n    # Check if this is possible\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.\n\nWhich one of the following could be true?\n\nOptions:\n(A) W, X, and Z all respond to ferromycin.\n(B) W, X, and Z all respond to ganocyclene.\n(C) W and exactly one other organism respond to ganocyclene.\n(D) W responds to more of the antibiotics than X does.\n(E) More of the organisms respond to ferromycin than to ganocyclene.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\norganisms = ['W', 'X', 'Y', 'Z']\nantibiotics = ['ferromycin', 'ganocyclene', 'heptocillin']\n\n# Create variables: resp[o][a] = Bool indicating if organism o responds to antibiotic a\nresp = {o: {a: Bool(f\"{o}_{a}\") for a in antibiotics} for o in organisms}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each organism responds to at least one antibiotic\nfor o in organisms:\n    solver.add(Or([resp[o][a] for a in antibiotics]))\n\n# 2. No organism responds to all three antibiotics\nfor o in organisms:\n    solver.add(Not(And([resp[o][a] for a in antibiotics])))\n\n# 3. At least two but not all four respond to ferromycin\nferro_responders = [resp[o]['ferromycin'] for o in organisms]\nsolver.add(Sum([If(f,1,0) for f in ferro_responders]) >= 2)\nsolver.add(Sum([If(f,1,0) for f in ferro_responders]) < 4)\n\n# 4. If W responds to any antibiotic, then X responds to that antibiotic\nfor a in antibiotics:\n    solver.add(Implies(resp['W'][a], resp['X'][a]))\n\n# 5. If an organism responds to ferromycin, then it responds to ganocyclene\nfor o in organisms:\n    solver.add(Implies(resp[o]['ferromycin'], resp[o]['ganocyclene']))\n\n# 6. Y responds to ferromycin\nsolver.add(resp['Y']['ferromycin'])\n\n# OPTION CHECKING\n\n# Helper function to check an option\ndef check_option(constraints):\n    solver.push()\n    for c in constraints:\n        solver.add(c)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# (A) W, X, and Z all respond to ferromycin.\noption_A = [resp['W']['ferromycin'], resp['X']['ferromycin'], resp['Z']['ferromycin']]\n\n# (B) W, X, and Z all respond to ganocyclene.\noption_B = [resp['W']['ganocyclene'], resp['X']['ganocyclene'], resp['Z']['ganocyclene']]\n\n# (C) W and exactly one other organism respond to ganocyclene.\nganocyclene_responders = [resp[o]['ganocyclene'] for o in organisms]\n# W responds to ganocyclene\nc1 = resp['W']['ganocyclene']\n# Exactly 2 organisms respond to ganocyclene\nc2 = (Sum([If(g,1,0) for g in ganocyclene_responders]) == 2)\noption_C = [c1, c2]\n\n# (D) W responds to more of the antibiotics than X does.\n# Count responses for W and X\nw_count = Sum([If(resp['W'][a],1,0) for a in antibiotics])\nx_count = Sum([If(resp['X'][a],1,0) for a in antibiotics])\noption_D = [w_count > x_count]\n\n# (E) More of the organisms respond to ferromycin than to ganocyclene.\nferro_count = Sum([If(resp[o]['ferromycin'],1,0) for o in organisms])\ngano_count = Sum([If(resp[o]['ganocyclene'],1,0) for o in organisms])\noption_E = [ferro_count > gano_count]\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, option in enumerate(options):\n    if check_option(option):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Exactly one of the organisms responds to ferromycin.\n(B) All four of the organisms respond to heptocillin.\n(C) At least one of the organisms responds both to ferromycin and to heptocillin.\n(D) At least one of the organisms responds neither to ganocyclene nor to heptocillin.\n(E) At least one of the organisms responds to ganocyclene but does not respond to ferromycin.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\norganisms = ['W', 'X', 'Y', 'Z']\nantibiotics = ['ferromycin', 'ganocyclene', 'heptocillin']\n\n# Create response variables: response[o][a] = Bool indicating if organism o responds to antibiotic a\nresponse = {o: {a: Bool(f\"{o}_{a}\") for a in antibiotics} for o in organisms}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each organism responds to at least one antibiotic\nfor o in organisms:\n    at_least_one = Or([response[o][a] for a in antibiotics])\n    solver.add(at_least_one)\n\n# No organism responds to all three antibiotics\nfor o in organisms:\n    all_three = And([response[o][a] for a in antibiotics])\n    solver.add(Not(all_three))\n\n# At least two but not all four organisms respond to ferromycin\nferro_responders = [response[o]['ferromycin'] for o in organisms]\nnum_ferro = Sum([If(resp, 1, 0) for resp in ferro_responders])\nsolver.add(num_ferro >= 2)\nsolver.add(num_ferro < 4)\n\n# If W responds to any antibiotic, then X responds to that antibiotic\nfor a in antibiotics:\n    solver.add(Implies(response['W'][a], response['X'][a]))\n\n# If an organism responds to ferromycin, then it responds to ganocyclene\nfor o in organisms:\n    solver.add(Implies(response[o]['ferromycin'], response[o]['ganocyclene']))\n\n# Y responds to ferromycin\nsolver.add(response['Y']['ferromycin'])\n\n# OPTION CHECKING\noptions = {\n    'A': \"Exactly one of the organisms responds to ferromycin.\",\n    'B': \"All four of the organisms respond to heptocillin.\",\n    'C': \"At least one of the organisms responds both to ferromycin and to heptocillin.\",\n    'D': \"At least one of the organisms responds neither to ganocyclene nor to heptocillin.\",\n    'E': \"At least one of the organisms responds to ganocyclene but does not respond to ferromycin.\"\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    if letter == 'A':\n        # Exactly one organism responds to ferromycin\n        solver.add(num_ferro == 1)\n    elif letter == 'B':\n        # All four organisms respond to heptocillin\n        all_hepto = And([response[o]['heptocillin'] for o in organisms])\n        solver.add(all_hepto)\n    elif letter == 'C':\n        # At least one organism responds to both ferromycin and heptocillin\n        both_resp = Or([And(response[o]['ferromycin'], response[o]['heptocillin']) for o in organisms])\n        solver.add(both_resp)\n    elif letter == 'D':\n        # At least one organism responds neither to ganocyclene nor heptocillin\n        neither_resp = Or([And(Not(response[o]['ganocyclene']), Not(response[o]['heptocillin'])) for o in organisms])\n        solver.add(neither_resp)\n    elif letter == 'E':\n        # At least one organism responds to ganocyclene but not to ferromycin\n        ganocyclene_not_ferro = Or([And(response[o]['ganocyclene'], Not(response[o]['ferromycin'])) for o in organisms])\n        solver.add(ganocyclene_not_ferro)\n    else:\n        solver.pop()\n        continue\n\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.\n\nIf X does not respond to ferromycin, then which one of the following must be true?\n\nOptions:\n(A) W responds to ganocyclene.\n(B) X responds to ganocyclene.\n(C) X responds to heptocillin.\n(D) Z responds to ferromycin.\n(E) Z responds to heptocillin.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\norganisms = ['W', 'X', 'Y', 'Z']\nantibiotics = ['ferromycin', 'ganocyclene', 'heptocillin']\n\n# Create variables: response[o][a] = Bool variable indicating if organism o responds to antibiotic a\nresponse = {}\nfor o in organisms:\n    response[o] = {}\n    for a in antibiotics:\n        response[o][a] = Bool(f\"{o}_{a}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each organism responds to at least one antibiotic\nfor o in organisms:\n    solver.add(Or([response[o][a] for a in antibiotics]))\n\n# 2. No organism responds to all three antibiotics\nfor o in organisms:\n    solver.add(Not(And([response[o][a] for a in antibiotics])))\n\n# 3. At least two but not all four organisms respond to ferromycin\nferro_responders = [response[o]['ferromycin'] for o in organisms]\nnum_ferro_responders = Sum([If(r, 1, 0) for r in ferro_responders])\nsolver.add(num_ferro_responders >= 2)\nsolver.add(num_ferro_responders < 4)\n\n# 4. If W responds to any antibiotic, then X responds to that antibiotic\nfor a in antibiotics:\n    solver.add(Implies(response['W'][a], response['X'][a]))\n\n# 5. If an organism responds to ferromycin, then it responds to ganocyclene\nfor o in organisms:\n    solver.add(Implies(response[o]['ferromycin'], response[o]['ganocyclene']))\n\n# 6. Y responds to ferromycin\nsolver.add(response['Y']['ferromycin'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': response['W']['ganocyclene'],\n    'B': response['X']['ganocyclene'],\n    'C': response['X']['heptocillin'],\n    'D': response['Z']['ferromycin'],\n    'E': response['Z']['heptocillin']\n}\n\n# Add the condition: X does NOT respond to ferromycin\nsolver.add(Not(response['X']['ferromycin']))\n\n# We want to find which option must be true under these constraints.\n# For each option, check if the option can be false.\n# The correct option is the one that cannot be false (i.e., must be true).\n\nfor letter, cond in options.items():\n    solver.push()\n    # Add negation of the option to check if it can be false\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        # If adding Not(cond) makes it unsat, then cond must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.\n\nIf any of the organisms responds to two of the antibiotics, then which one of the following is true about such an organism?\n\nOptions:\n(A) It must respond to ferromycin.\n(B) It must respond to ganocyclene.\n(C) It must respond to heptocillin.\n(D) It cannot respond to ferromycin.\n(E) It cannot respond to ganocyclene.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\norganisms = ['W', 'X', 'Y', 'Z']\nantibiotics = ['ferromycin', 'ganocyclene', 'heptocillin']\n\n# Create a dictionary of Bool variables: response[organism][antibiotic]\nresponse = {}\nfor o in organisms:\n    response[o] = {}\n    for a in antibiotics:\n        response[o][a] = Bool(f\"{o}_{a}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1) Each organism responds to at least one antibiotic\nfor o in organisms:\n    at_least_one = Or([response[o][a] for a in antibiotics])\n    solver.add(at_least_one)\n\n# 2) No organism responds to all three antibiotics\nfor o in organisms:\n    all_three = And([response[o][a] for a in antibiotics])\n    solver.add(Not(all_three))\n\n# 3) At least two but not all four respond to ferromycin\nferromycin_responders = [response[o]['ferromycin'] for o in organisms]\ncount_ferromycin = Sum([If(r, 1, 0) for r in ferromycin_responders])\nsolver.add(count_ferromycin >= 2)\nsolver.add(count_ferromycin < 4)\n\n# 4) If W responds to any antibiotic, then X responds to that antibiotic\nfor a in antibiotics:\n    solver.add(Implies(response['W'][a], response['X'][a]))\n\n# 5) If an organism responds to ferromycin, then it responds to ganocyclene\nfor o in organisms:\n    solver.add(Implies(response[o]['ferromycin'], response[o]['ganocyclene']))\n\n# 6) Y responds to ferromycin\nsolver.add(response['Y']['ferromycin'])\n\n# OPTION CHECKING\n# The question: If any organism responds to two antibiotics, then which is true about such an organism?\n\n# We will check each option by adding the condition \"there exists an organism responding to exactly two antibiotics\"\n# and the negation of the option, and see if the model is satisfiable.\n# The correct option is the one for which adding the negation leads to unsat.\n\n# Helper: exactly two antibiotics for an organism o\ndef exactly_two_antibiotics(o):\n    count = Sum([If(response[o][a], 1, 0) for a in antibiotics])\n    return count == 2\n\n# Options:\n# (A) It must respond to ferromycin.\n# (B) It must respond to ganocyclene.\n# (C) It must respond to heptocillin.\n# (D) It cannot respond to ferromycin.\n# (E) It cannot respond to ganocyclene.\n\noptions = {\n    'A': lambda o: response[o]['ferromycin'],\n    'B': lambda o: response[o]['ganocyclene'],\n    'C': lambda o: response[o]['heptocillin'],\n    'D': lambda o: Not(response[o]['ferromycin']),\n    'E': lambda o: Not(response[o]['ganocyclene']),\n}\n\nfor letter, prop in options.items():\n    solver.push()\n    # There exists an organism with exactly two antibiotics\n    exists_two = Or([exactly_two_antibiotics(o) for o in organisms])\n    solver.add(exists_two)\n    # There exists an organism with exactly two antibiotics that does NOT satisfy the property\n    neg_prop = Or([And(exactly_two_antibiotics(o), Not(prop(o))) for o in organisms])\n    solver.add(neg_prop)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.\n\nIf none of the organisms responds to heptocillin, then which one of the following must be true?\n\nOptions:\n(A) W responds to ferromycin.\n(B) X responds to ferromycin.\n(C) Z responds to ferromycin.\n(D) Exactly three of the organisms respond to ganocyclene.\n(E) Exactly four of the organisms respond to ganocyclene.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\norganisms = ['W', 'X', 'Y', 'Z']\nantibiotics = ['ferromycin', 'ganocyclene', 'heptocillin']\n\n# Create variables: response[o][a] = Bool indicating if organism o responds to antibiotic a\nresponse = {}\nfor o in organisms:\n    for a in antibiotics:\n        response[(o, a)] = Bool(f\"{o}_{a}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each organism responds to at least one antibiotic\nfor o in organisms:\n    solver.add(Or([response[(o, a)] for a in antibiotics]))\n\n# No organism responds to all three antibiotics\nfor o in organisms:\n    solver.add(Not(And([response[(o, a)] for a in antibiotics])))\n\n# At least two but not all four respond to ferromycin\nferro_responses = [response[(o, 'ferromycin')] for o in organisms]\nferro_count = Sum([If(r, 1, 0) for r in ferro_responses])\nsolver.add(ferro_count >= 2)\nsolver.add(ferro_count < 4)\n\n# If W responds to any antibiotic, then X responds to that antibiotic\nfor a in antibiotics:\n    solver.add(Implies(response[('W', a)], response[('X', a)]))\n\n# If an organism responds to ferromycin, then it responds to ganocyclene\nfor o in organisms:\n    solver.add(Implies(response[(o, 'ferromycin')], response[(o, 'ganocyclene')]))\n\n# Y responds to ferromycin\nsolver.add(response[('Y', 'ferromycin')])\n\n# Additional constraint: none of the organisms responds to heptocillin\nfor o in organisms:\n    solver.add(Not(response[(o, 'heptocillin')]))\n\n# OPTION CHECKING\n\n# Define option constraints\noptions = {\n    'A': response[('W', 'ferromycin')],\n    'B': response[('X', 'ferromycin')],\n    'C': response[('Z', 'ferromycin')],\n    'D': Sum([If(response[(o, 'ganocyclene')], 1, 0) for o in organisms]) == 3,\n    'E': Sum([If(response[(o, 'ganocyclene')], 1, 0) for o in organisms]) == 4,\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    # Add negation of option to check if it's necessarily true\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "The organisms W, X, Y, and Z respond to the antibiotics ferromycin, ganocyclene, and heptocillin in a manner consistent with the following: Each of the organisms responds to at least one of the antibiotics. No organism responds to all three antibiotics. At least two but not all four of the organisms respond to ferromycin. If W responds to any antibiotic, then X responds to that antibiotic. If an organism responds to ferromycin, then it responds to ganocyclene. Y responds to ferromycin.\n\nIf three of the organisms respond to exactly the same set of antibiotics as each other, and if Z does not respond to ferromycin, then each of the following must be true EXCEPT:\n\nOptions:\n(A) W responds to ferromycin.\n(B) X responds to ganocyclene.\n(C) Z responds to ganocyclene.\n(D) W responds to exactly the same set of antibiotics as Y.\n(E) X responds to exactly the same set of antibiotics as Y.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\norganisms = ['W', 'X', 'Y', 'Z']\nantibiotics = ['ferromycin', 'ganocyclene', 'heptocillin']\n\n# Create variables: response[o][a] = Bool indicating if organism o responds to antibiotic a\nresponse = {}\nfor o in organisms:\n    for a in antibiotics:\n        response[(o, a)] = Bool(f\"{o}_{a}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each organism responds to at least one antibiotic\nfor o in organisms:\n    solver.add(Or([response[(o, a)] for a in antibiotics]))\n\n# 2. No organism responds to all three antibiotics\nfor o in organisms:\n    solver.add(Not(And([response[(o, a)] for a in antibiotics])))\n\n# 3. At least two but not all four respond to ferromycin\nferro_responders = [response[(o, 'ferromycin')] for o in organisms]\nsolver.add(Sum([If(f, 1, 0) for f in ferro_responders]) >= 2)\nsolver.add(Sum([If(f, 1, 0) for f in ferro_responders]) < 4)\n\n# 4. If W responds to any antibiotic, then X responds to that antibiotic\nfor a in antibiotics:\n    solver.add(Implies(response[('W', a)], response[('X', a)]))\n\n# 5. If an organism responds to ferromycin, then it responds to ganocyclene\nfor o in organisms:\n    solver.add(Implies(response[(o, 'ferromycin')], response[(o, 'ganocyclene')]))\n\n# 6. Y responds to ferromycin\nsolver.add(response[('Y', 'ferromycin')])\n\n# Additional conditions from the question:\n# - Three organisms respond to exactly the same set of antibiotics\n# - Z does NOT respond to ferromycin\n\n# Add Z does not respond to ferromycin\nsolver.add(Not(response[('Z', 'ferromycin')]))\n\n# Define a helper function to get the set of antibiotics an organism responds to as a tuple of Bools\ndef get_response_tuple(o):\n    return tuple(response[(o, a)] for a in antibiotics)\n\n# We want exactly three organisms with the same response set\n# We will encode that there is a set S of three organisms with identical responses,\n# and the fourth organism is not identical to them\n\n# Create a helper function to assert that two organisms have identical responses\ndef identical_response(o1, o2):\n    return And([response[(o1, a)] == response[(o2, a)] for a in antibiotics])\n\n# We try all combinations of 3 organisms to be identical\nthree_identical_constraints = []\nfrom itertools import combinations\n\nfor triple in combinations(organisms, 3):\n    # The three in triple have identical responses\n    cond1 = And([identical_response(triple[0], triple[1]),\n                 identical_response(triple[1], triple[2])])\n    # The fourth organism is different\n    fourth = [o for o in organisms if o not in triple][0]\n    cond2 = Not(identical_response(triple[0], fourth))\n    three_identical_constraints.append(And(cond1, cond2))\n\nsolver.add(Or(three_identical_constraints))\n\n# OPTION CHECKING\n\noptions = {\n    'A': response[('W', 'ferromycin')],\n    'B': response[('X', 'ganocyclene')],\n    'C': response[('Z', 'ganocyclene')],\n    'D': identical_response('W', 'Y'),\n    'E': identical_response('X', 'Y')\n}\n\n# We want to find which option can be false (EXCEPT)\n# So for each option, check if the model can be satisfied with that option false.\n# The one that can be false is the EXCEPT answer.\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(Not(cond))  # Assume the option is false\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A florist is making three corsages from four types of flowers: gardenias, orchids, roses, and violets. Each of the corsages will contain exactly three flowers. The nine flowers used in the corsages must include at least one flower from each of the four types, and at least twice as many roses as orchids must be used. The corsages must also meet the following specifications: Corsage 1 must contain exactly two types of flowers. Corsage 2 must contain at least one rose. Corsage 3 must contain at least one gardenia but no orchids.\n\nThe maximum total number of roses that can be used in the three corsages is\n\nOptions:\n(A) three\n(B) four\n(C) five\n(D) six\n(E) seven",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflower_types = ['gardenia', 'orchid', 'rose', 'violet']\ncorsages = [1, 2, 3]\n\n# Create variables for number of each flower type in each corsage\n# Each variable represents the count of that flower type in that corsage\nflowers = {}\nfor c in corsages:\n    for f in flower_types:\n        flowers[(c, f)] = Int(f\"{f}_{c}\")\n\nsolver = Optimize()\n\n# CONSTRAINTS\n\n# Each corsage has exactly 3 flowers\nfor c in corsages:\n    solver.add(Sum([flowers[(c, f)] for f in flower_types]) == 3)\n\n# All flower counts are >= 0 and integers\nfor c in corsages:\n    for f in flower_types:\n        solver.add(flowers[(c, f)] >= 0)\n\n# Total flowers used = 9 (3 corsages * 3 flowers each)\n# This is implicitly guaranteed by sum per corsage, so no need to add separately\n\n# At least one flower from each type is used in total\nfor f in flower_types:\n    total_f = Sum([flowers[(c, f)] for c in corsages])\n    solver.add(total_f >= 1)\n\n# At least twice as many roses as orchids used in total:\ntotal_roses = Sum([flowers[(c, 'rose')] for c in corsages])\ntotal_orchids = Sum([flowers[(c, 'orchid')] for c in corsages])\nsolver.add(total_roses >= 2 * total_orchids)\n\n# Corsage 1 must contain exactly two types of flowers\n# Number of flower types with count > 0 in corsage 1 == 2\ncorsage1_types = [flowers[(1, f)] for f in flower_types]\n# Create boolean variables for flower presence in corsage 1\ncorsage1_presence = []\nfor f in flower_types:\n    pres = Bool(f\"pres_1_{f}\")\n    solver.add(pres == (flowers[(1, f)] > 0))\n    corsage1_presence.append(pres)\nsolver.add(Sum([If(p, 1, 0) for p in corsage1_presence]) == 2)\n\n# Corsage 2 must contain at least one rose\nsolver.add(flowers[(2, 'rose')] >= 1)\n\n# Corsage 3 must contain at least one gardenia but no orchids\nsolver.add(flowers[(3, 'gardenia')] >= 1)\nsolver.add(flowers[(3, 'orchid')] == 0)\n\n# OPTION CHECKING\n# The question asks for maximum total number of roses used in the three corsages\n\n# We will maximize total_roses subject to constraints\nh = solver.maximize(total_roses)\n\nif solver.check() == sat:\n    model = solver.model()\n    max_roses = model.eval(total_roses).as_long()\n    # Map max_roses to options:\n    # (A) 3\n    # (B) 4\n    # (C) 5\n    # (D) 6\n    # (E) 7\n\n    options_map = {3: 'A', 4: 'B', 5: 'C', 6: 'D', 7: 'E'}\n    # Print the letter corresponding to max_roses\n    # The problem states only one correct option, so max_roses should be one of these\n    print(f\"'{options_map[max_roses]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A florist is making three corsages from four types of flowers: gardenias, orchids, roses, and violets. Each of the corsages will contain exactly three flowers. The nine flowers used in the corsages must include at least one flower from each of the four types, and at least twice as many roses as orchids must be used. The corsages must also meet the following specifications: Corsage 1 must contain exactly two types of flowers. Corsage 2 must contain at least one rose. Corsage 3 must contain at least one gardenia but no orchids.\n\nIf corsage 1 contains two orchids and one rose, what is the maximum total number of violets that the florist can use in making the three corsages?\n\nOptions:\n(A) one\n(B) two\n(C) three\n(D) four\n(E) five",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflowers = ['gardenias', 'orchids', 'roses', 'violets']\ncorsages = [1, 2, 3]\n\n# Create variables for number of each flower in each corsage\n# Each variable is an Int representing count of that flower in that corsage\nflower_counts = {}\nfor c in corsages:\n    for f in flowers:\n        flower_counts[(c, f)] = Int(f\"{f}_{c}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each corsage contains exactly 3 flowers\nfor c in corsages:\n    total_flowers = Sum([flower_counts[(c, f)] for f in flowers])\n    solver.add(total_flowers == 3)\n\n# All flower counts are >= 0 and integers\nfor c in corsages:\n    for f in flowers:\n        solver.add(flower_counts[(c, f)] >= 0)\n\n# The total flowers used in all corsages is 9 (3 corsages * 3 flowers each)\ntotal_all = Sum([flower_counts[(c, f)] for c in corsages for f in flowers])\nsolver.add(total_all == 9)\n\n# At least one flower from each type is used in total\nfor f in flowers:\n    total_f = Sum([flower_counts[(c, f)] for c in corsages])\n    solver.add(total_f >= 1)\n\n# At least twice as many roses as orchids in total\ntotal_roses = Sum([flower_counts[(c, 'roses')] for c in corsages])\ntotal_orchids = Sum([flower_counts[(c, 'orchids')] for c in corsages])\nsolver.add(total_roses >= 2 * total_orchids)\n\n# Corsage 1 contains exactly two types of flowers\n# Number of flower types used in corsage 1 is 2\ncorsage1_types = []\nfor f in flowers:\n    # Boolean indicating if flower f is used in corsage 1 (count > 0)\n    corsage1_types.append(flower_counts[(1, f)] > 0)\nsolver.add(Sum([If(cond, 1, 0) for cond in corsage1_types]) == 2)\n\n# Corsage 2 must contain at least one rose\nsolver.add(flower_counts[(2, 'roses')] >= 1)\n\n# Corsage 3 must contain at least one gardenia but no orchids\nsolver.add(flower_counts[(3, 'gardenias')] >= 1)\nsolver.add(flower_counts[(3, 'orchids')] == 0)\n\n# Given: Corsage 1 contains two orchids and one rose\nsolver.add(flower_counts[(1, 'orchids')] == 2)\nsolver.add(flower_counts[(1, 'roses')] == 1)\n# Other flowers in corsage 1 are zero\nsolver.add(flower_counts[(1, 'gardenias')] == 0)\nsolver.add(flower_counts[(1, 'violets')] == 0)\n\n# OPTION CHECKING\n# We want to find the maximum total number of violets used in all corsages\n# So we will maximize Sum of violets counts\n\nmax_violets = None\nmax_violets_value = -1\n\nfor option_letter, option_value in zip(['A', 'B', 'C', 'D', 'E'], [1, 2, 3, 4, 5]):\n    solver.push()\n    total_violets = Sum([flower_counts[(c, 'violets')] for c in corsages])\n    # Add constraint that total violets >= option_value\n    solver.add(total_violets >= option_value)\n    # Also add constraint that total violets < option_value + 1 to check exact max\n    solver.add(total_violets < option_value + 1)\n    if solver.check() == sat:\n        max_violets = option_letter\n        max_violets_value = option_value\n        solver.pop()\n    else:\n        solver.pop()\n        break\n\nprint(f\"'{max_violets}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A florist is making three corsages from four types of flowers: gardenias, orchids, roses, and violets. Each of the corsages will contain exactly three flowers. The nine flowers used in the corsages must include at least one flower from each of the four types, and at least twice as many roses as orchids must be used. The corsages must also meet the following specifications: Corsage 1 must contain exactly two types of flowers. Corsage 2 must contain at least one rose. Corsage 3 must contain at least one gardenia but no orchids.\n\nIf corsage 2 is exactly the same as corsage 3, the nine flowers used in the corsages can include exactly\n\nOptions:\n(A) two orchids\n(B) three gardenias\n(C) three roses\n(D) five roses\n(E) five violets",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflowers = ['gardenias', 'orchids', 'roses', 'violets']\ncorsages = [1, 2, 3]\n\n# Variables: number of each flower in each corsage\n# corsage_flower[c][f] = number of flower f in corsage c\ncorsage_flower = {}\nfor c in corsages:\n    for f in flowers:\n        corsage_flower[(c, f)] = Int(f\"{c}_{f}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each corsage has exactly 3 flowers\nfor c in corsages:\n    solver.add(Sum([corsage_flower[(c, f)] for f in flowers]) == 3)\n\n# Each flower count in corsage is >= 0 and <= 3 (max 3 in a corsage)\nfor c in corsages:\n    for f in flowers:\n        solver.add(corsage_flower[(c, f)] >= 0)\n        solver.add(corsage_flower[(c, f)] <= 3)\n\n# Total flowers used: sum over corsages of each flower\ntotal_flowers = {}\nfor f in flowers:\n    total_flowers[f] = Sum([corsage_flower[(c, f)] for c in corsages])\n\n# The nine flowers used in the corsages must include at least one flower from each of the four types\nfor f in flowers:\n    solver.add(total_flowers[f] >= 1)\n\n# At least twice as many roses as orchids must be used\nsolver.add(total_flowers['roses'] >= 2 * total_flowers['orchids'])\n\n# Corsage 1 must contain exactly two types of flowers\n# Number of flower types in corsage 1 with count > 0 is exactly 2\n# Use Bool variables to represent if flower is present in corsage 1\ncorsage1_presence = []\nfor f in flowers:\n    b = Bool(f\"c1_{f}_present\")\n    solver.add(b == (corsage_flower[(1, f)] > 0))\n    corsage1_presence.append(b)\nsolver.add(Sum([If(b, 1, 0) for b in corsage1_presence]) == 2)\n\n# Corsage 2 must contain at least one rose\nsolver.add(corsage_flower[(2, 'roses')] >= 1)\n\n# Corsage 3 must contain at least one gardenia but no orchids\nsolver.add(corsage_flower[(3, 'gardenias')] >= 1)\nsolver.add(corsage_flower[(3, 'orchids')] == 0)\n\n# Corsage 2 is exactly the same as corsage 3\nfor f in flowers:\n    solver.add(corsage_flower[(2, f)] == corsage_flower[(3, f)])\n\n# OPTION CHECKING\n# Options: number of flowers used in total for each flower type\noptions = {\n    'A': ('orchids', 2),\n    'B': ('gardenias', 3),\n    'C': ('roses', 3),\n    'D': ('roses', 5),\n    'E': ('violets', 5)\n}\n\nfor letter, (flower_type, count) in options.items():\n    solver.push()\n    solver.add(total_flowers[flower_type] == count)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A florist is making three corsages from four types of flowers: gardenias, orchids, roses, and violets. Each of the corsages will contain exactly three flowers. The nine flowers used in the corsages must include at least one flower from each of the four types, and at least twice as many roses as orchids must be used. The corsages must also meet the following specifications: Corsage 1 must contain exactly two types of flowers. Corsage 2 must contain at least one rose. Corsage 3 must contain at least one gardenia but no orchids.\n\nIf two of the corsages contain at least one orchid each, then the flowers in corsage 2 must include at least\n\nOptions:\n(A) one gardenia and one orchid\n(B) one gardenia and one rose\n(C) one orchid and one rose\n(D) one orchid and one violet\n(E) one rose and one violet",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflowers = ['gardenias', 'orchids', 'roses', 'violets']\ncorsages = [1, 2, 3]\n\n# Create variables: number of each flower in each corsage (ints >= 0)\nflower_counts = {}\nfor c in corsages:\n    for f in flowers:\n        flower_counts[(c, f)] = Int(f\"{f}_{c}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each corsage has exactly 3 flowers\nfor c in corsages:\n    total_flowers = Sum([flower_counts[(c, f)] for f in flowers])\n    solver.add(total_flowers == 3)\n\n# Total flowers used: 9 flowers (3 corsages * 3 flowers each)\n# But this is already enforced by the above constraints\n\n# The nine flowers used must include at least one flower from each type\nfor f in flowers:\n    total_f = Sum([flower_counts[(c, f)] for c in corsages])\n    solver.add(total_f >= 1)\n\n# At least twice as many roses as orchids must be used in total\ntotal_roses = Sum([flower_counts[(c, 'roses')] for c in corsages])\ntotal_orchids = Sum([flower_counts[(c, 'orchids')] for c in corsages])\nsolver.add(total_roses >= 2 * total_orchids)\n\n# Corsage 1 must contain exactly two types of flowers\n# Number of flower types with count > 0 in corsage 1 is exactly 2\ncorsage1_types = [flower_counts[(1, f)] > 0 for f in flowers]\n# Count how many are True\ncorsage1_type_count = Sum([If(cond, 1, 0) for cond in corsage1_types])\nsolver.add(corsage1_type_count == 2)\n\n# Corsage 2 must contain at least one rose\nsolver.add(flower_counts[(2, 'roses')] >= 1)\n\n# Corsage 3 must contain at least one gardenia but no orchids\nsolver.add(flower_counts[(3, 'gardenias')] >= 1)\nsolver.add(flower_counts[(3, 'orchids')] == 0)\n\n# Now, the question states:\n# If two of the corsages contain at least one orchid each,\n# then the flowers in corsage 2 must include at least...\n\n# We will check each option by adding the condition:\n# \"Two corsages have orchids >= 1\"\n# and \"Corsage 2 includes the flowers specified by the option\"\n# and check satisfiability.\n# The correct option is the one that is necessarily true (i.e., if two corsages have orchids, then corsage 2 must have these flowers)\n# So we check the negation of the option under the condition \"two corsages have orchids\"\n# If unsat, then option is correct.\n\n# Helper: count how many corsages have orchids >= 1\norchid_presence = [flower_counts[(c, 'orchids')] >= 1 for c in corsages]\norchid_count = Sum([If(cond, 1, 0) for cond in orchid_presence])\ntwo_corsages_with_orchids = (orchid_count == 2)\n\n# Define options as dict of flower requirements for corsage 2\noptions = {\n    'A': {'gardenias': 1, 'orchids': 1},\n    'B': {'gardenias': 1, 'roses': 1},\n    'C': {'orchids': 1, 'roses': 1},\n    'D': {'orchids': 1, 'violets': 1},\n    'E': {'roses': 1, 'violets': 1},\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add condition: two corsages have orchids\n    solver.add(two_corsages_with_orchids)\n    # Negate the option: corsage 2 does NOT contain at least the specified flowers\n    # So at least one of the flowers in option is missing (count < required)\n    option_flowers = options[letter]\n    neg_conditions = []\n    for f, req in option_flowers.items():\n        neg_conditions.append(flower_counts[(2, f)] < req)\n    solver.add(Or(neg_conditions))\n    # Check satisfiability\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A florist is making three corsages from four types of flowers: gardenias, orchids, roses, and violets. Each of the corsages will contain exactly three flowers. The nine flowers used in the corsages must include at least one flower from each of the four types, and at least twice as many roses as orchids must be used. The corsages must also meet the following specifications: Corsage 1 must contain exactly two types of flowers. Corsage 2 must contain at least one rose. Corsage 3 must contain at least one gardenia but no orchids.\n\nIf corsage 1 contains at least one gardenia and at least one violet, and if corsage 3 contains three different types of flowers, which one of the following could be used to make corsage 2?\n\nOptions:\n(A) one rose, one orchid, and one gardenia\n(B) one rose and two orchids\n(C) one rose and two violets\n(D) two roses and one gardenia\n(E) two roses and one violet",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflowers = ['gardenia', 'orchid', 'rose', 'violet']\ncorsages = [1, 2, 3]\n\n# Variables: number of each flower in each corsage\n# flower_counts[c][f] = number of flowers of type f in corsage c\nflower_counts = {}\nfor c in corsages:\n    for f in flowers:\n        flower_counts[(c,f)] = Int(f'c{c}_{f}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each corsage has exactly 3 flowers\nfor c in corsages:\n    solver.add(Sum([flower_counts[(c,f)] for f in flowers]) == 3)\n\n# All flower counts are >= 0 and <= 3 (max 3 flowers in a corsage)\nfor c in corsages:\n    for f in flowers:\n        solver.add(And(flower_counts[(c,f)] >= 0, flower_counts[(c,f)] <= 3))\n\n# Total flowers used is 9 (3 corsages * 3 flowers each)\n# This is implicit but we can check total sum of all flowers = 9\ntotal_flowers = Sum([flower_counts[(c,f)] for c in corsages for f in flowers])\nsolver.add(total_flowers == 9)\n\n# At least one flower of each type is used in total\nfor f in flowers:\n    total_f = Sum([flower_counts[(c,f)] for c in corsages])\n    solver.add(total_f >= 1)\n\n# At least twice as many roses as orchids total\ntotal_roses = Sum([flower_counts[(c,'rose')] for c in corsages])\ntotal_orchids = Sum([flower_counts[(c,'orchid')] for c in corsages])\nsolver.add(total_roses >= 2 * total_orchids)\n\n# Corsage 1 must contain exactly two types of flowers\n# Count how many flower types have count > 0 in corsage 1\ncorsage1_types = [flower_counts[(1,f)] > 0 for f in flowers]\n# Number of True in corsage1_types is 2\nsolver.add(Sum([If(cond, 1, 0) for cond in corsage1_types]) == 2)\n\n# Corsage 2 must contain at least one rose\nsolver.add(flower_counts[(2,'rose')] >= 1)\n\n# Corsage 3 must contain at least one gardenia but no orchids\nsolver.add(flower_counts[(3,'gardenia')] >= 1)\nsolver.add(flower_counts[(3,'orchid')] == 0)\n\n# Additional conditions:\n# Corsage 1 contains at least one gardenia and at least one violet\nsolver.add(flower_counts[(1,'gardenia')] >= 1)\nsolver.add(flower_counts[(1,'violet')] >= 1)\n\n# Corsage 3 contains three different types of flowers\ncorsage3_types = [flower_counts[(3,f)] > 0 for f in flowers]\nsolver.add(Sum([If(cond, 1, 0) for cond in corsage3_types]) == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': {'rose':1, 'orchid':1, 'gardenia':1},\n    'B': {'rose':1, 'orchid':2},\n    'C': {'rose':1, 'violet':2},\n    'D': {'rose':2, 'gardenia':1},\n    'E': {'rose':2, 'violet':1}\n}\n\nfor opt_letter in ['A','B','C','D','E']:\n    solver.push()\n    # Set corsage 2 flower counts to the option's values\n    for f in flowers:\n        count = options[opt_letter].get(f, 0)\n        solver.add(flower_counts[(2,f)] == count)\n    # Check if the model is satisfiable\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.\n\nWhich one of the following could be the four people selected to attend the retirement dinner?\n\nOptions:\n(A) J, K, M, P\n(B) J, L, N, Q\n(C) J, M, N, Q\n(D) K, M, P, Q\n(E) L, M, N, P",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['J', 'K', 'L', 'M', 'N', 'P', 'Q']\nselected = {p: Bool(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly four people selected\nsolver.add(Sum([If(selected[p], 1, 0) for p in people]) == 4)\n\n# Either J or K must be selected, but not both\nsolver.add(Xor(selected['J'], selected['K']))\n\n# Either N or P must be selected, but not both\nsolver.add(Xor(selected['N'], selected['P']))\n\n# N cannot be selected unless L is selected (N => L)\nsolver.add(Implies(selected['N'], selected['L']))\n\n# Q cannot be selected unless K is selected (Q => K)\nsolver.add(Implies(selected['Q'], selected['K']))\n\n# OPTION CHECKING\noptions = [\n    ['J', 'K', 'M', 'P'],  # A\n    ['J', 'L', 'N', 'Q'],  # B\n    ['J', 'M', 'N', 'Q'],  # C\n    ['K', 'M', 'P', 'Q'],  # D\n    ['L', 'M', 'N', 'P']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that these people are selected and others not selected\n    for p in people:\n        if p in option:\n            solver.add(selected[p] == True)\n        else:\n            solver.add(selected[p] == False)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.\n\nAmong the people selected to attend the retirement dinner there must be\n\nOptions:\n(A) K or Q or both\n(B) L or M or both\n(C) N or M or both\n(D) N or Q or both\n(E) P or Q or both",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['J', 'K', 'L', 'M', 'N', 'P', 'Q']\nselected = {p: Bool(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly four people are selected\nsolver.add(Sum([If(selected[p], 1, 0) for p in people]) == 4)\n\n# Either J or K must be selected, but not both\nsolver.add(Xor(selected['J'], selected['K']))\n\n# Either N or P must be selected, but not both\nsolver.add(Xor(selected['N'], selected['P']))\n\n# N cannot be selected unless L is selected\nsolver.add(Implies(selected['N'], selected['L']))\n\n# Q cannot be selected unless K is selected\nsolver.add(Implies(selected['Q'], selected['K']))\n\n# OPTION CHECKING\noptions = {\n    'A': Or([selected['K'], selected['Q']]),\n    'B': Or([selected['L'], selected['M']]),\n    'C': Or([selected['N'], selected['M']]),\n    'D': Or([selected['N'], selected['Q']]),\n    'E': Or([selected['P'], selected['Q']])\n}\n\nfor option_letter, option_condition in options.items():\n    solver.push()\n    # Add negation of the option condition to test if it can be false\n    solver.add(Not(option_condition))\n    if solver.check() == unsat:\n        # If negation is unsat, option condition must always be true\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.\n\nWhich one of the following is a pair of people who CANNOT both be selected to attend the retirement dinner?\n\nOptions:\n(A) J and N\n(B) J and Q\n(C) K and L\n(D) K and N\n(E) N and Q",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['J', 'K', 'L', 'M', 'N', 'P', 'Q']\nselected = {p: Bool(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly four people selected\nsolver.add(Sum([If(selected[p], 1, 0) for p in people]) == 4)\n\n# Either J or K must be selected, but not both\nsolver.add(Xor(selected['J'], selected['K']))\n\n# Either N or P must be selected, but not both\nsolver.add(Xor(selected['N'], selected['P']))\n\n# N cannot be selected unless L is selected (N => L)\nsolver.add(Implies(selected['N'], selected['L']))\n\n# Q cannot be selected unless K is selected (Q => K)\nsolver.add(Implies(selected['Q'], selected['K']))\n\n# OPTION CHECKING\noptions = [\n    ('J', 'N'),\n    ('J', 'Q'),\n    ('K', 'L'),\n    ('K', 'N'),\n    ('N', 'Q'),\n]\n\nfor i, (p1, p2) in enumerate(options):\n    solver.push()\n    # Add constraint that both p1 and p2 are selected\n    solver.add(selected[p1])\n    solver.add(selected[p2])\n    if solver.check() == sat:\n        # Both can be selected, so this is NOT the answer\n        solver.pop()\n    else:\n        # Both cannot be selected, print the letter of this option\n        print(f\"'{chr(65 + i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.\n\nIf M is not selected to attend the retirement dinner, the four people selected to attend must include which one of the following pairs of people?\n\nOptions:\n(A) J and Q\n(B) K and L\n(C) K and P\n(D) L and P\n(E) N and Q",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['J', 'K', 'L', 'M', 'N', 'P', 'Q']\nselected = {p: Bool(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly four people selected\nsolver.add(Sum([If(selected[p], 1, 0) for p in people]) == 4)\n\n# Either J or K must be selected, but not both\nsolver.add(Xor(selected['J'], selected['K']))\n\n# Either N or P must be selected, but not both\nsolver.add(Xor(selected['N'], selected['P']))\n\n# N cannot be selected unless L is selected (N -> L)\nsolver.add(Implies(selected['N'], selected['L']))\n\n# Q cannot be selected unless K is selected (Q -> K)\nsolver.add(Implies(selected['Q'], selected['K']))\n\n# M is not selected\nsolver.add(selected['M'] == False)\n\n# OPTION CHECKING\noptions = [\n    ('J', 'Q'),\n    ('K', 'L'),\n    ('K', 'P'),\n    ('L', 'P'),\n    ('N', 'Q'),\n]\n\nfor i, (p1, p2) in enumerate(options):\n    solver.push()\n    # Add constraint that the pair p1 and p2 are selected\n    solver.add(selected[p1] == True)\n    solver.add(selected[p2] == True)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.\n\nIf P is not selected to attend the retirement dinner, then exactly how many different groups of four are there each of which would be an acceptable selection?\n\nOptions:\n(A) one\n(B) two\n(C) three\n(D) four\n(E) five",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['J', 'K', 'L', 'M', 'N', 'P', 'Q']\n\n# Create Bool variables for selection of each person\nselection = {p: Bool(p) for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly four people are selected\nsolver.add(Sum([If(selection[p], 1, 0) for p in people]) == 4)\n\n# Either J or K must be selected, but not both\nsolver.add(Xor(selection['J'], selection['K']))\n\n# Either N or P must be selected, but not both\nsolver.add(Xor(selection['N'], selection['P']))\n\n# N cannot be selected unless L is selected (N => L)\nsolver.add(Implies(selection['N'], selection['L']))\n\n# Q cannot be selected unless K is selected (Q => K)\nsolver.add(Implies(selection['Q'], selection['K']))\n\n# OPTION CHECKING\n# We want to find number of acceptable groups if P is NOT selected\nsolver.push()\nsolver.add(selection['P'] == False)\n\n# Enumerate all solutions under this constraint\nsolutions = []\nwhile solver.check() == sat:\n    model = solver.model()\n    group = []\n    for p in people:\n        if is_true(model.eval(selection[p])):\n            group.append(p)\n    solutions.append(sorted(group))\n    # Block this solution for next search\n    block = []\n    for p in people:\n        val = is_true(model.eval(selection[p]))\n        block.append(selection[p] != val)\n    solver.add(Or(block))\nsolver.pop()\n\n# Count distinct solutions\nnum_solutions = len(solutions)\n\n# Map count to options\n# (A) one\n# (B) two\n# (C) three\n# (D) four\n# (E) five\n\noption_map = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E'}\n\nprint(f\"'{option_map[num_solutions]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "From a group of seven people—J, K, L, M, N, P, and Q—exactly four will be selected to attend a diplomat's retirement dinner. Selection must conform to the following conditions: Either J or K must be selected, but J and K cannot both be selected. Either N or P must be selected, but N and P cannot both be selected. N cannot be selected unless L is selected. Q cannot be selected unless K is selected.\n\nThere is only one acceptable group of four that can be selected to attend the retirement dinner if which one of the following pairs of people is selected?\n\nOptions:\n(A) J and L\n(B) K and M\n(C) L and N\n(D) L and Q\n(E) M and Q",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['J', 'K', 'L', 'M', 'N', 'P', 'Q']\nselected = {p: Bool(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly four people selected\nsolver.add(Sum([If(selected[p], 1, 0) for p in people]) == 4)\n\n# Either J or K must be selected, but not both\nsolver.add(Or(selected['J'], selected['K']))\nsolver.add(Not(And(selected['J'], selected['K'])))\n\n# Either N or P must be selected, but not both\nsolver.add(Or(selected['N'], selected['P']))\nsolver.add(Not(And(selected['N'], selected['P'])))\n\n# N cannot be selected unless L is selected\nsolver.add(Implies(selected['N'], selected['L']))\n\n# Q cannot be selected unless K is selected\nsolver.add(Implies(selected['Q'], selected['K']))\n\n# OPTION CHECKING\noptions = {\n    'A': ['J', 'L'],\n    'B': ['K', 'M'],\n    'C': ['L', 'N'],\n    'D': ['L', 'Q'],\n    'E': ['M', 'Q']\n}\n\nfor letter, pair in options.items():\n    solver.push()\n    # Add constraints that the pair is selected\n    for p in pair:\n        solver.add(selected[p])\n    # Check if there is exactly one acceptable group of four with this pair\n    # Find all possible solutions with the pair selected\n    # We will enumerate solutions and count them\n    count = 0\n    while solver.check() == sat:\n        count += 1\n        if count > 1:\n            break\n        m = solver.model()\n        # Block current solution\n        block = []\n        for p in people:\n            if is_true(m[selected[p]]):\n                block.append(selected[p])\n            else:\n                block.append(Not(selected[p]))\n        solver.add(Not(And(block)))\n    solver.pop()\n    if count == 1:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Three boys—Karl, Luis, and Miguel—and three girls—Rita, Sarah, and Tura—are giving a dance recital. Three dances—1, 2, and 3—are to be performed. Each dance involves three pairs of children, a boy and a girl partnering each other in each pair, according to the following conditions: Karl partners Sarah in either dance 1 or dance 2. Whoever partners Rita in dance 2 must partner Sarah in dance 3. No two children can partner each other in more than one dance.\n\nIf Miguel partners Rita in dance 2, which one of the following could be true?\n\nOptions:\n(A) Karl partners Tura in dance 1.\n(B) Luis partners Sarah in dance 2.\n(C) Luis partners Sarah in dance 3.\n(D) Miguel partners Sarah in dance 1.\n(E) Miguel partners Tura in dance 3.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nboys = ['Karl', 'Luis', 'Miguel']\ngirls = ['Rita', 'Sarah', 'Tura']\ndances = [1, 2, 3]\n\n# Create variables: partner[boy][dance] = girl index\npartner = {b: {d: Int(f'{b}_{d}') for d in dances} for b in boys}\n\n# Create variables: partner_girl[g][d] = boy index\npartner_girl = {g: {d: Int(f'{g}_{d}') for d in dances} for g in girls}\n\n# Create mappings for boys and girls indices\nboy_idx = {b: i for i, b in enumerate(boys)}\ngirl_idx = {g: i for i, g in enumerate(girls)}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each partner variable domain constraints\nfor b in boys:\n    for d in dances:\n        solver.add(And(partner[b][d] >= 0, partner[b][d] < len(girls)))\nfor g in girls:\n    for d in dances:\n        solver.add(And(partner_girl[g][d] >= 0, partner_girl[g][d] < len(boys)))\n\n# Link partner and partner_girl variables: if boy b partners girl g in dance d then partner_girl[g][d] == boy_idx[b] and partner[b][d] == girl_idx[g]\nfor d in dances:\n    for b in boys:\n        for g in girls:\n            # If partner[b][d] == girl_idx[g] then partner_girl[g][d] == boy_idx[b]\n            solver.add(Implies(partner[b][d] == girl_idx[g], partner_girl[g][d] == boy_idx[b]))\n            # If partner_girl[g][d] == boy_idx[b] then partner[b][d] == girl_idx[g]\n            solver.add(Implies(partner_girl[g][d] == boy_idx[b], partner[b][d] == girl_idx[g]))\n\n# Each dance: all boys partner distinct girls\nfor d in dances:\n    solver.add(Distinct([partner[b][d] for b in boys]))\n\n# Each dance: all girls partner distinct boys\nfor d in dances:\n    solver.add(Distinct([partner_girl[g][d] for g in girls]))\n\n# Each dance has 3 pairs, each boy partners one girl, each girl partners one boy\n\n# Condition 1: Karl partners Sarah in either dance 1 or dance 2\nkarl_sarah_d1 = partner['Karl'][1] == girl_idx['Sarah']\nkarl_sarah_d2 = partner['Karl'][2] == girl_idx['Sarah']\nsolver.add(Or(karl_sarah_d1, karl_sarah_d2))\n\n# Condition 2: Whoever partners Rita in dance 2 must partner Sarah in dance 3\n# Let x be the boy who partners Rita in dance 2\n# That boy must partner Sarah in dance 3\nfor b in boys:\n    cond = Implies(partner[b][2] == girl_idx['Rita'], partner[b][3] == girl_idx['Sarah'])\n    solver.add(cond)\n\n# Condition 3: No two children can partner each other in more than one dance\n# For each boy-girl pair, count dances where they partner; max 1\nfor b in boys:\n    for g in girls:\n        count = Sum([If(partner[b][d] == girl_idx[g], 1, 0) for d in dances])\n        solver.add(count <= 1)\n\n# Given: Miguel partners Rita in dance 2\nsolver.add(partner['Miguel'][2] == girl_idx['Rita'])\n\n# OPTION CHECKING\noptions = {\n    'A': partner['Karl'][1] == girl_idx['Tura'],\n    'B': partner['Luis'][2] == girl_idx['Sarah'],\n    'C': partner['Luis'][3] == girl_idx['Sarah'],\n    'D': partner['Miguel'][1] == girl_idx['Sarah'],\n    'E': partner['Miguel'][3] == girl_idx['Tura'],\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Six cities are located within the numbered areas as follows: Within the six-city area there are exactly four hospitals, two jails, and two universities. These eight institutions are located as follows: No institution is in more than one of the cities. None of the cities contains more than one jail, and none contains more than one university. None of the cities contains both a jail and a university. Each jail is located in a city that contains at least one hospital. The universities are located in two cities that do not share a common boundary. City 3 contains a university, and city 6 contains a jail.\n\nWhich one of the following could be true?\n\nOptions:\n(A) City 1 contains exactly one hospital.\n(B) City 1 contains exactly one university.\n(C) City 2 contains exactly one jail.\n(D) City 5 contains exactly one university.\n(E) City 6 contains exactly one university.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncities = [1, 2, 3, 4, 5, 6]\n\n# Number of institutions\nnum_hospitals = 4\nnum_jails = 2\nnum_universities = 2\n\n# Variables for each city: number of hospitals, jails, universities\nH = {c: Int(f'H_{c}') for c in cities}\nJ = {c: Int(f'J_{c}') for c in cities}\nU = {c: Int(f'U_{c}') for c in cities}\n\n# Adjacency map (common boundaries)\n# From the problem context, we assume adjacency as follows:\n# City 1 adjacent to 2 and 4\n# City 2 adjacent to 1,3,5\n# City 3 adjacent to 2,6\n# City 4 adjacent to 1,5\n# City 5 adjacent to 2,4,6\n# City 6 adjacent to 3,5\nadjacency = {\n    1: [2,4],\n    2: [1,3,5],\n    3: [2,6],\n    4: [1,5],\n    5: [2,4,6],\n    6: [3,5]\n}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each institution count per city is 0 or 1 for jails and universities (no more than one jail or university per city)\nfor c in cities:\n    solver.add(And(H[c] >= 0, H[c] <= 4))  # Hospitals can be 0 or more, max 4 total\n    solver.add(And(J[c] >= 0, J[c] <= 1))\n    solver.add(And(U[c] >= 0, U[c] <= 1))\n\n# Total hospitals = 4\nsolver.add(Sum([H[c] for c in cities]) == num_hospitals)\n\n# Total jails = 2\nsolver.add(Sum([J[c] for c in cities]) == num_jails)\n\n# Total universities = 2\nsolver.add(Sum([U[c] for c in cities]) == num_universities)\n\n# No city contains both a jail and a university\nfor c in cities:\n    solver.add(J[c] + U[c] <= 1)\n\n# Each jail is located in a city that contains at least one hospital\nfor c in cities:\n    # If jail in city c, then hospital in city c (H[c]>=1)\n    solver.add(Implies(J[c] == 1, H[c] >= 1))\n\n# The universities are located in two cities that do not share a common boundary\n# Find all pairs of cities that both have U=1 and are adjacent, forbid that\nfor c1 in cities:\n    for c2 in adjacency.get(c1, []):\n        # To avoid double constraints, only consider c1 < c2\n        if c1 < c2:\n            solver.add(Or(U[c1] == 0, U[c2] == 0))\n\n# City 3 contains a university\nsolver.add(U[3] == 1)\n\n# City 6 contains a jail\nsolver.add(J[6] == 1)\n\n# OPTION CHECKING\n\noptions = {\n    'A': H[1] == 1,\n    'B': U[1] == 1,\n    'C': J[2] == 1,\n    'D': U[5] == 1,\n    'E': U[6] == 1,\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Six cities are located within the numbered areas as follows: Within the six-city area there are exactly four hospitals, two jails, and two universities. These eight institutions are located as follows: No institution is in more than one of the cities. None of the cities contains more than one jail, and none contains more than one university. None of the cities contains both a jail and a university. Each jail is located in a city that contains at least one hospital. The universities are located in two cities that do not share a common boundary. City 3 contains a university, and city 6 contains a jail.\n\nIf one of the cities contains exactly two hospitals and exactly one university, then which one of the following lists three cities that might, among them, contain no hospital?\n\nOptions:\n(A) 1, 3, 5\n(B) 1, 4, 5\n(C) 2, 3, 5\n(D) 2, 4, 6\n(E) 4, 5, 6",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Cities are numbered 1 to 6\ncities = [1, 2, 3, 4, 5, 6]\n\n# Number of institutions\ntotal_hospitals = 4\ntotal_jails = 2\ntotal_universities = 2\n\n# For each city, define number of hospitals, jails, universities\nhospital = {c: Int(f'hospital_{c}') for c in cities}\njail = {c: Int(f'jail_{c}') for c in cities}\nuniversity = {c: Int(f'university_{c}') for c in cities}\n\n# Adjacency (common boundary) between cities\n# We define adjacency based on typical city numbering logic or given info.\n# Since adjacency is needed only for university constraint, we need to know which cities share boundaries.\n# The problem states: \"The universities are located in two cities that do not share a common boundary.\"\n# The puzzle does not explicitly give adjacency, so we must assume or define adjacency.\n# Let's assume adjacency based on city numbering and typical layout:\n# Adjacency pairs (undirected):\nadjacency_pairs = [\n    (1, 2), (1, 4),\n    (2, 3), (2, 5),\n    (3, 6),\n    (4, 5),\n    (5, 6)\n]\n\n# Create adjacency dictionary for quick lookup\nadjacency = {c: set() for c in cities}\nfor a, b in adjacency_pairs:\n    adjacency[a].add(b)\n    adjacency[b].add(a)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each city has 0 or more hospitals (integer), jails (0 or 1), universities (0 or 1)\nfor c in cities:\n    solver.add(hospital[c] >= 0)\n    solver.add(hospital[c] <= total_hospitals)  # max 4 hospitals total, so per city max 4\n    solver.add(jail[c] >= 0, jail[c] <= 1)  # no more than one jail per city\n    solver.add(university[c] >= 0, university[c] <= 1)  # no more than one university per city\n\n# Total institutions count\nsolver.add(Sum([hospital[c] for c in cities]) == total_hospitals)\nsolver.add(Sum([jail[c] for c in cities]) == total_jails)\nsolver.add(Sum([university[c] for c in cities]) == total_universities)\n\n# No city contains both a jail and a university\nfor c in cities:\n    solver.add(Or(jail[c] == 0, university[c] == 0))\n\n# Each jail is located in a city that contains at least one hospital\nfor c in cities:\n    # if jail[c] == 1 then hospital[c] >= 1\n    solver.add(Implies(jail[c] == 1, hospital[c] >= 1))\n\n# City 3 contains a university\nsolver.add(university[3] == 1)\n\n# City 6 contains a jail\nsolver.add(jail[6] == 1)\n\n# The universities are located in two cities that do not share a common boundary\n# The two university cities: city 3 and another city u2 != 3\n# university[3] == 1, so sum of universities is 2, so one other city has university == 1\nother_university_cities = [c for c in cities if c != 3]\n# We enforce that the other university city does not share boundary with city 3\n# We add a constraint: university[c] == 1 for exactly one c in other_university_cities and that c not adjacent to 3\n# First, sum of university in other_university_cities == 1\nsolver.add(Sum([university[c] for c in other_university_cities]) == 1)\n# The other university city cannot be adjacent to city 3\nfor c in other_university_cities:\n    if c in adjacency[3]:\n        # If c adjacent to 3, university[c] == 0\n        solver.add(university[c] == 0)\n\n# None of the cities contains more than one jail, already enforced (jail[c] <= 1)\n# None of the cities contains more than one university, already enforced (university[c] <= 1)\n# No institution is in more than one city (implied by separate variables per city)\n\n# If one of the cities contains exactly two hospitals and exactly one university,\n# then which one of the following lists three cities might, among them, contain no hospital?\n\n# We will check each option by adding the constraint:\n# There exists a city c with hospital[c] == 2 and university[c] == 1\n# and the three cities in the option have hospital sum == 0 (no hospital in these three cities)\n# If this is satisfiable, that option might be correct.\n\noptions = {\n    'A': [1, 3, 5],\n    'B': [1, 4, 5],\n    'C': [2, 3, 5],\n    'D': [2, 4, 6],\n    'E': [4, 5, 6]\n}\n\nfor opt_letter, opt_cities in options.items():\n    solver.push()\n    # Add constraint: there exists a city with hospital == 2 and university == 1\n    city_with_2h_1u = Int('city_with_2h_1u')\n    solver.add(Or([city_with_2h_1u == c for c in cities]))\n    for c in cities:\n        is_chosen = city_with_2h_1u == c\n        # hospital[c] == 2 and university[c] == 1 if chosen, else no constraint\n        solver.add(Implies(is_chosen, hospital[c] == 2))\n        solver.add(Implies(is_chosen, university[c] == 1))\n    # Exactly one city satisfies this (enforced by city_with_2h_1u variable)\n\n    # The three cities in the option might contain no hospital\n    # So sum of hospital in these three cities == 0\n    solver.add(Sum([hospital[c] for c in opt_cities]) == 0)\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "On the basis of an examination, nine students—Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, and Nick—are each placed in one of three classes. The three highest scorers are placed in the level 1 class; the three lowest scorers are placed in the level 3 class. The remaining three are placed in the level 2 class. Each class has exactly three students. Ida scores higher than Glen. Glen scores higher than both Jan and Kathy. Jan scores higher than Mike. Mike scores higher than Hilary. Hilary scores higher than Nick. Kathy scores higher than both Fred and Laura.\n\nHow many different combinations of students could form the level 1 class?\n\nOptions:\n(A) one\n(B) two\n(C) three\n(D) four\n(E) six",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Fred', 'Glen', 'Hilary', 'Ida', 'Jan', 'Kathy', 'Laura', 'Mike', 'Nick']\nstudent_indices = {s: i for i, s in enumerate(students)}\n\n# Create a Z3 Int variable for each student representing their rank (1=highest, 9=lowest)\nrank = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank is between 1 and 9\nfor s in students:\n    solver.add(And(rank[s] >= 1, rank[s] <= 9))\n\n# All ranks are distinct\nsolver.add(Distinct([rank[s] for s in students]))\n\n# Ranking constraints from the problem\n\n# Ida scores higher than Glen: Ida's rank < Glen's rank\nsolver.add(rank['Ida'] < rank['Glen'])\n\n# Glen scores higher than both Jan and Kathy\nsolver.add(rank['Glen'] < rank['Jan'])\nsolver.add(rank['Glen'] < rank['Kathy'])\n\n# Jan scores higher than Mike\nsolver.add(rank['Jan'] < rank['Mike'])\n\n# Mike scores higher than Hilary\nsolver.add(rank['Mike'] < rank['Hilary'])\n\n# Hilary scores higher than Nick\nsolver.add(rank['Hilary'] < rank['Nick'])\n\n# Kathy scores higher than both Fred and Laura\nsolver.add(rank['Kathy'] < rank['Fred'])\nsolver.add(rank['Kathy'] < rank['Laura'])\n\n# Level 1 class: ranks 1,2,3 (top three scorers)\n# Level 2 class: ranks 4,5,6\n# Level 3 class: ranks 7,8,9\n\n# OPTION CHECKING\n\n# We want to find how many different combinations of students could form the level 1 class.\n# So we enumerate all possible level 1 classes that satisfy the constraints.\n\n# We will find all possible sets of students with ranks in {1,2,3}\n# Because rank variables are integers with constraints, we can iterate over models.\n\n# To do this, we find all solutions, collect the level 1 students sets, and count unique ones.\n\nlevel1_combinations = set()\n\nwhile solver.check() == sat:\n    model = solver.model()\n    # Extract rank values\n    rank_values = {s: model.eval(rank[s]).as_long() for s in students}\n    # Find students with rank in {1,2,3}\n    level1_students = tuple(sorted([s for s in students if rank_values[s] in [1,2,3]]))\n    level1_combinations.add(level1_students)\n\n    # Add blocking clause to find different solutions\n    block = []\n    for s in students:\n        block.append(rank[s] != rank_values[s])\n    solver.add(Or(block))\n\n# Count how many different combinations of level 1 class students\ncount = len(level1_combinations)\n\n# Map count to answer options\n# Options:\n# (A) one\n# (B) two\n# (C) three\n# (D) four\n# (E) six\n\noption_map = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 6: 'E'}\n\n# Print the letter of the correct answer option\nprint(f\"'{option_map[count]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "On the basis of an examination, nine students—Fred, Glen, Hilary, Ida, Jan, Kathy, Laura, Mike, and Nick—are each placed in one of three classes. The three highest scorers are placed in the level 1 class; the three lowest scorers are placed in the level 3 class. The remaining three are placed in the level 2 class. Each class has exactly three students. Ida scores higher than Glen. Glen scores higher than both Jan and Kathy. Jan scores higher than Mike. Mike scores higher than Hilary. Hilary scores higher than Nick. Kathy scores higher than both Fred and Laura.\n\nWhich one of the following pairs of students cannot be in the same class as Fred?\n\nOptions:\n(A) Hilary and Nick\n(B) Jan and Laura\n(C) Kathy and Laura\n(D) Jan and Mike\n(E) Laura and Mike",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Fred', 'Glen', 'Hilary', 'Ida', 'Jan', 'Kathy', 'Laura', 'Mike', 'Nick']\nnum_students = len(students)\nlevels = [1, 2, 3]  # Class levels\n\n# Create Z3 Int variables for each student representing their class level (1, 2, or 3)\nclass_level = {s: Int(s) for s in students}\n\n# Create Z3 Int variables for each student representing their score rank (1 highest, 9 lowest)\nrank = {s: Int(s + '_rank') for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each class level is between 1 and 3\nfor s in students:\n    solver.add(And(class_level[s] >= 1, class_level[s] <= 3))\n    solver.add(And(rank[s] >= 1, rank[s] <= 9))\n\n# Exactly three students per class\nfor lvl in levels:\n    count_in_level = Sum([If(class_level[s] == lvl, 1, 0) for s in students])\n    solver.add(count_in_level == 3)\n\n# Ranks are distinct (no ties)\nsolver.add(Distinct([rank[s] for s in students]))\n\n# Class level corresponds to rank: \n# Highest three scorers (rank 1,2,3) in level 1\n# Middle three scorers (rank 4,5,6) in level 2\n# Lowest three scorers (rank 7,8,9) in level 3\nfor s in students:\n    solver.add(If(And(rank[s] >= 1, rank[s] <= 3), class_level[s] == 1,\n              If(And(rank[s] >= 4, rank[s] <= 6), class_level[s] == 2,\n                 class_level[s] == 3)))\n\n# Ranking constraints from the problem\n# Ida > Glen\nsolver.add(rank['Ida'] < rank['Glen'])\n\n# Glen > Jan and Glen > Kathy\nsolver.add(rank['Glen'] < rank['Jan'])\nsolver.add(rank['Glen'] < rank['Kathy'])\n\n# Jan > Mike\nsolver.add(rank['Jan'] < rank['Mike'])\n\n# Mike > Hilary\nsolver.add(rank['Mike'] < rank['Hilary'])\n\n# Hilary > Nick\nsolver.add(rank['Hilary'] < rank['Nick'])\n\n# Kathy > Fred and Kathy > Laura\nsolver.add(rank['Kathy'] < rank['Fred'])\nsolver.add(rank['Kathy'] < rank['Laura'])\n\n# OPTION CHECKING\n# Options:\n# (A) Hilary and Nick\n# (B) Jan and Laura\n# (C) Kathy and Laura\n# (D) Jan and Mike\n# (E) Laura and Mike\n\noptions = {\n    'A': ['Hilary', 'Nick'],\n    'B': ['Jan', 'Laura'],\n    'C': ['Kathy', 'Laura'],\n    'D': ['Jan', 'Mike'],\n    'E': ['Laura', 'Mike']\n}\n\nfor letter, pair in options.items():\n    solver.push()\n    # Add constraint that Fred and both students in pair are in the same class\n    solver.add(class_level['Fred'] == class_level[pair[0]])\n    solver.add(class_level['Fred'] == class_level[pair[1]])\n    # Check satisfiability\n    if solver.check() == sat:\n        # If satisfiable, this pair can be in same class as Fred, so not the answer\n        solver.pop()\n    else:\n        # If unsat, this pair cannot be in the same class as Fred, so print the letter\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.\n\nIf Lena reviews Seasonings, which one of the following must be true?\n\nOptions:\n(A) Hilda reviews Retreat.\n(B) Jackie reviews Seasonings.\n(C) Karl reviews Mystery.\n(D) Karl reviews Retreat.\n(E) Karl reviews Wolves.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nreviewers = ['Frank', 'George', 'Hilda', 'Jackie', 'Karl', 'Lena']\nmovies = ['Mystery', 'Retreat', 'Seasonings', 'Wolves']\n\n# Create Z3 Int variables for each reviewer representing the movie index they review\nreview = {r: Int(r) for r in reviewers}\n\nsolver = Solver()\n\n# Each reviewer reviews exactly one movie (values must be valid indices)\nfor r in reviewers:\n    solver.add(And(review[r] >= 0, review[r] < len(movies)))\n\n# Each movie is reviewed by at least one reviewer\nfor m in range(len(movies)):\n    at_least_one = Or([review[r] == m for r in reviewers])\n    solver.add(at_least_one)\n\n# Hilda reviews the same movie as Frank\nsolver.add(review['Hilda'] == review['Frank'])\n\n# Lena reviews the same movie as exactly one other reviewer\n# Count how many reviewers (excluding Lena) review the same movie as Lena\nsame_as_lena = [If(review[r] == review['Lena'], 1, 0) for r in reviewers if r != 'Lena']\nsolver.add(Sum(same_as_lena) == 1)\n\n# George reviews Mystery (index 0)\nsolver.add(review['George'] == movies.index('Mystery'))\n\n# Jackie reviews either Mystery or Wolves (indices 0 or 3)\nsolver.add(Or(review['Jackie'] == movies.index('Mystery'), review['Jackie'] == movies.index('Wolves')))\n\n# Hilda does not review Wolves (index 3)\nsolver.add(review['Hilda'] != movies.index('Wolves'))\n\n# Lena reviews Seasonings (index 2)\nsolver.add(review['Lena'] == movies.index('Seasonings'))\n\n# OPTION CHECKING\noptions = {\n    'A': review['Hilda'] == movies.index('Retreat'),\n    'B': review['Jackie'] == movies.index('Seasonings'),\n    'C': review['Karl'] == movies.index('Mystery'),\n    'D': review['Karl'] == movies.index('Retreat'),\n    'E': review['Karl'] == movies.index('Wolves'),\n}\n\nfor option_letter, option_constraint in options.items():\n    solver.push()\n    # Add negation of the option to check if it must be true\n    solver.add(Not(option_constraint))\n    if solver.check() == unsat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.\n\nIf Karl does not review Seasonings, which one of the following must be true?\n\nOptions:\n(A) Lena reviews Mystery.\n(B) Lena reviews Retreat.\n(C) Lena reviews Seasonings.\n(D) Frank and Hilda review Retreat.\n(E) Frank and Hilda review Seasonings.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nreviewers = ['Frank', 'George', 'Hilda', 'Jackie', 'Karl', 'Lena']\nmovies = ['Mystery', 'Retreat', 'Seasonings', 'Wolves']\n\n# Map movie names to indices for easy reference\nMystery = movies.index('Mystery')\nRetreat = movies.index('Retreat')\nSeasonings = movies.index('Seasonings')\nWolves = movies.index('Wolves')\n\n# Create Z3 Int variables for each reviewer representing the movie they review\nreview = {r: Int(r) for r in reviewers}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each reviewer reviews exactly one movie (valid index)\nfor r in reviewers:\n    solver.add(And(review[r] >= 0, review[r] < len(movies)))\n\n# Each movie is reviewed by at least one reviewer\nfor m in range(len(movies)):\n    solver.add(Or([review[r] == m for r in reviewers]))\n\n# Hilda reviews the same movie as Frank\nsolver.add(review['Hilda'] == review['Frank'])\n\n# Lena reviews the same movie as exactly one other reviewer\n# Count how many reviewers (other than Lena) review the same movie as Lena\nsame_as_lena = [If(review[r] == review['Lena'], 1, 0) for r in reviewers if r != 'Lena']\nsolver.add(Sum(same_as_lena) == 1)\n\n# George reviews Mystery\nsolver.add(review['George'] == Mystery)\n\n# Jackie reviews either Mystery or Wolves\nsolver.add(Or(review['Jackie'] == Mystery, review['Jackie'] == Wolves))\n\n# Hilda does not review Wolves\nsolver.add(review['Hilda'] != Wolves)\n\n# We add the condition for the question:\n# Karl does NOT review Seasonings\nsolver.add(review['Karl'] != Seasonings)\n\n# OPTION CHECKING\n# Define a function to check if an option must be true under the above constraints\ndef option_must_be_true(option_constraint):\n    s = Solver()\n    # Add all previous constraints\n    s.add(solver.assertions())\n    # Add negation of the option constraint to check if it can be false\n    s.add(Not(option_constraint))\n    # If unsat, then option_constraint must be true\n    return s.check() == unsat\n\n# (A) Lena reviews Mystery.\noptA = (review['Lena'] == Mystery)\nif option_must_be_true(optA):\n    print(\"'A'\")\n    exit()\n\n# (B) Lena reviews Retreat.\noptB = (review['Lena'] == Retreat)\nif option_must_be_true(optB):\n    print(\"'B'\")\n    exit()\n\n# (C) Lena reviews Seasonings.\noptC = (review['Lena'] == Seasonings)\nif option_must_be_true(optC):\n    print(\"'C'\")\n    exit()\n\n# (D) Frank and Hilda review Retreat.\noptD = And(review['Frank'] == Retreat, review['Hilda'] == Retreat)\nif option_must_be_true(optD):\n    print(\"'D'\")\n    exit()\n\n# (E) Frank and Hilda review Seasonings.\noptE = And(review['Frank'] == Seasonings, review['Hilda'] == Seasonings)\nif option_must_be_true(optE):\n    print(\"'E'\")\n    exit()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.\n\nWhich one of the following is a complete and accurate list of the movies each of which could be the movie that Lena reviews?\n\nOptions:\n(A) Mystery, Retreat\n(B) Retreat, Seasonings\n(C) Mystery, Seasonings, Wolves\n(D) Retreat, Seasonings, Wolves\n(E) Mystery, Retreat, Seasonings, Wolves",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nreviewers = ['Frank', 'George', 'Hilda', 'Jackie', 'Karl', 'Lena']\nmovies = ['Mystery', 'Retreat', 'Seasonings', 'Wolves']\n\n# Map movie names to indices\nmovie_idx = {m: i for i, m in enumerate(movies)}\n\n# Create Z3 Int variables for each reviewer representing the movie index they review\nreview = {r: Int(r) for r in reviewers}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each reviewer reviews exactly one movie\nfor r in reviewers:\n    solver.add(And(review[r] >= 0, review[r] < len(movies)))\n\n# Each movie is reviewed by at least one reviewer\nfor m_i in range(len(movies)):\n    movie_reviewed = [review[r] == m_i for r in reviewers]\n    solver.add(Or(movie_reviewed))\n\n# Hilda reviews the same movie as Frank\nsolver.add(review['Hilda'] == review['Frank'])\n\n# Lena reviews the same movie as exactly one other reviewer\n# Count how many reviewers (other than Lena) have the same movie as Lena\nsame_as_lena = [If(review[r] == review['Lena'], 1, 0) for r in reviewers if r != 'Lena']\nsolver.add(Sum(same_as_lena) == 1)\n\n# George reviews Mystery\nsolver.add(review['George'] == movie_idx['Mystery'])\n\n# Jackie reviews either Mystery or Wolves\nsolver.add(Or(review['Jackie'] == movie_idx['Mystery'], review['Jackie'] == movie_idx['Wolves']))\n\n# Hilda does not review Wolves\nsolver.add(review['Hilda'] != movie_idx['Wolves'])\n\n# OPTION CHECKING\n# We want to find the set of possible movies for Lena under all constraints\n# Then check which options match exactly that set\n\n# First, find all possible movies Lena can review by checking satisfiability with Lena fixed to each movie\npossible_lena_movies = []\nfor m_i in range(len(movies)):\n    solver.push()\n    solver.add(review['Lena'] == m_i)\n    if solver.check() == sat:\n        possible_lena_movies.append(m_i)\n    solver.pop()\n\n# Define options as sets of movie indices\noptions = [\n    {movie_idx['Mystery'], movie_idx['Retreat']},                         # A\n    {movie_idx['Retreat'], movie_idx['Seasonings']},                      # B\n    {movie_idx['Mystery'], movie_idx['Seasonings'], movie_idx['Wolves']}, # C\n    {movie_idx['Retreat'], movie_idx['Seasonings'], movie_idx['Wolves']}, # D\n    {movie_idx['Mystery'], movie_idx['Retreat'], movie_idx['Seasonings'], movie_idx['Wolves']} # E\n]\n\n# Check which option matches the possible movies exactly\nfor i, opt_set in enumerate(options):\n    if set(possible_lena_movies) == opt_set:\n        print(f\"'{chr(65 + i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.\n\nWhich one of the following can be true?\n\nOptions:\n(A) Frank and George review Mystery.\n(B) Frank and Lena review Wolves.\n(C) George and Jackie review Mystery.\n(D) Karl reviews Wolves and Lena reviews Mystery.\n(E) Lena reviews Retreat and Frank reviews Seasonings.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nreviewers = ['Frank', 'George', 'Hilda', 'Jackie', 'Karl', 'Lena']\nmovies = ['Mystery', 'Retreat', 'Seasonings', 'Wolves']\n\n# Create Z3 variables: one Int per reviewer indicating movie index\nreview = {r: Int(r) for r in reviewers}\n\n# Helper function: count how many reviewers review a given movie\ndef count_reviewers_for_movie(m):\n    return Sum([If(review[r] == m, 1, 0) for r in reviewers])\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each reviewer reviews exactly one movie (valid index)\nfor r in reviewers:\n    solver.add(And(review[r] >= 0, review[r] < len(movies)))\n\n# Each movie is reviewed by at least one reviewer\nfor m in range(len(movies)):\n    solver.add(count_reviewers_for_movie(m) >= 1)\n\n# Hilda reviews the same movie as Frank\nsolver.add(review['Hilda'] == review['Frank'])\n\n# Lena reviews the same movie as exactly one other reviewer\n# Count how many reviewers (other than Lena) review the same movie as Lena\nsame_as_lena_count = Sum([If(And(r != 'Lena', review[r] == review['Lena']), 1, 0) for r in reviewers])\nsolver.add(same_as_lena_count == 1)\n\n# George reviews Mystery\nsolver.add(review['George'] == movies.index('Mystery'))\n\n# Jackie reviews either Mystery or Wolves\njackie_cond = Or(review['Jackie'] == movies.index('Mystery'), review['Jackie'] == movies.index('Wolves'))\nsolver.add(jackie_cond)\n\n# Hilda does not review Wolves\nsolver.add(review['Hilda'] != movies.index('Wolves'))\n\n# OPTION CHECKING\n# Each option imposes some additional constraints; check which can be true\n\n# Option (A) Frank and George review Mystery.\noption_A = And(review['Frank'] == movies.index('Mystery'), review['George'] == movies.index('Mystery'))\n\n# Option (B) Frank and Lena review Wolves.\noption_B = And(review['Frank'] == movies.index('Wolves'), review['Lena'] == movies.index('Wolves'))\n\n# Option (C) George and Jackie review Mystery.\noption_C = And(review['George'] == movies.index('Mystery'), review['Jackie'] == movies.index('Mystery'))\n\n# Option (D) Karl reviews Wolves and Lena reviews Mystery.\noption_D = And(review['Karl'] == movies.index('Wolves'), review['Lena'] == movies.index('Mystery'))\n\n# Option (E) Lena reviews Retreat and Frank reviews Seasonings.\noption_E = And(review['Lena'] == movies.index('Retreat'), review['Frank'] == movies.index('Seasonings'))\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Six reviewers—Frank, George, Hilda, Jackie, Karl, and Lena—will review four movies—Mystery, Retreat, Seasonings, and Wolves—according to the following conditions: Each reviewer reviews exactly one movie, and each movie is reviewed by at least one of the six reviewers. Hilda reviews the same movie as Frank. Lena reviews the same movie as exactly one other reviewer. George reviews Mystery. Jackie reviews either Mystery or else Wolves. Hilda does not review Wolves.\n\nIf Karl reviews the same movie as exactly one other reviewer, which one of the following is a complete and accurate list of the movies any one of which could be the movie that these two reviewers review?\n\nOptions:\n(A) Mystery, Retreat\n(B) Mystery, Seasonings\n(C) Retreat, Seasonings\n(D) Mystery, Seasonings, Wolves\n(E) Retreat, Seasonings, Wolves",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nreviewers = ['Frank', 'George', 'Hilda', 'Jackie', 'Karl', 'Lena']\nmovies = ['Mystery', 'Retreat', 'Seasonings', 'Wolves']\n\n# Map reviewer names to Z3 Int variables representing movie indices\nreview = {r: Int(r) for r in reviewers}\n\n# Helper function to count how many reviewers review a given movie\ndef count_reviewers_for_movie(mov_idx):\n    return Sum([If(review[r] == mov_idx, 1, 0) for r in reviewers])\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each reviewer reviews exactly one movie (valid index)\nfor r in reviewers:\n    solver.add(And(review[r] >= 0, review[r] < len(movies)))\n\n# Each movie is reviewed by at least one reviewer\nfor m in range(len(movies)):\n    solver.add(count_reviewers_for_movie(m) >= 1)\n\n# Hilda reviews the same movie as Frank\nsolver.add(review['Hilda'] == review['Frank'])\n\n# Lena reviews the same movie as exactly one other reviewer\n# Count how many reviewers review the same movie as Lena (excluding Lena)\nsame_as_lena = Sum([If(And(review[r] == review['Lena'], r != 'Lena'), 1, 0) for r in reviewers])\nsolver.add(same_as_lena == 1)\n\n# George reviews Mystery\nsolver.add(review['George'] == movies.index('Mystery'))\n\n# Jackie reviews either Mystery or Wolves\nsolver.add(Or(review['Jackie'] == movies.index('Mystery'), review['Jackie'] == movies.index('Wolves')))\n\n# Hilda does not review Wolves\nsolver.add(review['Hilda'] != movies.index('Wolves'))\n\n# Karl reviews the same movie as exactly one other reviewer\n# Count how many reviewers review the same movie as Karl (excluding Karl)\nsame_as_karl = Sum([If(And(review[r] == review['Karl'], r != 'Karl'), 1, 0) for r in reviewers])\nsolver.add(same_as_karl == 1)\n\n# OPTION CHECKING\noptions = [\n    ['Mystery', 'Retreat'],                # A\n    ['Mystery', 'Seasonings'],             # B\n    ['Retreat', 'Seasonings'],             # C\n    ['Mystery', 'Seasonings', 'Wolves'],  # D\n    ['Retreat', 'Seasonings', 'Wolves']   # E\n]\n\n# We want to find which option is the complete and accurate list of movies that Karl and the other reviewer who shares his movie could be reviewing.\n\nfor i, option_movies in enumerate(options):\n    solver.push()\n    # Add constraint: Karl's movie is in option_movies\n    valid_movies_indices = [movies.index(mov) for mov in option_movies]\n    solver.add(Or([review['Karl'] == idx for idx in valid_movies_indices]))\n    # Check satisfiability\n    if solver.check() == sat:\n        # Now check if any movie not in option_movies can be Karl's movie under constraints\n        solver.pop()\n        solver.push()\n        # Karl's movie is NOT in option_movies\n        solver.add(Not(Or([review['Karl'] == idx for idx in valid_movies_indices])))\n        if solver.check() == unsat:\n            # If no solution exists outside option_movies, then option_movies is complete and accurate\n            print(f\"'{chr(65+i)}'\")\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "In a game, \"words\" (real or nonsensical) consist of any combination of at least four letters of the English alphabet. Any \"sentence\" consists of exactly five words and satisfies the following conditions: The five words are written from left to right on a single line in alphabetical order. The sentence is started by any word, and each successive word is formed by applying exactly one of three operations to the word immediately to its left: delete one letter; add one letter; replace one letter with another letter. At most three of the five words begin with the same letter as one another. Except for the leftmost word, each word is formed by a different operation from that which formed the word immediately to its left.\n\nIf the first word in a sentence consists of nine letters, then the minimum number of letters that the fourth word can contain is\n\nOptions:\n(A) four\n(B) five\n(C) six\n(D) seven\n(E) eight",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Operations: 0 = delete, 1 = add, 2 = replace\nops = [0, 1, 2]\n\n# Words: w0 to w4 - lengths of words (integers)\nw_lengths = [Int(f'w{i}_len') for i in range(5)]\n\n# Operations used to form words w1 to w4 from previous words\nw_ops = [Int(f'op{i}') for i in range(1, 5)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Length constraints for words (at least 4 letters)\nfor length in w_lengths:\n    solver.add(length >= 4)\n\n# 2. First word length is 9\nsolver.add(w_lengths[0] == 9)\n\n# 3. Each operation must be one of {0,1,2}\nfor op in w_ops:\n    solver.add(Or([op == o for o in ops]))\n\n# 4. Each successive word formed by exactly one operation applied to previous word:\n#    length relations depending on operation:\n#    - delete: length decreases by 1\n#    - add: length increases by 1\n#    - replace: length stays the same\nfor i in range(1, 5):\n    length_before = w_lengths[i-1]\n    length_after = w_lengths[i]\n    op = w_ops[i-1]\n    # Encode length_after depending on op\n    # Using If for conditional constraints\n    solver.add(\n        If(op == 0, length_after == length_before - 1,\n        If(op == 1, length_after == length_before + 1,\n        length_after == length_before))\n    )\n\n# 5. The operations for forming words w2 to w4 must differ from the immediately previous operation\nfor i in range(2, 5):\n    solver.add(w_ops[i-1] != w_ops[i-2])\n\n# 6. Words are in alphabetical order from left to right\n# Since words themselves are unknown, but the problem states alphabetical order,\n# and words differ by exactly one operation on the previous word,\n# the problem is about lengths and operations only.\n# We do not model actual words or letters, so we do not add constraints here for alphabetical order\n# because it is guaranteed by the problem statement and operations.\n\n# 7. At most three of the five words begin with the same letter\n# We do not know actual words or letters, so this constraint is not modeled explicitly.\n# The problem is about lengths and operations only, so we ignore this constraint here.\n\n# OBJECTIVE: Find the minimum possible length of the 4th word (w3, zero-based indexing)\n# We want to minimize w_lengths[3] subject to constraints.\n\n# OPTION CHECKING: The question asks for minimum length of the 4th word (index 3)\n# Options: (A)4, (B)5, (C)6, (D)7, (E)8\n\noptions = [4, 5, 6, 7, 8]\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\n# For each option, check if w_lengths[3] can be <= option value\nfor i, val in enumerate(options):\n    solver.push()\n    solver.add(w_lengths[3] <= val)\n    if solver.check() == sat:\n        # Check if smaller value is possible\n        # To confirm minimality, check if smaller than val is possible\n        solver.pop()\n        solver.push()\n        solver.add(w_lengths[3] < val)\n        if solver.check() == unsat:\n            # val is minimal possible length for w4\n            print(f\"'{option_letters[i]}'\")\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A soloist will play six different guitar concertos, exactly one each Sunday for six consecutive weeks. Two concertos will be selected from among three concertos by Giuliani—H, J, and K; two from among four concertos by Rodrigo—M, N, O, and P; and two from among three concertos by Vivaldi—X, Y, and Z. The following conditions apply without exception: If N is selected, then J is also selected. If M is selected, then neither J nor O can be selected. If X is selected, then neither Z nor P can be selected. If both J and O are selected, then J is played at some time before O. X cannot be played on the fifth Sunday unless one of Rodrigo's concertos is played on the first Sunday.\n\nWhich one of the following is an acceptable selection of concertos that the soloist could play on the first through the sixth Sunday?\n\nOptions:\n(A) H Z M N Y K\n(B) K J Y O Z N\n(C) K Y P J Z M\n(D) P Y J H X O\n(E) X N K O J Z",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Concertos by composer\ngiuliani = ['H', 'J', 'K']\nrodrigo = ['M', 'N', 'O', 'P']\nvivaldi = ['X', 'Y', 'Z']\n\nall_concertos = giuliani + rodrigo + vivaldi\n\n# Map each concerto to a unique integer\nconcerto_indices = {c: i for i, c in enumerate(all_concertos)}\n\n# Variables: concertos played on Sundays 1 through 6\n# Each variable is an Int representing the concerto index\nconcertos = [Int(f'c{i+1}') for i in range(6)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each concerto is unique (no repeats)\nsolver.add(Distinct(concertos))\n\n# 2) Exactly two Giuliani concertos selected among the 6\n# Count how many Giuliani concertos are selected\ngiuliani_indices = [concerto_indices[c] for c in giuliani]\ngiuliani_selected = [If(Or([concertos[i] == idx for idx in giuliani_indices]), 1, 0) for i in range(6)]\n# Actually, the above is per position, so sum of these 6 values counts how many positions have Giuliani concertos\n# But this counts multiple times if multiple Giuliani concertos appear\n# We want the total number of Giuliani concertos selected is 2\n# So sum of (concertos[i] in giuliani) for i in [0..5] == 2\ngiuliani_count = Sum([If(Or([concertos[i] == idx for idx in giuliani_indices]), 1, 0) for i in range(6)])\nsolver.add(giuliani_count == 2)\n\n# 3) Exactly two Rodrigo concertos selected among the 6\nrodrigo_indices = [concerto_indices[c] for c in rodrigo]\nrodrigo_count = Sum([If(Or([concertos[i] == idx for idx in rodrigo_indices]), 1, 0) for i in range(6)])\nsolver.add(rodrigo_count == 2)\n\n# 4) Exactly two Vivaldi concertos selected among the 6\nvivaldi_indices = [concerto_indices[c] for c in vivaldi]\nvivaldi_count = Sum([If(Or([concertos[i] == idx for idx in vivaldi_indices]), 1, 0) for i in range(6)])\nsolver.add(vivaldi_count == 2)\n\n# 5) Each concerto played is from the all_concertos list\nfor i in range(6):\n    solver.add(And(concertos[i] >= 0, concertos[i] < len(all_concertos)))\n\n# 6) Conditional constraints:\n\n# If N is selected, then J is also selected.\n# N index:\nN_idx = concerto_indices['N']\nJ_idx = concerto_indices['J']\nN_selected = Or([concertos[i] == N_idx for i in range(6)])\nJ_selected = Or([concertos[i] == J_idx for i in range(6)])\nsolver.add(Implies(N_selected, J_selected))\n\n# If M is selected, then neither J nor O can be selected.\nM_idx = concerto_indices['M']\nO_idx = concerto_indices['O']\nM_selected = Or([concertos[i] == M_idx for i in range(6)])\nO_selected = Or([concertos[i] == O_idx for i in range(6)])\nsolver.add(Implies(M_selected, And(Not(J_selected), Not(O_selected))))\n\n# If X is selected, then neither Z nor P can be selected.\nX_idx = concerto_indices['X']\nZ_idx = concerto_indices['Z']\nP_idx = concerto_indices['P']\nX_selected = Or([concertos[i] == X_idx for i in range(6)])\nZ_selected = Or([concertos[i] == Z_idx for i in range(6)])\nP_selected = Or([concertos[i] == P_idx for i in range(6)])\nsolver.add(Implies(X_selected, And(Not(Z_selected), Not(P_selected))))\n\n# If both J and O are selected, then J is played before O.\n# Find positions of J and O if both selected\n# We can express: If J_selected and O_selected then exists i,j with i<j, concertos[i]==J_idx and concertos[j]==O_idx\n# Implement by checking positions\npositions_J = [If(concertos[i] == J_idx, i, -1) for i in range(6)]\npositions_O = [If(concertos[i] == O_idx, i, -1) for i in range(6)]\n\n# Function to get index of J and O (only one each because distinct concertos)\n# The position of J is the max of positions_J (only one valid >=0)\npos_J = Int('pos_J')\npos_O = Int('pos_O')\nsolver.add(Or([concertos[i] == J_idx for i in range(6)]) == J_selected)\nsolver.add(Or([concertos[i] == O_idx for i in range(6)]) == O_selected)\n\n# pos_J is the index where concertos[pos_J] == J_idx\nsolver.add(Or([pos_J == i for i in range(6)]))\nfor i in range(6):\n    solver.add(Implies(pos_J == i, concertos[i] == J_idx))\n\n# pos_O is the index where concertos[pos_O] == O_idx\nsolver.add(Or([pos_O == i for i in range(6)]))\nfor i in range(6):\n    solver.add(Implies(pos_O == i, concertos[i] == O_idx))\n\n# If both J and O selected, pos_J < pos_O\nsolver.add(Implies(And(J_selected, O_selected), pos_J < pos_O))\n\n# X cannot be played on the fifth Sunday unless one of Rodrigo's concertos is played on the first Sunday.\n# Sunday 5 is concertos[4], Sunday 1 is concertos[0]\nsolver.add(Implies(concertos[4] == X_idx, Or([concertos[0] == idx for idx in rodrigo_indices])))\n\n# OPTION CHECKING\noptions = {\n    'A': ['H', 'Z', 'M', 'N', 'Y', 'K'],\n    'B': ['K', 'J', 'Y', 'O', 'Z', 'N'],\n    'C': ['K', 'Y', 'P', 'J', 'Z', 'M'],\n    'D': ['P', 'Y', 'J', 'H', 'X', 'O'],\n    'E': ['X', 'N', 'K', 'O', 'J', 'Z'],\n}\n\nfor letter, selection in options.items():\n    solver.push()\n    # Add constraints that concertos on each Sunday equal the selected concertos\n    for i in range(6):\n        solver.add(concertos[i] == concerto_indices[selection[i]])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A soloist will play six different guitar concertos, exactly one each Sunday for six consecutive weeks. Two concertos will be selected from among three concertos by Giuliani—H, J, and K; two from among four concertos by Rodrigo—M, N, O, and P; and two from among three concertos by Vivaldi—X, Y, and Z. The following conditions apply without exception: If N is selected, then J is also selected. If M is selected, then neither J nor O can be selected. If X is selected, then neither Z nor P can be selected. If both J and O are selected, then J is played at some time before O. X cannot be played on the fifth Sunday unless one of Rodrigo's concertos is played on the first Sunday.\n\nIf the six concertos to be played are J, K, N, O, Y, and Z and if N is to be played on the first Sunday, then which one of the following concertos CANNOT be played on the second Sunday?\n\nOptions:\n(A) J\n(B) K\n(C) O\n(D) Y\n(E) Z",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Concertos\ngiuliani = ['H', 'J', 'K']\nrodrigo = ['M', 'N', 'O', 'P']\nvivaldi = ['X', 'Y', 'Z']\n\nall_concertos = giuliani + rodrigo + vivaldi\n\n# Selected concertos for the problem\nselected_concertos = ['J', 'K', 'N', 'O', 'Y', 'Z']\n\n# Map concertos to indices for Z3\nconc_indices = {c: i for i, c in enumerate(selected_concertos)}\n\n# Variables: six Sundays, each assigned a concerto index from selected_concertos\nSundays = [Int(f'Sunday_{i+1}') for i in range(6)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each Sunday is assigned a concerto from selected_concertos\nfor s in Sundays:\n    solver.add(And(s >= 0, s < len(selected_concertos)))\n\n# 2. Each concerto is played exactly once (all distinct)\nsolver.add(Distinct(Sundays))\n\n# 3. The six concertos are exactly J, K, N, O, Y, Z\n# Already enforced by distinctness and domain\n\n# 4. N is played on the first Sunday\nsolver.add(Sundays[0] == conc_indices['N'])\n\n# 5. Conditions from the problem applied to selected concertos:\n\n# If N is selected, then J is also selected.\n# Given N and J are both selected, this is true, no constraint needed here.\n\n# If M is selected, then neither J nor O can be selected.\n# M is not selected, so no constraint.\n\n# If X is selected, then neither Z nor P can be selected.\n# X and P not selected, no constraint.\n\n# If both J and O are selected, then J is played before O.\n# Both J and O are selected, so we enforce order.\n# Find indices of J and O in Sundays\nidx_J = Int('idx_J')\nidx_O = Int('idx_O')\nfor i in range(6):\n    solver.add(If(Sundays[i] == conc_indices['J'], idx_J == i, True))\n    solver.add(If(Sundays[i] == conc_indices['O'], idx_O == i, True))\nsolver.add(idx_J < idx_O)\n\n# X cannot be played on the fifth Sunday unless one of Rodrigo's concertos is played on the first Sunday.\n# X is not selected, so no constraint.\n\n# OPTION CHECKING\noptions = ['J', 'K', 'O', 'Y', 'Z']\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraint: option played on second Sunday (index 1)\n    solver.add(Sundays[1] == conc_indices[option])\n    check_result = solver.check()\n    if check_result == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A soloist will play six different guitar concertos, exactly one each Sunday for six consecutive weeks. Two concertos will be selected from among three concertos by Giuliani—H, J, and K; two from among four concertos by Rodrigo—M, N, O, and P; and two from among three concertos by Vivaldi—X, Y, and Z. The following conditions apply without exception: If N is selected, then J is also selected. If M is selected, then neither J nor O can be selected. If X is selected, then neither Z nor P can be selected. If both J and O are selected, then J is played at some time before O. X cannot be played on the fifth Sunday unless one of Rodrigo's concertos is played on the first Sunday.\n\nWhich one of the following is a concerto that must be selected?\n\nOptions:\n(A) J\n(B) K\n(C) O\n(D) Y\n(E) Z",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Concertos by composer\nGiuliani = ['H', 'J', 'K']\nRodrigo = ['M', 'N', 'O', 'P']\nVivaldi = ['X', 'Y', 'Z']\n\n# All concertos\nconcertos = Giuliani + Rodrigo + Vivaldi  # ['H','J','K','M','N','O','P','X','Y','Z']\n\n# Map concerto to index\nconcerto_index = {c: i for i, c in enumerate(concertos)}\n\n# Variables: selected[c] = Bool indicating if concerto c is selected\nselected = {c: Bool(c) for c in concertos}\n\n# Variables: position[c] = Int indicating the Sunday (1 to 6) concerto c is played if selected\n# If not selected, position is irrelevant but must be distinct among selected\nposition = {c: Int('pos_'+c) for c in concertos}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Exactly six concertos are selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in concertos]) == 6)\n\n# 2. Exactly two concertos from Giuliani selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in Giuliani]) == 2)\n\n# 3. Exactly two concertos from Rodrigo selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in Rodrigo]) == 2)\n\n# 4. Exactly two concertos from Vivaldi selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in Vivaldi]) == 2)\n\n# 5. Positions for selected concertos are in 1..6\nfor c in concertos:\n    # If selected, position in 1..6\n    solver.add(Implies(selected[c], And(position[c] >= 1, position[c] <= 6)))\n    # If not selected, position can be any int (no restriction needed)\n    # But to avoid conflicts, we can constrain positions of non-selected to be out of range (e.g., 0)\n    solver.add(Implies(Not(selected[c]), position[c] == 0))\n\n# 6. Positions of selected concertos are distinct\nselected_positions = [position[c] for c in concertos if True]  # all positions\n# But only positions of selected concertos count for distinctness\n# We'll add a constraint that positions of selected concertos are distinct ignoring non-selected (positions=0)\n# So we collect positions of selected concertos\nselected_pos_vars = []\nfor c in concertos:\n    # Create an int var for position if selected, else 0 (already done)\n    selected_pos_vars.append(position[c])\n# To enforce distinctness only among selected, we create a list of positions of selected concertos and enforce distinctness\n# We do this by collecting positions of selected concertos only\n# So we will create a list of positions of selected concertos, and constrain Distinct on them\n# But Z3 Distinct requires fixed-length list, so we will use a trick:\n# Create a list of all positions, and add constraints that if two concertos are selected, their positions differ\nfor i in range(len(concertos)):\n    for j in range(i+1, len(concertos)):\n        c1 = concertos[i]\n        c2 = concertos[j]\n        # If both selected, positions differ\n        solver.add(Implies(And(selected[c1], selected[c2]), position[c1] != position[c2]))\n\n# 7. If N is selected, then J is also selected\nsolver.add(Implies(selected['N'], selected['J']))\n\n# 8. If M is selected, then neither J nor O can be selected\nsolver.add(Implies(selected['M'], And(Not(selected['J']), Not(selected['O']))))\n\n# 9. If X is selected, then neither Z nor P can be selected\nsolver.add(Implies(selected['X'], And(Not(selected['Z']), Not(selected['P']))))\n\n# 10. If both J and O are selected, then J is played before O\nsolver.add(Implies(And(selected['J'], selected['O']), position['J'] < position['O']))\n\n# 11. X cannot be played on the fifth Sunday unless one of Rodrigo's concertos is played on the first Sunday.\n# If X is played at position 5, then exists r in Rodrigo with position 1\n# This is: If position[X] == 5 then (Or selected Rodrigo concerto at position 1)\nrodigo_at_1 = Or([And(selected[r], position[r] == 1) for r in Rodrigo])\nsolver.add(Implies(position['X'] == 5, rodigo_at_1))\n\n# OPTION CHECKING\n\noptions = ['J', 'K', 'O', 'Y', 'Z']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that the option concerto is NOT selected (to test if solution exists without it)\n    solver.add(Not(selected[opt]))\n    if solver.check() == unsat:\n        # No solution without this concerto, so it must be selected\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A soloist will play six different guitar concertos, exactly one each Sunday for six consecutive weeks. Two concertos will be selected from among three concertos by Giuliani—H, J, and K; two from among four concertos by Rodrigo—M, N, O, and P; and two from among three concertos by Vivaldi—X, Y, and Z. The following conditions apply without exception: If N is selected, then J is also selected. If M is selected, then neither J nor O can be selected. If X is selected, then neither Z nor P can be selected. If both J and O are selected, then J is played at some time before O. X cannot be played on the fifth Sunday unless one of Rodrigo's concertos is played on the first Sunday.\n\nWhich one of the following is a concerto that CANNOT be selected together with N?\n\nOptions:\n(A) M\n(B) O\n(C) P\n(D) X\n(E) Z",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Concertos by composer\nGiuliani = ['H', 'J', 'K']\nRodrigo = ['M', 'N', 'O', 'P']\nVivaldi = ['X', 'Y', 'Z']\n\nall_concertos = Giuliani + Rodrigo + Vivaldi\nconcerto_index = {c: i for i, c in enumerate(all_concertos)}\n\n# We have 6 weeks, each week exactly one concerto played\nweeks = 6\n\n# Variables: for each week, which concerto is played (index into all_concertos)\nweek_concerto = [Int(f'w{i+1}') for i in range(weeks)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each concerto index must be valid\nfor w in week_concerto:\n    solver.add(And(w >= 0, w < len(all_concertos)))\n\n# All concerts must be distinct (exactly 6 different concertos)\nsolver.add(Distinct(week_concerto))\n\n# Exactly two Giuliani concertos selected from H, J, K\n# Count how many Giuliani concertos are selected\ngiuliani_selected = [Bool(f'giuliani_{c}') for c in Giuliani]\nfor i, c in enumerate(Giuliani):\n    c_idx = concerto_index[c]\n    # Giuliani c is selected iff it appears in week_concerto\n    is_selected = Or([week_concerto[w] == c_idx for w in range(weeks)])\n    solver.add(giuliani_selected[i] == is_selected)\nsolver.add(Sum([If(b, 1, 0) for b in giuliani_selected]) == 2)\n\n# Exactly two Rodrigo concertos selected from M, N, O, P\nrodrigo_selected = [Bool(f'rodrigo_{c}') for c in Rodrigo]\nfor i, c in enumerate(Rodrigo):\n    c_idx = concerto_index[c]\n    is_selected = Or([week_concerto[w] == c_idx for w in range(weeks)])\n    solver.add(rodrigo_selected[i] == is_selected)\nsolver.add(Sum([If(b, 1, 0) for b in rodrigo_selected]) == 2)\n\n# Exactly two Vivaldi concertos selected from X, Y, Z\nvivaldi_selected = [Bool(f'vivaldi_{c}') for c in Vivaldi]\nfor i, c in enumerate(Vivaldi):\n    c_idx = concerto_index[c]\n    is_selected = Or([week_concerto[w] == c_idx for w in range(weeks)])\n    solver.add(vivaldi_selected[i] == is_selected)\nsolver.add(Sum([If(b, 1, 0) for b in vivaldi_selected]) == 2)\n\n# Conditions:\n# 1) If N is selected, then J is also selected\nN_idx = concerto_index['N']\nJ_idx = concerto_index['J']\nN_selected = Or([week_concerto[w] == N_idx for w in range(weeks)])\nJ_selected = Or([week_concerto[w] == J_idx for w in range(weeks)])\nsolver.add(Implies(N_selected, J_selected))\n\n# 2) If M is selected, then neither J nor O can be selected\nM_idx = concerto_index['M']\nO_idx = concerto_index['O']\nM_selected = Or([week_concerto[w] == M_idx for w in range(weeks)])\nO_selected = Or([week_concerto[w] == O_idx for w in range(weeks)])\nsolver.add(Implies(M_selected, And(Not(J_selected), Not(O_selected))))\n\n# 3) If X is selected, then neither Z nor P can be selected\nX_idx = concerto_index['X']\nZ_idx = concerto_index['Z']\nP_idx = concerto_index['P']\nX_selected = Or([week_concerto[w] == X_idx for w in range(weeks)])\nZ_selected = Or([week_concerto[w] == Z_idx for w in range(weeks)])\nP_selected = Or([week_concerto[w] == P_idx for w in range(weeks)])\nsolver.add(Implies(X_selected, And(Not(Z_selected), Not(P_selected))))\n\n# 4) If both J and O are selected, then J is played before O\nO_selected = Or([week_concerto[w] == O_idx for w in range(weeks)])\nJ_and_O_selected = And(J_selected, O_selected)\nif J_and_O_selected is not None:\n    # find the week index of J and O\n    J_week = Int('J_week')\n    O_week = Int('O_week')\n    solver.add(And(J_week >= 1, J_week <= weeks))\n    solver.add(And(O_week >= 1, O_week <= weeks))\n    # J_week is the index of week where J is played\n    J_week_conditions = [If(week_concerto[i] == J_idx, J_week == i+1, True) for i in range(weeks)]\n    solver.add(And(J_week_conditions))\n    # O_week is the index of week where O is played\n    O_week_conditions = [If(week_concerto[i] == O_idx, O_week == i+1, True) for i in range(weeks)]\n    solver.add(And(O_week_conditions))\n    # If both J and O selected, then J_week < O_week\n    solver.add(Implies(J_and_O_selected, J_week < O_week))\n\n# 5) X cannot be played on the fifth Sunday unless one of Rodrigo's concertos is played on the first Sunday\n# week 5 index = 4, week 1 index = 0\nX_on_fifth = week_concerto[4] == X_idx\nRodrigo_first = Or([week_concerto[0] == concerto_index[c] for c in Rodrigo])\nsolver.add(Implies(X_on_fifth, Rodrigo_first))\n\n# OPTION CHECKING\n# Question: Which concerto cannot be selected together with N?\n\n# Options:\noptions = ['M', 'O', 'P', 'X', 'Z']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraints that N and opt are both selected\n    opt_idx = concerto_index[opt]\n    N_selected_opt = Or([week_concerto[w] == N_idx for w in range(weeks)])\n    opt_selected = Or([week_concerto[w] == opt_idx for w in range(weeks)])\n    solver.add(N_selected_opt)\n    solver.add(opt_selected)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        # This option cannot be selected together with N\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.\n\nWhich one of the following is an acceptable assignment of the counselors to the activities?\n\nOptions:\n(A) Swimming: Fran, George, Henry; Tennis: Joan, Lewis; Volleyball: Kathy, Nathan, Olga\n(B) Swimming: George, Henry, Olga; Tennis: Fran, Joan, Lewis; Volleyball: Kathy, Nathan\n(C) Swimming: Henry; Tennis: Fran, George, Joan, Lewis; Volleyball: Kathy, Nathan, Olga\n(D) Swimming: Henry, Joan, Kathy; Tennis: George, Nathan; Volleyball: Fran, Lewis, Olga\n(E) Swimming: Henry, Nathan; Tennis: Fran, Kathy, Lewis; Volleyball: George, Joan, Olga",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncounselors = ['Fran', 'George', 'Henry', 'Joan', 'Kathy', 'Lewis', 'Nathan', 'Olga']\nactivities = ['Swimming', 'Tennis', 'Volleyball']\n\n# Map counselors to Int variables representing activities (0=Swimming, 1=Tennis, 2=Volleyball)\nassign = {c: Int(c) for c in counselors}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each counselor assigned to a valid activity index\nfor c in counselors:\n    solver.add(And(assign[c] >= 0, assign[c] < 3))\n\n# Each activity has at least 2 and at most 3 counselors\nfor i in range(3):\n    count_i = Sum([If(assign[c] == i, 1, 0) for c in counselors])\n    solver.add(count_i >= 2)\n    solver.add(count_i <= 3)\n\n# Henry supervises swimming (0)\nsolver.add(assign['Henry'] == 0)\n\n# Neither Kathy nor Olga supervises tennis (1)\nsolver.add(assign['Kathy'] != 1)\nsolver.add(assign['Olga'] != 1)\n\n# Neither Kathy nor Nathan supervises the same activity as Joan\n# assign[Kathy] != assign[Joan]\nsolver.add(assign['Kathy'] != assign['Joan'])\nsolver.add(assign['Nathan'] != assign['Joan'])\n\n# If George supervises swimming (0), then Nathan and Olga supervise volleyball (2)\ncond = assign['George'] == 0\nimplication = Implies(cond, And(assign['Nathan'] == 2, assign['Olga'] == 2))\nsolver.add(implication)\n\n# OPTION CHECKING\noptions = [\n    # (A) Swimming: Fran, George, Henry; Tennis: Joan, Lewis; Volleyball: Kathy, Nathan, Olga\n    {'Fran':0, 'George':0, 'Henry':0, 'Joan':1, 'Lewis':1, 'Kathy':2, 'Nathan':2, 'Olga':2},\n    # (B) Swimming: George, Henry, Olga; Tennis: Fran, Joan, Lewis; Volleyball: Kathy, Nathan\n    {'George':0, 'Henry':0, 'Olga':0, 'Fran':1, 'Joan':1, 'Lewis':1, 'Kathy':2, 'Nathan':2},\n    # (C) Swimming: Henry; Tennis: Fran, George, Joan, Lewis; Volleyball: Kathy, Nathan, Olga\n    {'Henry':0, 'Fran':1, 'George':1, 'Joan':1, 'Lewis':1, 'Kathy':2, 'Nathan':2, 'Olga':2},\n    # (D) Swimming: Henry, Joan, Kathy; Tennis: George, Nathan; Volleyball: Fran, Lewis, Olga\n    {'Henry':0, 'Joan':0, 'Kathy':0, 'George':1, 'Nathan':1, 'Fran':2, 'Lewis':2, 'Olga':2},\n    # (E) Swimming: Henry, Nathan; Tennis: Fran, Kathy, Lewis; Volleyball: George, Joan, Olga\n    {'Henry':0, 'Nathan':0, 'Fran':1, 'Kathy':1, 'Lewis':1, 'George':2, 'Joan':2, 'Olga':2}\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that assignment matches the option\n    for c in option:\n        solver.add(assign[c] == option[c])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.\n\nWhich one of the following is a pair of counselors who could be two of three counselors assigned to supervise swimming?\n\nOptions:\n(A) George and Nathan\n(B) George and Olga\n(C) Joan and Kathy\n(D) Joan and Nathan\n(E) Joan and Olga",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncounselors = ['Fran', 'George', 'Henry', 'Joan', 'Kathy', 'Lewis', 'Nathan', 'Olga']\nactivities = ['swimming', 'tennis', 'volleyball']\n\n# Map counselors to Z3 Int variables representing assigned activity indices\nassign = {c: Int(c) for c in counselors}\n\n# Create solver instance\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each counselor assigned to an activity index 0..2\nfor c in counselors:\n    solver.add(And(assign[c] >= 0, assign[c] < len(activities)))\n\n# Each activity has at least 2 and at most 3 counselors\nfor a_idx in range(len(activities)):\n    count = Sum([If(assign[c] == a_idx, 1, 0) for c in counselors])\n    solver.add(count >= 2)\n    solver.add(count <= 3)\n\n# Henry supervises swimming (activity 0)\nsolver.add(assign['Henry'] == activities.index('swimming'))\n\n# Neither Kathy nor Olga supervises tennis (activity 1)\nsolver.add(assign['Kathy'] != activities.index('tennis'))\nsolver.add(assign['Olga'] != activities.index('tennis'))\n\n# Neither Kathy nor Nathan supervises the same activity as Joan\nfor c in ['Kathy', 'Nathan']:\n    solver.add(assign[c] != assign['Joan'])\n\n# If George supervises swimming, then Nathan and Olga supervise volleyball (activity 2)\ngeorge_swimming = assign['George'] == activities.index('swimming')\nnathan_volleyball = assign['Nathan'] == activities.index('volleyball')\nolga_volleyball = assign['Olga'] == activities.index('volleyball')\nsolver.add(Implies(george_swimming, And(nathan_volleyball, olga_volleyball)))\n\n# OPTION CHECKING\noptions = {\n    'A': ['George', 'Nathan'],\n    'B': ['George', 'Olga'],\n    'C': ['Joan', 'Kathy'],\n    'D': ['Joan', 'Nathan'],\n    'E': ['Joan', 'Olga'],\n}\n\nfor letter, pair in options.items():\n    solver.push()\n    # Both counselors in the pair assigned to swimming (activity 0)\n    solver.add(assign[pair[0]] == activities.index('swimming'))\n    solver.add(assign[pair[1]] == activities.index('swimming'))\n    # Check if the assignment is satisfiable\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.\n\nWhich one of the following is a pair of counselors who could together be assigned to supervise tennis?\n\nOptions:\n(A) Fran and Kathy\n(B) George and Nathan\n(C) Henry and Lewis\n(D) Joan and Nathan\n(E) Joan and Olga",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncounselors = ['Fran', 'George', 'Henry', 'Joan', 'Kathy', 'Lewis', 'Nathan', 'Olga']\nactivities = ['swimming', 'tennis', 'volleyball']\n\n# Map counselors to Z3 Int variables representing assigned activity index\nassign = {c: Int(c) for c in counselors}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each counselor assigned to one activity index 0..2\nfor c in counselors:\n    solver.add(And(assign[c] >= 0, assign[c] < len(activities)))\n\n# Each activity supervised by at least 2 and at most 3 counselors\nfor a in range(len(activities)):\n    count_a = Sum([If(assign[c] == a, 1, 0) for c in counselors])\n    solver.add(count_a >= 2)\n    solver.add(count_a <= 3)\n\n# Henry supervises swimming (activity index 0)\nsolver.add(assign['Henry'] == activities.index('swimming'))\n\n# Neither Kathy nor Olga supervises tennis (activity index 1)\nsolver.add(assign['Kathy'] != activities.index('tennis'))\nsolver.add(assign['Olga'] != activities.index('tennis'))\n\n# Neither Kathy nor Nathan supervises the same activity as Joan\nsolver.add(assign['Kathy'] != assign['Joan'])\nsolver.add(assign['Nathan'] != assign['Joan'])\n\n# If George supervises swimming, both Nathan and Olga supervise volleyball\n# swimming = 0, volleyball = 2\ngeorge_swimming = assign['George'] == activities.index('swimming')\nnathan_volleyball = assign['Nathan'] == activities.index('volleyball')\nolga_volleyball = assign['Olga'] == activities.index('volleyball')\nsolver.add(Implies(george_swimming, And(nathan_volleyball, olga_volleyball)))\n\n# OPTION CHECKING\noptions = [\n    ('A', ['Fran', 'Kathy']),\n    ('B', ['George', 'Nathan']),\n    ('C', ['Henry', 'Lewis']),\n    ('D', ['Joan', 'Nathan']),\n    ('E', ['Joan', 'Olga']),\n]\n\nfor letter, pair in options:\n    solver.push()\n    # Add constraint that both counselors in pair supervise tennis (index 1)\n    solver.add(assign[pair[0]] == activities.index('tennis'))\n    solver.add(assign[pair[1]] == activities.index('tennis'))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.\n\nIf George and Kathy are two of three counselors assigned to supervise swimming, which one of the following could be true of the assignment?\n\nOptions:\n(A) Fran supervises swimming.\n(B) Henry supervises tennis.\n(C) Joan supervises volleyball.\n(D) Lewis supervises volleyball.\n(E) Nathan supervises tennis.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncounselors = ['Fran', 'George', 'Henry', 'Joan', 'Kathy', 'Lewis', 'Nathan', 'Olga']\nactivities = ['Swimming', 'Tennis', 'Volleyball']\n\n# Map counselor to Int variable representing activity index\nactivity_vars = {c: Int(c) for c in counselors}\n\nsolver = Solver()\n\n# Each counselor assigned to an activity index 0..2\nfor c in counselors:\n    solver.add(And(activity_vars[c] >= 0, activity_vars[c] < len(activities)))\n\n# Each activity has at least 2 and at most 3 counselors\nfor i in range(len(activities)):\n    count_i = Sum([If(activity_vars[c] == i, 1, 0) for c in counselors])\n    solver.add(And(count_i >= 2, count_i <= 3))\n\n# Henry supervises swimming (Swimming index = 0)\nsolver.add(activity_vars['Henry'] == 0)\n\n# Neither Kathy nor Olga supervises tennis (Tennis index = 1)\nsolver.add(activity_vars['Kathy'] != 1)\nsolver.add(activity_vars['Olga'] != 1)\n\n# Neither Kathy nor Nathan supervises the same activity as Joan\nsolver.add(activity_vars['Kathy'] != activity_vars['Joan'])\nsolver.add(activity_vars['Nathan'] != activity_vars['Joan'])\n\n# If George supervises swimming, then Nathan and Olga supervise volleyball (Volleyball index = 2)\ngeorge_swimming = activity_vars['George'] == 0\nnathan_volleyball = activity_vars['Nathan'] == 2\nolga_volleyball = activity_vars['Olga'] == 2\nsolver.add(Implies(george_swimming, And(nathan_volleyball, olga_volleyball)))\n\n# Given: George and Kathy are two of three counselors assigned to swimming\n# Swimming index = 0\n# Count swimming counselors must be 3\nswimming_count = Sum([If(activity_vars[c] == 0, 1, 0) for c in counselors])\nsolver.add(swimming_count == 3)\nsolver.add(activity_vars['George'] == 0)\nsolver.add(activity_vars['Kathy'] == 0)\n\n# OPTION CHECKING\noptions = {\n    'A': activity_vars['Fran'] == 0,\n    'B': activity_vars['Henry'] == 1,\n    'C': activity_vars['Joan'] == 2,\n    'D': activity_vars['Lewis'] == 2,\n    'E': activity_vars['Nathan'] == 1\n}\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[opt])\n    if solver.check() == sat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.\n\nIf Fran and Lewis are two of three counselors assigned to supervise swimming, which one of the following must be true of the assignment?\n\nOptions:\n(A) George supervises volleyball.\n(B) Henry supervises volleyball.\n(C) Joan supervises tennis.\n(D) Kathy supervises swimming.\n(E) Nathan supervises tennis.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncounselors = ['Fran', 'George', 'Henry', 'Joan', 'Kathy', 'Lewis', 'Nathan', 'Olga']\nactivities = ['swimming', 'tennis', 'volleyball']\n\n# Create Z3 Int variables for each counselor's activity assignment\n# Values: 0 = swimming, 1 = tennis, 2 = volleyball\nassign = {c: Int(c) for c in counselors}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each counselor assigned to exactly one valid activity\nfor c in counselors:\n    solver.add(And(assign[c] >= 0, assign[c] < len(activities)))\n\n# Each activity has at least 2 and at most 3 counselors\nfor a in range(len(activities)):\n    count = Sum([If(assign[c] == a, 1, 0) for c in counselors])\n    solver.add(count >= 2, count <= 3)\n\n# Henry supervises swimming (activity 0)\nsolver.add(assign['Henry'] == 0)\n\n# Neither Kathy nor Olga supervises tennis (activity 1)\nsolver.add(assign['Kathy'] != 1)\nsolver.add(assign['Olga'] != 1)\n\n# Neither Kathy nor Nathan supervises the same activity as Joan\nsolver.add(assign['Kathy'] != assign['Joan'])\nsolver.add(assign['Nathan'] != assign['Joan'])\n\n# If George supervises swimming (0), then Nathan and Olga supervise volleyball (2)\ngeorge_swimming = assign['George'] == 0\nnathan_volleyball = assign['Nathan'] == 2\nolga_volleyball = assign['Olga'] == 2\nsolver.add(Implies(george_swimming, And(nathan_volleyball, olga_volleyball)))\n\n# Additional constraint from the question: Fran and Lewis are two of three counselors assigned to swimming (0)\n# So Fran and Lewis both assigned swimming\nsolver.add(assign['Fran'] == 0)\nsolver.add(assign['Lewis'] == 0)\n# Swimming has exactly 3 counselors\ncount_swimming = Sum([If(assign[c] == 0, 1, 0) for c in counselors])\nsolver.add(count_swimming == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': assign['George'] == 2,    # George supervises volleyball\n    'B': assign['Henry'] == 2,     # Henry supervises volleyball\n    'C': assign['Joan'] == 1,      # Joan supervises tennis\n    'D': assign['Kathy'] == 0,     # Kathy supervises swimming\n    'E': assign['Nathan'] == 1     # Nathan supervises tennis\n}\n\nfor opt in ['A','B','C','D','E']:\n    solver.push()\n    # Add negation of option to test if option must be true\n    solver.add(Not(options[opt]))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Eight camp counselors—Fran, George, Henry, Joan, Kathy, Lewis, Nathan, and Olga—must each be assigned to supervise exactly one of three activities—swimming, tennis, and volleyball. The assignment of counselors must conform to the following conditions: Each activity is supervised by at least two, but not more than three, of the eight counselors. Henry supervises swimming. Neither Kathy nor Olga supervises tennis. Neither Kathy nor Nathan supervises the same activity as Joan. If George supervises swimming, both Nathan and Olga supervise volleyball.\n\nIf Joan is assigned to supervise the same activity as Olga, which one of the following CANNOT be true of the assignment?\n\nOptions:\n(A) Fran supervises swimming.\n(B) George supervises swimming.\n(C) Kathy supervises volleyball.\n(D) Lewis supervises volleyball.\n(E) Nathan supervises tennis.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncounselors = ['Fran', 'George', 'Henry', 'Joan', 'Kathy', 'Lewis', 'Nathan', 'Olga']\nactivities = ['swimming', 'tennis', 'volleyball']\n\n# Create Z3 Int variables for each counselor's activity assignment\nassign = {c: Int(c) for c in counselors}\n\n# Map activity names to indices\nactivity_idx = {a: i for i, a in enumerate(activities)}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each counselor assigned to a valid activity index\nfor c in counselors:\n    solver.add(And(assign[c] >= 0, assign[c] < len(activities)))\n\n# Count how many counselors assigned to each activity\ndef count_activity(activity):\n    return Sum([If(assign[c] == activity_idx[activity], 1, 0) for c in counselors])\n\n# Each activity has at least 2 and at most 3 counselors\nfor a in activities:\n    count = count_activity(a)\n    solver.add(count >= 2)\n    solver.add(count <= 3)\n\n# Henry supervises swimming\nsolver.add(assign['Henry'] == activity_idx['swimming'])\n\n# Neither Kathy nor Olga supervises tennis\nsolver.add(assign['Kathy'] != activity_idx['tennis'])\nsolver.add(assign['Olga'] != activity_idx['tennis'])\n\n# Neither Kathy nor Nathan supervises the same activity as Joan\nsolver.add(assign['Kathy'] != assign['Joan'])\nsolver.add(assign['Nathan'] != assign['Joan'])\n\n# If George supervises swimming, both Nathan and Olga supervise volleyball\ngeorge_swimming = assign['George'] == activity_idx['swimming']\nnathan_volleyball = assign['Nathan'] == activity_idx['volleyball']\nolga_volleyball = assign['Olga'] == activity_idx['volleyball']\nsolver.add(Implies(george_swimming, And(nathan_volleyball, olga_volleyball)))\n\n# Additional condition: Joan is assigned to the same activity as Olga\nsolver.add(assign['Joan'] == assign['Olga'])\n\n# OPTION CHECKING\noptions = {\n    'A': assign['Fran'] == activity_idx['swimming'],\n    'B': assign['George'] == activity_idx['swimming'],\n    'C': assign['Kathy'] == activity_idx['volleyball'],\n    'D': assign['Lewis'] == activity_idx['volleyball'],\n    'E': assign['Nathan'] == activity_idx['tennis'],\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A fire chief is determining the work schedules of five firefighters: Fuentes, Graber, Howell, Iman, and Jackson. The schedule must meet the following conditions: Except for Saturday and Sunday, when none of them works, exactly one of the firefighters works each day. None of the firefighters can work more than two days per week. No firefighter works on two consecutive days. Fuentes never works later in the week than Jackson. If Howell works, then Graber must work on the following day.\n\nIf Fuentes works two days during the week and Jackson works on Thursday, which one of the following statements could be true?\n\nOptions:\n(A) Fuentes works on Tuesday.\n(B) Graber works on Tuesday.\n(C) Howell works on Tuesday.\n(D) Graber works on Wednesday.\n(E) Howell works on Wednesday.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfirefighters = ['Fuentes', 'Graber', 'Howell', 'Iman', 'Jackson']\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\nnum_firefighters = len(firefighters)\nnum_days = len(days)\n\n# Create a matrix of Bool variables: work[firefighter][day]\nwork = {}\nfor f in firefighters:\n    for d in days:\n        work[(f, d)] = Bool(f + '_' + d)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Except for Saturday and Sunday (no work), exactly one firefighter works each day\nfor d in days:\n    # Exactly one firefighter works on day d\n    works_today = [work[(f, d)] for f in firefighters]\n    solver.add(PbEq([(w, 1) for w in works_today], 1))\n\n# 2. None of the firefighters can work more than two days per week\nfor f in firefighters:\n    works_f = [work[(f, d)] for d in days]\n    solver.add(PbLe([(w, 1) for w in works_f], 2))\n\n# 3. No firefighter works on two consecutive days\nfor f in firefighters:\n    for i in range(num_days - 1):\n        day1 = days[i]\n        day2 = days[i + 1]\n        # Not work both day1 and day2\n        solver.add(Or(Not(work[(f, day1)]), Not(work[(f, day2)])))\n\n# 4. Fuentes never works later in the week than Jackson\n# For all pairs of days (d1, d2), if Fuentes works on d2 and Jackson works on d1, then d1 >= d2\n# This means Fuentes's latest work day <= Jackson's latest work day\n# We'll encode: For any day dFuentes and dJackson, if Fuentes works dFuentes and Jackson works dJackson, then dFuentes <= dJackson\nday_indices = {day: i for i, day in enumerate(days)}\nfor dF in days:\n    for dJ in days:\n        cond = Implies(And(work[('Fuentes', dF)], work[('Jackson', dJ)]), day_indices[dF] <= day_indices[dJ])\n        solver.add(cond)\n\n# 5. If Howell works, then Graber must work on the following day\nfor i in range(num_days - 1):\n    dH = days[i]\n    dG = days[i + 1]\n    solver.add(Implies(work[('Howell', dH)], work[('Graber', dG)]))\n\n# 6. Fuentes works two days during the week\nsolver.add(PbEq([(work[('Fuentes', d)], 1) for d in days], 2))\n\n# 7. Jackson works on Thursday\nsolver.add(work[('Jackson', 'Thursday')])\n\n# OPTION CHECKING\n\noptions = {\n    'A': work[('Fuentes', 'Tuesday')],\n    'B': work[('Graber', 'Tuesday')],\n    'C': work[('Howell', 'Tuesday')],\n    'D': work[('Graber', 'Wednesday')],\n    'E': work[('Howell', 'Wednesday')],\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A housing committee will consist of exactly five representatives, one of whom will be its chairperson. The representatives will be selected from among a group of five tenants—F, G, J, K, and M—and a group of four homeowners—P, Q, R, and S. The following conditions must be met: The committee must include at least two representatives from each group. The chairperson must be a representative belonging to the group from which exactly two representatives are selected. If F is selected, Q must be selected. If G is selected, K must be selected. If either J or M is selected, the other must also be selected. M and P cannot both be selected.\n\nWhich one of the following lists three representatives who could be selected together for the committee?\n\nOptions:\n(A) F, G, J\n(B) F, G, M\n(C) F, J, M\n(D) G, J, K\n(E) G, J, M",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Define members\ntenants = ['F', 'G', 'J', 'K', 'M']\nhomeowners = ['P', 'Q', 'R', 'S']\nall_members = tenants + homeowners\n\n# Create Z3 Bool variables for selection of each member\nselected = {m: Bool(m) for m in all_members}\n\n# Create Z3 Bool variable for chairperson for each member (only one chairperson)\nchair = {m: Bool('chair_' + m) for m in all_members}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly 5 representatives selected\nsolver.add(Sum([If(selected[m], 1, 0) for m in all_members]) == 5)\n\n# Exactly one chairperson selected\nsolver.add(Sum([If(chair[m], 1, 0) for m in all_members]) == 1)\n\n# Chairperson must be selected\nfor m in all_members:\n    solver.add(Implies(chair[m], selected[m]))\n\n# At least two tenants selected\nsolver.add(Sum([If(selected[m], 1, 0) for m in tenants]) >= 2)\n\n# At least two homeowners selected\nsolver.add(Sum([If(selected[m], 1, 0) for m in homeowners]) >= 2)\n\n# The chairperson must be from the group with exactly two representatives\n# So either tenants are exactly two and chair is tenant, or homeowners are exactly two and chair is homeowner\nnum_tenants = Sum([If(selected[m], 1, 0) for m in tenants])\nnum_homeowners = Sum([If(selected[m], 1, 0) for m in homeowners])\n\n# Chair is tenant\nchair_is_tenant = Or([chair[m] for m in tenants])\n# Chair is homeowner\nchair_is_homeowner = Or([chair[m] for m in homeowners])\n\nsolver.add(Or(\n    And(num_tenants == 2, chair_is_tenant),\n    And(num_homeowners == 2, chair_is_homeowner)\n))\n\n# If F is selected, then Q is selected\nsolver.add(Implies(selected['F'], selected['Q']))\n\n# If G is selected, then K is selected\nsolver.add(Implies(selected['G'], selected['K']))\n\n# If J or M is selected, then the other must also be selected (J and M selected together or both not selected)\nsolver.add(selected['J'] == selected['M'])\n\n# M and P cannot both be selected\nsolver.add(Not(And(selected['M'], selected['P'])))\n\n# OPTION CHECKING\noptions = {\n    'A': ['F', 'G', 'J'],\n    'B': ['F', 'G', 'M'],\n    'C': ['F', 'J', 'M'],\n    'D': ['G', 'J', 'K'],\n    'E': ['G', 'J', 'M']\n}\n\nfor letter, group in options.items():\n    solver.push()\n    # Add constraints that these three are selected\n    for m in group:\n        solver.add(selected[m])\n    # No constraints that these three only, so others can be selected as well\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A housing committee will consist of exactly five representatives, one of whom will be its chairperson. The representatives will be selected from among a group of five tenants—F, G, J, K, and M—and a group of four homeowners—P, Q, R, and S. The following conditions must be met: The committee must include at least two representatives from each group. The chairperson must be a representative belonging to the group from which exactly two representatives are selected. If F is selected, Q must be selected. If G is selected, K must be selected. If either J or M is selected, the other must also be selected. M and P cannot both be selected.\n\nIf F is selected, any one of the following people could be the chairperson of the committee EXCEPT:\n\nOptions:\n(A) G\n(B) K\n(C) P\n(D) Q\n(E) S",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Define members\ntenants = ['F', 'G', 'J', 'K', 'M']\nhomeowners = ['P', 'Q', 'R', 'S']\nall_members = tenants + homeowners\n\n# Create Bool variables for selection of each member\nselected = {m: Bool(m) for m in all_members}\n\n# Chairperson variable: one of the selected members\n# Represent chairperson as an Int index into all_members\nchairperson = Int('chairperson')\n\n# Create mapping from index to member name for convenience\nmember_indices = {m: i for i, m in enumerate(all_members)}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Committee size is exactly 5\nsolver.add(Sum([If(selected[m], 1, 0) for m in all_members]) == 5)\n\n# At least two representatives from each group\nsolver.add(Sum([If(selected[m], 1, 0) for m in tenants]) >= 2)\nsolver.add(Sum([If(selected[m], 1, 0) for m in homeowners]) >= 2)\n\n# Chairperson must be selected\nsolver.add(And(chairperson >= 0, chairperson < len(all_members)))\nchair_selected = [chairperson == member_indices[m] for m in all_members]\nsolver.add(Or(chair_selected))\n# Chairperson must be selected member\nsolver.add(Or([And(chairperson == member_indices[m], selected[m]) for m in all_members]))\n\n# Chairperson must belong to the group from which exactly two representatives are selected\n# Number of tenants selected\nnum_tenants = Sum([If(selected[m], 1, 0) for m in tenants])\n# Number of homeowners selected\nnum_homeowners = Sum([If(selected[m], 1, 0) for m in homeowners])\n\n# Chairperson group constraint:\n# If tenants selected == 2, chairperson must be a tenant\n# If homeowners selected == 2, chairperson must be a homeowner\n# Because total is 5 and both groups >=2, exactly one group has exactly 2 members\nsolver.add(Or(\n    And(num_tenants == 2,\n        Or([chairperson == member_indices[m] for m in tenants])\n       ),\n    And(num_homeowners == 2,\n        Or([chairperson == member_indices[m] for m in homeowners])\n       )\n))\n\n# If F is selected, Q must be selected\nsolver.add(Implies(selected['F'], selected['Q']))\n\n# If G is selected, K must be selected\nsolver.add(Implies(selected['G'], selected['K']))\n\n# If either J or M is selected, the other must also be selected\nsolver.add(selected['J'] == selected['M'])\n\n# M and P cannot both be selected\nsolver.add(Not(And(selected['M'], selected['P'])))\n\n# OPTION CHECKING\n# Given F is selected, check which chairpersons are possible\n# Options: (A) G, (B) K, (C) P, (D) Q, (E) S\n\noptions = ['G', 'K', 'P', 'Q', 'S']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add condition: F is selected\n    solver.add(selected['F'] == True)\n    # Add condition: chairperson is opt\n    solver.add(chairperson == member_indices[opt])\n    # Check if satisfiable\n    if solver.check() == sat:\n        # This option can be chairperson if F is selected\n        solver.pop()\n    else:\n        # This option cannot be chairperson if F is selected\n        print(f\"'{chr(65+i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Four apprentices—Louis, Madelyn, Nora, and Oliver—are initially assigned to projects Q, R, S, and T, respectively. During the year in which they are apprentices, two reassignments of apprentices to projects will be made, each time according to a different one of the following plans, which can be used in any order: Plan 1. The apprentice assigned to project Q switches projects with the apprentice assigned to project S and the apprentice assigned to project R switches projects with the apprentice assigned to project T. Plan 2. The apprentice assigned to project S switches projects with the apprentice assigned to project T. Plan 3. Louis and Madelyn switch projects with each other.\n\nWhich one of the following must be true after the second reassignment of apprentices to projects during the year if that reassignment assigns Nora to project T ?\n\nOptions:\n(A) Louis is assigned to project S.\n(B) Madelyn is assigned to project R.\n(C) Madelyn is assigned to project S.\n(D) Oliver is assigned to project R.\n(E) Oliver is assigned to project S.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napprentices = ['Louis', 'Madelyn', 'Nora', 'Oliver']\nprojects = ['Q', 'R', 'S', 'T']\n\n# Map apprentices and projects to indices\nL, M, N, O = 0, 1, 2, 3\nQ, R, S, T = 0, 1, 2, 3\n\n# Variables for assignments after first and second reassignment\n# Each variable is an Int array of length 4, where index is apprentice and value is project assigned\n# For example, first_reassign[L] is the project assigned to Louis after first reassignment\nfirst_reassign = [Int(f'first_{apprentices[i]}') for i in range(4)]\nsecond_reassign = [Int(f'second_{apprentices[i]}') for i in range(4)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Initial assignment before any reassignment\n# Louis->Q, Madelyn->R, Nora->S, Oliver->T\ninitial = [Q, R, S, T]\n\n# All assignments must be valid projects\nfor i in range(4):\n    solver.add(And(first_reassign[i] >= 0, first_reassign[i] < 4))\n    solver.add(And(second_reassign[i] >= 0, second_reassign[i] < 4))\n\n# All assignments after each reassignment must be distinct (one apprentice per project)\nsolver.add(Distinct(first_reassign))\nsolver.add(Distinct(second_reassign))\n\n# Define functions to apply each plan given an assignment to get the next assignment\n\ndef apply_plan1(assign):\n    # Plan 1: Q<->S and R<->T swap apprentices\n    # We have project->apprentice mapping to swap, but we have apprentice->project mapping\n    # So first invert mapping: project_of_apprentice = assign[i]\n    # We create an array new_assign so that new_assign[i] = new project for apprentice i\n    # Since we know initial assignment of projects, we can find which apprentice is on each project\n    # But here assign is apprentice->project, so we invert to get project->apprentice\n    proj_to_app = [None]*4\n    for app_i in range(4):\n        proj_to_app[assign[app_i].as_long() if is_const(assign[app_i]) else -1] = app_i\n    # We can't use as_long() on symbolic variables, so we implement symbolically:\n    # We create an array of 4 Ints for project->apprentice, each is Int var\n    # But since assign is symbolic, we define constraints for new assignment accordingly\n    # Instead, define new assignment for each apprentice:\n    new_assign = [Int(f'plan1_{apprentices[i]}') for i in range(4)]\n    # The plan swaps apprentices assigned to Q and S, and R and T\n    # So for each project, find which apprentice is assigned, then swap accordingly\n    # We define constraints that for each apprentice i:\n    # If assign[i] == Q then new_assign[app_on_S] == Q and new_assign[i] == S\n    # Similarly for R and T\n    # For others, project stays same.\n\n    # We will encode this by considering all apprentices:\n    # For each apprentice i:\n    # If assign[i] == Q, then new_assign[i] = S\n    # If assign[i] == S, then new_assign[i] = Q\n    # If assign[i] == R, then new_assign[i] = T\n    # If assign[i] == T, then new_assign[i] = R\n\n    for i in range(4):\n        cond_Q = assign[i] == Q\n        cond_S = assign[i] == S\n        cond_R = assign[i] == R\n        cond_T = assign[i] == T\n        solver.add(Or(cond_Q, cond_S, cond_R, cond_T))  # project assigned is one of Q,R,S,T\n\n        # new_assign[i] = swapped project according to plan 1\n        solver.add(If(cond_Q, new_assign[i] == S,\n                  If(cond_S, new_assign[i] == Q,\n                  If(cond_R, new_assign[i] == T,\n                  new_assign[i] == R))))\n    # Return new_assign list\n    return new_assign\n\ndef apply_plan2(assign):\n    # Plan 2: S <-> T swap\n    new_assign = [Int(f'plan2_{apprentices[i]}') for i in range(4)]\n    for i in range(4):\n        cond_S = assign[i] == S\n        cond_T = assign[i] == T\n        cond_other = And(assign[i] != S, assign[i] != T)\n        solver.add(Or(cond_S, cond_T, cond_other))\n        solver.add(If(cond_S, new_assign[i] == T,\n                  If(cond_T, new_assign[i] == S,\n                  new_assign[i] == assign[i])))\n    return new_assign\n\ndef apply_plan3(assign):\n    # Plan 3: Louis and Madelyn switch projects\n    new_assign = [Int(f'plan3_{apprentices[i]}') for i in range(4)]\n    for i in range(4):\n        if i == L:\n            # Louis gets Madelyn's project\n            solver.add(new_assign[i] == assign[M])\n        elif i == M:\n            # Madelyn gets Louis's project\n            solver.add(new_assign[i] == assign[L])\n        else:\n            # Others keep their projects\n            solver.add(new_assign[i] == assign[i])\n    return new_assign\n\n# The two reassignments are from the set {Plan1, Plan2, Plan3} with different plans and any order\n# So possible pairs of plans (order matters) with distinct plans:\nplan_functions = [apply_plan1, apply_plan2, apply_plan3]\nplan_names = ['Plan1', 'Plan2', 'Plan3']\nplan_pairs = [(0,1), (0,2), (1,0), (1,2), (2,0), (2,1)]\n\n# We will encode that first_reassign and second_reassign correspond to applying two distinct plans in some order to the initial assignment\n\n# Create a Boolean variable for each plan pair to indicate if it's the chosen order\npair_bools = [Bool(f'pair_{i}') for i in range(len(plan_pairs))]\nsolver.add(PbEq([(pair_bools[i],1) for i in range(len(pair_bools))],1))  # Exactly one pair chosen\n\n# For each pair, create constraints that if chosen, then first_reassign and second_reassign are result of applying those plans in order\nfor idx,(p1,p2) in enumerate(plan_pairs):\n    # Apply p1 to initial to get first_reassign\n    # Apply p2 to first_reassign to get second_reassign\n    # We create intermediate variables for first_reassign and second_reassign for this pair\n    # But we already have first_reassign and second_reassign variables, so we encode conditional constraints\n\n    # Apply p1 to initial\n    # initial is a list of constants\n    # For plan 1,2,3, apply_plan functions expect symbolic variables, so create Int variables for initial\n    initial_vars = [Int(f'initial_{apprentices[i]}_{idx}') for i in range(4)]\n    for i in range(4):\n        solver.add(initial_vars[i] == initial[i])\n\n    # Apply first plan\n    first_plan_assign = [Int(f'first_plan_{idx}_{apprentices[i]}') for i in range(4)]\n    # We encode the plan application constraints for first_plan_assign given initial_vars\n    # Because apply_plan functions add constraints directly to solver, we need to separate constraints for each plan pair\n    # So we duplicate the apply_plan logic here with fresh variables and conditional constraints\n\n    # We define function to add constraints for plan application given input_vars and output_vars, plan index, and idx for naming\n    def add_plan_constraints(plan_index, input_vars, output_vars, idx):\n        if plan_index == 0:\n            # Plan1\n            for i in range(4):\n                cond_Q = input_vars[i] == Q\n                cond_S = input_vars[i] == S\n                cond_R = input_vars[i] == R\n                cond_T = input_vars[i] == T\n                solver.add(Or([cond_Q, cond_S, cond_R, cond_T]))\n                solver.add(If(cond_Q, output_vars[i] == S,\n                          If(cond_S, output_vars[i] == Q,\n                          If(cond_R, output_vars[i] == T,\n                          output_vars[i] == R))))\n        elif plan_index == 1:\n            # Plan2\n            for i in range(4):\n                cond_S = input_vars[i] == S\n                cond_T = input_vars[i] == T\n                cond_other = And(input_vars[i] != S, input_vars[i] != T)\n                solver.add(Or([cond_S, cond_T, cond_other]))\n                solver.add(If(cond_S, output_vars[i] == T,\n                          If(cond_T, output_vars[i] == S,\n                          output_vars[i] == input_vars[i])))\n        else:\n            # Plan3\n            for i in range(4):\n                if i == L:\n                    solver.add(output_vars[i] == input_vars[M])\n                elif i == M:\n                    solver.add(output_vars[i] == input_vars[L])\n                else:\n                    solver.add(output_vars[i] == input_vars[i])\n    # Add constraints for first plan application\n    add_plan_constraints(p1, initial_vars, first_plan_assign, idx)\n\n    # Apply second plan to first_plan_assign to get second_plan_assign\n    second_plan_assign = [Int(f'second_plan_{idx}_{apprentices[i]}') for i in range(4)]\n    add_plan_constraints(p2, first_plan_assign, second_plan_assign, idx)\n\n    # Now link first_plan_assign to first_reassign and second_plan_assign to second_reassign conditionally on pair_bools[idx]\n    for i in range(4):\n        solver.add(Implies(pair_bools[idx], first_reassign[i] == first_plan_assign[i]))\n        solver.add(Implies(pair_bools[idx], second_reassign[i] == second_plan_assign[i]))\n\n# Constraint: After second reassignment, Nora is assigned to project T\nsolver.add(second_reassign[N] == T)\n\n# OPTION CHECKING\noptions = [\n    (L, S),  # (A) Louis assigned to S\n    (M, R),  # (B) Madelyn assigned to R\n    (M, S),  # (C) Madelyn assigned to S\n    (O, R),  # (D) Oliver assigned to R\n    (O, S),  # (E) Oliver assigned to S\n]\n\nfor i, (app_i, proj_i) in enumerate(options):\n    solver.push()\n    # Add constraint that option is false to check if it can be false\n    solver.add(second_reassign[app_i] != proj_i)\n    if solver.check() == unsat:\n        # If adding negation makes it unsat, option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Four apprentices—Louis, Madelyn, Nora, and Oliver—are initially assigned to projects Q, R, S, and T, respectively. During the year in which they are apprentices, two reassignments of apprentices to projects will be made, each time according to a different one of the following plans, which can be used in any order: Plan 1. The apprentice assigned to project Q switches projects with the apprentice assigned to project S and the apprentice assigned to project R switches projects with the apprentice assigned to project T. Plan 2. The apprentice assigned to project S switches projects with the apprentice assigned to project T. Plan 3. Louis and Madelyn switch projects with each other.\n\nWhich one of the following could be true after only one reassignment during the year?\n\nOptions:\n(A) Louis is assigned to project T.\n(B) Nora is assigned to project R.\n(C) Oliver is assigned to project Q.\n(D) Louis and Nora each remain assigned to the same projects as before.\n(E) Nora and Oliver each remain assigned to the same projects as before.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napprentices = ['Louis', 'Madelyn', 'Nora', 'Oliver']\nprojects = ['Q', 'R', 'S', 'T']\n\n# Initial assignments (indices of projects)\ninitial_assignment = {\n    'Louis': projects.index('Q'),\n    'Madelyn': projects.index('R'),\n    'Nora': projects.index('S'),\n    'Oliver': projects.index('T')\n}\n\n# Variables for assignments after one reassignment\nassignment = {}\nfor a in apprentices:\n    assignment[a] = Int(a)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each apprentice assigned to a valid project\nfor a in apprentices:\n    solver.add(And(assignment[a] >= 0, assignment[a] < len(projects)))\n\n# Only one reassignment applied: Plan 1, Plan 2, or Plan 3\n# Define the result of applying each plan once\n\n# Plan 1: Q<->S and R<->T\nplan1 = {}\nfor a in apprentices:\n    if initial_assignment[a] == projects.index('Q'):\n        plan1[a] = projects.index('S')\n    elif initial_assignment[a] == projects.index('S'):\n        plan1[a] = projects.index('Q')\n    elif initial_assignment[a] == projects.index('R'):\n        plan1[a] = projects.index('T')\n    elif initial_assignment[a] == projects.index('T'):\n        plan1[a] = projects.index('R')\n\n# Plan 2: S<->T\nplan2 = {}\nfor a in apprentices:\n    if initial_assignment[a] == projects.index('S'):\n        plan2[a] = projects.index('T')\n    elif initial_assignment[a] == projects.index('T'):\n        plan2[a] = projects.index('S')\n    else:\n        plan2[a] = initial_assignment[a]\n\n# Plan 3: Louis<->Madelyn switch projects\nplan3 = {}\nfor a in apprentices:\n    if a == 'Louis':\n        plan3[a] = initial_assignment['Madelyn']\n    elif a == 'Madelyn':\n        plan3[a] = initial_assignment['Louis']\n    else:\n        plan3[a] = initial_assignment[a]\n\n# Possible assignments after one reassignment\nplans = [plan1, plan2, plan3]\n\n# OPTION CHECKING\noptions = {\n    'A': assignment['Louis'] == projects.index('T'),\n    'B': assignment['Nora'] == projects.index('R'),\n    'C': assignment['Oliver'] == projects.index('Q'),\n    'D': And(assignment['Louis'] == initial_assignment['Louis'], assignment['Nora'] == initial_assignment['Nora']),\n    'E': And(assignment['Nora'] == initial_assignment['Nora'], assignment['Oliver'] == initial_assignment['Oliver']),\n}\n\nfor i, (opt_letter, opt_constraint) in enumerate(options.items()):\n    solver.push()\n    # The assignment must be equal to one of the plans after one reassignment\n    plan_constraints = []\n    for plan in plans:\n        equalities = [assignment[a] == plan[a] for a in apprentices]\n        plan_constraints.append(And(equalities))\n    solver.add(Or(plan_constraints))\n    solver.add(opt_constraint)\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Four apprentices—Louis, Madelyn, Nora, and Oliver—are initially assigned to projects Q, R, S, and T, respectively. During the year in which they are apprentices, two reassignments of apprentices to projects will be made, each time according to a different one of the following plans, which can be used in any order: Plan 1. The apprentice assigned to project Q switches projects with the apprentice assigned to project S and the apprentice assigned to project R switches projects with the apprentice assigned to project T. Plan 2. The apprentice assigned to project S switches projects with the apprentice assigned to project T. Plan 3. Louis and Madelyn switch projects with each other.\n\nIf at some time during the year, Louis is reassigned to project R, which one of the following could have been the assignment of apprentices to the projects immediately before the reassignment?\n\nOptions:\n(A) Q: Louis; R: Madelyn; S: Oliver; T: Nora\n(B) Q: Louis; R: Nora; S: Oliver; T: Madelyn\n(C) Q: Nora; R: Madelyn; S: Louis; T: Oliver\n(D) Q: Nora; R: Oliver; S: Louis; T: Madelyn\n(E) Q: Oliver; R: Nora; S: Louis; T: Madelyn",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Apprentices and projects\napprentices = ['Louis', 'Madelyn', 'Nora', 'Oliver']\nprojects = ['Q', 'R', 'S', 'T']\n\n# Map apprentices and projects to indices\nappr_idx = {a: i for i, a in enumerate(apprentices)}\nproj_idx = {p: i for i, p in enumerate(projects)}\n\n# Initial assignment: Louis->Q, Madelyn->R, Nora->S, Oliver->T\n# Represent assignments as arrays: project_assignment[project] = apprentice assigned\n# Initial assignment:\n# Q: Louis (0)\n# R: Madelyn (1)\n# S: Nora (2)\n# T: Oliver (3)\ninitial_assignment = [appr_idx['Louis'], appr_idx['Madelyn'], appr_idx['Nora'], appr_idx['Oliver']]\n\n# Variables:\n# We model the assignment of apprentices to projects at three times:\n# time 0: initial\n# time 1: after first reassignment (after applying one plan)\n# time 2: after second reassignment (after applying second plan)\n# Each is a list of 4 Ints representing apprentices assigned to projects Q,R,S,T\n# Values in 0..3 representing apprentices\nassignment_0 = [Int(f'a0_{p}') for p in projects]\nassignment_1 = [Int(f'a1_{p}') for p in projects]\nassignment_2 = [Int(f'a2_{p}') for p in projects]\n\n# Plans are functions that take an assignment and return a new assignment\ndef plan1(assign):\n    # Plan 1: Q<->S and R<->T swaps\n    new_assign = assign[:]\n    new_assign = new_assign[:]  # copy\n    # Swap Q and S\n    new_assign_q = assign[proj_idx['S']]\n    new_assign_s = assign[proj_idx['Q']]\n    # Swap R and T\n    new_assign_r = assign[proj_idx['T']]\n    new_assign_t = assign[proj_idx['R']]\n    res = assign[:]\n    res[proj_idx['Q']] = new_assign_q\n    res[proj_idx['S']] = new_assign_s\n    res[proj_idx['R']] = new_assign_r\n    res[proj_idx['T']] = new_assign_t\n    return res\n\ndef plan2(assign):\n    # Plan 2: S<->T swap\n    new_assign_s = assign[proj_idx['T']]\n    new_assign_t = assign[proj_idx['S']]\n    res = assign[:]\n    res[proj_idx['S']] = new_assign_s\n    res[proj_idx['T']] = new_assign_t\n    return res\n\ndef plan3(assign):\n    # Plan 3: Louis and Madelyn switch projects\n    # Find projects of Louis and Madelyn\n    # Louis = 0, Madelyn = 1\n    # Find project of Louis\n    # We create variables for projects of Louis and Madelyn to express constraints\n    # But here we define a function that returns an assignment with Louis and Madelyn swapped\n    # So find their projects in assign:\n    # For each project p, if assign[p] == Louis, then project_of_louis = p\n    # Similarly for Madelyn\n    # Then swap their assignments\n    # We must do this symbolically with Z3 variables, so we can't do this functionally\n    # Instead, we will implement plan3 as constraints later\n    # So here, we just return None and handle plan3 differently\n    return None\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Initial assignment fixed\nfor p in range(4):\n    solver.add(assignment_0[p] == initial_assignment[p])\n\n# All assignments are permutations of apprentices, so distinct and in range\ndef add_valid_assignment_constraints(assign):\n    for p in range(4):\n        solver.add(And(assign[p] >= 0, assign[p] < 4))\n    solver.add(Distinct(assign))\n\nadd_valid_assignment_constraints(assignment_0)\nadd_valid_assignment_constraints(assignment_1)\nadd_valid_assignment_constraints(assignment_2)\n\n# We must apply two different plans in some order from {plan1, plan2, plan3}\n# So the sequence is:\n# assignment_0 --planX--> assignment_1 --planY--> assignment_2\n# where planX != planY and planX, planY in {1,2,3}\n\n# We create Int variables to represent which plans are applied in first and second reassignment\nplan_vars = [Int('plan1'), Int('plan2')]  # plan_vars[0] = plan applied first, plan_vars[1] = plan applied second\nsolver.add(And(plan_vars[0] >= 1, plan_vars[0] <= 3))\nsolver.add(And(plan_vars[1] >= 1, plan_vars[1] <= 3))\nsolver.add(plan_vars[0] != plan_vars[1])\n\n# Define helper functions for applying plans symbolically\n# For plan1 and plan2, we can define constraints directly\n# For plan3, we define constraints enforcing Louis and Madelyn swap projects\n\n# Helper function: enforce assignment_1 = planX(assignment_0) if plan_vars[0] == X\ndef apply_plan(assign_before, assign_after, plan_var):\n    # Use If to select plan constraints\n    constraints = []\n    # Plan 1 constraints:\n    # Q<->S and R<->T swaps\n    # So assign_after[Q] == assign_before[S]\n    # assign_after[S] == assign_before[Q]\n    # assign_after[R] == assign_before[T]\n    # assign_after[T] == assign_before[R]\n    plan1_c = []\n    plan1_c.append(assign_after[proj_idx['Q']] == assign_before[proj_idx['S']])\n    plan1_c.append(assign_after[proj_idx['S']] == assign_before[proj_idx['Q']])\n    plan1_c.append(assign_after[proj_idx['R']] == assign_before[proj_idx['T']])\n    plan1_c.append(assign_after[proj_idx['T']] == assign_before[proj_idx['R']])\n\n    # Plan 2 constraints:\n    # S <-> T swap\n    plan2_c = []\n    for p in range(4):\n        if p == proj_idx['S']:\n            plan2_c.append(assign_after[p] == assign_before[proj_idx['T']])\n        elif p == proj_idx['T']:\n            plan2_c.append(assign_after[p] == assign_before[proj_idx['S']])\n        else:\n            plan2_c.append(assign_after[p] == assign_before[p])\n\n    # Plan 3 constraints:\n    # Louis and Madelyn switch projects\n    # Find projects of Louis and Madelyn in assign_before:\n    # proj_of_louis_before: p where assign_before[p] == Louis (0)\n    # proj_of_madelyn_before: p where assign_before[p] == Madelyn (1)\n    proj_of_louis_before = Int('proj_of_louis_before')\n    proj_of_madelyn_before = Int('proj_of_madelyn_before')\n    solver.add(And(proj_of_louis_before >= 0, proj_of_louis_before < 4))\n    solver.add(And(proj_of_madelyn_before >= 0, proj_of_madelyn_before < 4))\n    # Louis is assigned to proj_of_louis_before\n    for p in range(4):\n        solver.add(If(assign_before[p] == appr_idx['Louis'], proj_of_louis_before == p, True))\n        solver.add(If(assign_before[p] == appr_idx['Madelyn'], proj_of_madelyn_before == p, True))\n    # proj_of_louis_before != proj_of_madelyn_before\n    solver.add(proj_of_louis_before != proj_of_madelyn_before)\n\n    # Now assign_after is same as assign_before except Louis and Madelyn swapped\n    plan3_c = []\n    for p in range(4):\n        cond_louis = (p == proj_of_louis_before)\n        cond_madelyn = (p == proj_of_madelyn_before)\n        # If p == proj_of_louis_before => assign_after[p] == Madelyn\n        # If p == proj_of_madelyn_before => assign_after[p] == Louis\n        # Else assign_after[p] == assign_before[p]\n        c = If(p == proj_of_louis_before,\n               assign_after[p] == appr_idx['Madelyn'],\n               If(p == proj_of_madelyn_before,\n                  assign_after[p] == appr_idx['Louis'],\n                  assign_after[p] == assign_before[p]))\n        plan3_c.append(c)\n\n    # Return If expression for plan_var\n    return And(\n        If(plan_var == 1, And(plan1_c),\n        If(plan_var == 2, And(plan2_c),\n        And(plan3_c)))\n    )\n\n# Apply first plan: assignment_0 -> assignment_1\nsolver.add(apply_plan(assignment_0, assignment_1, plan_vars[0]))\n# Apply second plan: assignment_1 -> assignment_2\nsolver.add(apply_plan(assignment_1, assignment_2, plan_vars[1]))\n\n# Condition: At some time during the year, Louis is assigned to project R\n# That means assignment_1 or assignment_2 has Louis at project R\nlouis_at_R_time1 = assignment_1[proj_idx['R']] == appr_idx['Louis']\nlouis_at_R_time2 = assignment_2[proj_idx['R']] == appr_idx['Louis']\nsolver.add(Or([louis_at_R_time1, louis_at_R_time2]))\n\n# We want to check which option could have been the assignment immediately before the reassignment\n# That is, the assignment before Louis is assigned to R\n# So if Louis is assigned to R at time 1, then the assignment before reassignment is assignment_0\n# If Louis is assigned to R at time 2, then the assignment before reassignment is assignment_1\n# So the \"assignment immediately before the reassignment\" is the assignment at time before Louis moves to R\n\n# So for each option, check if it can be equal to assignment_0 when Louis assigned to R at time 1\n# or assignment_1 when Louis assigned to R at time 2\n\noptions = [\n    # (A) Q: Louis; R: Madelyn; S: Oliver; T: Nora\n    [appr_idx['Louis'], appr_idx['Madelyn'], appr_idx['Oliver'], appr_idx['Nora']],\n    # (B) Q: Louis; R: Nora; S: Oliver; T: Madelyn\n    [appr_idx['Louis'], appr_idx['Nora'], appr_idx['Oliver'], appr_idx['Madelyn']],\n    # (C) Q: Nora; R: Madelyn; S: Louis; T: Oliver\n    [appr_idx['Nora'], appr_idx['Madelyn'], appr_idx['Louis'], appr_idx['Oliver']],\n    # (D) Q: Nora; R: Oliver; S: Louis; T: Madelyn\n    [appr_idx['Nora'], appr_idx['Oliver'], appr_idx['Louis'], appr_idx['Madelyn']],\n    # (E) Q: Oliver; R: Nora; S: Louis; T: Madelyn\n    [appr_idx['Oliver'], appr_idx['Nora'], appr_idx['Louis'], appr_idx['Madelyn']],\n]\n\ncorrect_option = None\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Check if Louis assigned to R at time 1 and assignment_0 == option\n    cond_time1 = And(louis_at_R_time1, And([assignment_0[p] == opt[p] for p in range(4)]))\n    # or Louis assigned to R at time 2 and assignment_1 == option\n    cond_time2 = And(louis_at_R_time2, And([assignment_1[p] == opt[p] for p in range(4)]))\n    solver.add(Or([cond_time1, cond_time2]))\n    if solver.check() == sat:\n        correct_option = chr(65 + i)\n        solver.pop()\n        break\n    solver.pop()\n\nprint(f\"'{correct_option}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Four apprentices—Louis, Madelyn, Nora, and Oliver—are initially assigned to projects Q, R, S, and T, respectively. During the year in which they are apprentices, two reassignments of apprentices to projects will be made, each time according to a different one of the following plans, which can be used in any order: Plan 1. The apprentice assigned to project Q switches projects with the apprentice assigned to project S and the apprentice assigned to project R switches projects with the apprentice assigned to project T. Plan 2. The apprentice assigned to project S switches projects with the apprentice assigned to project T. Plan 3. Louis and Madelyn switch projects with each other.\n\nWhich one of the following is an acceptable assignment of apprentices to the projects after only one reassignment during the year?\n\nOptions:\n(A) Q: Louis; R: Madelyn; S: Nora; T: Oliver\n(B) Q: Madelyn; R: Louis; S: Nora; T: Oliver\n(C) Q: Madelyn; R: Oliver; S: Nora; T: Louis\n(D) Q: Nora; R: Louis; S: Oliver; T: Madelyn\n(E) Q: Nora; R: Madelyn; S: Oliver; T: Louis",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napprentices = ['Louis', 'Madelyn', 'Nora', 'Oliver']\nprojects = ['Q', 'R', 'S', 'T']\n\n# Create a mapping from project to apprentice after initial assignment\n# Initial assignment:\n# Q: Louis\n# R: Madelyn\n# S: Nora\n# T: Oliver\n\n# We will represent the assignment after one reassignment as a list of integers,\n# where assignment[i] is the apprentice assigned to projects[i]\n# apprentice indices: 0-Louis,1-Madelyn,2-Nora,3-Oliver\n# project indices: 0-Q,1-R,2-S,3-T\n\n# Initial assignment array: [Louis, Madelyn, Nora, Oliver] -> [0,1,2,3]\n\n# Define Z3 variables for the assignment after one reassignment\nassignment = [Int(f'assignment_{p}') for p in projects]\n\nsolver = Solver()\n\n# The assignment must be a permutation of apprentices (no duplicates)\nfor a in assignment:\n    solver.add(And(a >= 0, a < 4))\nsolver.add(Distinct(assignment))\n\n# Define the initial assignment as a list of ints\ninitial = [0, 1, 2, 3]\n\n# Define Plan 1: Q<->S and R<->T swap\ndef plan1(init):\n    # Copy the initial list\n    new = init[:]\n    # Q=0 <-> S=2 swap\n    new[0], new[2] = new[2], new[0]\n    # R=1 <-> T=3 swap\n    new[1], new[3] = new[3], new[1]\n    return new\n\n# Define Plan 2: S<->T swap\ndef plan2(init):\n    new = init[:]\n    new[2], new[3] = new[3], new[2]\n    return new\n\n# Define Plan 3: Louis and Madelyn switch projects\n# Louis=0, Madelyn=1\n# We find their projects in init and swap them\ndef plan3(init):\n    new = init[:]\n    # Find project indices of Louis and Madelyn\n    # Actually init is project->apprentice, so find projects assigned to Louis and Madelyn\n    # But we want to swap Louis and Madelyn's projects, so swap the values 0 and 1 in the list\n    # So in the list, wherever 0 is, put 1, and wherever 1 is put 0\n    # But we must swap only these two apprentices' assignments\n    # So swap the positions of 0 and 1 in the list\n    idx_louis = init.index(0)\n    idx_madelyn = init.index(1)\n    new[idx_louis], new[idx_madelyn] = new[idx_madelyn], new[idx_louis]\n    return new\n\n# Compute the possible assignments after exactly one reassignment (one plan)\npossible_assignments = [plan1(initial), plan2(initial), plan3(initial)]\n\n# Add constraint that assignment matches exactly one of these possibilities\nor_conditions = [And([assignment[i] == possible_assignments[j][i] for i in range(4)]) for j in range(3)]\nsolver.add(Or(or_conditions))\n\n# OPTION CHECKING\noptions = [\n    [0, 1, 2, 3],  # A: Q:Louis(0), R:Madelyn(1), S:Nora(2), T:Oliver(3)\n    [1, 0, 2, 3],  # B: Q:Madelyn(1), R:Louis(0), S:Nora(2), T:Oliver(3)\n    [1, 3, 2, 0],  # C: Q:Madelyn(1), R:Oliver(3), S:Nora(2), T:Louis(0)\n    [2, 0, 3, 1],  # D: Q:Nora(2), R:Louis(0), S:Oliver(3), T:Madelyn(1)\n    [2, 1, 3, 0],  # E: Q:Nora(2), R:Madelyn(1), S:Oliver(3), T:Louis(0)\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraints that assignment matches this option\n    for j in range(4):\n        solver.add(assignment[j] == opt[j])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Four apprentices—Louis, Madelyn, Nora, and Oliver—are initially assigned to projects Q, R, S, and T, respectively. During the year in which they are apprentices, two reassignments of apprentices to projects will be made, each time according to a different one of the following plans, which can be used in any order: Plan 1. The apprentice assigned to project Q switches projects with the apprentice assigned to project S and the apprentice assigned to project R switches projects with the apprentice assigned to project T. Plan 2. The apprentice assigned to project S switches projects with the apprentice assigned to project T. Plan 3. Louis and Madelyn switch projects with each other.\n\nIf the first reassignment is made according to plan 1, which one of the following must be true?\n\nOptions:\n(A) Louis is assigned to project T as a result of the second reassignment.\n(B) Madelyn is assigned to project Q as a result of the second reassignment.\n(C) Madelyn is assigned to project T as a result of the second reassignment.\n(D) Oliver is assigned to project S as a result of the second reassignment.\n(E) Oliver is assigned to project T as a result of the second reassignment.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Apprentices and projects\napprentices = ['Louis', 'Madelyn', 'Nora', 'Oliver']\nprojects = ['Q', 'R', 'S', 'T']\n\n# Map apprentices and projects to indices\napprentice_idx = {a: i for i, a in enumerate(apprentices)}\nproject_idx = {p: i for i, p in enumerate(projects)}\n\n# Number of apprentices/projects\nn = len(apprentices)\n\n# Variables: assignment after first reassignment and after second reassignment\n# assign1[a] = project index assigned to apprentice a after first reassignment\n# assign2[a] = project index assigned to apprentice a after second reassignment\nassign1 = [Int(f'assign1_{a}') for a in apprentices]\nassign2 = [Int(f'assign2_{a}') for a in apprentices]\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Initial assignment before any reassignment\n# Louis->Q(0), Madelyn->R(1), Nora->S(2), Oliver->T(3)\ninitial_assign = [project_idx['Q'], project_idx['R'], project_idx['S'], project_idx['T']]\n\n# Each assign1[a] and assign2[a] must be a valid project index\nfor i in range(n):\n    solver.add(And(assign1[i] >= 0, assign1[i] < n))\n    solver.add(And(assign2[i] >= 0, assign2[i] < n))\n\n# Assignments must be one-to-one (no two apprentices assigned to same project)\nsolver.add(Distinct(assign1))\nsolver.add(Distinct(assign2))\n\n# The first reassignment is made according to plan 1:\n# Plan 1: Q<->S and R<->T switch\n# So after first reassignment:\n# Apprentice initially at Q moves to S's project and vice versa\n# Apprentice initially at R moves to T's project and vice versa\n# Initial assignments:\n# Louis: Q(0)\n# Madelyn: R(1)\n# Nora: S(2)\n# Oliver: T(3)\n\n# Define inverse mapping from project to apprentice initially\n# project_to_apprentice_initial[p] = apprentice assigned to project p initially\nproject_to_apprentice_initial = [0]*n\nfor a_i in range(n):\n    p_i = initial_assign[a_i]\n    project_to_apprentice_initial[p_i] = a_i\n\n# After plan 1:\n# Louis (initially Q=0) switches with Nora (initially S=2) => Louis gets S(2), Nora gets Q(0)\n# Madelyn (initially R=1) switches with Oliver (initially T=3) => Madelyn gets T(3), Oliver gets R(1)\n\n# Add constraints for assign1 accordingly\nsolver.add(assign1[apprentice_idx['Louis']] == project_idx['S'])\nsolver.add(assign1[apprentice_idx['Nora']] == project_idx['Q'])\nsolver.add(assign1[apprentice_idx['Madelyn']] == project_idx['T'])\nsolver.add(assign1[apprentice_idx['Oliver']] == project_idx['R'])\n\n# The second reassignment is made according to plan 2 or plan 3, in any order\n# So the second reassignment is either plan 2 or plan 3\n\n# We will check each option for the second reassignment plan and check which option must be true regardless of order\n\n# Define helper functions for applying plan 2 and plan 3 to assign1 to get assign2\n\ndef apply_plan_2(assign_before):\n    # Plan 2: S <-> T switch\n    # Find apprentices assigned to S and T in assign_before\n    # Swap their projects\n    # Others remain the same\n    # assign_before: list of project indices assigned to each apprentice\n    # returns list of project indices after plan 2\n    assign_after = [Int(f'plan2_after_{a}') for a in apprentices]\n    s_apprentice = None\n    t_apprentice = None\n    for i in range(n):\n        # Identify who has S and T\n        s_cond = assign_before[i] == project_idx['S']\n        t_cond = assign_before[i] == project_idx['T']\n        # Use If to assign s_apprentice and t_apprentice\n        # We cannot assign variables conditionally in Z3 like this,\n        # so we just record indices and then add constraints later\n    # Instead, we will create constraints:\n    # For each apprentice:\n    # if assign_before[apprentice] == S => assign_after[apprentice] == T\n    # if assign_before[apprentice] == T => assign_after[apprentice] == S\n    # else assign_after[apprentice] == assign_before[apprentice]\n    constraints = []\n    for i in range(n):\n        c = If(assign_before[i] == project_idx['S'], assign_after[i] == project_idx['T'],\n               If(assign_before[i] == project_idx['T'], assign_after[i] == project_idx['S'],\n                  assign_after[i] == assign_before[i]))\n        constraints.append(c)\n    return assign_after, constraints\n\ndef apply_plan_3(assign_before):\n    # Plan 3: Louis and Madelyn switch projects with each other\n    # So swap their assigned projects, others remain same\n    assign_after = [Int(f'plan3_after_{a}') for a in apprentices]\n    constraints = []\n    for i in range(n):\n        if i == apprentice_idx['Louis']:\n            constraints.append(assign_after[i] == assign_before[apprentice_idx['Madelyn']])\n        elif i == apprentice_idx['Madelyn']:\n            constraints.append(assign_after[i] == assign_before[apprentice_idx['Louis']])\n        else:\n            constraints.append(assign_after[i] == assign_before[i])\n    return assign_after, constraints\n\n# We know the first reassignment is plan 1 (already applied in assign1)\n\n# The second reassignment is either plan 2 or plan 3\n# The order of plans is: first plan 1, then either plan 2 or plan 3\n\n# We must check which of the options (A-E) must be true regardless of second plan choice\n\n# We'll create two scenarios:\n\n# Scenario A: second reassignment is plan 2 applied to assign1\nassign2_plan2, constraints_plan2 = apply_plan_2(assign1)\n\n# Scenario B: second reassignment is plan 3 applied to assign1\nassign2_plan3, constraints_plan3 = apply_plan_3(assign1)\n\n# Add constraints that assignments after second reassignment are valid and distinct\n# For plan 2 scenario\nfor i in range(n):\n    solver.add(And(assign2_plan2[i] >= 0, assign2_plan2[i] < n))\nsolver.add(Distinct(assign2_plan2))\nsolver.add(constraints_plan2)\n\n# For plan 3 scenario\nfor i in range(n):\n    solver.add(And(assign2_plan3[i] >= 0, assign2_plan3[i] < n))\nsolver.add(Distinct(assign2_plan3))\nsolver.add(constraints_plan3)\n\n# Now, for each option, check if it must be true regardless of which second plan is chosen\n\n# Define a helper function to check if a given condition is true in both scenarios\n\ndef check_must_be_true(condition_func):\n    # condition_func takes assign2 as argument and returns a Z3 BoolRef\n    # We check if condition_func(assign2_plan2) and condition_func(assign2_plan3) are both true in all models\n    # To do this, we check if negation is unsat in both scenarios\n\n    # Check negation of condition for plan 2\n    solver.push()\n    solver.add(Not(condition_func(assign2_plan2)))\n    res2 = solver.check()\n    solver.pop()\n\n    # Check negation of condition for plan 3\n    solver.push()\n    solver.add(Not(condition_func(assign2_plan3)))\n    res3 = solver.check()\n    solver.pop()\n\n    # If negation is unsat in both, condition must be true in both scenarios\n    return res2 == unsat and res3 == unsat\n\n# Define conditions for each option\n\n# (A) Louis is assigned to project T as a result of the second reassignment.\ndef cond_A(assign2_var):\n    return assign2_var[apprentice_idx['Louis']] == project_idx['T']\n\n# (B) Madelyn is assigned to project Q as a result of the second reassignment.\ndef cond_B(assign2_var):\n    return assign2_var[apprentice_idx['Madelyn']] == project_idx['Q']\n\n# (C) Madelyn is assigned to project T as a result of the second reassignment.\ndef cond_C(assign2_var):\n    return assign2_var[apprentice_idx['Madelyn']] == project_idx['T']\n\n# (D) Oliver is assigned to project S as a result of the second reassignment.\ndef cond_D(assign2_var):\n    return assign2_var[apprentice_idx['Oliver']] == project_idx['S']\n\n# (E) Oliver is assigned to project T as a result of the second reassignment.\ndef cond_E(assign2_var):\n    return assign2_var[apprentice_idx['Oliver']] == project_idx['T']\n\noptions = [cond_A, cond_B, cond_C, cond_D, cond_E]\n\nfor i, cond in enumerate(options):\n    if check_must_be_true(cond):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A piano instructor will schedule exactly one lesson for each of six students—Grace, Henry, Janet, Steve, Tom, and Una—one lesson per day for six consecutive days. The schedule must conform to the following conditions: Henry's lesson is later in the schedule than Janet's lesson. Una's lesson is later in the schedule than Steve's lesson. Steve's lesson is exactly three days after Grace's lesson. Janet's lesson is on the first day or else the third day.\n\nIf Janet's lesson is scheduled for the first day, then the lesson for which one of the following students must be scheduled for the sixth day?\n\nOptions:\n(A) Grace\n(B) Henry\n(C) Steve\n(D) Tom\n(E) Una",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Grace', 'Henry', 'Janet', 'Steve', 'Tom', 'Una']\nnum_days = 6\n\n# Create a Z3 Int variable for each student representing their lesson day (1 to 6)\nlesson_day = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each lesson day is between 1 and 6\nfor s in students:\n    solver.add(And(lesson_day[s] >= 1, lesson_day[s] <= num_days))\n\n# All lesson days are distinct (one lesson per day)\nsolver.add(Distinct([lesson_day[s] for s in students]))\n\n# Henry's lesson is later than Janet's lesson\nsolver.add(lesson_day['Henry'] > lesson_day['Janet'])\n\n# Una's lesson is later than Steve's lesson\nsolver.add(lesson_day['Una'] > lesson_day['Steve'])\n\n# Steve's lesson is exactly three days after Grace's lesson\nsolver.add(lesson_day['Steve'] == lesson_day['Grace'] + 3)\n\n# Janet's lesson is on the first day or else the third day\njanet_first_or_third = Or(lesson_day['Janet'] == 1, lesson_day['Janet'] == 3)\nsolver.add(janet_first_or_third)\n\n# OPTION CHECKING\n# We are told: If Janet's lesson is scheduled for the first day,\n# then which student's lesson must be scheduled for the sixth day?\n\n# Fix Janet's lesson to day 1\nsolver.add(lesson_day['Janet'] == 1)\n\noptions = ['Grace', 'Henry', 'Steve', 'Tom', 'Una']\n\nfor i, option_student in enumerate(options):\n    solver.push()\n    # Add constraint that the option student's lesson is NOT on day 6\n    solver.add(lesson_day[option_student] != 6)\n    # Check if the constraints are still satisfiable\n    if solver.check() == unsat:\n        # If unsat, that means the option student's lesson MUST be on day 6\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A piano instructor will schedule exactly one lesson for each of six students—Grace, Henry, Janet, Steve, Tom, and Una—one lesson per day for six consecutive days. The schedule must conform to the following conditions: Henry's lesson is later in the schedule than Janet's lesson. Una's lesson is later in the schedule than Steve's lesson. Steve's lesson is exactly three days after Grace's lesson. Janet's lesson is on the first day or else the third day.\n\nFor which one of the following students is there an acceptable schedule in which the student's lesson is on the third day and another acceptable schedule in which the student's lesson is on the fifth day?\n\nOptions:\n(A) Grace\n(B) Henry\n(C) Steve\n(D) Tom\n(E) Una",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Grace', 'Henry', 'Janet', 'Steve', 'Tom', 'Una']\ndays = 6\n\n# Create a dictionary mapping each student to a Z3 Int variable representing their lesson day (1 to 6)\nlesson_day = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each lesson day must be between 1 and 6\nfor s in students:\n    solver.add(And(lesson_day[s] >= 1, lesson_day[s] <= days))\n\n# All lesson days must be distinct (one lesson per day)\nsolver.add(Distinct([lesson_day[s] for s in students]))\n\n# Henry's lesson is later than Janet's lesson\nsolver.add(lesson_day['Henry'] > lesson_day['Janet'])\n\n# Una's lesson is later than Steve's lesson\nsolver.add(lesson_day['Una'] > lesson_day['Steve'])\n\n# Steve's lesson is exactly three days after Grace's lesson\nsolver.add(lesson_day['Steve'] == lesson_day['Grace'] + 3)\n\n# Janet's lesson is on the first day or the third day\njanet_first = lesson_day['Janet'] == 1\njanet_third = lesson_day['Janet'] == 3\nsolver.add(Or(janet_first, janet_third))\n\n# OPTION CHECKING\n# For each student, check if there is an acceptable schedule with lesson on day 3 and another with lesson on day 5\nfor i, s in enumerate(students):\n    # Check lesson on day 3\n    solver.push()\n    solver.add(lesson_day[s] == 3)\n    if solver.check() == sat:\n        # Check lesson on day 5\n        solver.pop()\n        solver.push()\n        solver.add(lesson_day[s] == 5)\n        if solver.check() == sat:\n            print(f\"'{chr(65+i)}'\")\n            solver.pop()\n            break\n        solver.pop()\n    else:\n        solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A piano instructor will schedule exactly one lesson for each of six students—Grace, Henry, Janet, Steve, Tom, and Una—one lesson per day for six consecutive days. The schedule must conform to the following conditions: Henry's lesson is later in the schedule than Janet's lesson. Una's lesson is later in the schedule than Steve's lesson. Steve's lesson is exactly three days after Grace's lesson. Janet's lesson is on the first day or else the third day.\n\nWhich one of the following is a complete and accurate list of the students any one of whom could be the student whose lesson is scheduled for the second day?\n\nOptions:\n(A) Grace\n(B) Tom\n(C) Grace, Tom\n(D) Henry, Tom\n(E) Grace, Henry, Tom",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Grace', 'Henry', 'Janet', 'Steve', 'Tom', 'Una']\ndays = range(1, 7)  # Days 1 through 6\n\n# Create a Z3 Int variable for each student representing the day of their lesson\nlesson_day = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student's lesson day is between 1 and 6\nfor s in students:\n    solver.add(And(lesson_day[s] >= 1, lesson_day[s] <= 6))\n\n# All lessons are scheduled on distinct days\nsolver.add(Distinct([lesson_day[s] for s in students]))\n\n# Henry's lesson is later than Janet's lesson\nsolver.add(lesson_day['Henry'] > lesson_day['Janet'])\n\n# Una's lesson is later than Steve's lesson\nsolver.add(lesson_day['Una'] > lesson_day['Steve'])\n\n# Steve's lesson is exactly three days after Grace's lesson\nsolver.add(lesson_day['Steve'] == lesson_day['Grace'] + 3)\n\n# Janet's lesson is on the first day or else the third day\njanet_first = lesson_day['Janet'] == 1\njanet_third = lesson_day['Janet'] == 3\nsolver.add(Or(janet_first, janet_third))\n\n# OPTION CHECKING\n# The question: which students could have their lesson on the 2nd day?\n\n# We'll check for each student if there is a solution with lesson_day[student] == 2\npossible_students = []\n\nfor s in students:\n    solver.push()\n    solver.add(lesson_day[s] == 2)\n    if solver.check() == sat:\n        possible_students.append(s)\n    solver.pop()\n\n# The options to compare:\n# (A) Grace\n# (B) Tom\n# (C) Grace, Tom\n# (D) Henry, Tom\n# (E) Grace, Henry, Tom\n\n# We will match the possible_students set to each option\npossible_set = set(possible_students)\n\noptions = {\n    'A': {'Grace'},\n    'B': {'Tom'},\n    'C': {'Grace', 'Tom'},\n    'D': {'Henry', 'Tom'},\n    'E': {'Grace', 'Henry', 'Tom'}\n}\n\nfor letter, option_set in options.items():\n    if possible_set == option_set:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A piano instructor will schedule exactly one lesson for each of six students—Grace, Henry, Janet, Steve, Tom, and Una—one lesson per day for six consecutive days. The schedule must conform to the following conditions: Henry's lesson is later in the schedule than Janet's lesson. Una's lesson is later in the schedule than Steve's lesson. Steve's lesson is exactly three days after Grace's lesson. Janet's lesson is on the first day or else the third day.\n\nIf Janet's lesson is scheduled for the third day, which one of the following could be true?\n\nOptions:\n(A) Grace's lesson is scheduled for a later day than Henry's lesson.\n(B) Grace's lesson is scheduled for a later day than Una's lesson.\n(C) Henry's lesson is scheduled for a later day than Una's lesson.\n(D) Tom's lesson is scheduled for a later day than Henry's lesson.\n(E) Tom's lesson is scheduled for a later day than Una's lesson.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Grace', 'Henry', 'Janet', 'Steve', 'Tom', 'Una']\ndays = 6\n\n# Create Int variables for each student representing the day of their lesson (1 to 6)\nlesson_day = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each lesson day is between 1 and 6\nfor s in students:\n    solver.add(And(lesson_day[s] >= 1, lesson_day[s] <= days))\n\n# All lessons are on different days\nsolver.add(Distinct([lesson_day[s] for s in students]))\n\n# Henry's lesson is later than Janet's lesson\nsolver.add(lesson_day['Henry'] > lesson_day['Janet'])\n\n# Una's lesson is later than Steve's lesson\nsolver.add(lesson_day['Una'] > lesson_day['Steve'])\n\n# Steve's lesson is exactly three days after Grace's lesson\nsolver.add(lesson_day['Steve'] == lesson_day['Grace'] + 3)\n\n# Janet's lesson is on the first day or else the third day\n# We are told: \"If Janet's lesson is scheduled for the third day\" so we fix Janet = 3\nsolver.add(lesson_day['Janet'] == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': lesson_day['Grace'] > lesson_day['Henry'],\n    'B': lesson_day['Grace'] > lesson_day['Una'],\n    'C': lesson_day['Henry'] > lesson_day['Una'],\n    'D': lesson_day['Tom'] > lesson_day['Henry'],\n    'E': lesson_day['Tom'] > lesson_day['Una']\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Five children—F, G, H, J, and K—and four adults—Q, R, S, and T—are planning a canoeing trip. The canoeists will be divided into three groups—groups 1, 2, and 3—of three canoeists each, according to the following conditions: There must be at least one adult in each group. F must be in the same group as J. G cannot be in the same group as T. H cannot be in the same group as R. Neither H nor T can be in group 2.\n\nIf F is in group 1, which one of the following could be true?\n\nOptions:\n(A) G and K are in group 3.\n(B) G and R are in group 3.\n(C) J and S are in group 2.\n(D) K and R are in group 1.\n(E) Q and S are in group 2.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['F', 'G', 'H', 'J', 'K']\nadults = ['Q', 'R', 'S', 'T']\nall_canoeists = children + adults\ngroups = [1, 2, 3]\n\n# Create Int variables for each canoeist's group assignment (1, 2, or 3)\ngroup = {c: Int(c) for c in all_canoeists}\n\n# Helper function to check if a list of canoeists are all in the same group\ndef same_group(canoeists):\n    return And([group[c] == group[canoeists[0]] for c in canoeists[1:]])\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each canoeist is assigned to one of the three groups\nfor c in all_canoeists:\n    solver.add(And(group[c] >= 1, group[c] <= 3))\n\n# Each group has exactly 3 canoeists\nfor g in groups:\n    count_in_group = Sum([If(group[c] == g, 1, 0) for c in all_canoeists])\n    solver.add(count_in_group == 3)\n\n# At least one adult in each group\nfor g in groups:\n    adult_in_group = Or([group[a] == g for a in adults])\n    solver.add(adult_in_group)\n\n# F must be in the same group as J\nsolver.add(group['F'] == group['J'])\n\n# G cannot be in the same group as T\nsolver.add(group['G'] != group['T'])\n\n# H cannot be in the same group as R\nsolver.add(group['H'] != group['R'])\n\n# Neither H nor T can be in group 2\nsolver.add(group['H'] != 2)\nsolver.add(group['T'] != 2)\n\n# F is in group 1 (given condition)\nsolver.add(group['F'] == 1)\n\n# OPTION CHECKING\noptions = {\n    'A': And(group['G'] == 3, group['K'] == 3),\n    'B': And(group['G'] == 3, group['R'] == 3),\n    'C': And(group['J'] == 2, group['S'] == 2),\n    'D': And(group['K'] == 1, group['R'] == 1),\n    'E': And(group['Q'] == 2, group['S'] == 2)\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Five children—F, G, H, J, and K—and four adults—Q, R, S, and T—are planning a canoeing trip. The canoeists will be divided into three groups—groups 1, 2, and 3—of three canoeists each, according to the following conditions: There must be at least one adult in each group. F must be in the same group as J. G cannot be in the same group as T. H cannot be in the same group as R. Neither H nor T can be in group 2.\n\nIf F and S are in group 3, which one of the following must be true?\n\nOptions:\n(A) G is in group 2.\n(B) H is in group 3.\n(C) K is in group 1.\n(D) Q is in group 2.\n(E) R is in group 1.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['F', 'G', 'H', 'J', 'K']\nadults = ['Q', 'R', 'S', 'T']\nall_people = children + adults\ngroups = [1, 2, 3]\n\n# Create a Z3 Int variable for each person representing their group (1, 2, or 3)\ngroup_vars = {p: Int(p) for p in all_people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person must be in group 1, 2, or 3\nfor p in all_people:\n    solver.add(Or([group_vars[p] == g for g in groups]))\n\n# Each group has exactly 3 canoeists\nfor g in groups:\n    count_in_group = Sum([If(group_vars[p] == g, 1, 0) for p in all_people])\n    solver.add(count_in_group == 3)\n\n# There must be at least one adult in each group\nfor g in groups:\n    adult_in_group = Or([group_vars[a] == g for a in adults])\n    solver.add(adult_in_group)\n\n# F must be in the same group as J\nsolver.add(group_vars['F'] == group_vars['J'])\n\n# G cannot be in the same group as T\nsolver.add(group_vars['G'] != group_vars['T'])\n\n# H cannot be in the same group as R\nsolver.add(group_vars['H'] != group_vars['R'])\n\n# Neither H nor T can be in group 2\nsolver.add(group_vars['H'] != 2)\nsolver.add(group_vars['T'] != 2)\n\n# Given: F and S are in group 3\nsolver.add(group_vars['F'] == 3)\nsolver.add(group_vars['S'] == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': group_vars['G'] == 2,\n    'B': group_vars['H'] == 3,\n    'C': group_vars['K'] == 1,\n    'D': group_vars['Q'] == 2,\n    'E': group_vars['R'] == 1\n}\n\n# We want to find which option must be true given the constraints\n# So for each option, check if the negation is satisfiable with the constraints.\n# If negation is unsat, then the option must be true.\n\nfor letter, condition in options.items():\n    solver.push()\n    # Add negation of the option condition\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Five children—F, G, H, J, and K—and four adults—Q, R, S, and T—are planning a canoeing trip. The canoeists will be divided into three groups—groups 1, 2, and 3—of three canoeists each, according to the following conditions: There must be at least one adult in each group. F must be in the same group as J. G cannot be in the same group as T. H cannot be in the same group as R. Neither H nor T can be in group 2.\n\nIf G and K are in group 3, which one of the following must be true?\n\nOptions:\n(A) H is in group 3.\n(B) J is in group 1.\n(C) R is in group 2.\n(D) S is in group 3.\n(E) T is in group 1.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['F', 'G', 'H', 'J', 'K']\nadults = ['Q', 'R', 'S', 'T']\nall_people = children + adults\ngroups = [1, 2, 3]\n\n# Create a Z3 Int variable for each person representing their group (1, 2, or 3)\ngroup_vars = {p: Int(p) for p in all_people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person must be in a valid group (1, 2, or 3)\nfor p in all_people:\n    solver.add(And(group_vars[p] >= 1, group_vars[p] <= 3))\n\n# Groups are of size 3 each: total 3 groups * 3 people = 9 people\n# Enforce group sizes by counting how many people are in each group\nfor g in groups:\n    count_in_group = Sum([If(group_vars[p] == g, 1, 0) for p in all_people])\n    solver.add(count_in_group == 3)\n\n# There must be at least one adult in each group\nfor g in groups:\n    adult_in_group = Or([group_vars[a] == g for a in adults])\n    solver.add(adult_in_group)\n\n# F must be in the same group as J\nsolver.add(group_vars['F'] == group_vars['J'])\n\n# G cannot be in the same group as T\nsolver.add(group_vars['G'] != group_vars['T'])\n\n# H cannot be in the same group as R\nsolver.add(group_vars['H'] != group_vars['R'])\n\n# Neither H nor T can be in group 2\nsolver.add(group_vars['H'] != 2)\nsolver.add(group_vars['T'] != 2)\n\n# Given condition: G and K are in group 3\nsolver.add(group_vars['G'] == 3)\nsolver.add(group_vars['K'] == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': group_vars['H'] == 3,\n    'B': group_vars['J'] == 1,\n    'C': group_vars['R'] == 2,\n    'D': group_vars['S'] == 3,\n    'E': group_vars['T'] == 1\n}\n\nfor option_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add negation of the option to see if it can be false\n    solver.add(Not(options[option_letter]))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Five children—F, G, H, J, and K—and four adults—Q, R, S, and T—are planning a canoeing trip. The canoeists will be divided into three groups—groups 1, 2, and 3—of three canoeists each, according to the following conditions: There must be at least one adult in each group. F must be in the same group as J. G cannot be in the same group as T. H cannot be in the same group as R. Neither H nor T can be in group 2.\n\nIf Q is in group 1 and S is in group 3, which one of the following CANNOT be true?\n\nOptions:\n(A) G is in group 2.\n(B) T is in group 1.\n(C) There is exactly one child in group 1.\n(D) There is exactly one child in group 2.\n(E) There is exactly one child in group 3.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Define canoeists\nchildren = ['F', 'G', 'H', 'J', 'K']\nadults = ['Q', 'R', 'S', 'T']\nall_canoeists = children + adults\n\n# Groups indices: 1, 2, 3\ngroups = [1, 2, 3]\n\n# Create Z3 Int variables for group assignments for each canoeist\ngroup = {}\nfor c in all_canoeists:\n    group[c] = Int(c)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each canoeist must be assigned to one of the three groups\nfor c in all_canoeists:\n    solver.add(And(group[c] >= 1, group[c] <= 3))\n\n# Each group has exactly 3 canoeists\nfor g in groups:\n    count_in_group = Sum([If(group[c] == g, 1, 0) for c in all_canoeists])\n    solver.add(count_in_group == 3)\n\n# There must be at least one adult in each group\nfor g in groups:\n    adult_in_group = Or([group[a] == g for a in adults])\n    solver.add(adult_in_group)\n\n# F must be in the same group as J\nsolver.add(group['F'] == group['J'])\n\n# G cannot be in the same group as T\nsolver.add(group['G'] != group['T'])\n\n# H cannot be in the same group as R\nsolver.add(group['H'] != group['R'])\n\n# Neither H nor T can be in group 2\nsolver.add(group['H'] != 2)\nsolver.add(group['T'] != 2)\n\n# Given: Q is in group 1 and S is in group 3\nsolver.add(group['Q'] == 1)\nsolver.add(group['S'] == 3)\n\n# OPTION CHECKING\noptions = [\n    # (A) G is in group 2.\n    group['G'] == 2,\n    # (B) T is in group 1.\n    group['T'] == 1,\n    # (C) There is exactly one child in group 1.\n    Sum([If(group[c] == 1, 1, 0) for c in children]) == 1,\n    # (D) There is exactly one child in group 2.\n    Sum([If(group[c] == 2, 1, 0) for c in children]) == 1,\n    # (E) There is exactly one child in group 3.\n    Sum([If(group[c] == 3, 1, 0) for c in children]) == 1,\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Five children—F, G, H, J, and K—and four adults—Q, R, S, and T—are planning a canoeing trip. The canoeists will be divided into three groups—groups 1, 2, and 3—of three canoeists each, according to the following conditions: There must be at least one adult in each group. F must be in the same group as J. G cannot be in the same group as T. H cannot be in the same group as R. Neither H nor T can be in group 2.\n\nIf G is the only child in group 1, which one of the following must be true?\n\nOptions:\n(A) F is in group 3.\n(B) K is in group 3.\n(C) Q is in group 2.\n(D) R is in group 1.\n(E) S is in group 2.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['F', 'G', 'H', 'J', 'K']\nadults = ['Q', 'R', 'S', 'T']\ncanoeists = children + adults\ngroups = [1, 2, 3]\n\n# Create a Z3 Int variable for each canoeist representing their group (1, 2, or 3)\ngroup_vars = {c: Int(c) for c in canoeists}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each canoeist must be in group 1, 2, or 3\nfor c in canoeists:\n    solver.add(And(group_vars[c] >= 1, group_vars[c] <= 3))\n\n# Each group has exactly 3 canoeists\nfor g in groups:\n    count_in_group = Sum([If(group_vars[c] == g, 1, 0) for c in canoeists])\n    solver.add(count_in_group == 3)\n\n# Each group must have at least one adult\nfor g in groups:\n    count_adults_in_group = Sum([If(And(group_vars[a] == g, a in adults), 1, 0) for a in adults])\n    solver.add(count_adults_in_group >= 1)\n\n# F must be in the same group as J\nsolver.add(group_vars['F'] == group_vars['J'])\n\n# G cannot be in the same group as T\nsolver.add(group_vars['G'] != group_vars['T'])\n\n# H cannot be in the same group as R\nsolver.add(group_vars['H'] != group_vars['R'])\n\n# Neither H nor T can be in group 2\nsolver.add(group_vars['H'] != 2)\nsolver.add(group_vars['T'] != 2)\n\n# Additional condition: G is the only child in group 1\n# So G is in group 1, and no other children are in group 1\nsolver.add(group_vars['G'] == 1)\nfor c in children:\n    if c != 'G':\n        solver.add(group_vars[c] != 1)\n\n# OPTION CHECKING\noptions = {\n    'A': group_vars['F'] == 3,\n    'B': group_vars['K'] == 3,\n    'C': group_vars['Q'] == 2,\n    'D': group_vars['R'] == 1,\n    'E': group_vars['S'] == 2\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Lara, Mendel, and Nastassia each buy at least one kind of food from a street vendor who sells only fruit cups, hot dogs, pretzels, and shish kebabs. They make their selections in accordance with the following restrictions: None of the three buys more than one portion of each kind of food. If any of the three buys a hot dog, that person does not also buy a shish kebab. At least one of the three buys a hot dog, and at least one buys a pretzel. Mendel buys a shish kebab. Nastassia buys a fruit cup. Neither Lara nor Nastassia buys a pretzel. Mendel does not buy any kind of food that Nastassia buys.\n\nWhich one of the following statements must be true?\n\nOptions:\n(A) Lara buys a hot dog.\n(B) Lara buys a shish kebab.\n(C) Mendel buys a hot dog.\n(D) Mendel buys a pretzel.\n(E) Nastassia buys a hot dog.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['Lara', 'Mendel', 'Nastassia']\nfoods = ['fruit_cup', 'hot_dog', 'pretzel', 'shish_kebab']\n\n# Create variables: person_food[p][f] = Bool indicating if person p buys food f\nperson_food = {}\nfor p in persons:\n    for f in foods:\n        person_food[(p, f)] = Bool(f\"{p}_{f}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# None buys more than one portion of each kind of food (already modeled by Bool variables)\n\n# If any person buys hot dog, that person does not buy shish kebab\nfor p in persons:\n    hot_dog = person_food[(p, 'hot_dog')]\n    shish_kebab = person_food[(p, 'shish_kebab')]\n    solver.add(Implies(hot_dog, Not(shish_kebab)))\n\n# At least one of the three buys a hot dog\nsolver.add(Or([person_food[(p, 'hot_dog')] for p in persons]))\n\n# At least one buys a pretzel\nsolver.add(Or([person_food[(p, 'pretzel')] for p in persons]))\n\n# Mendel buys a shish kebab\nsolver.add(person_food[('Mendel', 'shish_kebab')])\n\n# Nastassia buys a fruit cup\nsolver.add(person_food[('Nastassia', 'fruit_cup')])\n\n# Neither Lara nor Nastassia buys a pretzel\nsolver.add(Not(person_food[('Lara', 'pretzel')]))\nsolver.add(Not(person_food[('Nastassia', 'pretzel')]))\n\n# Mendel does not buy any food that Nastassia buys\nfor f in foods:\n    solver.add(Implies(person_food[('Nastassia', f)], Not(person_food[('Mendel', f)])))\n\n# Each person buys at least one kind of food\nfor p in persons:\n    solver.add(Or([person_food[(p, f)] for f in foods]))\n\n# OPTION CHECKING\n\noptions = [\n    ('A', person_food[('Lara', 'hot_dog')]),\n    ('B', person_food[('Lara', 'shish_kebab')]),\n    ('C', person_food[('Mendel', 'hot_dog')]),\n    ('D', person_food[('Mendel', 'pretzel')]),\n    ('E', person_food[('Nastassia', 'hot_dog')]),\n]\n\nfor letter, option_expr in options:\n    solver.push()\n    # Add negation of the option to check if it must be true\n    solver.add(Not(option_expr))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Lara, Mendel, and Nastassia each buy at least one kind of food from a street vendor who sells only fruit cups, hot dogs, pretzels, and shish kebabs. They make their selections in accordance with the following restrictions: None of the three buys more than one portion of each kind of food. If any of the three buys a hot dog, that person does not also buy a shish kebab. At least one of the three buys a hot dog, and at least one buys a pretzel. Mendel buys a shish kebab. Nastassia buys a fruit cup. Neither Lara nor Nastassia buys a pretzel. Mendel does not buy any kind of food that Nastassia buys.\n\nIf the vendor charges $1 for each portion of food, what is the minimum amount the three people could spend?\n\nOptions:\n(A) $3\n(B) $4\n(C) $5\n(D) $6\n(E) $7",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Lara', 'Mendel', 'Nastassia']\nfoods = ['fruit_cup', 'hot_dog', 'pretzel', 'shish_kebab']\n\n# Create variables: For each person and food, 1 if bought, 0 if not\nbuy = {}\nfor p in people:\n    for f in foods:\n        buy[(p, f)] = Int(f\"{p}_{f}\")\n        \n# Total cost variable\ntotal_cost = Int(\"total_cost\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each buy variable is 0 or 1 (no more than one portion)\nfor p in people:\n    for f in foods:\n        solver.add(Or(buy[(p, f)] == 0, buy[(p, f)] == 1))\n\n# If a person buys a hot dog, they do not buy a shish kebab\nfor p in people:\n    solver.add(Implies(buy[(p, 'hot_dog')] == 1, buy[(p, 'shish_kebab')] == 0))\n\n# At least one person buys a hot dog\nhot_dog_buys = [buy[(p, 'hot_dog')] == 1 for p in people]\nsolver.add(Or(hot_dog_buys))\n\n# At least one person buys a pretzel\npretzel_buys = [buy[(p, 'pretzel')] == 1 for p in people]\nsolver.add(Or(pretzel_buys))\n\n# Mendel buys a shish kebab\nsolver.add(buy[('Mendel', 'shish_kebab')] == 1)\n\n# Nastassia buys a fruit cup\nsolver.add(buy[('Nastassia', 'fruit_cup')] == 1)\n\n# Neither Lara nor Nastassia buys a pretzel\nsolver.add(buy[('Lara', 'pretzel')] == 0)\nsolver.add(buy[('Nastassia', 'pretzel')] == 0)\n\n# Mendel does not buy any kind of food that Nastassia buys\nfor f in foods:\n    # If Nastassia buys f (==1), Mendel must not buy f (==0)\n    solver.add(Implies(buy[('Nastassia', f)] == 1, buy[('Mendel', f)] == 0))\n\n# Each person buys at least one kind of food (at least one portion)\nfor p in people:\n    person_buys = [buy[(p, f)] for f in foods]\n    solver.add(Sum(person_buys) >= 1)\n\n# Define total cost as sum of all portions bought\nall_buys = [buy[(p, f)] for p in people for f in foods]\nsolver.add(total_cost == Sum(all_buys))\n\n# OPTION CHECKING\noptions = [3,4,5,6,7]\n\nfor i, cost_option in enumerate(options):\n    solver.push()\n    solver.add(total_cost == cost_option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Lara, Mendel, and Nastassia each buy at least one kind of food from a street vendor who sells only fruit cups, hot dogs, pretzels, and shish kebabs. They make their selections in accordance with the following restrictions: None of the three buys more than one portion of each kind of food. If any of the three buys a hot dog, that person does not also buy a shish kebab. At least one of the three buys a hot dog, and at least one buys a pretzel. Mendel buys a shish kebab. Nastassia buys a fruit cup. Neither Lara nor Nastassia buys a pretzel. Mendel does not buy any kind of food that Nastassia buys.\n\nIf Lara and Mendel buy exactly two kinds of food each, which one of the following statements must be true.\n\nOptions:\n(A) Lara buys a fruit cup.\n(B) Lara buys a hot dog.\n(C) Mendel buys a fruit cup.\n(D) There is exactly one kind of food that Lara and Mendel both buy.\n(E) There is exactly one kind of food that Lara and Nastassia both buy.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Lara', 'Mendel', 'Nastassia']\nfoods = ['fruit_cup', 'hot_dog', 'pretzel', 'shish_kebab']\n\n# Create variables: for each person and food, a Bool indicating if they buy it\nbuy = {}\nfor p in people:\n    for f in foods:\n        buy[(p, f)] = Bool(f\"{p}_{f}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# None buys more than one portion of each kind (already modeled as Bool, so max one portion)\n# Each person buys at least one kind of food\nfor p in people:\n    solver.add(Or([buy[(p, f)] for f in foods]))\n\n# If any person buys a hot dog, that person does not also buy a shish kebab\nfor p in people:\n    hot_dog = buy[(p, 'hot_dog')]\n    shish_kebab = buy[(p, 'shish_kebab')]\n    solver.add(Implies(hot_dog, Not(shish_kebab)))\n\n# At least one buys a hot dog\nsolver.add(Or([buy[(p, 'hot_dog')] for p in people]))\n\n# At least one buys a pretzel\nsolver.add(Or([buy[(p, 'pretzel')] for p in people]))\n\n# Mendel buys a shish kebab\nsolver.add(buy[('Mendel', 'shish_kebab')])\n\n# Nastassia buys a fruit cup\nsolver.add(buy[('Nastassia', 'fruit_cup')])\n\n# Neither Lara nor Nastassia buys a pretzel\nsolver.add(Not(buy[('Lara', 'pretzel')]))\nsolver.add(Not(buy[('Nastassia', 'pretzel')]))\n\n# Mendel does not buy any kind of food that Nastassia buys\nfor f in foods:\n    solver.add(Implies(buy[('Mendel', f)], Not(buy[('Nastassia', f)])))\n\n# Lara and Mendel buy exactly two kinds of food each\ndef exactly_two(person):\n    return PbEq([(buy[(person, f)], 1) for f in foods], 2)\n\nsolver.add(exactly_two('Lara'))\nsolver.add(exactly_two('Mendel'))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Lara buys a fruit cup.\n    buy[('Lara', 'fruit_cup')],\n    # (B) Lara buys a hot dog.\n    buy[('Lara', 'hot_dog')],\n    # (C) Mendel buys a fruit cup.\n    buy[('Mendel', 'fruit_cup')],\n    # (D) There is exactly one kind of food that Lara and Mendel both buy.\n    # Calculate intersection count\n    PbEq([(And(buy[('Lara', f)], buy[('Mendel', f)]), 1) for f in foods], 1),\n    # (E) There is exactly one kind of food that Lara and Nastassia both buy.\n    PbEq([(And(buy[('Lara', f)], buy[('Nastassia', f)]), 1) for f in foods], 1),\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add negation of option to check if option must be true\n    solver.add(Not(opt))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Lara, Mendel, and Nastassia each buy at least one kind of food from a street vendor who sells only fruit cups, hot dogs, pretzels, and shish kebabs. They make their selections in accordance with the following restrictions: None of the three buys more than one portion of each kind of food. If any of the three buys a hot dog, that person does not also buy a shish kebab. At least one of the three buys a hot dog, and at least one buys a pretzel. Mendel buys a shish kebab. Nastassia buys a fruit cup. Neither Lara nor Nastassia buys a pretzel. Mendel does not buy any kind of food that Nastassia buys.\n\nIf Lara buys a shish kebab, which one of the following statements must be true?\n\nOptions:\n(A) Lara buys a fruit cup.\n(B) Mendel buys a fruit cup.\n(C) Nastassia buys a hot dog.\n(D) Nastassia buys exactly one kind of food.\n(E) Exactly one person buys a fruit cup.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Lara', 'Mendel', 'Nastassia']\nfoods = ['fruit_cup', 'hot_dog', 'pretzel', 'shish_kebab']\n\n# Create variables: person_food[person][food] = Bool indicating if person buys that food\nperson_food = {}\nfor p in people:\n    for f in foods:\n        person_food[(p, f)] = Bool(f\"{p}_{f}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# None buys more than one portion of each kind of food (each variable is Bool, so this is implicit)\n\n# If any person buys hot dog, that person does not also buy shish kebab\nfor p in people:\n    hd = person_food[(p, 'hot_dog')]\n    sk = person_food[(p, 'shish_kebab')]\n    solver.add(Implies(hd, Not(sk)))\n\n# At least one buys a hot dog\nsolver.add(Or([person_food[(p, 'hot_dog')] for p in people]))\n\n# At least one buys a pretzel\nsolver.add(Or([person_food[(p, 'pretzel')] for p in people]))\n\n# Mendel buys a shish kebab\nsolver.add(person_food[('Mendel', 'shish_kebab')])\n\n# Nastassia buys a fruit cup\nsolver.add(person_food[('Nastassia', 'fruit_cup')])\n\n# Neither Lara nor Nastassia buys a pretzel\nsolver.add(Not(person_food[('Lara', 'pretzel')]))\nsolver.add(Not(person_food[('Nastassia', 'pretzel')]))\n\n# Mendel does not buy any kind of food that Nastassia buys\nfor f in foods:\n    solver.add(Or(Not(person_food[('Mendel', f)]), Not(person_food[('Nastassia', f)])))\n\n# Each person buys at least one kind of food\nfor p in people:\n    solver.add(Or([person_food[(p, f)] for f in foods]))\n\n# If Lara buys a shish kebab, test options:\n# We will check each option by adding Lara buys shish kebab, and option is false, and check if unsat.\n\n# First add Lara buys shish kebab\nsolver.add(person_food[('Lara', 'shish_kebab')])\n\n# OPTION CHECKING\n\noptions = {\n    'A': person_food[('Lara', 'fruit_cup')],\n    'B': person_food[('Mendel', 'fruit_cup')],\n    'C': person_food[('Nastassia', 'hot_dog')],\n    'D': And([If(person_food[('Nastassia', f)], True, False) for f in foods])  # Nastassia buys exactly one kind of food\n}\n\n# For option D: Nastassia buys exactly one kind of food\nnastassia_foods = [person_food[('Nastassia', f)] for f in foods]\nexactly_one = PbEq([(f, 1) for f in nastassia_foods], 1)\noptions['D'] = exactly_one\n\n# For option E: Exactly one person buys a fruit cup\nfruit_cup_vars = [person_food[(p, 'fruit_cup')] for p in people]\nexactly_one_fruit_cup = PbEq([(f, 1) for f in fruit_cup_vars], 1)\noptions['E'] = exactly_one_fruit_cup\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add negation of the option, check if still satisfiable\n    solver.add(Not(options[letter]))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Lara, Mendel, and Nastassia each buy at least one kind of food from a street vendor who sells only fruit cups, hot dogs, pretzels, and shish kebabs. They make their selections in accordance with the following restrictions: None of the three buys more than one portion of each kind of food. If any of the three buys a hot dog, that person does not also buy a shish kebab. At least one of the three buys a hot dog, and at least one buys a pretzel. Mendel buys a shish kebab. Nastassia buys a fruit cup. Neither Lara nor Nastassia buys a pretzel. Mendel does not buy any kind of food that Nastassia buys.\n\nAssume that the condition is removed that prevents a customer who buys a hot dog from buying a shish kebab but all other conditions remain the same. If the vendor charges $1 for each portion of food, what is the maximum amount the three people could spend?\n\nOptions:\n(A) $5\n(B) $6\n(C) $7\n(D) $8\n(E) $9",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# People\npeople = ['Lara', 'Mendel', 'Nastassia']\n\n# Foods\nfoods = ['fruit_cup', 'hot_dog', 'pretzel', 'shish_kebab']\nfood_indices = {food: i for i, food in enumerate(foods)}\n\n# Create a dictionary of Bool variables: buys[person][food] == True if person buys that food\nbuys = {}\nfor person in people:\n    buys[person] = {}\n    for food in foods:\n        buys[person][food] = Bool(f\"{person}_{food}\")\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# None buys more than one portion of each kind of food (already ensured by Bool variables)\n\n# Condition removed: \"If any of the three buys a hot dog, that person does not also buy a shish kebab.\"\n# So we do NOT add that constraint.\n\n# At least one of the three buys a hot dog\nsolver.add(Or([buys[p]['hot_dog'] for p in people]))\n\n# At least one of the three buys a pretzel\nsolver.add(Or([buys[p]['pretzel'] for p in people]))\n\n# Mendel buys a shish kebab\nsolver.add(buys['Mendel']['shish_kebab'])\n\n# Nastassia buys a fruit cup\nsolver.add(buys['Nastassia']['fruit_cup'])\n\n# Neither Lara nor Nastassia buys a pretzel\nsolver.add(Not(buys['Lara']['pretzel']))\nsolver.add(Not(buys['Nastassia']['pretzel']))\n\n# Mendel does not buy any kind of food that Nastassia buys\nfor food in foods:\n    solver.add(Or(Not(buys['Mendel'][food]), Not(buys['Nastassia'][food])))\n\n# Each person buys at least one kind of food\nfor person in people:\n    solver.add(Or([buys[person][food] for food in foods]))\n\n# OPTION CHECKING\n\n# We want to maximize total amount spent (each portion costs $1).\n# Total cost = sum of all buys[p][f] (True=1, False=0)\n\n# We'll use an optimization solver to maximize the sum\n\nopt = Optimize()\n\n# Add all constraints from solver to opt\nfor c in solver.assertions():\n    opt.add(c)\n\n# Define total cost variable as sum of all buys\ntotal_cost = Sum([If(buys[p][f], 1, 0) for p in people for f in foods])\n\nh = opt.maximize(total_cost)\n\nif opt.check() == sat:\n    m = opt.model()\n    max_cost = m.evaluate(total_cost).as_long()\nelse:\n    max_cost = 0\n\n# Map max_cost to options\noptions = {'A':5, 'B':6, 'C':7, 'D':8, 'E':9}\n\n# Find the letter corresponding to max_cost\ncorrect_option = None\nfor letter, value in options.items():\n    if value == max_cost:\n        correct_option = letter\n        break\n\nprint(f\"'{correct_option}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A science student has exactly four flasks—1, 2, 3, and 4—originally containing a red, a blue, a green, and an orange chemical, respectively. An experiment consists of mixing exactly two of these chemicals together by completely emptying the contents of one of the flasks into another of the flasks. The following conditions apply: The product of an experiment cannot be used in further experiments. Mixing the contents of 1 and 2 produces a red chemical. Mixing the contents of 2 and 3 produces an orange chemical. Mixing the contents of 3 with the contents of either 1 or 4 produces a blue chemical. Mixing the contents of 4 with the contents of either 1 or 2 produces a green chemical.\n\nIf the student performs exactly one experiment, which one of the following could be the colors of the chemicals in the resulting three nonempty flasks?\n\nOptions:\n(A) blue, blue, green\n(B) blue, orange, orange\n(C) blue, orange, red\n(D) green, green, red\n(E) green, orange, orange",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Flasks 1,2,3,4 with initial colors: red(0), blue(1), green(2), orange(3)\ncolors = ['red', 'blue', 'green', 'orange']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Variables: color of each flask after exactly one experiment (mixing two flasks)\n# Each flask color is an Int representing the color index\nflasks = [Int(f'flask_{i}') for i in range(1, 5)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Initial colors before experiment\ninitial_colors = [color_indices['red'], color_indices['blue'], color_indices['green'], color_indices['orange']]\n\n# Exactly one experiment: mix contents of one flask into another\n# After mixing, one flask is emptied (color = -1) and the other flask has the new color\n# The other two flasks remain unchanged\n\n# Possible experiments: (source, target) pairs where source != target\n# Mixing rules:\n# (1,2) or (2,1) -> red(0)\n# (2,3) or (3,2) -> orange(3)\n# (3,1) or (1,3) or (3,4) or (4,3) -> blue(1)\n# (4,1) or (1,4) or (4,2) or (2,4) -> green(2)\n\nexperiments = []\n# We'll represent each experiment as a tuple (source_index, target_index, result_color_index)\nexperiments.append((0, 1, color_indices['red']))    # 1->2\nexperiments.append((1, 0, color_indices['red']))    # 2->1\nexperiments.append((1, 2, color_indices['orange'])) # 2->3\nexperiments.append((2, 1, color_indices['orange'])) # 3->2\nexperiments.append((2, 0, color_indices['blue']))   # 3->1\nexperiments.append((0, 2, color_indices['blue']))   # 1->3\nexperiments.append((2, 3, color_indices['blue']))   # 3->4\nexperiments.append((3, 2, color_indices['blue']))   # 4->3\nexperiments.append((3, 0, color_indices['green']))  # 4->1\nexperiments.append((0, 3, color_indices['green']))  # 1->4\nexperiments.append((3, 1, color_indices['green']))  # 4->2\nexperiments.append((1, 3, color_indices['green']))  # 2->4\n\n# A flask emptied by experiment has color -1 (empty)\nEMPTY = -1\n\n# For each experiment, define the flask colors after mixing\ndef experiment_constraints(src, tgt, res_color):\n    constraints = []\n    # The source flask is emptied\n    constraints.append(flasks[src] == EMPTY)\n    # The target flask has the resulting color\n    constraints.append(flasks[tgt] == res_color)\n    # The other two flasks keep their initial colors\n    others = [i for i in range(4) if i != src and i != tgt]\n    for o in others:\n        constraints.append(flasks[o] == initial_colors[o])\n    return constraints\n\n# The flasks after experiment must correspond to exactly one of the possible experiments\nexperiment_cases = []\nfor (src, tgt, res_color) in experiments:\n    experiment_cases.append(And(experiment_constraints(src, tgt, res_color)))\n\nsolver.add(Or(experiment_cases))\n\n# The problem states exactly one experiment performed, so exactly one flask emptied (color -1)\nemptied_flasks = [flasks[i] == EMPTY for i in range(4)]\nsolver.add(Sum([If(cond, 1, 0) for cond in emptied_flasks]) == 1)\n\n# The resulting 3 nonempty flasks have colors from flasks array excluding EMPTY\n# We'll extract the list of colors of nonempty flasks to compare with options\n\n# OPTION CHECKING\noptions = {\n    'A': ['blue', 'blue', 'green'],\n    'B': ['blue', 'orange', 'orange'],\n    'C': ['blue', 'orange', 'red'],\n    'D': ['green', 'green', 'red'],\n    'E': ['green', 'orange', 'orange']\n}\n\nfor letter, option_colors in options.items():\n    solver.push()\n    # Constraint: the nonempty flasks have exactly the colors in option_colors (order doesn't matter)\n    # Extract nonempty flasks colors\n    nonempty_colors = [flasks[i] for i in range(4)]\n    # Filter out EMPTY\n    nonempty_colors_filtered = [c for c in nonempty_colors]\n\n    # We'll add constraints to enforce that the multiset of nonempty flask colors matches option_colors\n\n    # Count occurrences of each color in the option\n    option_color_indices = [color_indices[c] for c in option_colors]\n\n    # Count occurrences of colors in flasks (excluding EMPTY)\n    # Create integer variables for counts of each color in flasks\n    counts = []\n    for cidx in range(len(colors)):\n        count = Sum([If(flasks[i] == cidx, 1, 0) for i in range(4)])\n        counts.append(count)\n\n    # Count of EMPTY flasks is 1, so sum of counts of colors = 3\n    solver.add(Sum(counts) == 3)\n\n    # For each color, count must equal the number of times it appears in option_colors\n    for cidx in range(len(colors)):\n        expected_count = option_color_indices.count(cidx)\n        solver.add(counts[cidx] == expected_count)\n\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.\n\nGroup 1 could consist of\n\nOptions:\n(A) F, G, H, and J\n(B) F, H, L, and M\n(C) F, J, K, and L\n(D) G, H, L, and N\n(E) G, K, M, and N",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nconsumers = ['F', 'G', 'H', 'J', 'K', 'L', 'M', 'N']\n\n# Create Z3 Int variables for group assignments: 1 or 2\ngroups = {}\nfor c in consumers:\n    groups[c] = Int(c)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each consumer is in group 1 or 2\nfor c in consumers:\n    solver.add(Or(groups[c] == 1, groups[c] == 2))\n\n# Exactly two groups of four people each\n# Count how many are in group 1 (the rest are in group 2)\ngroup1_count = Sum([If(groups[c] == 1, 1, 0) for c in consumers])\nsolver.add(group1_count == 4)\n\n# F must be in the same group as J\nsolver.add(groups['F'] == groups['J'])\n\n# G must be in a different group from M\nsolver.add(groups['G'] != groups['M'])\n\n# If H is in group 1, then L must be in group 1\nsolver.add(Implies(groups['H'] == 1, groups['L'] == 1))\n\n# If N is in group 2, then G must be in group 1\nsolver.add(Implies(groups['N'] == 2, groups['G'] == 1))\n\n# OPTION CHECKING\noptions = [\n    ['F', 'G', 'H', 'J'],  # A\n    ['F', 'H', 'L', 'M'],  # B\n    ['F', 'J', 'K', 'L'],  # C\n    ['G', 'H', 'L', 'N'],  # D\n    ['G', 'K', 'M', 'N']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Assign the option group 1 and others group 2\n    for c in consumers:\n        if c in option:\n            solver.add(groups[c] == 1)\n        else:\n            solver.add(groups[c] == 2)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.\n\nIf K is in the same group as N, which one of the following must be true?\n\nOptions:\n(A) G is in group 1.\n(B) H is in group 2.\n(C) J is in group 1.\n(D) K is in group 2.\n(E) M is in group 1.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nconsumers = ['F', 'G', 'H', 'J', 'K', 'L', 'M', 'N']\ngroups = [1, 2]\n\n# Create a dictionary of Int variables for each consumer's group assignment (1 or 2)\nassign = {c: Int(c) for c in consumers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each consumer is assigned to either group 1 or group 2\nfor c in consumers:\n    solver.add(Or(assign[c] == 1, assign[c] == 2))\n\n# Exactly two groups of four people each means count of group 1 is 4 and group 2 is 4\ngroup1_count = Sum([If(assign[c] == 1, 1, 0) for c in consumers])\ngroup2_count = Sum([If(assign[c] == 2, 1, 0) for c in consumers])\nsolver.add(group1_count == 4)\nsolver.add(group2_count == 4)\n\n# F must be in the same group as J\nsolver.add(assign['F'] == assign['J'])\n\n# G must be in a different group from M\nsolver.add(assign['G'] != assign['M'])\n\n# If H is in group 1, then L must be in group 1\nsolver.add(Implies(assign['H'] == 1, assign['L'] == 1))\n\n# If N is in group 2, then G must be in group 1\nsolver.add(Implies(assign['N'] == 2, assign['G'] == 1))\n\n# OPTION CHECKING\noptions = {\n    'A': assign['G'] == 1,\n    'B': assign['H'] == 2,\n    'C': assign['J'] == 1,\n    'D': assign['K'] == 2,\n    'E': assign['M'] == 1,\n}\n\n# Add the condition: K is in the same group as N\nsolver.add(assign['K'] == assign['N'])\n\nfor option_letter, option_condition in options.items():\n    solver.push()\n    # Add negation of the option condition to test if it must be true\n    solver.add(Not(option_condition))\n    if solver.check() == unsat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.\n\nIf F is in the same group as H, which one of the following must be true?\n\nOptions:\n(A) G is in group 2.\n(B) J is in group 1.\n(C) K is in group 1.\n(D) L is in group 2.\n(E) M is in group 2.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nconsumers = ['F', 'G', 'H', 'J', 'K', 'L', 'M', 'N']\ngroup1 = 1\ngroup2 = 2\n\n# Create a dictionary of Int variables representing group assignments for each consumer\ngroups = {c: Int(c) for c in consumers}\n\nsolver = Solver()\n\n# Each consumer must be assigned to either group 1 or group 2\nfor c in consumers:\n    solver.add(Or(groups[c] == group1, groups[c] == group2))\n\n# Exactly two groups of 4 people each\n# Sum of people in group 1 must be 4\nin_group1 = [If(groups[c] == group1, 1, 0) for c in consumers]\nsolver.add(Sum(in_group1) == 4)\n\n# CONSTRAINTS\n\n# F must be in the same group as J\nsolver.add(groups['F'] == groups['J'])\n\n# G must be in a different group from M\nsolver.add(groups['G'] != groups['M'])\n\n# If H is in group 1, then L must be in group 1\nsolver.add(Implies(groups['H'] == group1, groups['L'] == group1))\n\n# If N is in group 2, then G must be in group 1\nsolver.add(Implies(groups['N'] == group2, groups['G'] == group1))\n\n# Additional condition: F is in the same group as H\nsolver.add(groups['F'] == groups['H'])\n\n# OPTION CHECKING\noptions = {\n    'A': groups['G'] == group2,\n    'B': groups['J'] == group1,\n    'C': groups['K'] == group1,\n    'D': groups['L'] == group2,\n    'E': groups['M'] == group2\n}\n\nfor option_letter, option_condition in options.items():\n    solver.push()\n    # Add negation of the option to check if it must be true\n    solver.add(Not(option_condition))\n    if solver.check() == unsat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.\n\nIf L and M are in group 2, then a person who could be assigned either to group 1 or, alternatively, to group 2 is\n\nOptions:\n(A) F\n(B) G\n(C) H\n(D) J\n(E) K",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nconsumers = ['F', 'G', 'H', 'J', 'K', 'L', 'M', 'N']\ngroup1_size = 4\ngroup2_size = 4\n\n# Create variables: group[c] = 1 if consumer c is in group 1, else 2\ngroup = {c: Int(c) for c in consumers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each consumer is in group 1 or group 2\nfor c in consumers:\n    solver.add(Or(group[c] == 1, group[c] == 2))\n\n# Exactly 4 consumers in group 1\nsolver.add(Sum([If(group[c] == 1, 1, 0) for c in consumers]) == group1_size)\n\n# Exactly 4 consumers in group 2\nsolver.add(Sum([If(group[c] == 2, 1, 0) for c in consumers]) == group2_size)\n\n# F must be in the same group as J\nsolver.add(group['F'] == group['J'])\n\n# G must be in a different group from M\nsolver.add(group['G'] != group['M'])\n\n# If H is in group 1, then L must be in group 1\nsolver.add(Implies(group['H'] == 1, group['L'] == 1))\n\n# If N is in group 2, then G must be in group 1\nsolver.add(Implies(group['N'] == 2, group['G'] == 1))\n\n# OPTION CHECKING\n# Given L and M are in group 2, check which person can be assigned either to group 1 or group 2\n\n# Fix L and M in group 2\nsolver.add(group['L'] == 2)\nsolver.add(group['M'] == 2)\n\n# The persons to test are options A to E:\noptions = ['F', 'G', 'H', 'J', 'K']\n\nfor i, person in enumerate(options):\n    solver.push()\n    # Check if person can be in group 1\n    solver.add(group[person] == 1)\n    if solver.check() == sat:\n        solver.pop()\n        solver.push()\n        # Check if person can be in group 2\n        solver.add(group[person] == 2)\n        if solver.check() == sat:\n            # person can be in either group 1 or group 2 under the constraints\n            print(f\"'{chr(65 + i)}'\")\n            solver.pop()\n            break\n        solver.pop()\n    else:\n        solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.\n\nEach of the following is a pair of people who could be in group 1 together EXCEPT\n\nOptions:\n(A) F and G\n(B) F and H\n(C) F and L\n(D) H and G\n(E) H and N",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nconsumers = ['F', 'G', 'H', 'J', 'K', 'L', 'M', 'N']\n# Each consumer assigned to group 1 or 2 (1 or 2)\ngroup = {c: Int(c) for c in consumers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each consumer is assigned to group 1 or 2\nfor c in consumers:\n    solver.add(Or(group[c] == 1, group[c] == 2))\n\n# Exactly two groups with 4 people each\n# Count number in group 1\ncount_group1 = Sum([If(group[c] == 1, 1, 0) for c in consumers])\nsolver.add(count_group1 == 4)\n\n# Count number in group 2 is 4 (implicitly, but we add for clarity)\ncount_group2 = Sum([If(group[c] == 2, 1, 0) for c in consumers])\nsolver.add(count_group2 == 4)\n\n# F must be in the same group as J\nsolver.add(group['F'] == group['J'])\n\n# G must be in a different group from M\nsolver.add(group['G'] != group['M'])\n\n# If H is in group 1, then L must be in group 1\nsolver.add(Implies(group['H'] == 1, group['L'] == 1))\n\n# If N is in group 2, then G must be in group 1\nsolver.add(Implies(group['N'] == 2, group['G'] == 1))\n\n# OPTION CHECKING\n# Each option is a pair who \"could be in group 1 together\" except one\noptions = [\n    ('F', 'G'),  # A\n    ('F', 'H'),  # B\n    ('F', 'L'),  # C\n    ('H', 'G'),  # D\n    ('H', 'N'),  # E\n]\n\nfor i, (c1, c2) in enumerate(options):\n    solver.push()\n    # Add constraint that c1 and c2 are both in group 1\n    solver.add(group[c1] == 1)\n    solver.add(group[c2] == 1)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        # This option cannot happen, so print its letter and break\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly eight consumers—F, G, H, J, K, L, M, and N—will be interviewed by market researchers. The eight will be divided into exactly two 4-person groups—group 1 and group 2—before interviews begin. Each person is assigned to exactly one of the two groups according to the following conditions: F must be in the same group as J. G must be in a different group from M. If H is in group 1, then L must be in group 1. If N is in group 2, then G must be in group 1.\n\nIf L is in group 2, then each of the following is a pair of people who could be in group 1 together EXCEPT\n\nOptions:\n(A) F and M\n(B) G and N\n(C) J and N\n(D) K and M\n(E) M and N",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nconsumers = ['F', 'G', 'H', 'J', 'K', 'L', 'M', 'N']\nnum_consumers = len(consumers)\n\n# Each consumer assigned to group 1 (0) or group 2 (1)\ngroup = {c: Int(c) for c in consumers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each group assignment is 0 or 1\nfor c in consumers:\n    solver.add(Or(group[c] == 0, group[c] == 1))\n\n# Exactly two groups of 4 people each\n# Sum of group == 0 (group 1) must be 4\nsum_group1 = Sum([If(group[c] == 0, 1, 0) for c in consumers])\nsolver.add(sum_group1 == 4)\n\n# Conditions:\n\n# F must be in the same group as J\nsolver.add(group['F'] == group['J'])\n\n# G must be in a different group from M\nsolver.add(group['G'] != group['M'])\n\n# If H is in group 1, then L must be in group 1\nsolver.add(Implies(group['H'] == 0, group['L'] == 0))\n\n# If N is in group 2, then G must be in group 1\nsolver.add(Implies(group['N'] == 1, group['G'] == 0))\n\n# Given: L is in group 2\nsolver.add(group['L'] == 1)\n\n# OPTION CHECKING\n# We test each option: \"If L is in group 2, then each of the following is a pair of people who could be in group 1 together EXCEPT\"\n\n# So for each option, we check if it is possible that both people in the pair are in group 1.\n# The EXCEPT option is the one that cannot be true.\n\noptions = [\n    ('F', 'M'),  # A\n    ('G', 'N'),  # B\n    ('J', 'N'),  # C\n    ('K', 'M'),  # D\n    ('M', 'N'),  # E\n]\n\nfor i, (p1, p2) in enumerate(options):\n    solver.push()\n    # Add constraint that p1 and p2 are both in group 1 (0)\n    solver.add(group[p1] == 0)\n    solver.add(group[p2] == 0)\n    # Check if satisfiable\n    if solver.check() == unsat:\n        # This option cannot be true, so it is the EXCEPT answer\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Five people—Harry, Iris, Kate, Nancy, and Victor—are to be scheduled as contestants on a television show, one contestant per day, for five consecutive days from Monday through Friday. The following restrictions governing the scheduling of contestants must be observed: Nancy is not scheduled for Monday. If Harry is scheduled for Monday, Nancy is scheduled for Friday. If Nancy is scheduled for Tuesday, Iris is scheduled for Monday. Kate is scheduled for the next day after the day for which Victor is scheduled.\n\nVictor can be scheduled for any day EXCEPT\n\nOptions:\n(A) Monday\n(B) Tuesday\n(C) Wednesday\n(D) Thursday\n(E) Friday",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Harry', 'Iris', 'Kate', 'Nancy', 'Victor']\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n# Create Z3 Int variables for each person representing the day index (0=Monday,...4=Friday)\nschedule = {p: Int(p) for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person is scheduled on a valid day\nfor p in people:\n    solver.add(And(schedule[p] >= 0, schedule[p] < 5))\n\n# All scheduled days are distinct (one person per day)\nsolver.add(Distinct([schedule[p] for p in people]))\n\n# Nancy is not scheduled for Monday\nsolver.add(schedule['Nancy'] != 0)\n\n# If Harry is scheduled for Monday, Nancy is scheduled for Friday\nharry_monday = schedule['Harry'] == 0\nnancy_friday = schedule['Nancy'] == 4\nsolver.add(Implies(harry_monday, nancy_friday))\n\n# If Nancy is scheduled for Tuesday, Iris is scheduled for Monday\nnancy_tuesday = schedule['Nancy'] == 1\niris_monday = schedule['Iris'] == 0\nsolver.add(Implies(nancy_tuesday, iris_monday))\n\n# Kate is scheduled the next day after Victor\nsolver.add(schedule['Kate'] == schedule['Victor'] + 1)\n\n# OPTION CHECKING\noptions = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\nfor i, day in enumerate(options):\n    solver.push()\n    # Add constraint that Victor is scheduled on this day\n    solver.add(schedule['Victor'] == i)\n    # Check if the constraints are satisfiable with Victor on this day\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Five people—Harry, Iris, Kate, Nancy, and Victor—are to be scheduled as contestants on a television show, one contestant per day, for five consecutive days from Monday through Friday. The following restrictions governing the scheduling of contestants must be observed: Nancy is not scheduled for Monday. If Harry is scheduled for Monday, Nancy is scheduled for Friday. If Nancy is scheduled for Tuesday, Iris is scheduled for Monday. Kate is scheduled for the next day after the day for which Victor is scheduled.\n\nIf Kate is scheduled for Wednesday, which one of the following could be true?\n\nOptions:\n(A) Iris is scheduled for Friday.\n(B) Nancy is scheduled for Tuesday.\n(C) Nancy is scheduled for an earlier day than the day for which Harry is scheduled.\n(D) Nancy is scheduled for an earlier day than the day for which Iris is scheduled.\n(E) Nancy is scheduled for an earlier day than the day for which Kate is scheduled.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Harry', 'Iris', 'Kate', 'Nancy', 'Victor']\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n# Map people to Z3 Int variables representing the day index (0=Monday, 4=Friday)\nschedule = {p: Int(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person is scheduled on a day from 0 to 4\nfor p in people:\n    solver.add(And(schedule[p] >= 0, schedule[p] < 5))\n\n# All scheduled days must be distinct (one contestant per day)\nsolver.add(Distinct([schedule[p] for p in people]))\n\n# Nancy is not scheduled for Monday\nsolver.add(schedule['Nancy'] != 0)\n\n# If Harry is scheduled for Monday, Nancy is scheduled for Friday\nharry_monday = schedule['Harry'] == 0\nnancy_friday = schedule['Nancy'] == 4\nsolver.add(Implies(harry_monday, nancy_friday))\n\n# If Nancy is scheduled for Tuesday, Iris is scheduled for Monday\nnancy_tuesday = schedule['Nancy'] == 1\niris_monday = schedule['Iris'] == 0\nsolver.add(Implies(nancy_tuesday, iris_monday))\n\n# Kate is scheduled the next day after Victor\nsolver.add(schedule['Kate'] == schedule['Victor'] + 1)\n\n# Kate is scheduled for Wednesday (day 2)\nsolver.add(schedule['Kate'] == 2)\n\n# OPTION CHECKING\n# Define option constraints for each option\noption_constraints = {\n    'A': schedule['Iris'] == 4,  # Iris is scheduled for Friday\n    'B': schedule['Nancy'] == 1, # Nancy is scheduled for Tuesday\n    'C': schedule['Nancy'] < schedule['Harry'], # Nancy earlier than Harry\n    'D': schedule['Nancy'] < schedule['Iris'],  # Nancy earlier than Iris\n    'E': schedule['Nancy'] < schedule['Kate'],  # Nancy earlier than Kate\n}\n\nfor option_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(option_constraints[option_letter])\n    if solver.check() == sat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Five people—Harry, Iris, Kate, Nancy, and Victor—are to be scheduled as contestants on a television show, one contestant per day, for five consecutive days from Monday through Friday. The following restrictions governing the scheduling of contestants must be observed: Nancy is not scheduled for Monday. If Harry is scheduled for Monday, Nancy is scheduled for Friday. If Nancy is scheduled for Tuesday, Iris is scheduled for Monday. Kate is scheduled for the next day after the day for which Victor is scheduled.\n\nIf Kate is scheduled for Friday, which one of the following must be true?\n\nOptions:\n(A) Harry is scheduled for Tuesday.\n(B) Harry is scheduled for Wednesday.\n(C) Iris is scheduled for Monday.\n(D) Iris is scheduled for Wednesday.\n(E) Nancy is scheduled for Wednesday.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Harry', 'Iris', 'Kate', 'Nancy', 'Victor']\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n# Create Z3 Int variables for each person representing the day index (0=Monday, ..., 4=Friday)\nschedule = {p: Int(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person must be scheduled on a valid day\nfor p in people:\n    solver.add(And(schedule[p] >= 0, schedule[p] < 5))\n\n# All persons must be scheduled on distinct days\nsolver.add(Distinct([schedule[p] for p in people]))\n\n# Nancy is not scheduled for Monday\nsolver.add(schedule['Nancy'] != 0)\n\n# If Harry is scheduled for Monday, Nancy is scheduled for Friday\nharry_monday = schedule['Harry'] == 0\nnancy_friday = schedule['Nancy'] == 4\nsolver.add(Implies(harry_monday, nancy_friday))\n\n# If Nancy is scheduled for Tuesday, Iris is scheduled for Monday\nnancy_tuesday = schedule['Nancy'] == 1\niris_monday = schedule['Iris'] == 0\nsolver.add(Implies(nancy_tuesday, iris_monday))\n\n# Kate is scheduled for the next day after Victor\nsolver.add(schedule['Kate'] == schedule['Victor'] + 1)\n\n# OPTION CHECKING\n# We add the condition: Kate is scheduled for Friday (day 4)\nsolver.push()\nsolver.add(schedule['Kate'] == 4)\n\n# For each option, check if it must be true\n# To check if an option must be true, we check if its negation is unsat\n\noptions = [\n    ('A', schedule['Harry'] == 1),     # Harry is scheduled for Tuesday (1)\n    ('B', schedule['Harry'] == 2),     # Harry is scheduled for Wednesday (2)\n    ('C', schedule['Iris'] == 0),      # Iris is scheduled for Monday (0)\n    ('D', schedule['Iris'] == 2),      # Iris is scheduled for Wednesday (2)\n    ('E', schedule['Nancy'] == 2)      # Nancy is scheduled for Wednesday (2)\n]\n\nfor letter, condition in options:\n    solver.push()\n    # Check if negation of condition is satisfiable\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()\n\nsolver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Five people—Harry, Iris, Kate, Nancy, and Victor—are to be scheduled as contestants on a television show, one contestant per day, for five consecutive days from Monday through Friday. The following restrictions governing the scheduling of contestants must be observed: Nancy is not scheduled for Monday. If Harry is scheduled for Monday, Nancy is scheduled for Friday. If Nancy is scheduled for Tuesday, Iris is scheduled for Monday. Kate is scheduled for the next day after the day for which Victor is scheduled.\n\nIf Iris is scheduled for Wednesday, which one of the following must be true?\n\nOptions:\n(A) Harry is scheduled for an earlier day than the day for which Nancy is scheduled.\n(B) Harry is scheduled for an earlier day than the day for which Kate is scheduled.\n(C) Kate is scheduled for an earlier day than the day for which Harry is scheduled.\n(D) Nancy is scheduled for an earlier day than the day for which Kate is scheduled.\n(E) Nancy is scheduled for an earlier day than the day for which Iris is scheduled.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Harry', 'Iris', 'Kate', 'Nancy', 'Victor']\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']\n\n# Create Z3 Int variables for each person representing the day index (0=Monday,...,4=Friday)\nschedule = {p: Int(p) for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person is scheduled on a day from 0 to 4\nfor p in people:\n    solver.add(And(schedule[p] >= 0, schedule[p] < 5))\n\n# All scheduled days are distinct (one contestant per day)\nsolver.add(Distinct([schedule[p] for p in people]))\n\n# Nancy is not scheduled for Monday (day 0)\nsolver.add(schedule['Nancy'] != 0)\n\n# If Harry is scheduled for Monday (0), Nancy is scheduled for Friday (4)\nharry_monday = schedule['Harry'] == 0\nnancy_friday = schedule['Nancy'] == 4\nsolver.add(Implies(harry_monday, nancy_friday))\n\n# If Nancy is scheduled for Tuesday (1), Iris is scheduled for Monday (0)\nnancy_tuesday = schedule['Nancy'] == 1\niris_monday = schedule['Iris'] == 0\nsolver.add(Implies(nancy_tuesday, iris_monday))\n\n# Kate is scheduled the next day after Victor\nsolver.add(schedule['Kate'] == schedule['Victor'] + 1)\n\n# Iris is scheduled for Wednesday (2)\nsolver.add(schedule['Iris'] == 2)\n\n# OPTION CHECKING\n# Define a helper function to check if an option must be true\ndef option_must_be_true(option_constraint):\n    # Check if the negation of the option constraint is satisfiable with all other constraints\n    solver.push()\n    solver.add(Not(option_constraint))\n    result = solver.check()\n    solver.pop()\n    return result == unsat\n\n# (A) Harry is scheduled earlier than Nancy\noption_A = schedule['Harry'] < schedule['Nancy']\n\n# (B) Harry is scheduled earlier than Kate\noption_B = schedule['Harry'] < schedule['Kate']\n\n# (C) Kate is scheduled earlier than Harry\noption_C = schedule['Kate'] < schedule['Harry']\n\n# (D) Nancy is scheduled earlier than Kate\noption_D = schedule['Nancy'] < schedule['Kate']\n\n# (E) Nancy is scheduled earlier than Iris\noption_E = schedule['Nancy'] < schedule['Iris']\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, opt in enumerate(options):\n    if option_must_be_true(opt):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "An art teacher will schedule exactly six of eight lectures—fresco, history, lithography, naturalism, oils, pastels, sculpture, and watercolors—for three days—1, 2, and 3. There will be exactly two lectures each day—morning and afternoon. Scheduling is governed by the following conditions: Day 2 is the only day for which oils can be scheduled. Neither sculpture nor watercolors can be scheduled for the afternoon. Neither oils nor pastels can be scheduled for the same day as lithography. If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order.\n\nWhich one of the following is an acceptable schedule of lectures for days 1, 2, and 3, respectively?\n\nOptions:\n(A) Morning: lithography, history, sculpture Afternoon: pastels, fresco, naturalism\n(B) Morning: naturalism, oils, fresco Afternoon: lithography, pastels, history\n(C) Morning: oils, history, naturalism Afternoon: pastels, fresco, lithography\n(D) Morning: sculpture, lithography, naturalism Afternoon: watercolors, fresco, pastels\n(E) Morning: sculpture, pastels, fresco Afternoon: lithography, history, naturalism",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Lectures\nlectures = ['fresco', 'history', 'lithography', 'naturalism', 'oils', 'pastels', 'sculpture', 'watercolors']\nlecture_indices = {lec: i for i, lec in enumerate(lectures)}\n\n# Days and sessions\ndays = [1, 2, 3]\nsessions = ['morning', 'afternoon']\n\n# We will create a variable for each day and session representing the lecture scheduled\n# schedule[day][session] = Int variable representing lecture index\nschedule = {}\nfor d in days:\n    schedule[d] = {}\n    for s in sessions:\n        schedule[d][s] = Int(f'schedule_{d}_{s}')\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# 1. Each scheduled lecture must be one of the 8 lectures\nfor d in days:\n    for s in sessions:\n        solver.add(And(schedule[d][s] >= 0, schedule[d][s] < len(lectures)))\n\n# 2. Exactly six of eight lectures are scheduled (no repeats, exactly 6 distinct lectures)\n# Collect all scheduled lectures\nscheduled_lectures = [schedule[d][s] for d in days for s in sessions]\n# Distinctness for all scheduled lectures\nsolver.add(Distinct(scheduled_lectures))\n# Exactly 6 lectures scheduled means 6 distinct lectures, so 2 lectures are not scheduled\n# No repeats in scheduled_lectures already enforced by Distinct\n# So the number of scheduled lectures is 6, which is size of scheduled_lectures (6)\n# So no further constraint needed here\n\n# 3. Day 2 is the only day for which oils can be scheduled.\n# So oils can only appear on day 2 morning or afternoon\nfor d in [1,3]:\n    for s in sessions:\n        solver.add(schedule[d][s] != lecture_indices['oils'])\n\n# 4. Neither sculpture nor watercolors can be scheduled for the afternoon.\nfor d in days:\n    solver.add(schedule[d]['afternoon'] != lecture_indices['sculpture'])\n    solver.add(schedule[d]['afternoon'] != lecture_indices['watercolors'])\n\n# 5. Neither oils nor pastels can be scheduled on the same day as lithography.\n# For each day, if lithography is scheduled, then oils and pastels are not scheduled on that day\nfor d in days:\n    # lithography scheduled on morning or afternoon\n    litho_morning = schedule[d]['morning'] == lecture_indices['lithography']\n    litho_afternoon = schedule[d]['afternoon'] == lecture_indices['lithography']\n    litho_scheduled = Or([litho_morning, litho_afternoon])\n    # oils or pastels scheduled on morning or afternoon\n    oils_morning = schedule[d]['morning'] == lecture_indices['oils']\n    oils_afternoon = schedule[d]['afternoon'] == lecture_indices['oils']\n    oils_scheduled = Or([oils_morning, oils_afternoon])\n    pastels_morning = schedule[d]['morning'] == lecture_indices['pastels']\n    pastels_afternoon = schedule[d]['afternoon'] == lecture_indices['pastels']\n    pastels_scheduled = Or([pastels_morning, pastels_afternoon])\n    # If lithography scheduled, then oils and pastels not scheduled\n    solver.add(Implies(litho_scheduled, And(Not(oils_scheduled), Not(pastels_scheduled))))\n\n# 6. If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history (not necessarily in that order).\n# Check day 1 and day 2 for pastels\nfor d in [1, 2]:\n    # pastels scheduled on morning or afternoon of day d\n    pastels_morning = schedule[d]['morning'] == lecture_indices['pastels']\n    pastels_afternoon = schedule[d]['afternoon'] == lecture_indices['pastels']\n    pastels_scheduled = Or([pastels_morning, pastels_afternoon])\n    # next day d+1 lectures\n    next_day = d + 1\n    # next day lectures\n    next_day_lectures = [schedule[next_day]['morning'], schedule[next_day]['afternoon']]\n    # Must be fresco and history in any order\n    fresco = lecture_indices['fresco']\n    history = lecture_indices['history']\n    fresco_history_condition = Or(\n        And(next_day_lectures[0] == fresco, next_day_lectures[1] == history),\n        And(next_day_lectures[0] == history, next_day_lectures[1] == fresco)\n    )\n    # If pastels scheduled on day d, then next day must have fresco and history\n    solver.add(Implies(pastels_scheduled, fresco_history_condition))\n\n# OPTION CHECKING\n\noptions = [\n    # (A)\n    {\n        1: {'morning': 'lithography', 'afternoon': 'pastels'},\n        2: {'morning': 'history', 'afternoon': 'fresco'},\n        3: {'morning': 'sculpture', 'afternoon': 'naturalism'}\n    },\n    # (B)\n    {\n        1: {'morning': 'naturalism', 'afternoon': 'lithography'},\n        2: {'morning': 'oils', 'afternoon': 'pastels'},\n        3: {'morning': 'fresco', 'afternoon': 'history'}\n    },\n    # (C)\n    {\n        1: {'morning': 'oils', 'afternoon': 'pastels'},\n        2: {'morning': 'history', 'afternoon': 'fresco'},\n        3: {'morning': 'naturalism', 'afternoon': 'lithography'}\n    },\n    # (D)\n    {\n        1: {'morning': 'sculpture', 'afternoon': 'watercolors'},\n        2: {'morning': 'lithography', 'afternoon': 'fresco'},\n        3: {'morning': 'naturalism', 'afternoon': 'pastels'}\n    },\n    # (E)\n    {\n        1: {'morning': 'sculpture', 'afternoon': 'lithography'},\n        2: {'morning': 'pastels', 'afternoon': 'history'},\n        3: {'morning': 'fresco', 'afternoon': 'naturalism'}\n    }\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints corresponding to the option schedule\n    for d in days:\n        for s in sessions:\n            lec_name = option[d][s]\n            lec_idx = lecture_indices[lec_name]\n            solver.add(schedule[d][s] == lec_idx)\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "An art teacher will schedule exactly six of eight lectures—fresco, history, lithography, naturalism, oils, pastels, sculpture, and watercolors—for three days—1, 2, and 3. There will be exactly two lectures each day—morning and afternoon. Scheduling is governed by the following conditions: Day 2 is the only day for which oils can be scheduled. Neither sculpture nor watercolors can be scheduled for the afternoon. Neither oils nor pastels can be scheduled for the same day as lithography. If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order.\n\nIf lithography and history are scheduled for the mornings of day 2 and day 3, respectively, which one of the following lectures could be scheduled for the morning of day 1?\n\nOptions:\n(A) fresco\n(B) naturalism\n(C) oils\n(D) pastels\n(E) sculpture",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nlectures = ['fresco', 'history', 'lithography', 'naturalism', 'oils', 'pastels', 'sculpture', 'watercolors']\ndays = [1, 2, 3]\ntimes = ['morning', 'afternoon']\n\n# Create variables: schedule[(day, time)] = lecture index or -1 if no lecture scheduled\n# Since exactly 6 of 8 lectures are scheduled, 2 slots remain empty (represented by -1)\nschedule = {}\nfor d in days:\n    for t in times:\n        schedule[(d, t)] = Int(f'schedule_{d}_{t}')\n\n# Map lectures to indices for easy reference\nlecture_idx = {lec: i for i, lec in enumerate(lectures)}\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each slot is either one of the lectures or -1 (not scheduled)\nfor d in days:\n    for t in times:\n        solver.add(Or([schedule[(d, t)] == i for i in range(len(lectures))] + [schedule[(d, t)] == -1]))\n\n# Exactly 6 lectures scheduled in total (2 slots empty)\nall_slots = [schedule[(d, t)] for d in days for t in times]\n# Count how many slots are not -1\nnum_scheduled = Sum([If(slot == -1, 0, 1) for slot in all_slots])\nsolver.add(num_scheduled == 6)\n\n# No lecture repeats - distinct scheduled lectures (ignore -1)\n# Extract scheduled lectures ignoring -1\nscheduled_lectures = [slot for slot in all_slots]\n# We must ensure that the scheduled lectures are distinct ignoring -1\n# To do this, we collect all scheduled lectures and enforce that no two are equal if both are not -1\nfor i in range(len(scheduled_lectures)):\n    for j in range(i+1, len(scheduled_lectures)):\n        solver.add(Or(scheduled_lectures[i] == -1, scheduled_lectures[j] == -1, scheduled_lectures[i] != scheduled_lectures[j]))\n\n# There are exactly two lectures each day (morning and afternoon)\n# This is implicit since all slots are assigned and total lectures are 6, so 2 slots are empty somewhere\n# But must ensure that each day has exactly two lectures scheduled (no empty slots)\nfor d in days:\n    slots_day = [schedule[(d, t)] for t in times]\n    # Count how many scheduled (not -1) in the day\n    count_day = Sum([If(slot == -1, 0, 1) for slot in slots_day])\n    solver.add(count_day == 2)\n\n# Day 2 is the only day for which oils can be scheduled.\n# So oils can only appear on day 2, and nowhere else.\nfor d in days:\n    for t in times:\n        slot = schedule[(d, t)]\n        # If slot is oils, then d must be 2\n        solver.add(Implies(slot == lecture_idx['oils'], d == 2))\n# Also, oils must be scheduled on day 2 if scheduled at all (already ensured by above)\n# No other day can have oils.\n\n# Neither sculpture nor watercolors can be scheduled for the afternoon.\nfor d in days:\n    slot = schedule[(d, 'afternoon')]\n    solver.add(slot != lecture_idx['sculpture'])\n    solver.add(slot != lecture_idx['watercolors'])\n\n# Neither oils nor pastels can be scheduled on the same day as lithography.\n# For each day, if lithography is scheduled, then oils and pastels cannot be scheduled on that day.\nfor d in days:\n    slots_day = [schedule[(d, t)] for t in times]\n    litho_in_day = Or([slot == lecture_idx['lithography'] for slot in slots_day])\n    oils_in_day = Or([slot == lecture_idx['oils'] for slot in slots_day])\n    pastels_in_day = Or([slot == lecture_idx['pastels'] for slot in slots_day])\n    solver.add(Implies(litho_in_day, And(Not(oils_in_day), Not(pastels_in_day))))\n\n# If pastels is scheduled for day 1 or day 2,\n# then the lectures scheduled for the day immediately following pastels must be fresco and history,\n# not necessarily in that order.\nfor d in [1, 2]:\n    slots_day = [schedule[(d, t)] for t in times]\n    pastels_in_day = Or([slot == lecture_idx['pastels'] for slot in slots_day])\n    next_day = d + 1\n    # Only if next_day exists (1 or 2 only)\n    if next_day <= 3:\n        slots_next_day = [schedule[(next_day, t)] for t in times]\n        # The next day must have fresco and history in any order\n        fresco_in_next = Or([slot == lecture_idx['fresco'] for slot in slots_next_day])\n        history_in_next = Or([slot == lecture_idx['history'] for slot in slots_next_day])\n        solver.add(Implies(pastels_in_day, And(fresco_in_next, history_in_next)))\n\n# Given: lithography and history are scheduled for the mornings of day 2 and day 3, respectively\nsolver.add(schedule[(2, 'morning')] == lecture_idx['lithography'])\nsolver.add(schedule[(3, 'morning')] == lecture_idx['history'])\n\n# The question: which lecture could be scheduled for the morning of day 1?\n\n# OPTION CHECKING\n\noptions = ['fresco', 'naturalism', 'oils', 'pastels', 'sculpture']\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(schedule[(1, 'morning')] == lecture_idx[option])\n    # Check if satisfiable\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "An art teacher will schedule exactly six of eight lectures—fresco, history, lithography, naturalism, oils, pastels, sculpture, and watercolors—for three days—1, 2, and 3. There will be exactly two lectures each day—morning and afternoon. Scheduling is governed by the following conditions: Day 2 is the only day for which oils can be scheduled. Neither sculpture nor watercolors can be scheduled for the afternoon. Neither oils nor pastels can be scheduled for the same day as lithography. If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history, not necessarily in that order.\n\nIf neither fresco nor naturalism is scheduled for any day, which one of the following must be scheduled for day 1?\n\nOptions:\n(A) history\n(B) lithography\n(C) oils\n(D) pastels\n(E) sculpture",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlectures = ['fresco', 'history', 'lithography', 'naturalism', 'oils', 'pastels', 'sculpture', 'watercolors']\ndays = [1, 2, 3]\ntimes = ['morning', 'afternoon']\n\n# Map lectures to indices\nlecture_idx = {lec: i for i, lec in enumerate(lectures)}\n\n# Variables: schedule[day][time] = lecture index or -1 if no lecture scheduled\nschedule = {}\nfor d in days:\n    for t in times:\n        schedule[(d, t)] = Int(f'sched_{d}_{t}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each scheduled lecture is either one of the 8 lectures or -1 if not scheduled\n# But since exactly 6 lectures are scheduled, we will assign -1 to 2 slots (out of 6 slots total)\n# Actually, there are 3 days * 2 times = 6 slots total, and exactly 6 lectures scheduled,\n# so no slot is empty, all slots assigned to a lecture.\n# So each slot must be assigned one of the 8 lectures, but exactly 6 lectures used in total.\n\n# So all slots assigned to lectures in [0..7]\nfor d in days:\n    for t in times:\n        solver.add(And(schedule[(d, t)] >= 0, schedule[(d, t)] < len(lectures)))\n\n# 2) Exactly 6 of 8 lectures scheduled, so exactly 2 lectures are not scheduled.\n# We will enforce that the 6 scheduled lectures are distinct (no repeats)\n# Because the problem states \"exactly six of eight\", so no repeats.\nall_slots = [schedule[(d, t)] for d in days for t in times]\nsolver.add(Distinct(all_slots))\n\n# 3) Day 2 is the only day for which oils can be scheduled.\n# So if oils is scheduled, it must be on day 2.\n# Also, oils cannot be scheduled on day 1 or day 3.\nfor d in [1, 3]:\n    for t in times:\n        solver.add(schedule[(d, t)] != lecture_idx['oils'])\n\n# 4) Neither sculpture nor watercolors can be scheduled for the afternoon.\nfor d in days:\n    solver.add(schedule[(d, 'afternoon')] != lecture_idx['sculpture'])\n    solver.add(schedule[(d, 'afternoon')] != lecture_idx['watercolors'])\n\n# 5) Neither oils nor pastels can be scheduled on the same day as lithography.\n# For each day, if lithography is scheduled, then oils and pastels are not scheduled that day.\nfor d in days:\n    slots = [schedule[(d, t)] for t in times]\n    # lithography scheduled on day d?\n    litho_on_d = Or([slot == lecture_idx['lithography'] for slot in slots])\n    # oils or pastels on day d?\n    oils_or_pastels_on_d = Or([slot == lecture_idx['oils'] for slot in slots] + [slot == lecture_idx['pastels'] for slot in slots])\n    solver.add(Implies(litho_on_d, Not(oils_or_pastels_on_d)))\n\n# 6) If pastels is scheduled for day 1 or day 2, then the lectures scheduled for the day immediately following pastels must be fresco and history (not necessarily in that order).\nfor d in [1, 2]:\n    slots_next_day = [schedule[(d+1, t)] for t in times]\n    pastels_on_d = Or([schedule[(d, t)] == lecture_idx['pastels'] for t in times])\n    # The next day must have fresco and history (order not important)\n    fresco_and_history_next_day = And(\n        Or(slots_next_day[0] == lecture_idx['fresco'], slots_next_day[1] == lecture_idx['fresco']),\n        Or(slots_next_day[0] == lecture_idx['history'], slots_next_day[1] == lecture_idx['history']),\n        slots_next_day[0] != slots_next_day[1]\n    )\n    solver.add(Implies(pastels_on_d, fresco_and_history_next_day))\n\n# 7) Exactly six of eight lectures are scheduled.\n# We already have 6 slots assigned distinct lectures.\n# So the two lectures not scheduled are the ones not in the 6 slots.\n# To handle \"If neither fresco nor naturalism is scheduled for any day\", we add:\n# Neither fresco nor naturalism scheduled => fresco and naturalism not in any slot\nsolver.add(Not(Or([slot == lecture_idx['fresco'] for slot in all_slots])))\nsolver.add(Not(Or([slot == lecture_idx['naturalism'] for slot in all_slots])))\n\n# OPTION CHECKING\n# We want to find which lecture must be scheduled for day 1.\n# The options are:\n# (A) history\n# (B) lithography\n# (C) oils\n# (D) pastels\n# (E) sculpture\n\noptions = ['history', 'lithography', 'oils', 'pastels', 'sculpture']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that the chosen option is NOT scheduled for day 1 (either morning or afternoon)\n    # If solver is unsat, means option must be scheduled for day 1.\n    day1_slots = [schedule[(1, t)] for t in times]\n    opt_idx = lecture_idx[opt]\n    not_scheduled_day1 = And([slot != opt_idx for slot in day1_slots])\n    solver.add(not_scheduled_day1)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.\n\nIf the clans participating in the first year of a given cycle are N, O, and P, which one of the following could be the clans participating in the second year of that cycle?\n\nOptions:\n(A) N, O, S\n(B) N, O, T\n(C) N, P, S\n(D) O, P, T\n(E) O, S, T",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclans = ['N', 'O', 'P', 'S', 'T']\nnum_clans = len(clans)\nyears = 2  # We only need to model two years to check the second year's participation\nparticipants_per_year = 3\n\n# Map clan names to indices for easy reference\nclan_idx = {clan: i for i, clan in enumerate(clans)}\n\n# Variables:\n# participation[y][c] = Bool indicating if clan c participates in year y\nparticipation = [[Bool(f'year{y}_clan{c}') for c in range(num_clans)] for y in range(years)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each year exactly three clans participate\nfor y in range(years):\n    solver.add(Sum([If(participation[y][c], 1, 0) for c in range(num_clans)]) == participants_per_year)\n\n# 2. Each clan must participate at least once in any two consecutive years\n# Since we only have two years, for each clan c:\n# participation in year 0 or year 1 must be True\nfor c in range(num_clans):\n    solver.add(Or(participation[0][c], participation[1][c]))\n\n# 3. No clan participates for three consecutive years\n# Since we only have two years, this is automatically satisfied (no three consecutive years)\n\n# 4. Participation takes place in cycles, each clan participates exactly 3 times per cycle\n# Since we only have two years, and each clan can participate at most 3 times in the cycle,\n# this constraint will not be fully enforced here, but we enforce no clan participates more than 3 times\n# So for these two years, no clan can participate more than twice (since max 3 in 5 years, so 2 in 2 years is ok)\n# This constraint is irrelevant for just two years, so we skip it here.\n\n# 5. The first year participation is given: N, O, P\nfirst_year_participants = ['N', 'O', 'P']\nfor c in range(num_clans):\n    if clans[c] in first_year_participants:\n        solver.add(participation[0][c] == True)\n    else:\n        solver.add(participation[0][c] == False)\n\n# OPTION CHECKING\n\noptions = [\n    ['N', 'O', 'S'],  # A\n    ['N', 'O', 'T'],  # B\n    ['N', 'P', 'S'],  # C\n    ['O', 'P', 'T'],  # D\n    ['O', 'S', 'T']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for the second year participation according to the option\n    for c in range(num_clans):\n        if clans[c] in option:\n            solver.add(participation[1][c] == True)\n        else:\n            solver.add(participation[1][c] == False)\n    # Check if the model is satisfiable\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.\n\nWhich one of the following can be true about the clans' participation in the ceremonies?\n\nOptions:\n(A) N participates in the first, second, and third years.\n(B) N participates in the second, third, and fourth years.\n(C) Both O and S participate in the first and third years.\n(D) Both N and S participate in the first, third, and fifth years.\n(E) Both S and T participate in the second, third, and fifth years.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclans = ['N', 'O', 'P', 'S', 'T']\nyears = 5\nclan_indices = {c: i for i, c in enumerate(clans)}\n\n# Create participation variables: participate[c][y] = Bool indicating if clan c participates in year y\nparticipate = [[Bool(f\"p_{c}_{y}\") for y in range(years)] for c in range(len(clans))]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each year exactly 3 clans participate\nfor y in range(years):\n    solver.add(Sum([If(participate[c][y], 1, 0) for c in range(len(clans))]) == 3)\n\n# Each clan participates at least once in any two consecutive years\nfor c in range(len(clans)):\n    for y in range(years - 1):\n        solver.add(Or(participate[c][y], participate[c][y + 1]))\n\n# No clan participates for three consecutive years\nfor c in range(len(clans)):\n    for y in range(years - 2):\n        solver.add(Not(And(participate[c][y], participate[c][y + 1], participate[c][y + 2])))\n\n# Participation takes place in cycles; each clan participates exactly 3 times in 5 years\nfor c in range(len(clans)):\n    solver.add(Sum([If(participate[c][y], 1, 0) for y in range(years)]) == 3)\n\n# OPTION CHECKING\n# Define option constraints as functions returning a list of constraints\ndef option_A():\n    # N participates in years 1,2,3 (indices 0,1,2)\n    return [participate[clan_indices['N']][0],\n            participate[clan_indices['N']][1],\n            participate[clan_indices['N']][2]]\n\ndef option_B():\n    # N participates in years 2,3,4 (indices 1,2,3)\n    return [participate[clan_indices['N']][1],\n            participate[clan_indices['N']][2],\n            participate[clan_indices['N']][3]]\n\ndef option_C():\n    # Both O and S participate in years 1 and 3 (indices 0 and 2)\n    return [participate[clan_indices['O']][0],\n            participate[clan_indices['O']][2],\n            participate[clan_indices['S']][0],\n            participate[clan_indices['S']][2]]\n\ndef option_D():\n    # Both N and S participate in years 1,3,5 (indices 0,2,4)\n    return [participate[clan_indices['N']][0],\n            participate[clan_indices['N']][2],\n            participate[clan_indices['N']][4],\n            participate[clan_indices['S']][0],\n            participate[clan_indices['S']][2],\n            participate[clan_indices['S']][4]]\n\ndef option_E():\n    # Both S and T participate in years 2,3,5 (indices 1,2,4)\n    return [participate[clan_indices['S']][1],\n            participate[clan_indices['S']][2],\n            participate[clan_indices['S']][4],\n            participate[clan_indices['T']][1],\n            participate[clan_indices['T']][2],\n            participate[clan_indices['T']][4]]\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt())\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.\n\nAny cycle for the clans' participation in the ceremonies must be completed at the end of exactly how many years?\n\nOptions:\n(A) five\n(B) six\n(C) seven\n(D) eight\n(E) nine",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclans = ['N', 'O', 'P', 'S', 'T']\nnum_clans = len(clans)\nparticipations_per_year = 3\n\n# We want to find the minimum number of years (length of cycle) such that:\n# - Each clan participates exactly 3 times in the cycle\n# - Each year exactly 3 clans participate\n# - Each clan participates at least once in any two consecutive years\n# - No clan participates three consecutive years\n# We will try all possible cycle lengths from 5 to 9 (options given).\n\n# Variables:\n# For each year y and clan c, participation[y][c] = Bool indicating if clan c participates in year y\n# We'll create a function to test for a given cycle length\n\ndef check_cycle_length(cycle_length):\n    solver = Solver()\n    participation = [[Bool(f\"p_{y}_{c}\") for c in clans] for y in range(cycle_length)]\n\n    # CONSTRAINTS\n\n    # 1) Each year exactly 3 clans participate\n    for y in range(cycle_length):\n        year_participations = participation[y]\n        solver.add(Sum([If(p, 1, 0) for p in year_participations]) == participations_per_year)\n\n    # 2) Each clan participates exactly 3 times in the cycle\n    for c_idx in range(num_clans):\n        clan_participations = [participation[y][c_idx] for y in range(cycle_length)]\n        solver.add(Sum([If(p, 1, 0) for p in clan_participations]) == 3)\n\n    # 3) Each clan must participate at least once in any two consecutive years\n    # For all y in [0..cycle_length-2], and each clan c:\n    # participation[y][c] OR participation[y+1][c] == True\n    for c_idx in range(num_clans):\n        for y in range(cycle_length - 1):\n            solver.add(Or([participation[y][c_idx], participation[y+1][c_idx]]))\n\n    # 4) No clan participates three consecutive years\n    # For all y in [0..cycle_length-3], and each clan c:\n    # NOT (participation[y][c] AND participation[y+1][c] AND participation[y+2][c])\n    for c_idx in range(num_clans):\n        for y in range(cycle_length - 2):\n            solver.add(Not(And([participation[y][c_idx], participation[y+1][c_idx], participation[y+2][c_idx]])))\n\n    # 5) Participation takes place in cycles, so cycle repeats after cycle_length years\n    # The constraints apply only inside the cycle, so no wrap-around needed here\n\n    # Check satisfiability\n    if solver.check() == sat:\n        return True\n    else:\n        return False\n\n# OPTION CHECKING\noptions = [5, 6, 7, 8, 9]\n\nfor i, length in enumerate(options):\n    if check_cycle_length(length):\n        print(f\"'{chr(65 + i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.\n\nWhich one of the following must be true about the three clans that participate in the ceremonies in the first year?\n\nOptions:\n(A) At most two of them participate together in the third year.\n(B) At least two of them participate together in the second year.\n(C) All three of them participate together in the fourth year.\n(D) All three of them participate together in the fifth year.\n(E) None of them participates in the third year.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclans = ['N', 'O', 'P', 'S', 'T']\nnum_clans = len(clans)\nyears = 5\nparticipating_clans_per_year = 3\n\n# Map clans to indices\nclan_idx = {c: i for i, c in enumerate(clans)}\n\n# participation[y][c] = Bool indicating if clan c participates in year y\nparticipation = [[Bool(f\"Y{y}_C{c}\") for c in range(num_clans)] for y in range(years)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each year exactly 3 clans participate\nfor y in range(years):\n    solver.add(Sum([If(participation[y][c], 1, 0) for c in range(num_clans)]) == participating_clans_per_year)\n\n# Each clan participates at least once in any two consecutive years\nfor y in range(years - 1):\n    for c in range(num_clans):\n        solver.add(Or(participation[y][c], participation[y+1][c]))\n\n# No clan participates for three consecutive years\nfor y in range(years - 2):\n    for c in range(num_clans):\n        solver.add(Not(And(participation[y][c], participation[y+1][c], participation[y+2][c])))\n\n# Each cycle ends when each clan has participated 3 times; no clan participates more than 3 times in any cycle\n# Here, we consider years 1 to 5 as one cycle\nfor c in range(num_clans):\n    total_participation = Sum([If(participation[y][c], 1, 0) for y in range(years)])\n    solver.add(total_participation == 3)\n\n# OPTION CHECKING\n# Options:\n# (A) At most two of first year clans participate together in the third year.\n# (B) At least two of first year clans participate together in the second year.\n# (C) All three of first year clans participate together in the fourth year.\n# (D) All three of first year clans participate together in the fifth year.\n# (E) None of first year clans participates in the third year.\n\n# We will check each option by adding its negation and see if the model is satisfiable.\n# If the negation is unsat, the option must be true.\n\n# Helper: get participation variables for first year clans\nfirst_year_clans = participation[0]\n\ndef check_option_A():\n    # Negation of A: There exist 3 first year clans all participating together in year 3\n    # Find the three clans that participate in year 1\n    # We don't know which clans participate in year 1, but exactly 3 do.\n    # So first_year_clans is a list of 5 Bool variables, exactly 3 True.\n    # Negation: In year 3, all three first year clans participate together.\n    # So the three clans that participate in year 1 also all participate in year 3.\n\n    # We model the negation:\n    # 1) Exactly 3 clans participate in year 1 (already enforced)\n    # 2) The clans that participate in year 1 all participate in year 3\n    # That means for each clan c:\n    # If clan c participates in year 1, then clan c participates in year 3\n    # So for all c: participation[0][c] => participation[2][c]\n\n    # Add this and check satisfiability\n    solver.push()\n    for c in range(num_clans):\n        solver.add(Implies(participation[0][c], participation[2][c]))\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\ndef check_option_B():\n    # Negation of B: Less than two of first year clans participate together in second year\n    # That means at most one of the first year clans participates in second year.\n\n    # Let FYC = clans participating in year 1\n    # Count how many FYC participate in year 2 <= 1\n\n    solver.push()\n    # Count how many clans participate in year 1\n    # Already 3 by constraints\n    # Count how many of those participate in year 2\n    count_in_year2 = Sum([If(And(participation[0][c], participation[1][c]), 1, 0) for c in range(num_clans)])\n    solver.add(count_in_year2 <= 1)\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\ndef check_option_C():\n    # Negation of C: Not all three first year clans participate together in year 4\n    # That means there exists a clan that participates in year 1 but not in year 4\n\n    solver.push()\n    exists_c = []\n    for c in range(num_clans):\n        # clan participates in year 1 but not in year 4\n        exists_c.append(And(participation[0][c], Not(participation[3][c])))\n    solver.add(Or(exists_c))\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\ndef check_option_D():\n    # Negation of D: Not all three first year clans participate together in year 5\n    # That means there exists a clan that participates in year 1 but not in year 5\n\n    solver.push()\n    exists_c = []\n    for c in range(num_clans):\n        exists_c.append(And(participation[0][c], Not(participation[4][c])))\n    solver.add(Or(exists_c))\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\ndef check_option_E():\n    # Negation of E: At least one of first year clans participates in year 3\n    # That means there exists a clan c such that participation[0][c] and participation[2][c]\n\n    solver.push()\n    exists_c = []\n    for c in range(num_clans):\n        exists_c.append(And(participation[0][c], participation[2][c]))\n    solver.add(Not(Or(exists_c)))  # Negation of negation: no first year clan participates in year 3\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\n# Check options in order A to E\nif check_option_A():\n    print(\"'A'\")\nelif check_option_B():\n    print(\"'B'\")\nelif check_option_C():\n    print(\"'C'\")\nelif check_option_D():\n    print(\"'D'\")\nelif check_option_E():\n    print(\"'E'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.\n\nIf, in a particular cycle, N, O, and S participate in the ceremonies in the first year, which one of the following must be true?\n\nOptions:\n(A) N participates in the second and third years.\n(B) O participates in the third and fourth years.\n(C) N and O both participate in the third year.\n(D) P and T both participate in the fifth year.\n(E) S and T both participate in the fifth year.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclans = ['N', 'O', 'P', 'S', 'T']\nnum_clans = len(clans)\nyears = 5  # We consider 5 years as per the problem options mentioning up to fifth year\n\n# Participation variables: participation[year][clan] = Bool indicating if clan participates in that year\nparticipation = [[Bool(f\"y{y+1}_{clan}\") for clan in clans] for y in range(years)]\n\n# Map clan names to indices for convenience\nclan_idx = {clan: i for i, clan in enumerate(clans)}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each year exactly 3 clans participate\nfor y in range(years):\n    solver.add(Sum([If(participation[y][c], 1, 0) for c in range(num_clans)]) == 3)\n\n# 2. Each clan must participate at least once in any two consecutive years\n# For years 1 to 4 (index 0 to 3), for each clan c:\nfor y in range(years - 1):\n    for c in range(num_clans):\n        # participation[y][c] OR participation[y+1][c] == True\n        solver.add(Or(participation[y][c], participation[y+1][c]))\n\n# 3. No clan participates for three consecutive years\n# For years 1 to 3 (index 0 to 2), for each clan c:\nfor y in range(years - 2):\n    for c in range(num_clans):\n        # Not (participation[y][c] AND participation[y+1][c] AND participation[y+2][c])\n        solver.add(Not(And(participation[y][c], participation[y+1][c], participation[y+2][c])))\n\n# 4. Participation takes place in cycles, each clan participates exactly 3 times in the cycle of 5 years\nfor c in range(num_clans):\n    solver.add(Sum([If(participation[y][c], 1, 0) for y in range(years)]) == 3)\n\n# 5. Given: In the first year, N, O, and S participate\nsolver.add(participation[0][clan_idx['N']])\nsolver.add(participation[0][clan_idx['O']])\nsolver.add(participation[0][clan_idx['S']])\nfor c in clans:\n    if c not in ['N', 'O', 'S']:\n        solver.add(Not(participation[0][clan_idx[c]]))\n\n# OPTION CHECKING\n\noptions = {\n    'A': And(participation[1][clan_idx['N']], participation[2][clan_idx['N']]),  # N participates in 2nd and 3rd years\n    'B': And(participation[2][clan_idx['O']], participation[3][clan_idx['O']]),  # O participates in 3rd and 4th years\n    'C': And(participation[2][clan_idx['N']], participation[2][clan_idx['O']]),  # N and O both participate in 3rd year\n    'D': And(participation[4][clan_idx['P']], participation[4][clan_idx['T']]),  # P and T both participate in 5th year\n    'E': And(participation[4][clan_idx['S']], participation[4][clan_idx['T']]),  # S and T both participate in 5th year\n}\n\n# The correct answer is the one that must be true in all solutions\n# So for each option, check if its negation is satisfiable; if negation is unsat, option must be true\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(Not(options[letter]))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.\n\nIf, in a particular cycle, N, O, and T participate in the first year and if O and P participate in the fourth year, any of the following could be a clan that participates in the third year EXCEPT\n\nOptions:\n(A) N\n(B) O\n(C) P\n(D) S\n(E) T",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclans = ['N', 'O', 'P', 'S', 'T']\nnum_clans = len(clans)\nyears = 15  # Each cycle has 15 clans participations (5 clans * 3 times), 3 per year => 5 years per cycle\n\n# We model the cycle as 5 years, each year 3 clans participate\nnum_years = 5\n\n# For each year and clan, a Bool variable indicating if clan participates that year\nparticipates = {}\nfor y in range(num_years):\n    for c in clans:\n        participates[(y, c)] = Bool(f\"p_{y}_{c}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each year exactly 3 clans participate\nfor y in range(num_years):\n    solver.add(Sum([If(participates[(y, c)], 1, 0) for c in clans]) == 3)\n\n# 2. Each clan participates exactly 3 times in the cycle (no more, no less)\nfor c in clans:\n    solver.add(Sum([If(participates[(y, c)], 1, 0) for y in range(num_years)]) == 3)\n\n# 3. Each clan must participate at least once in any two consecutive years\n# For y in 0 to 3 (two consecutive years), for each clan: participates[y,c] or participates[y+1,c] == True\nfor y in range(num_years - 1):\n    for c in clans:\n        solver.add(Or(participates[(y, c)], participates[(y + 1, c)]))\n\n# 4. No clan participates for three consecutive years\n# For y in 0 to 2 (three consecutive years), for each clan: not (participates[y,c] and participates[y+1,c] and participates[y+2,c])\nfor y in range(num_years - 2):\n    for c in clans:\n        solver.add(Not(And(participates[(y, c)], participates[(y + 1, c)], participates[(y + 2, c)])))\n\n# 5. Given conditions:\n# Year 0 participants: N, O, T\nsolver.add(participates[(0, 'N')])\nsolver.add(participates[(0, 'O')])\nsolver.add(participates[(0, 'T')])\nfor c in clans:\n    if c not in ['N', 'O', 'T']:\n        solver.add(Not(participates[(0, c)]))\n\n# Year 3 participants include O and P\nsolver.add(participates[(3, 'O')])\nsolver.add(participates[(3, 'P')])\n\n# Year 3 has exactly 3 clans participating, so the third participant is unknown\n# No other constraints on year 3 participants here\n\n# OPTION CHECKING\n# We want to find which clan could NOT participate in year 2 (third year, index 2)\n# For each option, add constraint that that clan participates in year 2 and check if model is SAT\n\noptions = ['N', 'O', 'P', 'S', 'T']\n\nfor i, clan_option in enumerate(options):\n    solver.push()\n    # Add that clan_option participates in year 2\n    solver.add(participates[(2, clan_option)])\n    # Check satisfiability\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "The population of a small country is organized into five clans—N, O, P, S, and T. Each year exactly three of the five clans participate in the annual harvest ceremonies. The rules specifying the order of participation of the clans in the ceremonies are as follows: Each clan must participate at least once in any two consecutive years. No clan participates for three consecutive years. Participation takes place in cycles, with each cycle ending when each of the five clans has participated three times. Only then does a new cycle begin. No clan participates more than three times within any cycle.\n\nIf, in a particular cycle, N, O, and S participate in the ceremonies in the first year and O, S, and T participate in the third year, then which one of the following could be the clans that participate in the fifth year?\n\nOptions:\n(A) N, O, P\n(B) N, O, S\n(C) N, P, S\n(D) O, P, S\n(E) P, S, T",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclans = ['N', 'O', 'P', 'S', 'T']\nnum_clans = len(clans)\nyears = 5\nparticipation_per_year = 3\n\n# Create a participation matrix: participation[y][c] = Bool indicating if clan c participates in year y\nparticipation = [[Bool(f\"Y{y}_{clans[c]}\") for c in range(num_clans)] for y in range(years)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Exactly 3 clans participate each year\nfor y in range(years):\n    solver.add(Sum([If(participation[y][c], 1, 0) for c in range(num_clans)]) == participation_per_year)\n\n# 2. Each clan must participate at least once in any two consecutive years\n# For years 0 to 3 (pairs of consecutive years)\nfor y in range(years - 1):\n    for c in range(num_clans):\n        # clan c participates in year y or year y+1\n        solver.add(Or(participation[y][c], participation[y+1][c]))\n\n# 3. No clan participates for three consecutive years\n# For years 0 to 2 (triplets of consecutive years)\nfor y in range(years - 2):\n    for c in range(num_clans):\n        # Not all three consecutive years have participation for clan c\n        solver.add(Not(And(participation[y][c], participation[y+1][c], participation[y+2][c])))\n\n# 4. Participation takes place in cycles, each clan participates exactly 3 times per cycle (5 years)\nfor c in range(num_clans):\n    total_participation = Sum([If(participation[y][c], 1, 0) for y in range(years)])\n    solver.add(total_participation == 3)\n\n# 5. Given participation in certain years:\n# Year 1 (index 0): N, O, S participate\nfor c in range(num_clans):\n    clan = clans[c]\n    if clan in ['N', 'O', 'S']:\n        solver.add(participation[0][c] == True)\n    else:\n        solver.add(participation[0][c] == False)\n\n# Year 3 (index 2): O, S, T participate\nfor c in range(num_clans):\n    clan = clans[c]\n    if clan in ['O', 'S', 'T']:\n        solver.add(participation[2][c] == True)\n    else:\n        solver.add(participation[2][c] == False)\n\n# OPTION CHECKING\noptions = [\n    ['N', 'O', 'P'],  # A\n    ['N', 'O', 'S'],  # B\n    ['N', 'P', 'S'],  # C\n    ['O', 'P', 'S'],  # D\n    ['P', 'S', 'T']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for year 5 (index 4) participation matching the option\n    for c in range(num_clans):\n        clan = clans[c]\n        if clan in option:\n            solver.add(participation[4][c] == True)\n        else:\n            solver.add(participation[4][c] == False)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A newly formed company has five employees—F, G, H, K, and L. Each employee holds exactly one of the following positions: president, manager, or technician. Only the president is not supervised. Other employees are each supervised by exactly one employee, who is either the president or a manager. Each supervised employee holds a different position than his or her supervisor. The following conditions apply: There is exactly one president. At least one of the employees whom the president supervises is a manager. Each manager supervises at least one employee. F does not supervise any employee. G supervises exactly two employees.\n\nWhich one of the following is an acceptable assignment of employees to the positions? President Manager Technician\n\nOptions:\n(A) G H, K, L F\n(B) G H F, K, L\n(C) H F, G K, L\n(D) H, K G F, L\n(E) K F, G, H, L",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['F', 'G', 'H', 'K', 'L']\npositions = ['President', 'Manager', 'Technician']\npos_idx = {p: i for i, p in enumerate(positions)}\n\n# Create Z3 Int variables for each employee's position\nemp_pos = {e: Int(e) for e in employees}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each employee holds exactly one position (0=President,1=Manager,2=Technician)\nfor e in employees:\n    solver.add(And(emp_pos[e] >= 0, emp_pos[e] < len(positions)))\n\n# Exactly one president\nsolver.add(Sum([If(emp_pos[e] == pos_idx['President'], 1, 0) for e in employees]) == 1)\n\n# Helper: who supervises whom\n# Only president and managers can supervise\n# Each employee except president is supervised by exactly one employee who is president or manager\n# The supervised employee's position differs from supervisor's position\n\n# Identify president variable\npresident = Int('president')\nsolver.add(Or([emp_pos[e] == pos_idx['President'] for e in employees]))\n# Link president variable to the employee who is president\n# We will represent supervisor as an Int variable per employee (except president)\nsupervisor = {}\nfor e in employees:\n    if e != '':  # placeholder, all employees have supervisor except president\n        supervisor[e] = Int('sup_' + e)\n\n# We don't know which employee is president, so we map employees to indices 0..4\nemp_index = {e: i for i, e in enumerate(employees)}\n\n# Create supervisor variables for all employees except president - but we don't know who president is yet\n# Instead, we assign supervisor only to employees who are not president\n# Find president first\n# We'll create a variable 'president_emp' indicating index of president\npresident_emp = Int('president_emp')\nsolver.add(president_emp >= 0, president_emp < len(employees))\nfor i, e in enumerate(employees):\n    solver.add(If(emp_pos[e] == pos_idx['President'], president_emp == i, True))\n\n# For each employee, create supervisor variable if not president\nsupervisor_vars = {}\nfor e in employees:\n    supervisor_vars[e] = Int('sup_' + e)\n    solver.add(Or([supervisor_vars[e] == i for i in range(len(employees))] + [supervisor_vars[e] == -1]))\n# -1 means no supervisor (president)\n\n# Constraints on supervisor variables\nfor e in employees:\n    # If e is president, supervisor is -1\n    solver.add(If(emp_pos[e] == pos_idx['President'], supervisor_vars[e] == -1, And(supervisor_vars[e] >= 0, supervisor_vars[e] < len(employees))))\n\n# Supervisor must be president or manager\nfor e in employees:\n    # If e is not president\n    solver.add(If(emp_pos[e] != pos_idx['President'],\n                  Or([And(supervisor_vars[e] == emp_index[sup_e],\n                          Or(emp_pos[sup_e] == pos_idx['President'], emp_pos[sup_e] == pos_idx['Manager']))\n                     for sup_e in employees]),\n                  True))\n\n# Each employee is not supervised by themselves\nfor e in employees:\n    solver.add(supervisor_vars[e] != emp_index[e])\n\n# Only president is not supervised\nfor e in employees:\n    solver.add(If(emp_pos[e] == pos_idx['President'], supervisor_vars[e] == -1, supervisor_vars[e] != -1))\n\n# Each supervised employee holds a different position than supervisor\nfor e in employees:\n    sup = supervisor_vars[e]\n    # If supervisor exists\n    cond = And(sup >= 0, sup < len(employees))\n    # emp_pos[e] != emp_pos[employee at sup]\n    # We need to express emp_pos[e] != emp_pos of employee with index sup\n    # Create a helper function to express emp_pos of employee with index sup\n    # Since sup is variable, we use a big Or over all employees\n    pos_diff_cases = []\n    for i, sup_e in enumerate(employees):\n        pos_diff_cases.append(And(sup == i, emp_pos[e] != emp_pos[sup_e]))\n    solver.add(Implies(cond, Or(pos_diff_cases)))\n\n# There is exactly one president (already added)\n\n# At least one of the employees whom the president supervises is a manager\n# Find employees supervised by president\npres_supervised = []\nfor e in employees:\n    cond_sup_pres = supervisor_vars[e] == president_emp\n    pres_supervised.append(cond_sup_pres)\n# At least one of these employees is manager\nmanager_cases = []\nfor e in employees:\n    manager_cases.append(And(supervisor_vars[e] == president_emp, emp_pos[e] == pos_idx['Manager']))\nsolver.add(Or(manager_cases))\n\n# Each manager supervises at least one employee\nfor e in employees:\n    is_manager = emp_pos[e] == pos_idx['Manager']\n    # Employees supervised by e\n    supervised_by_e = []\n    for sub in employees:\n        supervised_by_e.append(supervisor_vars[sub] == emp_index[e])\n    solver.add(Implies(is_manager, Or(supervised_by_e)))\n\n# F does not supervise any employee\nfor e in employees:\n    solver.add(supervisor_vars[e] != emp_index['F'])\n\n# G supervises exactly two employees\ncount_g_supervised = Sum([If(supervisor_vars[e] == emp_index['G'], 1, 0) for e in employees])\nsolver.add(count_g_supervised == 2)\n\n# OPTION CHECKING\noptions = {\n    'A': {'President': 'G', 'Manager': ['H', 'K', 'L'], 'Technician': ['F']},\n    'B': {'President': 'G', 'Manager': ['H'], 'Technician': ['F', 'K', 'L']},\n    'C': {'President': 'H', 'Manager': ['F', 'G'], 'Technician': ['K', 'L']},\n    'D': {'President': 'H', 'Manager': ['K'], 'Technician': ['G', 'F', 'L']},\n    'E': {'President': 'K', 'Manager': ['F', 'G', 'H', 'L'], 'Technician': []},\n}\n\nfor letter, assignment in options.items():\n    solver.push()\n    # Add constraints for this option\n    # Set positions accordingly\n    # President\n    pres_emp = assignment['President']\n    for e in employees:\n        if e == pres_emp:\n            solver.add(emp_pos[e] == pos_idx['President'])\n        else:\n            solver.add(emp_pos[e] != pos_idx['President'])\n    # Managers\n    for m in assignment['Manager']:\n        solver.add(emp_pos[m] == pos_idx['Manager'])\n    # Technicians\n    for t in assignment['Technician']:\n        solver.add(emp_pos[t] == pos_idx['Technician'])\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A newly formed company has five employees—F, G, H, K, and L. Each employee holds exactly one of the following positions: president, manager, or technician. Only the president is not supervised. Other employees are each supervised by exactly one employee, who is either the president or a manager. Each supervised employee holds a different position than his or her supervisor. The following conditions apply: There is exactly one president. At least one of the employees whom the president supervises is a manager. Each manager supervises at least one employee. F does not supervise any employee. G supervises exactly two employees.\n\nWhich one of the following must be true?\n\nOptions:\n(A) There are at most three technicians.\n(B) There is exactly one technician.\n(C) There are at least two managers.\n(D) There are exactly two managers.\n(E) There are exactly two employees who supervise no one.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['F', 'G', 'H', 'K', 'L']\npositions = ['president', 'manager', 'technician']\npos_idx = {p: i for i, p in enumerate(positions)}\n\n# Variables for positions: pos[e] in {0,1,2} representing president, manager, technician\npos = {e: Int(f'pos_{e}') for e in employees}\n\n# Variables for supervisor: supervisor[e] in employees or None (president has no supervisor)\n# We'll represent supervisor as Int in [0..4], or -1 for no supervisor\nemp_idx = {e: i for i, e in enumerate(employees)}\nsupervisor = {e: Int(f'supervisor_{e}') for e in employees}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each position is in 0..2\nfor e in employees:\n    solver.add(And(pos[e] >= 0, pos[e] < len(positions)))\n\n# Each supervisor is in -1..4 (where -1 means no supervisor)\nfor e in employees:\n    solver.add(And(supervisor[e] >= -1, supervisor[e] < len(employees)))\n\n# Exactly one president\npresidents = [If(pos[e] == pos_idx['president'], 1, 0) for e in employees]\nsolver.add(Sum(presidents) == 1)\n\n# The president is the only employee with no supervisor\nfor e in employees:\n    is_president = pos[e] == pos_idx['president']\n    no_supervisor = supervisor[e] == -1\n    solver.add(no_supervisor == is_president)\n\n# Other employees have exactly one supervisor who is president or manager\nfor e in employees:\n    if e != 'F' and e != 'G' and e != 'H' and e != 'K' and e != 'L':\n        pass  # no other employees\n    # For all employees except president:\n    is_president = pos[e] == pos_idx['president']\n    # If not president, supervisor != -1\n    solver.add(Implies(Not(is_president), supervisor[e] != -1))\n    # If supervisor[e] != -1, then supervisor's position is president or manager\n    sup = supervisor[e]\n    sup_pos = Int(f'sup_pos_{e}')\n    # sup_pos = pos of supervisor[e], if supervisor[e] != -1 else -1\n    # We'll create constraints for sup_pos for all possible values:\n    # We'll use a helper array of pos values to select from\n    # Create array of pos values\n    # Use If to select supervisor position\n    sup_pos_val = []\n    for i in range(len(employees)):\n        cond = sup == i\n        sup_pos_val.append(If(cond, pos[employees[i]], -1))\n    # sup_pos is one of sup_pos_val (only one is true)\n    solver.add(sup_pos == Sum(sup_pos_val))\n    # sup_pos must be president(0) or manager(1)\n    solver.add(Implies(sup != -1, Or(sup_pos == pos_idx['president'], sup_pos == pos_idx['manager'])))\n\n# Each supervised employee holds a different position than his/her supervisor\nfor e in employees:\n    sup = supervisor[e]\n    is_president = pos[e] == pos_idx['president']\n    # If e is president, no supervisor, skip\n    # If supervisor exists, positions differ\n    cond = And(sup != -1, Not(is_president))\n    sup_pos = Int(f'sup_pos2_{e}')\n    sup_pos_val = []\n    for i in range(len(employees)):\n        cond_sup = sup == i\n        sup_pos_val.append(If(cond_sup, pos[employees[i]], -1))\n    solver.add(sup_pos == Sum(sup_pos_val))\n    solver.add(Implies(cond, pos[e] != sup_pos))\n\n# There is exactly one president (already added)\n\n# At least one of the employees whom the president supervises is a manager\n# Find president index\npresident_idx = Int('president_idx')\nfor i, e in enumerate(employees):\n    solver.add(If(pos[e] == pos_idx['president'], president_idx == i, True))\n# president_idx must be in 0..4\nsolver.add(And(president_idx >= 0, president_idx < len(employees)))\n\n# Employees supervised by president:\npres_supervised = []\nfor e in employees:\n    cond = supervisor[e] == president_idx\n    pres_supervised.append(If(cond, 1, 0))\n# Number supervised by president >= 1 (at least one)\nsolver.add(Sum(pres_supervised) >= 1)\n\n# Among employees supervised by president, at least one is manager\npres_managers = []\nfor e in employees:\n    cond = And(supervisor[e] == president_idx, pos[e] == pos_idx['manager'])\n    pres_managers.append(If(cond, 1, 0))\nsolver.add(Sum(pres_managers) >= 1)\n\n# Each manager supervises at least one employee\nfor e in employees:\n    is_manager = pos[e] == pos_idx['manager']\n    supervised = []\n    for f in employees:\n        supervised.append(If(supervisor[f] == emp_idx[e], 1, 0))\n    total_supervised = Sum(supervised)\n    # If manager, total supervised >= 1\n    solver.add(Implies(is_manager, total_supervised >= 1))\n\n# F does not supervise any employee\nfor e in employees:\n    solver.add(If(supervisor[e] == emp_idx['F'], False, True))\n\n# G supervises exactly two employees\nsupervised_by_G = []\nfor e in employees:\n    supervised_by_G.append(If(supervisor[e] == emp_idx['G'], 1, 0))\nsolver.add(Sum(supervised_by_G) == 2)\n\n# OPTION CHECKING\noptions = [\n    # (A) There are at most three technicians.\n    lambda: Sum([If(pos[e] == pos_idx['technician'], 1, 0) for e in employees]) <= 3,\n    # (B) There is exactly one technician.\n    lambda: Sum([If(pos[e] == pos_idx['technician'], 1, 0) for e in employees]) == 1,\n    # (C) There are at least two managers.\n    lambda: Sum([If(pos[e] == pos_idx['manager'], 1, 0) for e in employees]) >= 2,\n    # (D) There are exactly two managers.\n    lambda: Sum([If(pos[e] == pos_idx['manager'], 1, 0) for e in employees]) == 2,\n    # (E) There are exactly two employees who supervise no one.\n    lambda: Sum([If(Sum([If(supervisor[f] == emp_idx[e], 1, 0) for f in employees]) == 0, 1, 0) for e in employees]) == 2,\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add negation of option to test if option must be true\n    solver.add(Not(opt()))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A newly formed company has five employees—F, G, H, K, and L. Each employee holds exactly one of the following positions: president, manager, or technician. Only the president is not supervised. Other employees are each supervised by exactly one employee, who is either the president or a manager. Each supervised employee holds a different position than his or her supervisor. The following conditions apply: There is exactly one president. At least one of the employees whom the president supervises is a manager. Each manager supervises at least one employee. F does not supervise any employee. G supervises exactly two employees.\n\nIf K supervises exactly two employees, which one of the following must be true?\n\nOptions:\n(A) F is supervised by K.\n(B) G is a manager.\n(C) L is supervised.\n(D) There are exactly two managers.\n(E) There are exactly two technicians.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['F', 'G', 'H', 'K', 'L']\npositions = ['president', 'manager', 'technician']\npos_idx = {p: i for i, p in enumerate(positions)}\n\n# Variables for positions: employee -> Int (0=president,1=manager,2=technician)\nposition = {e: Int(f'pos_{e}') for e in employees}\n\n# Variables for supervisors: employee -> Int (index of supervisor in employees or -1 if none)\n# Only president has no supervisor, so supervisor = -1 means no supervisor\nsupervisor = {e: Int(f'sup_{e}') for e in employees}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each employee holds exactly one position\nfor e in employees:\n    solver.add(And(position[e] >= 0, position[e] <= 2))\n\n# 2. Exactly one president\nsolver.add(Sum([If(position[e] == pos_idx['president'], 1, 0) for e in employees]) == 1)\n\n# 3. Only president is not supervised\nfor e in employees:\n    is_president = position[e] == pos_idx['president']\n    # If president, supervisor == -1\n    solver.add(If(is_president, supervisor[e] == -1, supervisor[e] >= 0))\n    # If not president, supervisor in employees\n    solver.add(If(is_president, True, And(supervisor[e] >= 0, supervisor[e] < len(employees))))\n\n# 4. Each supervised employee is supervised by president or manager\nfor e in employees:\n    is_president = position[e] == pos_idx['president']\n    # If not president, supervisor's position is president or manager\n    sup = supervisor[e]\n    sup_pos = Int(f'sup_pos_{e}')\n    # Define sup_pos only if supervisor exists\n    # Use conditional: if supervisor[e] == -1 then sup_pos = -1 else position[supervisor[e]]\n    # Create an array of positions to index\n    pos_array = [position[emp] for emp in employees]\n    # Because Z3 does not allow direct indexing with variables, use Ifs\n    sup_pos_cases = []\n    for i, emp in enumerate(employees):\n        sup_pos_cases.append((sup == i, position[emp]))\n    sup_pos_expr = If(sup == -1, -1,\n                      If(sup_pos_cases[0][0], sup_pos_cases[0][1],\n                         If(sup_pos_cases[1][0], sup_pos_cases[1][1],\n                            If(sup_pos_cases[2][0], sup_pos_cases[2][1],\n                               If(sup_pos_cases[3][0], sup_pos_cases[3][1],\n                                  If(sup_pos_cases[4][0], sup_pos_cases[4][1], -1))))))\n    solver.add(sup_pos == sup_pos_expr)\n    # If supervised (not president), supervisor's position in {president, manager} i.e. 0 or 1\n    solver.add(If(is_president, True, Or(sup_pos == pos_idx['president'], sup_pos == pos_idx['manager'])))\n\n# 5. Each supervised employee holds different position than supervisor\nfor e in employees:\n    is_president = position[e] == pos_idx['president']\n    sup = supervisor[e]\n    sup_pos = Int(f'sup_pos2_{e}')\n    sup_pos_cases = []\n    for i, emp in enumerate(employees):\n        sup_pos_cases.append((sup == i, position[emp]))\n    sup_pos_expr = If(sup == -1, -1,\n                      If(sup_pos_cases[0][0], sup_pos_cases[0][1],\n                         If(sup_pos_cases[1][0], sup_pos_cases[1][1],\n                            If(sup_pos_cases[2][0], sup_pos_cases[2][1],\n                               If(sup_pos_cases[3][0], sup_pos_cases[3][1],\n                                  If(sup_pos_cases[4][0], sup_pos_cases[4][1], -1))))))\n    solver.add(sup_pos == sup_pos_expr)\n    # If supervised, positions differ\n    solver.add(If(is_president, True, position[e] != sup_pos))\n\n# 6. At least one of the employees whom the president supervises is a manager\n# Find president index\npresident_idx = Int('president_idx')\nfor i, e in enumerate(employees):\n    solver.add(If(position[e] == pos_idx['president'], president_idx == i, True))\n# Employees supervised by president: supervisor[e] == president_idx\npresident_subordinates = [Bool(f'pres_sub_{e}') for e in employees]\nfor i, e in enumerate(employees):\n    solver.add(president_subordinates[i] == (supervisor[e] == president_idx))\n# At least one subordinate is a manager\nmanager_subordinate_conditions = []\nfor i, e in enumerate(employees):\n    cond = And(president_subordinates[i], position[e] == pos_idx['manager'])\n    manager_subordinate_conditions.append(cond)\nsolver.add(Or(manager_subordinate_conditions))\n\n# 7. Each manager supervises at least one employee\nfor e in employees:\n    is_manager = position[e] == pos_idx['manager']\n    # Count number of employees supervised by e\n    supervised_by_e = [supervisor[emp] == employees.index(e) for emp in employees]\n    count_supervised = Sum([If(cond, 1, 0) for cond in supervised_by_e])\n    solver.add(If(is_manager, count_supervised >= 1, True))\n\n# 8. F does not supervise any employee\nsupervised_by_F = [supervisor[emp] == employees.index('F') for emp in employees]\ncount_supervised_by_F = Sum([If(cond, 1, 0) for cond in supervised_by_F])\nsolver.add(count_supervised_by_F == 0)\n\n# 9. G supervises exactly two employees\nsupervised_by_G = [supervisor[emp] == employees.index('G') for emp in employees]\ncount_supervised_by_G = Sum([If(cond, 1, 0) for cond in supervised_by_G])\nsolver.add(count_supervised_by_G == 2)\n\n# 10. K supervises exactly two employees (given condition for the question)\nsupervised_by_K = [supervisor[emp] == employees.index('K') for emp in employees]\ncount_supervised_by_K = Sum([If(cond, 1, 0) for cond in supervised_by_K])\nsolver.add(count_supervised_by_K == 2)\n\n# OPTION CHECKING\n# Options:\n# (A) F is supervised by K.\n# (B) G is a manager.\n# (C) L is supervised.\n# (D) There are exactly two managers.\n# (E) There are exactly two technicians.\n\noptions = []\n\n# Option A: F is supervised by K\noptA = supervisor['F'] == employees.index('K')\noptions.append(optA)\n\n# Option B: G is a manager\noptB = position['G'] == pos_idx['manager']\noptions.append(optB)\n\n# Option C: L is supervised (i.e. supervisor[L] != -1)\noptC = supervisor['L'] != -1\noptions.append(optC)\n\n# Option D: Exactly two managers\nnum_managers = Sum([If(position[e] == pos_idx['manager'], 1, 0) for e in employees])\noptD = num_managers == 2\noptions.append(optD)\n\n# Option E: Exactly two technicians\nnum_technicians = Sum([If(position[e] == pos_idx['technician'], 1, 0) for e in employees])\noptE = num_technicians == 2\noptions.append(optE)\n\n# Check each option in turn by adding its negation and checking unsat (must be true in all models)\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(Not(opt))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "During each of the fall, winter, spring, and summer seasons of one year, Nikki and Otto each participate in exactly one of the following five sports: hockey, kayaking, mountaineering, running, and volleyball. Each child participates in exactly four different sports during the year. In the fall, each child participates in mountaineering, running, or volleyball. In the winter, each child participates in hockey or volleyball. In the spring, each child participates in kayaking, mountaineering, running, or volleyball. In the summer, each child participates in kayaking, mountaineering, or volleyball. Nikki and Otto do not participate in the same sport during the same season. Otto's summer sport is volleyball.\n\nWhich one of the following statements must be true?\n\nOptions:\n(A) Nikki's fall sport is running.\n(B) Nikki's winter sport is volleyball.\n(C) Nikki's spring sport is mountaineering.\n(D) Otto's fall sport is mountaineering.\n(E) Otto's spring sport is kayaking.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nseasons = ['fall', 'winter', 'spring', 'summer']\nsports = ['hockey', 'kayaking', 'mountaineering', 'running', 'volleyball']\nchildren = ['Nikki', 'Otto']\n\n# Map sports and seasons to indices for Z3 variables\nsport_idx = {sport: i for i, sport in enumerate(sports)}\nseason_idx = {season: i for i, season in enumerate(seasons)}\n\n# Create Z3 Int variables for each child's sport in each season\n# Values represent indices of sports\nsport_vars = {}\nfor child in children:\n    for season in seasons:\n        sport_vars[(child, season)] = Int(f\"{child}_{season}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each child's sport in each season must be a valid sport index\nfor child in children:\n    for season in seasons:\n        solver.add(And(sport_vars[(child, season)] >= 0, sport_vars[(child, season)] < len(sports)))\n\n# Each child participates in exactly four different sports during the year\n# So all four sports for each child are distinct\nfor child in children:\n    vars_list = [sport_vars[(child, season)] for season in seasons]\n    solver.add(Distinct(vars_list))\n\n# Season-specific sport restrictions for each child\n\n# Fall: mountaineering, running, or volleyball\nfall_allowed = [sport_idx['mountaineering'], sport_idx['running'], sport_idx['volleyball']]\nfor child in children:\n    solver.add(Or([sport_vars[(child, 'fall')] == s for s in fall_allowed]))\n\n# Winter: hockey or volleyball\nwinter_allowed = [sport_idx['hockey'], sport_idx['volleyball']]\nfor child in children:\n    solver.add(Or([sport_vars[(child, 'winter')] == s for s in winter_allowed]))\n\n# Spring: kayaking, mountaineering, running, or volleyball\nspring_allowed = [sport_idx['kayaking'], sport_idx['mountaineering'], sport_idx['running'], sport_idx['volleyball']]\nfor child in children:\n    solver.add(Or([sport_vars[(child, 'spring')] == s for s in spring_allowed]))\n\n# Summer: kayaking, mountaineering, or volleyball\nsummer_allowed = [sport_idx['kayaking'], sport_idx['mountaineering'], sport_idx['volleyball']]\nfor child in children:\n    solver.add(Or([sport_vars[(child, 'summer')] == s for s in summer_allowed]))\n\n# Nikki and Otto do not participate in the same sport during the same season\nfor season in seasons:\n    solver.add(sport_vars[('Nikki', season)] != sport_vars[('Otto', season)])\n\n# Otto's summer sport is volleyball\nsolver.add(sport_vars[('Otto', 'summer')] == sport_idx['volleyball'])\n\n# OPTION CHECKING\n# Define option constraints to test\noptions = {\n    'A': sport_vars[('Nikki', 'fall')] == sport_idx['running'],\n    'B': sport_vars[('Nikki', 'winter')] == sport_idx['volleyball'],\n    'C': sport_vars[('Nikki', 'spring')] == sport_idx['mountaineering'],\n    'D': sport_vars[('Otto', 'fall')] == sport_idx['mountaineering'],\n    'E': sport_vars[('Otto', 'spring')] == sport_idx['kayaking']\n}\n\n# Check which option must be true\n# To do this, for each option, check if the negation is satisfiable.\n# If negation is unsat, then the option must be true.\nfor opt_letter, opt_constraint in options.items():\n    solver.push()\n    solver.add(Not(opt_constraint))\n    if solver.check() == unsat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "During each of the fall, winter, spring, and summer seasons of one year, Nikki and Otto each participate in exactly one of the following five sports: hockey, kayaking, mountaineering, running, and volleyball. Each child participates in exactly four different sports during the year. In the fall, each child participates in mountaineering, running, or volleyball. In the winter, each child participates in hockey or volleyball. In the spring, each child participates in kayaking, mountaineering, running, or volleyball. In the summer, each child participates in kayaking, mountaineering, or volleyball. Nikki and Otto do not participate in the same sport during the same season. Otto's summer sport is volleyball.\n\nIt CANNOT be true that both Nikki and Otto participate during the year in which one of the following sports?\n\nOptions:\n(A) hockey\n(B) kayaking\n(C) mountaineering\n(D) running\n(E) volleyball",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nseasons = ['fall', 'winter', 'spring', 'summer']\nsports = ['hockey', 'kayaking', 'mountaineering', 'running', 'volleyball']\nplayers = ['Nikki', 'Otto']\n\n# Map sport names to indices for Z3 variables\nsport_indices = {sport: i for i, sport in enumerate(sports)}\n\n# Create Z3 Int variables for each player and season\n# Each variable represents the sport index the player participates in that season\nparticipation = {}\nfor player in players:\n    participation[player] = {}\n    for season in seasons:\n        participation[player][season] = Int(f\"{player}_{season}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each participation variable must be a valid sport index\nfor player in players:\n    for season in seasons:\n        solver.add(And(participation[player][season] >= 0, participation[player][season] < len(sports)))\n\n# 2. Each child participates in exactly four different sports during the year\n# That means all four seasons' sports for each player are distinct\nfor player in players:\n    solver.add(Distinct([participation[player][season] for season in seasons]))\n\n# 3. Seasonal restrictions for each child\n\n# Fall: mountaineering, running, or volleyball\nfall_allowed = [sport_indices[s] for s in ['mountaineering', 'running', 'volleyball']]\nfor player in players:\n    solver.add(Or([participation[player]['fall'] == s for s in fall_allowed]))\n\n# Winter: hockey or volleyball\nwinter_allowed = [sport_indices[s] for s in ['hockey', 'volleyball']]\nfor player in players:\n    solver.add(Or([participation[player]['winter'] == s for s in winter_allowed]))\n\n# Spring: kayaking, mountaineering, running, or volleyball\nspring_allowed = [sport_indices[s] for s in ['kayaking', 'mountaineering', 'running', 'volleyball']]\nfor player in players:\n    solver.add(Or([participation[player]['spring'] == s for s in spring_allowed]))\n\n# Summer: kayaking, mountaineering, or volleyball\nsummer_allowed = [sport_indices[s] for s in ['kayaking', 'mountaineering', 'volleyball']]\nfor player in players:\n    solver.add(Or([participation[player]['summer'] == s for s in summer_allowed]))\n\n# 4. Nikki and Otto do not participate in the same sport during the same season\nfor season in seasons:\n    solver.add(participation['Nikki'][season] != participation['Otto'][season])\n\n# 5. Otto's summer sport is volleyball\nsolver.add(participation['Otto']['summer'] == sport_indices['volleyball'])\n\n# OPTION CHECKING\n\noptions = ['hockey', 'kayaking', 'mountaineering', 'running', 'volleyball']\n\nfor i, sport in enumerate(options):\n    solver.push()\n    # Add constraint that both Nikki and Otto participate in the sport during the year\n    # That means sport appears in Nikki's sports and in Otto's sports at least once\n    nikki_sports = [participation['Nikki'][season] == sport_indices[sport] for season in seasons]\n    otto_sports = [participation['Otto'][season] == sport_indices[sport] for season in seasons]\n    both_participate = And(Or(nikki_sports), Or(otto_sports))\n    solver.add(both_participate)\n\n    # Check if this is possible\n    if solver.check() == unsat:\n        # If unsat, then this cannot be true that both participate in this sport\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "During each of the fall, winter, spring, and summer seasons of one year, Nikki and Otto each participate in exactly one of the following five sports: hockey, kayaking, mountaineering, running, and volleyball. Each child participates in exactly four different sports during the year. In the fall, each child participates in mountaineering, running, or volleyball. In the winter, each child participates in hockey or volleyball. In the spring, each child participates in kayaking, mountaineering, running, or volleyball. In the summer, each child participates in kayaking, mountaineering, or volleyball. Nikki and Otto do not participate in the same sport during the same season. Otto's summer sport is volleyball.\n\nIf Nikki's fall sport is running, then which one of the following statements must be true?\n\nOptions:\n(A) Nikki's spring sport is kayaking.\n(B) Nikki's summer sport is mountaineering.\n(C) Otto's fall sport is mountaineering.\n(D) Otto's spring sport is kayaking.\n(E) Otto's spring sport is running.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nseasons = ['fall', 'winter', 'spring', 'summer']\nsports = ['hockey', 'kayaking', 'mountaineering', 'running', 'volleyball']\n\n# Map sports to indices\nsport_idx = {sport: i for i, sport in enumerate(sports)}\n\n# Create variables for Nikki and Otto for each season\nNikki = {season: Int(f'Nikki_{season}') for season in seasons}\nOtto = {season: Int(f'Otto_{season}') for season in seasons}\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each child's sport each season is within valid range\nfor season in seasons:\n    solver.add(And(Nikki[season] >= 0, Nikki[season] < len(sports)))\n    solver.add(And(Otto[season] >= 0, Otto[season] < len(sports)))\n\n# Each child participates in exactly four different sports during the year\nsolver.add(Distinct([Nikki[season] for season in seasons]))\nsolver.add(Distinct([Otto[season] for season in seasons]))\n\n# Season-specific allowed sports for each child\n\n# Fall: mountaineering, running, or volleyball\nfall_allowed = [sport_idx[s] for s in ['mountaineering', 'running', 'volleyball']]\nsolver.add(Or([Nikki['fall'] == s for s in fall_allowed]))\nsolver.add(Or([Otto['fall'] == s for s in fall_allowed]))\n\n# Winter: hockey or volleyball\nwinter_allowed = [sport_idx[s] for s in ['hockey', 'volleyball']]\nsolver.add(Or([Nikki['winter'] == s for s in winter_allowed]))\nsolver.add(Or([Otto['winter'] == s for s in winter_allowed]))\n\n# Spring: kayaking, mountaineering, running, or volleyball\nspring_allowed = [sport_idx[s] for s in ['kayaking', 'mountaineering', 'running', 'volleyball']]\nsolver.add(Or([Nikki['spring'] == s for s in spring_allowed]))\nsolver.add(Or([Otto['spring'] == s for s in spring_allowed]))\n\n# Summer: kayaking, mountaineering, or volleyball\nsummer_allowed = [sport_idx[s] for s in ['kayaking', 'mountaineering', 'volleyball']]\nsolver.add(Or([Nikki['summer'] == s for s in summer_allowed]))\nsolver.add(Or([Otto['summer'] == s for s in summer_allowed]))\n\n# Nikki and Otto do not participate in the same sport during the same season\nfor season in seasons:\n    solver.add(Nikki[season] != Otto[season])\n\n# Otto's summer sport is volleyball\nsolver.add(Otto['summer'] == sport_idx['volleyball'])\n\n# Nikki's fall sport is running (given condition)\nsolver.add(Nikki['fall'] == sport_idx['running'])\n\n# OPTION CHECKING\n\n# Define the options as constraints to check\noptions = {\n    'A': Nikki['spring'] == sport_idx['kayaking'],\n    'B': Nikki['summer'] == sport_idx['mountaineering'],\n    'C': Otto['fall'] == sport_idx['mountaineering'],\n    'D': Otto['spring'] == sport_idx['kayaking'],\n    'E': Otto['spring'] == sport_idx['running'],\n}\n\n# Check which option must be true\n# For each option, check if the negation of that option is satisfiable with the constraints.\n# If negation is unsat, that means the option must be true.\n\nfor letter, constraint in options.items():\n    solver.push()\n    solver.add(Not(constraint))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "During each of the fall, winter, spring, and summer seasons of one year, Nikki and Otto each participate in exactly one of the following five sports: hockey, kayaking, mountaineering, running, and volleyball. Each child participates in exactly four different sports during the year. In the fall, each child participates in mountaineering, running, or volleyball. In the winter, each child participates in hockey or volleyball. In the spring, each child participates in kayaking, mountaineering, running, or volleyball. In the summer, each child participates in kayaking, mountaineering, or volleyball. Nikki and Otto do not participate in the same sport during the same season. Otto's summer sport is volleyball.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) Nikki's fall sport is neither mountaineering nor running.\n(B) Nikki's spring sport is neither mountaineering nor running.\n(C) Nikki's summer sport is neither kayaking nor mountaineering.\n(D) Otto's fall sport is neither mountaineering nor running.\n(E) Otto's spring sport is neither kayaking, nor mountaineering, nor running.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Define seasons and sports\nseasons = ['fall', 'winter', 'spring', 'summer']\nsports = ['hockey', 'kayaking', 'mountaineering', 'running', 'volleyball']\n\n# Create integer variables for Nikki and Otto for each season\nNikki = {season: Int(f'Nikki_{season}') for season in seasons}\nOtto = {season: Int(f'Otto_{season}') for season in seasons}\n\n# Map sports to indices for easy reference\nsport_indices = {sport: i for i, sport in enumerate(sports)}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each sport index must be valid (0 to 4) for all seasons and both children\nfor season in seasons:\n    solver.add(And(Nikki[season] >= 0, Nikki[season] < len(sports)))\n    solver.add(And(Otto[season] >= 0, Otto[season] < len(sports)))\n\n# Each child participates in exactly four different sports during the year (all distinct)\nsolver.add(Distinct([Nikki[season] for season in seasons]))\nsolver.add(Distinct([Otto[season] for season in seasons]))\n\n# In the fall, each child participates in mountaineering, running, or volleyball\nfall_allowed = [sport_indices[s] for s in ['mountaineering', 'running', 'volleyball']]\nsolver.add(Or([Nikki['fall'] == s for s in fall_allowed]))\nsolver.add(Or([Otto['fall'] == s for s in fall_allowed]))\n\n# In the winter, each child participates in hockey or volleyball\nwinter_allowed = [sport_indices[s] for s in ['hockey', 'volleyball']]\nsolver.add(Or([Nikki['winter'] == s for s in winter_allowed]))\nsolver.add(Or([Otto['winter'] == s for s in winter_allowed]))\n\n# In the spring, each child participates in kayaking, mountaineering, running, or volleyball\nspring_allowed = [sport_indices[s] for s in ['kayaking', 'mountaineering', 'running', 'volleyball']]\nsolver.add(Or([Nikki['spring'] == s for s in spring_allowed]))\nsolver.add(Or([Otto['spring'] == s for s in spring_allowed]))\n\n# In the summer, each child participates in kayaking, mountaineering, or volleyball\nsummer_allowed = [sport_indices[s] for s in ['kayaking', 'mountaineering', 'volleyball']]\nsolver.add(Or([Nikki['summer'] == s for s in summer_allowed]))\nsolver.add(Or([Otto['summer'] == s for s in summer_allowed]))\n\n# Nikki and Otto do not participate in the same sport during the same season\nfor season in seasons:\n    solver.add(Nikki[season] != Otto[season])\n\n# Otto's summer sport is volleyball\nsolver.add(Otto['summer'] == sport_indices['volleyball'])\n\n# OPTION CHECKING\n# Define options as lambda functions adding the option-specific constraint\noptions = [\n    # (A) Nikki's fall sport is neither mountaineering nor running.\n    lambda: And(Nikki['fall'] != sport_indices['mountaineering'], Nikki['fall'] != sport_indices['running']),\n    # (B) Nikki's spring sport is neither mountaineering nor running.\n    lambda: And(Nikki['spring'] != sport_indices['mountaineering'], Nikki['spring'] != sport_indices['running']),\n    # (C) Nikki's summer sport is neither kayaking nor mountaineering.\n    lambda: And(Nikki['summer'] != sport_indices['kayaking'], Nikki['summer'] != sport_indices['mountaineering']),\n    # (D) Otto's fall sport is neither mountaineering nor running.\n    lambda: And(Otto['fall'] != sport_indices['mountaineering'], Otto['fall'] != sport_indices['running']),\n    # (E) Otto's spring sport is neither kayaking, nor mountaineering, nor running.\n    lambda: And(Otto['spring'] != sport_indices['kayaking'], Otto['spring'] != sport_indices['mountaineering'], Otto['spring'] != sport_indices['running']),\n]\n\n# Check each option\nfor i, option_constraint in enumerate(options):\n    solver.push()\n    solver.add(option_constraint())\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "During each of the fall, winter, spring, and summer seasons of one year, Nikki and Otto each participate in exactly one of the following five sports: hockey, kayaking, mountaineering, running, and volleyball. Each child participates in exactly four different sports during the year. In the fall, each child participates in mountaineering, running, or volleyball. In the winter, each child participates in hockey or volleyball. In the spring, each child participates in kayaking, mountaineering, running, or volleyball. In the summer, each child participates in kayaking, mountaineering, or volleyball. Nikki and Otto do not participate in the same sport during the same season. Otto's summer sport is volleyball.\n\nIf Otto does not run during the year, then which one of the following statements must be false?\n\nOptions:\n(A) Nikki's fall sport is running.\n(B) Nikki's spring sport is running.\n(C) Nikki's summer sport is kayaking.\n(D) Otto's fall sport is mountaineering.\n(E) Otto's spring sport is kayaking.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nseasons = ['fall', 'winter', 'spring', 'summer']\nsports = ['hockey', 'kayaking', 'mountaineering', 'running', 'volleyball']\nchildren = ['Nikki', 'Otto']\n\n# Map sports to indices for easy reference\nsport_idx = {s: i for i, s in enumerate(sports)}\nseason_idx = {s: i for i, s in enumerate(seasons)}\n\n# Create variables for each child and season: which sport they do\n# Variables: child_season_sport[child][season] = Int representing sport index\nchild_season_sport = {\n    c: [Int(f\"{c}_{season}\") for season in seasons]\n    for c in children\n}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each child's sport in each season is within valid sport indices\nfor c in children:\n    for i in range(len(seasons)):\n        solver.add(And(child_season_sport[c][i] >= 0, child_season_sport[c][i] < len(sports)))\n\n# Each child participates in exactly four different sports during the year\n# i.e., the four sports assigned to the four seasons are distinct\nfor c in children:\n    solver.add(Distinct(child_season_sport[c]))\n\n# Season-specific sport restrictions:\n\n# Fall: mountaineering, running, or volleyball\nfall_allowed = [sport_idx[s] for s in ['mountaineering', 'running', 'volleyball']]\nfor c in children:\n    solver.add(Or([child_season_sport[c][season_idx['fall']] == s for s in fall_allowed]))\n\n# Winter: hockey or volleyball\nwinter_allowed = [sport_idx[s] for s in ['hockey', 'volleyball']]\nfor c in children:\n    solver.add(Or([child_season_sport[c][season_idx['winter']] == s for s in winter_allowed]))\n\n# Spring: kayaking, mountaineering, running, or volleyball\nspring_allowed = [sport_idx[s] for s in ['kayaking', 'mountaineering', 'running', 'volleyball']]\nfor c in children:\n    solver.add(Or([child_season_sport[c][season_idx['spring']] == s for s in spring_allowed]))\n\n# Summer: kayaking, mountaineering, or volleyball\nsummer_allowed = [sport_idx[s] for s in ['kayaking', 'mountaineering', 'volleyball']]\nfor c in children:\n    solver.add(Or([child_season_sport[c][season_idx['summer']] == s for s in summer_allowed]))\n\n# Nikki and Otto do not participate in the same sport during the same season\nfor i in range(len(seasons)):\n    solver.add(child_season_sport['Nikki'][i] != child_season_sport['Otto'][i])\n\n# Otto's summer sport is volleyball\nsolver.add(child_season_sport['Otto'][season_idx['summer']] == sport_idx['volleyball'])\n\n# Otto does not run during the year\n# So none of Otto's sports is running\nfor i in range(len(seasons)):\n    solver.add(child_season_sport['Otto'][i] != sport_idx['running'])\n\n# OPTION CHECKING\n\n# Each option states a fact about a child's sport in a season\n# We want to find which option must be false if Otto does not run during the year\n# So we check each option by adding it as a constraint and see if the model is SAT\n\noptions = [\n    # (description, constraint)\n    (\"Nikki's fall sport is running.\",\n     child_season_sport['Nikki'][season_idx['fall']] == sport_idx['running']),\n    (\"Nikki's spring sport is running.\",\n     child_season_sport['Nikki'][season_idx['spring']] == sport_idx['running']),\n    (\"Nikki's summer sport is kayaking.\",\n     child_season_sport['Nikki'][season_idx['summer']] == sport_idx['kayaking']),\n    (\"Otto's fall sport is mountaineering.\",\n     child_season_sport['Otto'][season_idx['fall']] == sport_idx['mountaineering']),\n    (\"Otto's spring sport is kayaking.\",\n     child_season_sport['Otto'][season_idx['spring']] == sport_idx['kayaking']),\n]\n\nfor i, (desc, constraint) in enumerate(options):\n    solver.push()\n    solver.add(constraint)\n    if solver.check() == sat:\n        # This option can be true under the given conditions\n        solver.pop()\n    else:\n        # This option must be false\n        solver.pop()\n        print(f\"'{chr(65 + i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "During each of the fall, winter, spring, and summer seasons of one year, Nikki and Otto each participate in exactly one of the following five sports: hockey, kayaking, mountaineering, running, and volleyball. Each child participates in exactly four different sports during the year. In the fall, each child participates in mountaineering, running, or volleyball. In the winter, each child participates in hockey or volleyball. In the spring, each child participates in kayaking, mountaineering, running, or volleyball. In the summer, each child participates in kayaking, mountaineering, or volleyball. Nikki and Otto do not participate in the same sport during the same season. Otto's summer sport is volleyball.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) Nikki's fall sport is mountaineering and Otto's spring sport is running.\n(B) Nikki's spring sport is running and her summer sport is mountaineering.\n(C) Nikki's spring sport is mountaineering and Otto's fall sport is mountaineering.\n(D) Nikki's spring sport is running and Otto's fall sport is mountaineering.\n(E) Nikki's summer sport is mountaineering and Otto's spring sport is mountaineering.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nseasons = ['fall', 'winter', 'spring', 'summer']\nsports = ['hockey', 'kayaking', 'mountaineering', 'running', 'volleyball']\nplayers = ['Nikki', 'Otto']\n\n# Create variables: sport played by each player in each season (integer indices)\nsport = {}\nfor p in players:\n    for s in seasons:\n        sport[(p, s)] = Int(f\"{p}_{s}\")\n\n# Map allowed sports per season (indices)\nallowed = {\n    'fall': [sports.index(sp) for sp in ['mountaineering', 'running', 'volleyball']],\n    'winter': [sports.index(sp) for sp in ['hockey', 'volleyball']],\n    'spring': [sports.index(sp) for sp in ['kayaking', 'mountaineering', 'running', 'volleyball']],\n    'summer': [sports.index(sp) for sp in ['kayaking', 'mountaineering', 'volleyball']]\n}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each player's sport per season must be in allowed sports for that season\nfor p in players:\n    for s in seasons:\n        solver.add(Or([sport[(p, s)] == sp for sp in allowed[s]]))\n\n# Each player participates in exactly 4 different sports during the year\nfor p in players:\n    solver.add(Distinct([sport[(p, s)] for s in seasons]))\n\n# Nikki and Otto do not participate in the same sport during the same season\nfor s in seasons:\n    solver.add(sport[('Nikki', s)] != sport[('Otto', s)])\n\n# Otto's summer sport is volleyball\nsolver.add(sport[('Otto', 'summer')] == sports.index('volleyball'))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Nikki's fall sport is mountaineering and Otto's spring sport is running.\n    [sport[('Nikki', 'fall')] == sports.index('mountaineering'),\n     sport[('Otto', 'spring')] == sports.index('running')],\n    # (B) Nikki's spring sport is running and her summer sport is mountaineering.\n    [sport[('Nikki', 'spring')] == sports.index('running'),\n     sport[('Nikki', 'summer')] == sports.index('mountaineering')],\n    # (C) Nikki's spring sport is mountaineering and Otto's fall sport is mountaineering.\n    [sport[('Nikki', 'spring')] == sports.index('mountaineering'),\n     sport[('Otto', 'fall')] == sports.index('mountaineering')],\n    # (D) Nikki's spring sport is running and Otto's fall sport is mountaineering.\n    [sport[('Nikki', 'spring')] == sports.index('running'),\n     sport[('Otto', 'fall')] == sports.index('mountaineering')],\n    # (E) Nikki's summer sport is mountaineering and Otto's spring sport is mountaineering.\n    [sport[('Nikki', 'summer')] == sports.index('mountaineering'),\n     sport[('Otto', 'spring')] == sports.index('mountaineering')]\n]\n\nfor i, option_constraints in enumerate(options):\n    solver.push()\n    for c in option_constraints:\n        solver.add(c)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.\n\nWhich one of the following could be the order, from first to last, in which the students deliver their speeches?\n\nOptions:\n(A) H, J, R, S, T, K\n(B) H, R, T, K, S, J\n(C) K, J, T, H, S, R\n(D) R, J, K, T, H, S\n(E) T, R, J, S, K, H",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['H', 'J', 'K', 'R', 'S', 'T']\nstudent_indices = {s: i for i, s in enumerate(students)}\n\n# Create Z3 Int variables for the position of each student (0-based index)\npos = {}\nfor s in students:\n    pos[s] = Int(s)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Positions must be between 0 and 5\nfor s in students:\n    solver.add(And(pos[s] >= 0, pos[s] < 6))\n\n# All positions must be distinct\nsolver.add(Distinct([pos[s] for s in students]))\n\n# Constraint 1: H, J, K speeches cannot be three consecutive in any order\n# That means the set {H, J, K} cannot occupy three consecutive positions in any order\n# So no block of three consecutive positions can be exactly H, J, K in any order\n# We'll check all 4 possible triples of consecutive positions: (0,1,2), (1,2,3), (2,3,4), (3,4,5)\n# For each triple, the set of students assigned to these positions cannot be exactly {H,J,K}\n\n# To do this, for each triple of consecutive positions, collect the students assigned to those positions\n# We can express that the set of students at positions p, p+1, p+2 is not exactly {H,J,K}\n\n# We'll create auxiliary variables: for each position, which student is assigned there\n# Since we have pos[s] variables, we can for each position p assert which student is at p by checking pos[s] == p\n# We'll create a helper function to get the students at positions p, p+1, p+2\n\ndef students_at_positions(p):\n    # returns list of Bool expressions: student s is at position p+i\n    return [Or([And(pos[s] == p+i) for s in students]) for i in range(3)]\n\n# We'll instead create a function that returns the set of students at positions p, p+1, p+2 as a list of Bool indicating if that student is in that triple\n\ndef students_in_triple(p):\n    # For each student s, check if pos[s] in {p, p+1, p+2}\n    return [Or([pos[s] == p, pos[s] == p+1, pos[s] == p+2]) for s in students]\n\n# For each p in 0..3, the triple at positions p, p+1, p+2 cannot be exactly H,J,K\n# That means the set of students in that triple is not exactly {H,J,K}\n# So the triple includes all of H,J,K and no other student\n\n# We can express that condition as:\n# (pos[H] in {p,p+1,p+2}) and (pos[J] in {p,p+1,p+2}) and (pos[K] in {p,p+1,p+2})\n# and for every other student s in {R,S,T}, pos[s] not in {p,p+1,p+2}\n\n# So to forbid this triple, we add the negation of the above condition\n\nfor start in range(4):\n    h_in = Or([pos['H'] == start, pos['H'] == start+1, pos['H'] == start+2])\n    j_in = Or([pos['J'] == start, pos['J'] == start+1, pos['J'] == start+2])\n    k_in = Or([pos['K'] == start, pos['K'] == start+1, pos['K'] == start+2])\n    r_not_in = And([pos['R'] != start, pos['R'] != start+1, pos['R'] != start+2])\n    s_not_in = And([pos['S'] != start, pos['S'] != start+1, pos['S'] != start+2])\n    t_not_in = And([pos['T'] != start, pos['T'] != start+1, pos['T'] != start+2])\n\n    triple_hjk = And(h_in, j_in, k_in, r_not_in, s_not_in, t_not_in)\n    solver.add(Not(triple_hjk))\n\n# Constraint 2: R, S, T speeches cannot be three consecutive in any order\n# Same logic as above but for R,S,T\n\nfor start in range(4):\n    r_in = Or([pos['R'] == start, pos['R'] == start+1, pos['R'] == start+2])\n    s_in = Or([pos['S'] == start, pos['S'] == start+1, pos['S'] == start+2])\n    t_in = Or([pos['T'] == start, pos['T'] == start+1, pos['T'] == start+2])\n    h_not_in = And([pos['H'] != start, pos['H'] != start+1, pos['H'] != start+2])\n    j_not_in = And([pos['J'] != start, pos['J'] != start+1, pos['J'] != start+2])\n    k_not_in = And([pos['K'] != start, pos['K'] != start+1, pos['K'] != start+2])\n\n    triple_rst = And(r_in, s_in, t_in, h_not_in, j_not_in, k_not_in)\n    solver.add(Not(triple_rst))\n\n# Constraint 3: H's speech must be earlier than S's speech\nsolver.add(pos['H'] < pos['S'])\n\n# Constraint 4: J's speech can be neither first nor sixth\nsolver.add(pos['J'] != 0)\nsolver.add(pos['J'] != 5)\n\n# Constraint 5: T's speech can be neither immediately before nor immediately after J's speech\n# So abs(pos[T] - pos[J]) != 1\nsolver.add(Abs(pos['T'] - pos['J']) != 1)\n\n# OPTION CHECKING\noptions = [\n    ['H', 'J', 'R', 'S', 'T', 'K'],  # A\n    ['H', 'R', 'T', 'K', 'S', 'J'],  # B\n    ['K', 'J', 'T', 'H', 'S', 'R'],  # C\n    ['R', 'J', 'K', 'T', 'H', 'S'],  # D\n    ['T', 'R', 'J', 'S', 'K', 'H'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that the positions correspond exactly to the option order\n    for position, student in enumerate(option):\n        solver.add(pos[student] == position)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.\n\nIf T delivers the third speech, which one of the following must be true?\n\nOptions:\n(A) H delivers the first speech.\n(B) J delivers the fifth speech.\n(C) K delivers the fourth speech.\n(D) R delivers the sixth speech.\n(E) S delivers the fourth speech.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['H', 'J', 'K', 'R', 'S', 'T']\npositions = range(6)  # positions 0 to 5 correspond to speeches 1 to 6\n\n# Create Int variables for each student representing their speech position (0-based)\npos = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student's position is between 0 and 5\nfor s in students:\n    solver.add(And(pos[s] >= 0, pos[s] < 6))\n\n# All positions are distinct\nsolver.add(Distinct([pos[s] for s in students]))\n\n# Constraint: The speeches by H, J, and K cannot form any sequence of three consecutive speeches\n# That means no three consecutive positions can all be occupied by H, J, and K in any order\n# So no triple of consecutive positions contains all three of H,J,K\n\n# To encode this, for every consecutive triple of positions (0-2,1-3,2-4,3-5):\n# The set of students in those positions cannot be exactly {H,J,K}\n\n# We'll create a helper function to check if the triple of positions contains exactly H,J,K\n\ndef triple_contains_HJK(p0, p1, p2):\n    # For each position p0,p1,p2, create a Bool array indicating if student is at that position\n    # Then assert that the set of students at these positions is exactly H,J,K\n    # Means that the three positions are exactly occupied by H,J,K in some order\n    conds = []\n    for s in ['H','J','K']:\n        conds.append(Or(pos[s] == p0, pos[s] == p1, pos[s] == p2))\n    # All H,J,K appear in these positions\n    all_three_in = And(conds)\n    # No other students in these positions means these three positions are exactly H,J,K\n    # Since positions are distinct and only 3 positions, if all H,J,K are in these positions,\n    # then no other student is in these positions.\n    return all_three_in\n\n# Similarly for R,S,T\n\ndef triple_contains_RST(p0, p1, p2):\n    conds = []\n    for s in ['R','S','T']:\n        conds.append(Or(pos[s] == p0, pos[s] == p1, pos[s] == p2))\n    all_three_in = And(conds)\n    return all_three_in\n\n# For every consecutive triple of positions, forbid triple_contains_HJK or triple_contains_RST\nfor start in range(4):\n    p0 = start\n    p1 = start + 1\n    p2 = start + 2\n    solver.add(Not(triple_contains_HJK(p0,p1,p2)))\n    solver.add(Not(triple_contains_RST(p0,p1,p2)))\n\n# H's speech must be earlier than S's speech\nsolver.add(pos['H'] < pos['S'])\n\n# J's speech can be neither first nor sixth (positions 0 and 5)\nsolver.add(And(pos['J'] != 0, pos['J'] != 5))\n\n# T's speech can be neither immediately before nor immediately after J's speech\nsolver.add(pos['T'] != pos['J'] - 1)\nsolver.add(pos['T'] != pos['J'] + 1)\n\n# OPTION CHECKING\n\n# Given T delivers the third speech (position 2)\nsolver.add(pos['T'] == 2)\n\noptions = {\n    'A': pos['H'] == 0,\n    'B': pos['J'] == 4,\n    'C': pos['K'] == 3,\n    'D': pos['R'] == 5,\n    'E': pos['S'] == 3\n}\n\nfor letter, constraint in options.items():\n    solver.push()\n    solver.add(Not(constraint))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.\n\nIf S delivers the third speech and T delivers the fourth speech, then which one of the following must be true?\n\nOptions:\n(A) H delivers the second speech.\n(B) J delivers the fifth speech.\n(C) K delivers the fifth speech.\n(D) K delivers the first speech.\n(E) R delivers the first speech.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['H', 'J', 'K', 'R', 'S', 'T']\n\n# Create variables: position of each student (1 to 6)\npos = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# Each position is between 1 and 6\nfor s in students:\n    solver.add(And(pos[s] >= 1, pos[s] <= 6))\n\n# All positions are distinct\nsolver.add(Distinct([pos[s] for s in students]))\n\n# CONSTRAINTS\n\n# The speeches delivered by H, J, and K cannot form a sequence of three consecutive speeches in any order\n# That means positions of H, J, K are not consecutive numbers in any order\n# So no triple of consecutive integers contains all three of H,J,K positions\n# We check all possible triples of consecutive positions 1-2-3, 2-3-4, 3-4-5, 4-5-6\n# For each triple, at least one of H,J,K is not in that triple\n\n# Define a helper function to check if all three are in a triple\ndef all_in_triple(triple):\n    return And([Or([pos[s] == triple[i] for i in range(3)]) for s in ['H','J','K']])\n\n# For each triple of consecutive positions\nfor start in range(1,5):\n    triple = [start, start+1, start+2]\n    # The triple cannot contain all of H,J,K\n    # So not all_in_triple(triple)\n    solver.add(Not(all_in_triple(triple)))\n\n# Similarly for R, S, and T\ndef all_in_triple_RST(triple):\n    return And([Or([pos[s] == triple[i] for i in range(3)]) for s in ['R','S','T']])\n\nfor start in range(1,5):\n    triple = [start, start+1, start+2]\n    solver.add(Not(all_in_triple_RST(triple)))\n\n# H's speech must be earlier than S's speech\nsolver.add(pos['H'] < pos['S'])\n\n# J's speech can be neither first nor sixth\nsolver.add(pos['J'] != 1)\nsolver.add(pos['J'] != 6)\n\n# T's speech can be neither immediately before nor immediately after J's speech\nsolver.add(pos['T'] != pos['J'] + 1)\nsolver.add(pos['T'] != pos['J'] - 1)\n\n# Additional given condition in the question:\n# S delivers the third speech and T delivers the fourth speech\nsolver.add(pos['S'] == 3)\nsolver.add(pos['T'] == 4)\n\n# OPTION CHECKING\n\noptions = {\n    'A': pos['H'] == 2,\n    'B': pos['J'] == 5,\n    'C': pos['K'] == 5,\n    'D': pos['K'] == 1,\n    'E': pos['R'] == 1\n}\n\n# For each option, check if it must be true:\n# That means: add the negation of the option and check if still satisfiable\n# If negation is unsat, option must be true\n\nfor letter in ['A','B','C','D','E']:\n    solver.push()\n    solver.add(Not(options[letter]))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.\n\nIf K delivers the first speech and H delivers the fifth speech, which one of the following must be true?\n\nOptions:\n(A) R delivers the third speech.\n(B) T delivers the fourth speech.\n(C) J's speech is immediately before H's speech.\n(D) K's speech is immediately before T's speech.\n(E) R's speech is immediately before J's speech.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['H', 'J', 'K', 'R', 'S', 'T']\npositions = range(1, 7)  # Positions 1 through 6\n\n# Create a dictionary mapping each student to an Int variable representing their speech position\npos = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# Each position is between 1 and 6\nfor s in students:\n    solver.add(And(pos[s] >= 1, pos[s] <= 6))\n\n# All positions are distinct\nsolver.add(Distinct([pos[s] for s in students]))\n\n# Constraint: The speeches by H, J, K cannot be three consecutive speeches in any order\n# This means the set {pos[H], pos[J], pos[K]} cannot be consecutive integers\n\n# Define a helper to check if three positions are consecutive integers (in any order)\ndef three_consecutive(p1, p2, p3):\n    ps = [p1, p2, p3]\n    min_p = If(And(p1 <= p2, p1 <= p3), p1, If(p2 <= p1, If(p2 <= p3, p2, p3), p3))\n    max_p = If(And(p1 >= p2, p1 >= p3), p1, If(p2 >= p1, If(p2 >= p3, p2, p3), p3))\n    # consecutive means max - min == 2 and all three distinct\n    return And(max_p - min_p == 2, Distinct(ps))\n\n# Add constraint that H,J,K do NOT form such a consecutive triple\nsolver.add(Not(three_consecutive(pos['H'], pos['J'], pos['K'])))\n\n# Constraint: The speeches by R, S, T cannot be three consecutive speeches in any order\nsolver.add(Not(three_consecutive(pos['R'], pos['S'], pos['T'])))\n\n# H's speech must be earlier than S's speech\nsolver.add(pos['H'] < pos['S'])\n\n# J's speech can be neither first nor sixth\nsolver.add(And(pos['J'] != 1, pos['J'] != 6))\n\n# T's speech can be neither immediately before nor immediately after J's speech\nsolver.add(And(pos['T'] != pos['J'] + 1, pos['T'] != pos['J'] - 1))\n\n# Given conditions for the question:\n# K delivers the first speech\nsolver.add(pos['K'] == 1)\n\n# H delivers the fifth speech\nsolver.add(pos['H'] == 5)\n\n# OPTION CHECKING\n# Define option constraints\n\noptions = {\n    'A': pos['R'] == 3,\n    'B': pos['T'] == 4,\n    'C': pos['J'] + 1 == pos['H'],\n    'D': pos['K'] + 1 == pos['T'],\n    'E': pos['R'] + 1 == pos['J'],\n}\n\n# We want to find which option must be true.\n# That means the option is true in all models that satisfy the constraints.\n\n# So for each option, check if the negation is satisfiable.\n# If negation is unsat, option must be true.\n\nfor letter, constraint in options.items():\n    solver.push()\n    solver.add(Not(constraint))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.\n\nIf R's speech is immediately after S's speech and immediately before K's speech, then which one of the following could be true?\n\nOptions:\n(A) H's speech is immediately before S's speech.\n(B) H's speech is immediately before T's speech.\n(C) K's speech is immediately before J's speech.\n(D) K's speech is immediately before T's speech.\n(E) T's speech is immediately before S's speech.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['H', 'J', 'K', 'R', 'S', 'T']\npositions = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are between 1 and 6\nfor s in students:\n    solver.add(And(positions[s] >= 1, positions[s] <= 6))\n\n# All positions distinct\nsolver.add(Distinct([positions[s] for s in students]))\n\n# The speeches delivered by H, J, and K cannot form a sequence of three consecutive speeches (in any order)\n# So no three consecutive positions can be exactly the positions of H,J,K in any order\n# That means no i in 1..4 such that the set {i, i+1, i+2} == {positions[H], positions[J], positions[K]}\n# We encode: For each i in 1..4, not all three positions are in {i, i+1, i+2}\nfor i in range(1, 5):\n    cond = And(\n        Or(positions['H'] == i, positions['H'] == i+1, positions['H'] == i+2),\n        Or(positions['J'] == i, positions['J'] == i+1, positions['J'] == i+2),\n        Or(positions['K'] == i, positions['K'] == i+1, positions['K'] == i+2),\n    )\n    # Also check that all three are distinct positions (they are distinct by earlier distinct)\n    # So if all three are in {i, i+1, i+2} then they form the consecutive triple i,i+1,i+2 in some order\n    # So we forbid cond\n    solver.add(Not(cond))\n\n# Similarly for R, S, T\nfor i in range(1, 5):\n    cond = And(\n        Or(positions['R'] == i, positions['R'] == i+1, positions['R'] == i+2),\n        Or(positions['S'] == i, positions['S'] == i+1, positions['S'] == i+2),\n        Or(positions['T'] == i, positions['T'] == i+1, positions['T'] == i+2),\n    )\n    solver.add(Not(cond))\n\n# H's speech must be earlier than S's speech\nsolver.add(positions['H'] < positions['S'])\n\n# J's speech can be neither first nor sixth\nsolver.add(positions['J'] != 1)\nsolver.add(positions['J'] != 6)\n\n# T's speech can be neither immediately before nor immediately after J's speech\nsolver.add(positions['T'] != positions['J'] + 1)\nsolver.add(positions['T'] != positions['J'] - 1)\n\n# Additional condition given in the question:\n# R's speech is immediately after S's speech and immediately before K's speech\nsolver.add(positions['R'] == positions['S'] + 1)\nsolver.add(positions['R'] == positions['K'] - 1)\n\n# OPTION CHECKING\noptions = {\n    'A': positions['H'] == positions['S'] - 1,  # H immediately before S\n    'B': positions['H'] == positions['T'] - 1,  # H immediately before T\n    'C': positions['K'] == positions['J'] - 1,  # K immediately before J\n    'D': positions['K'] == positions['T'] - 1,  # K immediately before T\n    'E': positions['T'] == positions['S'] - 1,  # T immediately before S\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A professor will listen to exactly one speech from each of six students—H, J, K, R, S, and T. The six speeches will be delivered one at a time, consecutively, according to the following conditions: The speeches delivered by H, J, and K, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. The speeches delivered by R, S, and T, no matter what their order relative to each other, cannot form a sequence of three consecutive speeches. H's speech must be earlier than S's speech. J's speech can be neither first nor sixth. T's speech can be neither immediately before nor immediately after J's speech.\n\nIf K delivers the third speech, any of the following could be the student who makes the fourth speech EXCEPT\n\nOptions:\n(A) H\n(B) J\n(C) R\n(D) S\n(E) T",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['H', 'J', 'K', 'R', 'S', 'T']\npositions = range(6)  # positions 0 to 5 represent speeches 1 to 6\n\n# Create Z3 Int variables for each student representing their speech position (0-based)\npos = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student delivers exactly one speech, positions are distinct and in [0..5]\nfor s in students:\n    solver.add(And(pos[s] >= 0, pos[s] < 6))\nsolver.add(Distinct([pos[s] for s in students]))\n\n# Constraint: The speeches by H, J, K cannot be three consecutive speeches in any order\n# That means no sequence of length 3 contains all of H,J,K in any order\n# Check all triples of consecutive positions for H,J,K presence\ntriples = [(i, i+1, i+2) for i in range(4)]\nfor (a,b,c) in triples:\n    # For each triple, count how many of H,J,K are in these positions\n    h_in = Or(pos['H'] == a, pos['H'] == b, pos['H'] == c)\n    j_in = Or(pos['J'] == a, pos['J'] == b, pos['J'] == c)\n    k_in = Or(pos['K'] == a, pos['K'] == b, pos['K'] == c)\n    # They cannot all be in the triple simultaneously\n    solver.add(Not(And(h_in, j_in, k_in)))\n\n# Constraint: The speeches by R, S, T cannot be three consecutive speeches in any order\nfor (a,b,c) in triples:\n    r_in = Or(pos['R'] == a, pos['R'] == b, pos['R'] == c)\n    s_in = Or(pos['S'] == a, pos['S'] == b, pos['S'] == c)\n    t_in = Or(pos['T'] == a, pos['T'] == b, pos['T'] == c)\n    solver.add(Not(And(r_in, s_in, t_in)))\n\n# Constraint: H's speech must be earlier than S's speech\nsolver.add(pos['H'] < pos['S'])\n\n# Constraint: J's speech can be neither first nor sixth\nsolver.add(And(pos['J'] != 0, pos['J'] != 5))\n\n# Constraint: T's speech can be neither immediately before nor immediately after J's speech\nsolver.add(Abs(pos['T'] - pos['J']) != 1)\n\n# K delivers the third speech (position 2)\nsolver.add(pos['K'] == 2)\n\n# OPTION CHECKING\n# For each option, check if that student could be fourth (position 3)\noptions = ['H', 'J', 'R', 'S', 'T']\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(pos[option] == 3)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.\n\nIf at noon K is within exactly two of the four areas, then which one of the following CANNOT be true at that time?\n\nOptions:\n(A) J is within area T.\n(B) K is within area R.\n(C) K is within area T.\n(D) L is within area R.\n(E) L is within area T.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nareas = ['R', 'S', 'T', 'U']\nplanes = ['J', 'K', 'L', 'M']\n\n# Map areas to indices\narea_idx = {a: i for i, a in enumerate(areas)}\n\n# Create variables: for each plane and area, a Bool indicating if plane is in that area\nin_area = {}\nfor p in planes:\n    for a in areas:\n        in_area[(p, a)] = Bool(f\"{p}_{a}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each plane is in at least one of the four areas\nfor p in planes:\n    solver.add(Or([in_area[(p, a)] for a in areas]))\n\n# Geometry constraints on areas:\n# R and T intersect (some overlap)\n# S and T intersect (some overlap)\n# R does not intersect S (no overlap)\n# U is completely within R and completely within T\n\n# We model these as constraints on planes' possible area combinations:\n# Since U is completely within R and T, any plane in U must also be in R and T\nfor p in planes:\n    # If plane in U then plane in R and plane in T\n    solver.add(Implies(in_area[(p, 'U')], And(in_area[(p, 'R')], in_area[(p, 'T')])))\n\n# R does not intersect S => no plane can be in both R and S\nfor p in planes:\n    solver.add(Not(And(in_area[(p, 'R')], in_area[(p, 'S')])))\n\n# J is in area S\nsolver.add(in_area[('J', 'S')])\n\n# K is not in any detection area that J is in\n# For every area a: if J in a then K not in a\nfor a in areas:\n    solver.add(Implies(in_area[('J', a)], Not(in_area[('K', a)])))\n\n# L is not in any detection area that M is in\n# For every area a: if M in a then L not in a\nfor a in areas:\n    solver.add(Implies(in_area[('M', a)], Not(in_area[('L', a)])))\n\n# M is in exactly one of the areas\nsolver.add(Sum([If(in_area[('M', a)], 1, 0) for a in areas]) == 1)\n\n# At noon K is within exactly two of the four areas\nsolver.add(Sum([If(in_area[('K', a)], 1, 0) for a in areas]) == 2)\n\n# Option checking\noptions = [\n    # (A) J is within area T.\n    in_area[('J', 'T')],\n    # (B) K is within area R.\n    in_area[('K', 'R')],\n    # (C) K is within area T.\n    in_area[('K', 'T')],\n    # (D) L is within area R.\n    in_area[('L', 'R')],\n    # (E) L is within area T.\n    in_area[('L', 'T')],\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.\n\nWhich one of the following statements CANNOT be true at noon about the planes?\n\nOptions:\n(A) K is within area T.\n(B) K is within area U.\n(C) L is within area R.\n(D) M is within area R.\n(E) M is within area U.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nareas = ['R', 'S', 'T', 'U']\nplanes = ['J', 'K', 'L', 'M']\n\n# Create variables: for each plane and each area, a Bool indicating if the plane is in that area\nin_area = {}\nfor p in planes:\n    for a in areas:\n        in_area[(p, a)] = Bool(f'{p}_{a}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each plane is in at least one area\nfor p in planes:\n    solver.add(Or([in_area[(p, a)] for a in areas]))\n\n# J is in area S\nsolver.add(in_area[('J', 'S')])\n\n# K is not in any detection area that J is in\nfor a in areas:\n    solver.add(Implies(in_area[('J', a)], Not(in_area[('K', a)])))\n\n# L is not in any detection area that M is in\nfor a in areas:\n    solver.add(Implies(in_area[('M', a)], Not(in_area[('L', a)])))\n\n# M is in exactly one of the areas\nsolver.add(Sum([If(in_area[('M', a)], 1, 0) for a in areas]) == 1)\n\n# Area relationships:\n# R does not intersect S: no plane can be in both R and S\nfor p in planes:\n    solver.add(Not(And(in_area[(p, 'R')], in_area[(p, 'S')])))\n\n# U is completely within R and completely within T\n# So any plane in U must be in R and in T\nfor p in planes:\n    solver.add(Implies(in_area[(p, 'U')], And(in_area[(p, 'R')], in_area[(p, 'T')])))\n\n# Part of R intersects T (some overlap), and part of S intersects T\n# These are about areas, not planes, so no direct constraints on planes\n\n# OPTION CHECKING\noptions = [\n    ('A', in_area[('K', 'T')]),\n    ('B', in_area[('K', 'U')]),\n    ('C', in_area[('L', 'R')]),\n    ('D', in_area[('M', 'R')]),\n    ('E', in_area[('M', 'U')])\n]\n\nfor letter, condition in options:\n    solver.push()\n    # Add constraint that the option is true\n    solver.add(condition)\n    # Check if this option can be true consistent with all constraints\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.\n\nIt CANNOT be true that at noon there is at least one plane that is within both area\n\nOptions:\n(A) R and area T\n(B) R and area U\n(C) S and area T\n(D) S and area U\n(E) T and area U",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nareas = ['R', 'S', 'T', 'U']\nplanes = ['J', 'K', 'L', 'M']\n\n# Create variables: plane_in_area[plane][area] is Bool indicating if plane is in area\nplane_in_area = {p: {a: Bool(f\"{p}_{a}\") for a in areas} for p in planes}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each plane is in at least one area\nfor p in planes:\n    solver.add(Or([plane_in_area[p][a] for a in areas]))\n\n# Area relations (logical constraints about areas)\n# R does not intersect S: no plane can be in both R and S\nfor p in planes:\n    solver.add(Not(And(plane_in_area[p]['R'], plane_in_area[p]['S'])))\n\n# U is completely within R and completely within T:\n# So any plane in U must be in R and in T\nfor p in planes:\n    solver.add(Implies(plane_in_area[p]['U'], And(plane_in_area[p]['R'], plane_in_area[p]['T'])))\n\n# Part of R intersects T, part of S intersects T: no direct constraints on planes from this except that R and T can overlap, S and T can overlap.\n\n# J is in area S\nsolver.add(plane_in_area['J']['S'])\n\n# K is not in any detection area that J is in\nfor a in areas:\n    solver.add(Implies(plane_in_area['J'][a], Not(plane_in_area['K'][a])))\n\n# L is not in any detection area that M is in\nfor a in areas:\n    solver.add(Implies(plane_in_area['M'][a], Not(plane_in_area['L'][a])))\n\n# M is in exactly one of the areas\nsolver.add(Sum([If(plane_in_area['M'][a], 1, 0) for a in areas]) == 1)\n\n# Helper function to check if it can be true that some plane is in both area1 and area2\ndef can_be_in_both(area1, area2):\n    solver.push()\n    # Add constraint: there exists at least one plane in both area1 and area2\n    plane_in_both = []\n    for p in planes:\n        plane_in_both.append(And(plane_in_area[p][area1], plane_in_area[p][area2]))\n    solver.add(Or(plane_in_both))\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\n# OPTION CHECKING\noptions = [('A', 'R', 'T'),\n           ('B', 'R', 'U'),\n           ('C', 'S', 'T'),\n           ('D', 'S', 'U'),\n           ('E', 'T', 'U')]\n\nfor letter, a1, a2 in options:\n    if not can_be_in_both(a1, a2):\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "The country of Zendu contains exactly four areas for radar detection: R, S, T, and U. Each detection area is circular and falls completely within Zendu. Part of R intersects T; part of S also intersects T; R does not intersect S. Area U is completely within R and also completely within T. At noon exactly four planes J, K, L, M—are over Zendu, in a manner consistent with the following statements: Each plane is in at least one of the four areas. J is in area S. K is not in any detection area that J is in. L is not in any detection area that M is in. M is in exactly one of the areas.\n\nIf at noon M is within area T, then which one of the following statements CANNOT be true at that time?\n\nOptions:\n(A) J is within area T.\n(B) L is within area R.\n(C) L is within area S.\n(D) K is within exactly two areas.\n(E) L is within exactly two areas.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nareas = ['R', 'S', 'T', 'U']\nplanes = ['J', 'K', 'L', 'M']\n\n# Create Int variables for each plane and each area: 1 if plane is in area, 0 otherwise\nin_area = {}\nfor p in planes:\n    for a in areas:\n        in_area[(p,a)] = Int(f'{p}_{a}')\n        \nsolver = Solver()\n\n# Each in_area variable is either 0 or 1\nfor p in planes:\n    for a in areas:\n        solver.add(Or(in_area[(p,a)] == 0, in_area[(p,a)] == 1))\n\n# CONSTRAINTS\n\n# Geometry constraints (about areas)\n# R does not intersect S: no plane can be in both R and S\nfor p in planes:\n    solver.add(Or(in_area[(p,'R')] == 0, in_area[(p,'S')] == 0))\n\n# U is completely within R and T: if a plane is in U, then it is in R and in T\nfor p in planes:\n    solver.add(Implies(in_area[(p,'U')] == 1, And(in_area[(p,'R')] == 1, in_area[(p,'T')] == 1)))\n\n# Part of R intersects T and part of S intersects T: this affects areas but no direct plane constraint\n# No direct constraint on planes from this except the above about U\n\n# Each plane is in at least one of the four areas\nfor p in planes:\n    solver.add(Sum([in_area[(p,a)] for a in areas]) >= 1)\n\n# J is in area S\nsolver.add(in_area[('J','S')] == 1)\n\n# K is not in any detection area that J is in\n# For each area a: if J is in a, K is not in a\nfor a in areas:\n    solver.add(Implies(in_area[('J',a)] == 1, in_area[('K',a)] == 0))\n\n# L is not in any detection area that M is in\nfor a in areas:\n    solver.add(Implies(in_area[('M',a)] == 1, in_area[('L',a)] == 0))\n\n# M is in exactly one of the areas\nsolver.add(Sum([in_area[('M',a)] for a in areas]) == 1)\n\n# Additional condition: M is within area T\nsolver.add(in_area[('M','T')] == 1)\n\n# OPTION CHECKING\n\n# We will check each option by adding its statement and see if the model is satisfiable\n\n# Option (A) J is within area T\nsolver.push()\nsolver.add(in_area[('J','T')] == 1)\nif solver.check() == unsat:\n    print(\"'A'\")\nsolver.pop()\n\n# Option (B) L is within area R\nsolver.push()\nsolver.add(in_area[('L','R')] == 1)\nif solver.check() == unsat:\n    print(\"'B'\")\nsolver.pop()\n\n# Option (C) L is within area S\nsolver.push()\nsolver.add(in_area[('L','S')] == 1)\nif solver.check() == unsat:\n    print(\"'C'\")\nsolver.pop()\n\n# Option (D) K is within exactly two areas\nsolver.push()\nsolver.add(Sum([in_area[('K',a)] for a in areas]) == 2)\nif solver.check() == unsat:\n    print(\"'D'\")\nsolver.pop()\n\n# Option (E) L is within exactly two areas\nsolver.push()\nsolver.add(Sum([in_area[('L',a)] for a in areas]) == 2)\nif solver.check() == unsat:\n    print(\"'E'\")\nsolver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Four people—Fritz, Gina, Helen, and Jerry—have formed a car pool to commute to work together six days a week from Monday through Saturday. Each day exactly one of the people drives. The schedule of the car pool's drivers for any given week must meet the following conditions: Each person drives on at least one day. No person drives on two consecutive days. Fritz does not drive on Monday. Jerry drives on Wednesday or Saturday or both, and he may also drive on other days. If Gina drives on Monday, then Jerry does not drive on Saturday.\n\nWhich one of the following could be the schedule of drivers for one week, for the days Monday through Saturday, respectively?\n\nOptions:\n(A) Gina, Fritz, Jerry, Helen, Gina, Gina\n(B) Gina, Fritz, Jerry, Helen, Fritz, Jerry\n(C) Helen, Fritz, Gina, Jerry, Helen, Fritz\n(D) Helen, Gina, Jerry, Fritz, Helen, Fritz\n(E) Helen, Gina, Jerry, Helen, Jerry, Gina",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\npeople = ['Fritz', 'Gina', 'Helen', 'Jerry']\n\n# Map people to indices\nperson_idx = {p: i for i, p in enumerate(people)}\n\n# Create Z3 Int variables for each day representing the driver\ndriver = [Int(f'driver_{d}') for d in days]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each driver variable must be a valid person index\nfor d in range(len(days)):\n    solver.add(And(driver[d] >= 0, driver[d] < len(people)))\n\n# Each person drives at least one day\nfor p in range(len(people)):\n    drives_p = [driver[d] == p for d in range(len(days))]\n    solver.add(Or(drives_p))\n\n# No person drives two consecutive days\nfor d in range(len(days)-1):\n    solver.add(driver[d] != driver[d+1])\n\n# Fritz does not drive on Monday\nsolver.add(driver[0] != person_idx['Fritz'])\n\n# Jerry drives on Wednesday or Saturday or both\nsolver.add(Or(driver[2] == person_idx['Jerry'], driver[5] == person_idx['Jerry']))\n\n# If Gina drives on Monday, then Jerry does not drive on Saturday\ncond_gina_mon = driver[0] == person_idx['Gina']\ncond_jerry_sat = driver[5] == person_idx['Jerry']\nsolver.add(Implies(cond_gina_mon, Not(cond_jerry_sat)))\n\n# OPTION CHECKING\noptions = [\n    ['Gina', 'Fritz', 'Jerry', 'Helen', 'Gina', 'Gina'],  # A\n    ['Gina', 'Fritz', 'Jerry', 'Helen', 'Fritz', 'Jerry'],  # B\n    ['Helen', 'Fritz', 'Gina', 'Jerry', 'Helen', 'Fritz'],  # C\n    ['Helen', 'Gina', 'Jerry', 'Fritz', 'Helen', 'Fritz'],  # D\n    ['Helen', 'Gina', 'Jerry', 'Helen', 'Jerry', 'Gina'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that driver on each day matches the option\n    for d in range(len(days)):\n        solver.add(driver[d] == person_idx[option[d]])\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Four people—Fritz, Gina, Helen, and Jerry—have formed a car pool to commute to work together six days a week from Monday through Saturday. Each day exactly one of the people drives. The schedule of the car pool's drivers for any given week must meet the following conditions: Each person drives on at least one day. No person drives on two consecutive days. Fritz does not drive on Monday. Jerry drives on Wednesday or Saturday or both, and he may also drive on other days. If Gina drives on Monday, then Jerry does not drive on Saturday.\n\nWhich one of the following could be true of one week's schedule of drivers?\n\nOptions:\n(A) Fritz drives on both Wednesday and Saturday.\n(B) Gina drives on both Monday and Wednesday.\n(C) Jerry drives on both Tuesday and Friday.\n(D) Gina drives on Monday and Jerry drives on Thursday.\n(E) Jerry drives on Wednesday and Gina drives on Saturday.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\ndrivers = ['Fritz', 'Gina', 'Helen', 'Jerry']\n\n# Create a driver variable for each day (integer representing driver index)\nday_driver = [Int(day) for day in days]\n\n# Map driver names to indices\ndriver_idx = {name: i for i, name in enumerate(drivers)}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each day exactly one person drives (day_driver values are valid indices)\nfor d in day_driver:\n    solver.add(And(d >= 0, d < len(drivers)))\n\n# Each person drives at least one day (each driver appears at least once)\nfor i in range(len(drivers)):\n    appears = [day_driver[d] == i for d in range(len(days))]\n    solver.add(Or(appears))\n\n# No person drives two consecutive days\nfor i in range(len(days) - 1):\n    solver.add(day_driver[i] != day_driver[i + 1])\n\n# Fritz does not drive on Monday\nsolver.add(day_driver[0] != driver_idx['Fritz'])\n\n# Jerry drives on Wednesday or Saturday or both\nwed_jerry = day_driver[2] == driver_idx['Jerry']\nsat_jerry = day_driver[5] == driver_idx['Jerry']\nsolver.add(Or([wed_jerry, sat_jerry]))\n\n# If Gina drives on Monday, then Jerry does not drive on Saturday\ngina_mon = day_driver[0] == driver_idx['Gina']\njerry_sat = day_driver[5] == driver_idx['Jerry']\nsolver.add(Implies(gina_mon, Not(jerry_sat)))\n\n# OPTION CHECKING\n\n# Helper to add option-specific constraints and check satisfiability\ndef check_option(option_num):\n    solver.push()\n    if option_num == 0:  # (A) Fritz drives on both Wednesday and Saturday.\n        solver.add(day_driver[2] == driver_idx['Fritz'])\n        solver.add(day_driver[5] == driver_idx['Fritz'])\n    elif option_num == 1:  # (B) Gina drives on both Monday and Wednesday.\n        solver.add(day_driver[0] == driver_idx['Gina'])\n        solver.add(day_driver[2] == driver_idx['Gina'])\n    elif option_num == 2:  # (C) Jerry drives on both Tuesday and Friday.\n        solver.add(day_driver[1] == driver_idx['Jerry'])\n        solver.add(day_driver[4] == driver_idx['Jerry'])\n    elif option_num == 3:  # (D) Gina drives on Monday and Jerry drives on Thursday.\n        solver.add(day_driver[0] == driver_idx['Gina'])\n        solver.add(day_driver[3] == driver_idx['Jerry'])\n    elif option_num == 4:  # (E) Jerry drives on Wednesday and Gina drives on Saturday.\n        solver.add(day_driver[2] == driver_idx['Jerry'])\n        solver.add(day_driver[5] == driver_idx['Gina'])\n    else:\n        solver.pop()\n        return False\n\n    if solver.check() == sat:\n        solver.pop()\n        return True\n    else:\n        solver.pop()\n        return False\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\nfor i, opt in enumerate(options):\n    if check_option(i):\n        print(f\"'{opt}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Four people—Fritz, Gina, Helen, and Jerry—have formed a car pool to commute to work together six days a week from Monday through Saturday. Each day exactly one of the people drives. The schedule of the car pool's drivers for any given week must meet the following conditions: Each person drives on at least one day. No person drives on two consecutive days. Fritz does not drive on Monday. Jerry drives on Wednesday or Saturday or both, and he may also drive on other days. If Gina drives on Monday, then Jerry does not drive on Saturday.\n\nIf during one week Gina drives on Monday and Saturday only, which one of the following must be true of that week?\n\nOptions:\n(A) One other person besides Gina drives on exactly two days.\n(B) The person who drives on Wednesday does not drive on Friday.\n(C) Helen drives on a day immediately before a day on which Fritz drives.\n(D) Either Fritz or Helen drives on Friday.\n(E) Either Helen or Jerry drives on Tuesday.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Fritz', 'Gina', 'Helen', 'Jerry']\ndays = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\nnum_people = len(people)\nnum_days = len(days)\n\n# Map people and days to indices\nperson_idx = {p: i for i, p in enumerate(people)}\nday_idx = {d: i for i, d in enumerate(days)}\n\n# For each day, who drives? Integer variable in [0..3] representing person index\ndriver = [Int(f'driver_{d}') for d in days]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each day's driver must be a valid person index\nfor d in range(num_days):\n    solver.add(And(driver[d] >= 0, driver[d] < num_people))\n\n# Each person drives at least one day\nfor p in range(num_people):\n    drives_p = [driver[d] == p for d in range(num_days)]\n    solver.add(Or(drives_p))\n\n# No person drives two consecutive days\nfor d in range(num_days - 1):\n    solver.add(driver[d] != driver[d+1])\n\n# Fritz does not drive on Monday\nsolver.add(driver[day_idx['Monday']] != person_idx['Fritz'])\n\n# Jerry drives on Wednesday or Saturday or both\nsolver.add(Or(driver[day_idx['Wednesday']] == person_idx['Jerry'], driver[day_idx['Saturday']] == person_idx['Jerry']))\n\n# If Gina drives on Monday, then Jerry does not drive on Saturday\ncond_gina_monday = driver[day_idx['Monday']] == person_idx['Gina']\ncond_jerry_saturday = driver[day_idx['Saturday']] == person_idx['Jerry']\nsolver.add(Implies(cond_gina_monday, Not(cond_jerry_saturday)))\n\n# Additional condition given in the question:\n# Gina drives on Monday and Saturday only\n# So Gina drives exactly on Monday and Saturday, no other days\nfor d in range(num_days):\n    if d == day_idx['Monday'] or d == day_idx['Saturday']:\n        solver.add(driver[d] == person_idx['Gina'])\n    else:\n        solver.add(driver[d] != person_idx['Gina'])\n\n# OPTION CHECKING\n# Options:\n# (A) One other person besides Gina drives on exactly two days.\n# (B) The person who drives on Wednesday does not drive on Friday.\n# (C) Helen drives on a day immediately before a day on which Fritz drives.\n# (D) Either Fritz or Helen drives on Friday.\n# (E) Either Helen or Jerry drives on Tuesday.\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\ndef check_option_A():\n    # Count how many days each person drives\n    counts = [Sum([If(driver[d] == p, 1, 0) for d in range(num_days)]) for p in range(num_people)]\n    # Gina drives exactly 2 days (Monday and Saturday)\n    # We want exactly one other person (not Gina) drives exactly 2 days\n    other_two_day_drivers = [counts[p] == 2 for p in range(num_people) if p != person_idx['Gina']]\n    # Count how many satisfy counts[p]==2 among others\n    count_true = Sum([If(cond, 1, 0) for cond in other_two_day_drivers])\n    return count_true == 1\n\ndef check_option_B():\n    # The person who drives on Wednesday does not drive on Friday\n    wed_driver = driver[day_idx['Wednesday']]\n    fri_driver = driver[day_idx['Friday']]\n    return wed_driver != fri_driver\n\ndef check_option_C():\n    # Helen drives on a day immediately before a day on which Fritz drives\n    # Check if there exists a day d in [0..4] such that driver[d] == Helen and driver[d+1] == Fritz\n    conds = [And(driver[d] == person_idx['Helen'], driver[d+1] == person_idx['Fritz']) for d in range(num_days -1)]\n    return Or(conds)\n\ndef check_option_D():\n    # Either Fritz or Helen drives on Friday\n    fri_driver = driver[day_idx['Friday']]\n    return Or(fri_driver == person_idx['Fritz'], fri_driver == person_idx['Helen'])\n\ndef check_option_E():\n    # Either Helen or Jerry drives on Tuesday\n    tue_driver = driver[day_idx['Tuesday']]\n    return Or(tue_driver == person_idx['Helen'], tue_driver == person_idx['Jerry'])\n\noption_checks = [check_option_A, check_option_B, check_option_C, check_option_D, check_option_E]\n\nfor i, check in enumerate(option_checks):\n    solver.push()\n    solver.add(Not(check()))\n    if solver.check() == unsat:\n        # If adding Not(option) makes it unsat, option must be true\n        print(f\"'{options[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Four people—Fritz, Gina, Helen, and Jerry—have formed a car pool to commute to work together six days a week from Monday through Saturday. Each day exactly one of the people drives. The schedule of the car pool's drivers for any given week must meet the following conditions: Each person drives on at least one day. No person drives on two consecutive days. Fritz does not drive on Monday. Jerry drives on Wednesday or Saturday or both, and he may also drive on other days. If Gina drives on Monday, then Jerry does not drive on Saturday.\n\nWhich one of the following CANNOT be true of one week's schedule of drivers?\n\nOptions:\n(A) Fritz drives on Tuesday and Gina drives on Friday.\n(B) Gina drives on Monday and Jerry drives on Tuesday.\n(C) Gina drives on Monday and Jerry drives on Friday.\n(D) Helen drives on Monday and Jerry drives on Tuesday.\n(E) Helen drives on Tuesday and Jerry drives on Friday.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\npeople = ['Fritz', 'Gina', 'Helen', 'Jerry']\n\n# Map people to indices for Z3 variables\nperson_idx = {p: i for i, p in enumerate(people)}\n\n# Create Z3 Int variables for each day representing the driver (0 to 3)\ndriver = {d: Int(d) for d in days}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each day exactly one person drives (value in valid range)\nfor d in days:\n    solver.add(And(driver[d] >= 0, driver[d] < len(people)))\n\n# Each person drives at least one day\nfor p in people:\n    drives_p = [driver[d] == person_idx[p] for d in days]\n    solver.add(Or(drives_p))\n\n# No person drives on two consecutive days\nfor i in range(len(days)-1):\n    solver.add(driver[days[i]] != driver[days[i+1]])\n\n# Fritz does not drive on Monday\nsolver.add(driver['Mon'] != person_idx['Fritz'])\n\n# Jerry drives on Wednesday or Saturday or both\nsolver.add(Or(driver['Wed'] == person_idx['Jerry'], driver['Sat'] == person_idx['Jerry']))\n\n# If Gina drives on Monday, then Jerry does not drive on Saturday\ngina_mon = driver['Mon'] == person_idx['Gina']\njerry_sat = driver['Sat'] == person_idx['Jerry']\nsolver.add(Implies(gina_mon, Not(jerry_sat)))\n\n# OPTION CHECKING\noptions = [\n    # (A) Fritz drives on Tuesday and Gina drives on Friday.\n    [driver['Tue'] == person_idx['Fritz'], driver['Fri'] == person_idx['Gina']],\n\n    # (B) Gina drives on Monday and Jerry drives on Tuesday.\n    [driver['Mon'] == person_idx['Gina'], driver['Tue'] == person_idx['Jerry']],\n\n    # (C) Gina drives on Monday and Jerry drives on Friday.\n    [driver['Mon'] == person_idx['Gina'], driver['Fri'] == person_idx['Jerry']],\n\n    # (D) Helen drives on Monday and Jerry drives on Tuesday.\n    [driver['Mon'] == person_idx['Helen'], driver['Tue'] == person_idx['Jerry']],\n\n    # (E) Helen drives on Tuesday and Jerry drives on Friday.\n    [driver['Tue'] == person_idx['Helen'], driver['Fri'] == person_idx['Jerry']],\n]\n\nfor i, option_constraints in enumerate(options):\n    solver.push()\n    for c in option_constraints:\n        solver.add(c)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Four people—Fritz, Gina, Helen, and Jerry—have formed a car pool to commute to work together six days a week from Monday through Saturday. Each day exactly one of the people drives. The schedule of the car pool's drivers for any given week must meet the following conditions: Each person drives on at least one day. No person drives on two consecutive days. Fritz does not drive on Monday. Jerry drives on Wednesday or Saturday or both, and he may also drive on other days. If Gina drives on Monday, then Jerry does not drive on Saturday.\n\nIf during one week Fritz drives exactly twice but he drives on neither Tuesday nor Wednesday, which one of the following could be true of that week?\n\nOptions:\n(A) One person drives exactly three times during the week.\n(B) Three people drive exactly one time each during the week.\n(C) Jerry drives on no day that is immediately before a day on which Fritz drives.\n(D) Gina drives on Wednesday.\n(E) Jerry drives on Friday.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\npeople = ['Fritz', 'Gina', 'Helen', 'Jerry']\n\n# Map people to indices\nperson_idx = {p: i for i, p in enumerate(people)}\n\n# Create variables: driver for each day (0..3)\ndriver = [Int(day) for day in days]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each day's driver is a valid person index\nfor d in driver:\n    solver.add(And(d >= 0, d < len(people)))\n\n# Each person drives at least once\nfor p in range(len(people)):\n    drives_p = [driver[d] == p for d in range(len(days))]\n    solver.add(Or(drives_p))\n\n# No person drives two consecutive days\nfor i in range(len(days)-1):\n    solver.add(driver[i] != driver[i+1])\n\n# Fritz does not drive on Monday\nsolver.add(driver[0] != person_idx['Fritz'])\n\n# Jerry drives on Wednesday or Saturday or both\nsolver.add(Or(driver[2] == person_idx['Jerry'], driver[5] == person_idx['Jerry']))\n\n# If Gina drives on Monday, then Jerry does not drive on Saturday\nsolver.add(Implies(driver[0] == person_idx['Gina'], driver[5] != person_idx['Jerry']))\n\n# Given: Fritz drives exactly twice but not on Tuesday or Wednesday\n# Fritz drives count == 2\nfritz_days = [driver[d] == person_idx['Fritz'] for d in range(len(days))]\nsolver.add(Sum([If(cond, 1, 0) for cond in fritz_days]) == 2)\n# Fritz not on Tuesday (index 1) or Wednesday (index 2)\nsolver.add(driver[1] != person_idx['Fritz'])\nsolver.add(driver[2] != person_idx['Fritz'])\n\n# OPTION CHECKING\n\n# (A) One person drives exactly three times during the week.\nsolver.push()\ncounts = []\nfor p in range(len(people)):\n    count_p = Sum([If(driver[d] == p, 1, 0) for d in range(len(days))])\n    counts.append(count_p)\none_three = Or([counts[p] == 3 for p in range(len(people))])\nsolver.add(one_three)\nif solver.check() == sat:\n    print(\"'A'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (B) Three people drive exactly one time each during the week.\nsolver.push()\ncounts = []\nfor p in range(len(people)):\n    count_p = Sum([If(driver[d] == p, 1, 0) for d in range(len(days))])\n    counts.append(count_p)\nthree_one = Sum([If(counts[p] == 1, 1, 0) for p in range(len(people))]) == 3\nsolver.add(three_one)\nif solver.check() == sat:\n    print(\"'B'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (C) Jerry drives on no day that is immediately before a day on which Fritz drives.\nsolver.push()\n# For all i: if day i driver is Jerry, then day i+1 driver is not Fritz\nno_jerry_before_fritz = []\nfor i in range(len(days)-1):\n    cond = Implies(driver[i] == person_idx['Jerry'], driver[i+1] != person_idx['Fritz'])\n    no_jerry_before_fritz.append(cond)\nsolver.add(And(no_jerry_before_fritz))\nif solver.check() == sat:\n    print(\"'C'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (D) Gina drives on Wednesday.\nsolver.push()\nsolver.add(driver[2] == person_idx['Gina'])\nif solver.check() == sat:\n    print(\"'D'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (E) Jerry drives on Friday.\nsolver.push()\nsolver.add(driver[4] == person_idx['Jerry'])\nif solver.check() == sat:\n    print(\"'E'\")\n    solver.pop()\nelse:\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Five experienced plumbers—Frank, Gene, Jill, Kathy, and Mark—and four inexperienced plumbers—Roberta, Sally, Tim, and Vernon—must decide which of them will be assigned to four work teams of exactly two plumbers each. Assignments must meet the following restrictions: Each plumber is assigned to at most one team. At least one plumber on each team must be experienced. Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank. If Tim is assigned to a team, either Gene or Kathy must be assigned to that team. Jill cannot be assigned to a team with Roberta.\n\nWhich one of the following is a pair of plumbers who can be assigned together to a team?\n\nOptions:\n(A) Frank and Roberta\n(B) Frank and Vernon\n(C) Jill and Mark\n(D) Roberta and Tim\n(E) Sally and Vernon",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nexperienced = ['Frank', 'Gene', 'Jill', 'Kathy', 'Mark']\ninexperienced = ['Roberta', 'Sally', 'Tim', 'Vernon']\nall_plumbers = experienced + inexperienced\n\n# We have 4 teams, each with exactly 2 plumbers\nnum_teams = 4\nteam_indices = range(num_teams)\n\n# Create variables: team_of[p] = team index plumber p is assigned to, or -1 if unassigned\nteam_of = {p: Int(p) for p in all_plumbers}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each plumber is assigned to at most one team (team index in 0..3 or -1 for unassigned)\nfor p in all_plumbers:\n    solver.add(Or([team_of[p] == i for i in team_indices] + [team_of[p] == -1]))\n\n# Exactly 4 teams with exactly 2 plumbers each\n# Count how many plumbers assigned to each team\nfor i in team_indices:\n    count_on_team = Sum([If(team_of[p] == i, 1, 0) for p in all_plumbers])\n    solver.add(count_on_team == 2)\n\n# At least one plumber on each team must be experienced\nfor i in team_indices:\n    experienced_on_team = Or([team_of[p] == i for p in experienced])\n    solver.add(experienced_on_team)\n\n# Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank\nfor p in ['Mark', 'Roberta', 'Vernon']:\n    solver.add(Or(team_of['Frank'] == -1, team_of[p] == -1, team_of['Frank'] != team_of[p]))\n\n# If Tim is assigned to a team, either Gene or Kathy must be assigned to that team\ntim_team = team_of['Tim']\ngene_kathy_in_team = Or([team_of['Gene'] == tim_team, team_of['Kathy'] == tim_team])\nsolver.add(Or(tim_team == -1, gene_kathy_in_team))\n\n# Jill cannot be assigned to a team with Roberta\nsolver.add(Or(team_of['Jill'] == -1, team_of['Roberta'] == -1, team_of['Jill'] != team_of['Roberta']))\n\n# OPTION CHECKING\noptions = [\n    ('Frank', 'Roberta'),  # A\n    ('Frank', 'Vernon'),   # B\n    ('Jill', 'Mark'),      # C\n    ('Roberta', 'Tim'),    # D\n    ('Sally', 'Vernon')    # E\n]\n\nfor i, (p1, p2) in enumerate(options):\n    solver.push()\n    # Add constraint that p1 and p2 are assigned to the same team and both assigned (team != -1)\n    solver.add(team_of[p1] != -1)\n    solver.add(team_of[p2] != -1)\n    solver.add(team_of[p1] == team_of[p2])\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Five experienced plumbers—Frank, Gene, Jill, Kathy, and Mark—and four inexperienced plumbers—Roberta, Sally, Tim, and Vernon—must decide which of them will be assigned to four work teams of exactly two plumbers each. Assignments must meet the following restrictions: Each plumber is assigned to at most one team. At least one plumber on each team must be experienced. Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank. If Tim is assigned to a team, either Gene or Kathy must be assigned to that team. Jill cannot be assigned to a team with Roberta.\n\nIf Tim is assigned to a team, and if Sally is assigned to a team with a plumber who could have been assigned to a team with Tim, then the only plumber with whom Frank could be assigned to a team is\n\nOptions:\n(A) Gene\n(B) Jill\n(C) Mark\n(D) Roberta\n(E) Vernon",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Plumbers\nexperienced = ['Frank', 'Gene', 'Jill', 'Kathy', 'Mark']\ninexperienced = ['Roberta', 'Sally', 'Tim', 'Vernon']\nall_plumbers = experienced + inexperienced\n\n# Teams: 4 teams, each with 2 plumbers\nteams = [(\"Team1\", 0), (\"Team2\", 1), (\"Team3\", 2), (\"Team4\", 3)]\n\n# Create variables: for each plumber, which team (0-3) or -1 if not assigned\n# Assigned team is -1 if plumber is not assigned to any team\nteam_of = {p: Int(p) for p in all_plumbers}\n\n# Values for team_of[p]:\n# -1 means not assigned\n# 0..3 means assigned to that team\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each plumber assigned to at most one team (team_of[p] in [-1..3])\nfor p in all_plumbers:\n    solver.add(Or([team_of[p] == i for i in range(-1, 4)]))\n\n# Each team has exactly two plumbers assigned\nfor t in range(4):\n    assigned_to_team_t = [If(team_of[p] == t, 1, 0) for p in all_plumbers]\n    solver.add(Sum(assigned_to_team_t) == 2)\n\n# At least one plumber on each team is experienced\nfor t in range(4):\n    experienced_on_team = [If(team_of[p] == t, 1, 0) for p in experienced]\n    solver.add(Sum(experienced_on_team) >= 1)\n\n# No plumber assigned to more than one team (already ensured by single variable per plumber)\n\n# Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank\n# So Frank's team != Mark's team (if both assigned)\n# Frank's team != Roberta's team (if both assigned)\n# Frank's team != Vernon's team (if both assigned)\n\n# Define helper function: assigned and same team\ndef assigned_and_same_team(p1, p2):\n    return And(team_of[p1] != -1, team_of[p2] != -1, team_of[p1] == team_of[p2])\n\nsolver.add(Not(assigned_and_same_team('Frank', 'Mark')))\nsolver.add(Not(assigned_and_same_team('Frank', 'Roberta')))\nsolver.add(Not(assigned_and_same_team('Frank', 'Vernon')))\n\n# If Tim is assigned to a team, either Gene or Kathy must be assigned to that team\ntim_assigned = team_of['Tim'] != -1\ntim_team = team_of['Tim']\ngene_assigned_to_tim_team = team_of['Gene'] == tim_team\nkathy_assigned_to_tim_team = team_of['Kathy'] == tim_team\nsolver.add(Implies(tim_assigned, Or(gene_assigned_to_tim_team, kathy_assigned_to_tim_team)))\n\n# Jill cannot be assigned to a team with Roberta\nsolver.add(Not(assigned_and_same_team('Jill', 'Roberta')))\n\n# OPTION CHECKING\n\n# The question:\n# If Tim is assigned to a team, and if Sally is assigned to a team with a plumber who could have been assigned to a team with Tim,\n# then the only plumber with whom Frank could be assigned to a team is ?\n\n# We need to test each option (A-E), and check which one is the only plumber Frank can be assigned with under these conditions.\n\n# The options:\noptions = ['Gene', 'Jill', 'Mark', 'Roberta', 'Vernon']\n\n# We will encode the question condition and check for each option if it can be the only plumber with whom Frank can be assigned.\n\n# Helper: plumbers who could have been assigned to a team with Tim\n# That means plumbers who are not Mark, Roberta, or Vernon (because those can't be assigned with Frank),\n# and not Frank himself (since Frank can't be assigned with Mark, Roberta, or Vernon)\n# But the question is about Sally being assigned to a team with a plumber who could have been assigned to a team with Tim.\n# So \"could have been assigned to a team with Tim\" means the plumber is not disallowed with Tim.\n# The restrictions specifically say:\n# - Mark, Roberta, Vernon cannot be assigned with Frank.\n# - If Tim is assigned, either Gene or Kathy must be on Tim's team.\n# - Jill cannot be with Roberta.\n# So plumbers who could be assigned with Tim are all except those who can't violate constraints.\n# But the question is about the plumber on Sally's team who could have been assigned with Tim.\n\n# To simplify, we will interpret \"plumber who could have been assigned to a team with Tim\" as any plumber p (other than Tim) such that assigning p to Tim's team would not violate constraints.\n\n# Let's enumerate candidates for \"could have been assigned to a team with Tim\":\n\n# Conditions for plumber p to be assignable with Tim:\n# 1) p != Tim\n# 2) p != Mark, Roberta, Vernon (because Mark, Roberta, Vernon cannot be assigned with Frank, but that is about Frank, not Tim)\n# Actually, no direct restriction about Tim's teammates except that if Tim is assigned, Gene or Kathy must be assigned to Tim's team.\n# So Tim's team must include Gene or Kathy.\n# So the plumber who could have been assigned to Tim's team must be either Gene or Kathy or someone else?\n\n# The question is about Sally assigned with a plumber who could have been assigned with Tim.\n\n# So let's define a function to check if a plumber p can be assigned with Tim on a team (without violating constraints).\n\n# We'll check for each plumber p != Tim whether Tim and p can be assigned together on a team (both assigned to same team), respecting constraints.\n\n# We'll use a helper solver to check for each plumber p if Tim and p can be on the same team.\n\ndef can_be_assigned_with_tim(plumber):\n    s = Solver()\n    # Copy all constraints except the question-specific ones\n    s.add(solver.assertions())\n    # Tim and plumber assigned to same team (not -1)\n    s.add(team_of['Tim'] != -1)\n    s.add(team_of[plumber] != -1)\n    s.add(team_of['Tim'] == team_of[plumber])\n    # The team has exactly 2 plumbers (Tim and plumber)\n    # So no other plumber assigned to that team\n    for p in all_plumbers:\n        if p != 'Tim' and p != plumber:\n            s.add(team_of[p] != team_of['Tim'])\n    # Check if satisfiable\n    if s.check() == sat:\n        return True\n    else:\n        return False\n\n# Determine plumbers who could have been assigned with Tim\ncould_be_with_tim = [p for p in all_plumbers if p != 'Tim' and can_be_assigned_with_tim(p)]\n\n# Now, the question says:\n# If Tim is assigned to a team,\n# and if Sally is assigned to a team with a plumber who could have been assigned to a team with Tim,\n# then the only plumber with whom Frank could be assigned to a team is ?\n\n# So under the condition:\n# 1) Tim is assigned (team_of['Tim'] != -1)\n# 2) Sally is assigned with a plumber p in could_be_with_tim (assigned_and_same_team('Sally', p))\n\n# Then Frank can only be assigned with exactly one plumber.\n\n# So for each option, we check if that plumber is the only plumber that Frank can be assigned with.\n\n# We will check for each option plumber o:\n\n# Add the condition:\n# Tim assigned\n# Sally assigned with some plumber p in could_be_with_tim\n# Frank assigned with plumber o (assigned_and_same_team('Frank', o))\n# Frank not assigned with any other plumber besides o (no other plumber assigned with Frank)\n\n# If this is satisfiable, then o can be the only plumber Frank can be assigned with.\n\n# We check which option satisfies this and is unique.\n\n# Because the question says \"the only plumber with whom Frank could be assigned to a team is\", so only one plumber satisfies this.\n\n# We'll check options one by one.\n\nfor i, opt_plumber in enumerate(options):\n    solver.push()\n    # Add condition: Tim assigned\n    solver.add(team_of['Tim'] != -1)\n    # Sally assigned with a plumber who could have been assigned with Tim\n    # We add: Or over p in could_be_with_tim: assigned_and_same_team('Sally', p)\n    sally_with_possible = Or([assigned_and_same_team('Sally', p) for p in could_be_with_tim])\n    solver.add(sally_with_possible)\n    # Frank assigned with opt_plumber\n    solver.add(assigned_and_same_team('Frank', opt_plumber))\n    # Frank not assigned with any other plumber besides opt_plumber\n    other_plumbers = [p for p in all_plumbers if p != 'Frank' and p != opt_plumber]\n    no_other_with_frank = And([Not(assigned_and_same_team('Frank', p)) for p in other_plumbers])\n    solver.add(no_other_with_frank)\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Five experienced plumbers—Frank, Gene, Jill, Kathy, and Mark—and four inexperienced plumbers—Roberta, Sally, Tim, and Vernon—must decide which of them will be assigned to four work teams of exactly two plumbers each. Assignments must meet the following restrictions: Each plumber is assigned to at most one team. At least one plumber on each team must be experienced. Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank. If Tim is assigned to a team, either Gene or Kathy must be assigned to that team. Jill cannot be assigned to a team with Roberta.\n\nIf Gene is not assigned to a team, then Jill must be assigned to a team with\n\nOptions:\n(A) Vernon\n(B) Tim\n(C) Mark\n(D) Kathy\n(E) Frank",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nexperienced = ['Frank', 'Gene', 'Jill', 'Kathy', 'Mark']\ninexperienced = ['Roberta', 'Sally', 'Tim', 'Vernon']\nall_plumbers = experienced + inexperienced\n\nteams = [0, 1, 2, 3]  # Four teams\n\n# We create a dictionary: plumber -> team assigned (or -1 if not assigned)\n# Since each plumber is assigned to at most one team, team is in -1..3\nplumber_team = {}\nfor p in all_plumbers:\n    plumber_team[p] = Int(p)\n    \n# CONSTRAINTS\nsolver = Solver()\n\n# Each plumber is assigned to at most one team (team in -1..3, -1 means no team)\nfor p in all_plumbers:\n    solver.add(Or([plumber_team[p] == t for t in teams] + [plumber_team[p] == -1]))\n\n# Teams have exactly two plumbers assigned\n# For each team, count how many plumbers assigned to it: must be exactly 2\nfor t in teams:\n    assigned_to_t = [plumber_team[p] == t for p in all_plumbers]\n    # Sum of assigned_to_t == 2\n    # BoolRef cannot be summed directly, convert to Int\n    assigned_ints = [If(cond, 1, 0) for cond in assigned_to_t]\n    solver.add(Sum(assigned_ints) == 2)\n\n# Each plumber assigned to at most one team (already ensured by single integer variable)\n\n# At least one plumber on each team must be experienced\nfor t in teams:\n    experienced_assigned = [plumber_team[p] == t for p in experienced]\n    solver.add(Or(experienced_assigned))\n\n# Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank\n# For each team, if Frank assigned, then Mark, Roberta, Vernon not assigned\nfor t in teams:\n    frank_assigned = (plumber_team['Frank'] == t)\n    mark_assigned = (plumber_team['Mark'] == t)\n    roberta_assigned = (plumber_team['Roberta'] == t)\n    vernon_assigned = (plumber_team['Vernon'] == t)\n    solver.add(Implies(frank_assigned, And(Not(mark_assigned), Not(roberta_assigned), Not(vernon_assigned))))\n\n# If Tim is assigned to a team, either Gene or Kathy must be assigned to that team\nfor t in teams:\n    tim_assigned = (plumber_team['Tim'] == t)\n    gene_assigned = (plumber_team['Gene'] == t)\n    kathy_assigned = (plumber_team['Kathy'] == t)\n    solver.add(Implies(tim_assigned, Or(gene_assigned, kathy_assigned)))\n\n# Jill cannot be assigned to a team with Roberta\nfor t in teams:\n    jill_assigned = (plumber_team['Jill'] == t)\n    roberta_assigned = (plumber_team['Roberta'] == t)\n    solver.add(Not(And(jill_assigned, roberta_assigned)))\n\n# If Gene is not assigned to a team, then Jill must be assigned to a team with ...\n# We will check options by adding this condition plus each option condition and test satisfiability\n\n# Gene not assigned means plumber_team['Gene'] == -1\ngene_not_assigned = (plumber_team['Gene'] == -1)\njill_assigned = (plumber_team['Jill'] >= 0)  # Jill assigned to some team\n\n# Jill must be assigned to a team with X means:\n# There exists a team t such that Jill assigned to t and X assigned to t\n\n# OPTION CHECKING\noptions = {\n    'A': 'Vernon',\n    'B': 'Tim',\n    'C': 'Mark',\n    'D': 'Kathy',\n    'E': 'Frank'\n}\n\nfor letter, plumber_x in options.items():\n    solver.push()\n    # Add condition: Gene not assigned => Jill assigned with plumber_x\n    # This means:\n    # (plumber_team['Gene'] == -1) => (exists t: plumber_team['Jill'] == t and plumber_team[plumber_x] == t)\n    # Also Jill must be assigned (already implied if assigned with someone)\n    exists_team = []\n    for t in teams:\n        cond = And(plumber_team['Jill'] == t, plumber_team[plumber_x] == t)\n        exists_team.append(cond)\n    jill_with_x = Or(exists_team)\n    implication = Implies(gene_not_assigned, jill_with_x)\n    solver.add(implication)\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Five experienced plumbers—Frank, Gene, Jill, Kathy, and Mark—and four inexperienced plumbers—Roberta, Sally, Tim, and Vernon—must decide which of them will be assigned to four work teams of exactly two plumbers each. Assignments must meet the following restrictions: Each plumber is assigned to at most one team. At least one plumber on each team must be experienced. Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank. If Tim is assigned to a team, either Gene or Kathy must be assigned to that team. Jill cannot be assigned to a team with Roberta.\n\nIf all of the inexperienced plumbers are assigned to teams, and neither Roberta nor Tim nor Vernon is assigned to a team with Gene, then Sally must be assigned to a team with either\n\nOptions:\n(A) Frank or else Gene\n(B) Frank or else Mark\n(C) Gene or else Mark\n(D) Jill or else Kathy\n(E) Jill or else Mark",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Plumbers\nexperienced = ['Frank', 'Gene', 'Jill', 'Kathy', 'Mark']\ninexperienced = ['Roberta', 'Sally', 'Tim', 'Vernon']\nall_plumbers = experienced + inexperienced\n\n# Teams: 4 teams of 2 plumbers each\n# We'll represent each team as a pair of plumbers (indices)\n# Since each plumber can be assigned at most to one team, the teams form a partition of assigned plumbers\n\n# Create variables for each team member: team[i][j] = plumber index assigned to team i, position j\n# Positions 0 and 1 for each team\nteam = [[Int(f'team_{i}_{j}') for j in range(2)] for i in range(4)]\n\n# Map plumber name to index\nplumber_index = {p: i for i, p in enumerate(all_plumbers)}\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# 1) Each plumber assigned to at most one team\n# All assigned plumbers in teams must be distinct (no repeats)\nall_assigned = [team[i][j] for i in range(4) for j in range(2)]\nsolver.add(Distinct(all_assigned))\n\n# 2) Each team has exactly two plumbers (already modeled as pairs)\n\n# 3) Each plumber assigned to at most one team (already ensured by Distinct)\n\n# 4) Each team must have at least one experienced plumber\n\n# Helper: set of experienced plumber indices\nexperienced_indices = [plumber_index[p] for p in experienced]\n\nfor i in range(4):\n    # team[i][0] or team[i][1] must be experienced\n    cond0 = Or([team[i][0] == idx for idx in experienced_indices])\n    cond1 = Or([team[i][1] == idx for idx in experienced_indices])\n    solver.add(Or(cond0, cond1))\n\n# 5) Neither Mark nor Roberta nor Vernon can be assigned to a team with Frank\n\nmark_idx = plumber_index['Mark']\nroberta_idx = plumber_index['Roberta']\nvernon_idx = plumber_index['Vernon']\nfrank_idx = plumber_index['Frank']\n\nfor i in range(4):\n    t0 = team[i][0]\n    t1 = team[i][1]\n\n    # If Frank is on team i, then Mark, Roberta, Vernon are not on team i\n    # So for each team:\n    # (t0 == frank_idx or t1 == frank_idx) => (t0 != mark_idx and t1 != mark_idx and t0 != roberta_idx and t1 != roberta_idx and t0 != vernon_idx and t1 != vernon_idx)\n    frank_on_team = Or(t0 == frank_idx, t1 == frank_idx)\n    mark_on_team = Or(t0 == mark_idx, t1 == mark_idx)\n    roberta_on_team = Or(t0 == roberta_idx, t1 == roberta_idx)\n    vernon_on_team = Or(t0 == vernon_idx, t1 == vernon_idx)\n\n    solver.add(Implies(frank_on_team, Not(mark_on_team)))\n    solver.add(Implies(frank_on_team, Not(roberta_on_team)))\n    solver.add(Implies(frank_on_team, Not(vernon_on_team)))\n\n# 6) If Tim is assigned to a team, either Gene or Kathy must be assigned to that team\n\ntim_idx = plumber_index['Tim']\ngene_idx = plumber_index['Gene']\nkathy_idx = plumber_index['Kathy']\n\nfor i in range(4):\n    t0 = team[i][0]\n    t1 = team[i][1]\n    tim_on_team = Or(t0 == tim_idx, t1 == tim_idx)\n    gene_or_kathy_on_team = Or(t0 == gene_idx, t1 == gene_idx, t0 == kathy_idx, t1 == kathy_idx)\n    solver.add(Implies(tim_on_team, gene_or_kathy_on_team))\n\n# 7) Jill cannot be assigned to a team with Roberta\n\njill_idx = plumber_index['Jill']\n\nfor i in range(4):\n    t0 = team[i][0]\n    t1 = team[i][1]\n    jill_on_team = Or(t0 == jill_idx, t1 == jill_idx)\n    roberta_on_team = Or(t0 == roberta_idx, t1 == roberta_idx)\n    solver.add(Not(And(jill_on_team, roberta_on_team)))\n\n# 8) All inexperienced plumbers are assigned to teams\n# That means Roberta, Sally, Tim, Vernon all appear in the teams\n\nfor p in ['Roberta', 'Sally', 'Tim', 'Vernon']:\n    idx = plumber_index[p]\n    assigned = Or([team[i][j] == idx for i in range(4) for j in range(2)])\n    solver.add(assigned)\n\n# 9) Neither Roberta nor Tim nor Vernon is assigned to a team with Gene\n\nfor i in range(4):\n    t0 = team[i][0]\n    t1 = team[i][1]\n    gene_on_team = Or(t0 == gene_idx, t1 == gene_idx)\n\n    roberta_on_team = Or(t0 == roberta_idx, t1 == roberta_idx)\n    tim_on_team = Or(t0 == tim_idx, t1 == tim_idx)\n    vernon_on_team = Or(t0 == vernon_idx, t1 == vernon_idx)\n\n    # For each of these inexperienced plumbers, if they are on team with Gene, forbidden\n    solver.add(Not(And(gene_on_team, roberta_on_team)))\n    solver.add(Not(And(gene_on_team, tim_on_team)))\n    solver.add(Not(And(gene_on_team, vernon_on_team)))\n\n# The question: If all above hold, then Sally must be assigned to a team with either...\n\n# Options:\n# (A) Frank or else Gene\n# (B) Frank or else Mark\n# (C) Gene or else Mark\n# (D) Jill or else Kathy\n# (E) Jill or else Mark\n\n# We will test each option by adding the negation of the option and checking for unsat.\n# The one that makes the problem unsat is the correct answer.\n\nsally_idx = plumber_index['Sally']\n\n# Find which team Sally is on\n# Create a helper variable for Sally's team index\nsally_team_idx = Int('sally_team_idx')\nsolver.add(And(sally_team_idx >= 0, sally_team_idx < 4))\n\n# Sally must be on exactly one team\n# Link sally_team_idx to the team where Sally is assigned\n# For each team i: if sally_team_idx == i then Sally is in team[i]\nfor i in range(4):\n    sally_in_team_i = Or(team[i][0] == sally_idx, team[i][1] == sally_idx)\n    solver.add(Implies(sally_team_idx == i, sally_in_team_i))\n# Also, Sally is assigned to exactly one team, so if Sally is in team i, sally_team_idx == i\nfor i in range(4):\n    sally_in_team_i = Or(team[i][0] == sally_idx, team[i][1] == sally_idx)\n    solver.add(Implies(sally_in_team_i, sally_team_idx == i))\n\n# Helper to get the two plumbers on Sally's team\ndef sally_team_members():\n    t0 = Int('sally_team_member0')\n    t1 = Int('sally_team_member1')\n    solver.add(And(t0 >= 0, t0 < len(all_plumbers)))\n    solver.add(And(t1 >= 0, t1 < len(all_plumbers)))\n    for i in range(4):\n        solver.add(Implies(sally_team_idx == i, team[i][0] == t0))\n        solver.add(Implies(sally_team_idx == i, team[i][1] == t1))\n    return t0, t1\n\nt0, t1 = sally_team_members()\n\n# Option checking\noptions = {\n    'A': Or(t0 == frank_idx, t1 == frank_idx, t0 == gene_idx, t1 == gene_idx),\n    'B': Or(t0 == frank_idx, t1 == frank_idx, t0 == mark_idx, t1 == mark_idx),\n    'C': Or(t0 == gene_idx, t1 == gene_idx, t0 == mark_idx, t1 == mark_idx),\n    'D': Or(t0 == jill_idx, t1 == jill_idx, t0 == kathy_idx, t1 == kathy_idx),\n    'E': Or(t0 == jill_idx, t1 == jill_idx, t0 == mark_idx, t1 == mark_idx),\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add negation of option (negate Sally is assigned to team with either X or Y)\n    solver.add(Not(options[letter]))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.\n\nWhich one of the following is an acceptable assignment of students to the three classes?\n\nOptions:\n(A) R, T, Y V, W, X S, Z\n(B) R, T, Z S, V, Y W, X\n(C) R, W, X V, Y, Z S, T\n(D) R, X, Z T, V, Y S, W\n(E) R, X, Z V, W, Y S, T",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z']\nclasses = [1, 2, 3]\n\n# Create Int variables for each student representing their class assignment\nstudent_class = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student assigned to exactly one class (1, 2, or 3)\nfor s in students:\n    solver.add(And(student_class[s] >= 1, student_class[s] <= 3))\n\n# Class sizes: classes 1 and 2 have 3 students each; class 3 has 2 students\nclass1_count = Sum([If(student_class[s] == 1, 1, 0) for s in students])\nclass2_count = Sum([If(student_class[s] == 2, 1, 0) for s in students])\nclass3_count = Sum([If(student_class[s] == 3, 1, 0) for s in students])\n\nsolver.add(class1_count == 3)\nsolver.add(class2_count == 3)\nsolver.add(class3_count == 2)\n\n# R must be in class 1\nsolver.add(student_class['R'] == 1)\n\n# S must be in class 3\nsolver.add(student_class['S'] == 3)\n\n# Neither S nor W can be in the same class as Y\nsolver.add(student_class['S'] != student_class['Y'])\nsolver.add(student_class['W'] != student_class['Y'])\n\n# V cannot be in the same class as Z\nsolver.add(student_class['V'] != student_class['Z'])\n\n# If T is in class 1, then Z must be in class 1\nsolver.add(Implies(student_class['T'] == 1, student_class['Z'] == 1))\n\n# OPTION CHECKING\n\noptions = {\n    'A': {'class1': ['R', 'T', 'Y'], 'class2': ['V', 'W', 'X'], 'class3': ['S', 'Z']},\n    'B': {'class1': ['R', 'T', 'Z'], 'class2': ['S', 'V', 'Y'], 'class3': ['W', 'X']},\n    'C': {'class1': ['R', 'W', 'X'], 'class2': ['V', 'Y', 'Z'], 'class3': ['S', 'T']},\n    'D': {'class1': ['R', 'X', 'Z'], 'class2': ['T', 'V', 'Y'], 'class3': ['S', 'W']},\n    'E': {'class1': ['R', 'X', 'Z'], 'class2': ['V', 'W', 'Y'], 'class3': ['S', 'T']},\n}\n\nfor letter, assignment in options.items():\n    solver.push()\n    # Add constraints fixing each student's class to the option's assignment\n    for cls, studs in assignment.items():\n        cls_num = int(cls[-1])  # Extract class number from 'class1', 'class2', etc.\n        for stud in studs:\n            solver.add(student_class[stud] == cls_num)\n    # Check if the constraints are satisfiable with the puzzle constraints\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.\n\nWhich one of the following is a complete and accurate list of classes any one of which could be the class to which V is added?\n\nOptions:\n(A) class 1\n(B) class 3\n(C) class 1, class 3\n(D) class 2, class 3\n(E) class 1, class 2, class 3",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z']\nclasses = [1, 2, 3]\n\n# Create a Z3 Int variable for each student representing the class they are assigned to\nstudent_class = {}\nfor student in students:\n    student_class[student] = Int(student)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student must be assigned to one of the three classes\nfor student in students:\n    solver.add(And(student_class[student] >= 1, student_class[student] <= 3))\n\n# Class size constraints\n# Count how many students are assigned to each class\ndef count_students_in_class(c):\n    return Sum([If(student_class[s] == c, 1, 0) for s in students])\n\nsolver.add(count_students_in_class(1) == 3)\nsolver.add(count_students_in_class(2) == 3)\nsolver.add(count_students_in_class(3) == 2)\n\n# R must be added to class 1\nsolver.add(student_class['R'] == 1)\n\n# S must be added to class 3\nsolver.add(student_class['S'] == 3)\n\n# Neither S nor W can be added to the same class as Y\n# So Y's class is different from S's class and W's class\nsolver.add(student_class['Y'] != student_class['S'])\nsolver.add(student_class['Y'] != student_class['W'])\n\n# V cannot be added to the same class as Z\nsolver.add(student_class['V'] != student_class['Z'])\n\n# If T is added to class 1, Z must also be added to class 1\nt_in_class_1 = student_class['T'] == 1\nz_in_class_1 = student_class['Z'] == 1\nsolver.add(Implies(t_in_class_1, z_in_class_1))\n\n# OPTION CHECKING\n# Check which classes V can be assigned to\npossible_classes_for_V = []\n\nfor c in classes:\n    solver.push()\n    solver.add(student_class['V'] == c)\n    if solver.check() == sat:\n        possible_classes_for_V.append(c)\n    solver.pop()\n\n# Map possible classes to options\n# Options:\n# (A) class 1\n# (B) class 3\n# (C) class 1, class 3\n# (D) class 2, class 3\n# (E) class 1, class 2, class 3\n\nif possible_classes_for_V == [1]:\n    print(\"'A'\")\nelif possible_classes_for_V == [3]:\n    print(\"'B'\")\nelif sorted(possible_classes_for_V) == [1,3]:\n    print(\"'C'\")\nelif sorted(possible_classes_for_V) == [2,3]:\n    print(\"'D'\")\nelif sorted(possible_classes_for_V) == [1,2,3]:\n    print(\"'E'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.\n\nIf X is added to class 1, which one of the following is a student who must be added to class 2?\n\nOptions:\n(A) T\n(B) V\n(C) W\n(D) Y\n(E) Z",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z']\nclasses = [1, 2, 3]\n\n# Create variables: student_class[student] = class number (1, 2, or 3)\nstudent_class = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student assigned to a class 1, 2, or 3\nfor s in students:\n    solver.add(And(student_class[s] >= 1, student_class[s] <= 3))\n\n# Class size constraints:\n# Class 1 has exactly 3 students\n# Class 2 has exactly 3 students\n# Class 3 has exactly 2 students\nfor c in classes:\n    count_c = Sum([If(student_class[s] == c, 1, 0) for s in students])\n    if c == 1:\n        solver.add(count_c == 3)\n    elif c == 2:\n        solver.add(count_c == 3)\n    else:\n        solver.add(count_c == 2)\n\n# R must be in class 1\nsolver.add(student_class['R'] == 1)\n\n# S must be in class 3\nsolver.add(student_class['S'] == 3)\n\n# Neither S nor W can be in the same class as Y\n# So Y's class != S's class and Y's class != W's class\nsolver.add(student_class['Y'] != student_class['S'])\nsolver.add(student_class['Y'] != student_class['W'])\n\n# V cannot be in the same class as Z\nsolver.add(student_class['V'] != student_class['Z'])\n\n# If T is in class 1, then Z must also be in class 1\nT_in_class_1 = student_class['T'] == 1\nZ_in_class_1 = student_class['Z'] == 1\nsolver.add(Implies(T_in_class_1, Z_in_class_1))\n\n# OPTION CHECKING\n\n# We are told: If X is added to class 1,\n# which student must be added to class 2?\n\n# So add constraint: X in class 1\nsolver.add(student_class['X'] == 1)\n\noptions = ['T', 'V', 'W', 'Y', 'Z']\n\n# We want to find the student who must be in class 2\n# That means: for the correct student s, \n# in every solution with X=1, student_class[s] == 2\n\n# For each option, check if it's possible for that student to NOT be in class 2\n# If possible, then that student is not forced to be in class 2\n# The one for which NOT being in class 2 is impossible (unsat) is the correct answer\n\nfor i, student in enumerate(options):\n    solver.push()\n    # Add constraint that student is NOT in class 2\n    solver.add(student_class[student] != 2)\n    if solver.check() == unsat:\n        # Then student must be in class 2\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.\n\nIf T is added to class 3, which one of the following is a student who must be added to class 2?\n\nOptions:\n(A) V\n(B) W\n(C) X\n(D) Y\n(E) Z",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z']\nclasses = [1, 2, 3]\n\n# Create a Z3 Int variable for each student representing their class assignment\nstudent_class = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student must be assigned to a valid class (1, 2, or 3)\nfor s in students:\n    solver.add(Or([student_class[s] == c for c in classes]))\n\n# Class size constraints\n# Exactly three students in class 1\nsolver.add(Sum([If(student_class[s] == 1, 1, 0) for s in students]) == 3)\n\n# Exactly three students in class 2\nsolver.add(Sum([If(student_class[s] == 2, 1, 0) for s in students]) == 3)\n\n# Exactly two students in class 3\nsolver.add(Sum([If(student_class[s] == 3, 1, 0) for s in students]) == 2)\n\n# R must be in class 1\nsolver.add(student_class['R'] == 1)\n\n# S must be in class 3\nsolver.add(student_class['S'] == 3)\n\n# Neither S nor W can be added to the same class as Y\n# So Y's class != S's class and Y's class != W's class\nsolver.add(student_class['Y'] != student_class['S'])\nsolver.add(student_class['Y'] != student_class['W'])\n\n# V cannot be added to the same class as Z\nsolver.add(student_class['V'] != student_class['Z'])\n\n# If T is in class 1, then Z must be in class 1\nsolver.add(Implies(student_class['T'] == 1, student_class['Z'] == 1))\n\n# OPTION CHECKING\n# The question: If T is added to class 3, which student must be added to class 2?\n\n# We will check each option and see if there is any solution where T is in class 3 and the option student is NOT in class 2.\n# If such a solution exists, that option is not \"must be in class 2\".\n# If no such solution exists, that option must be in class 2.\n\noptions = ['V', 'W', 'X', 'Y', 'Z']\n\nfor i, opt_student in enumerate(options):\n    solver.push()\n    # Add condition: T is in class 3\n    solver.add(student_class['T'] == 3)\n    # Check if the option student can be NOT in class 2\n    solver.add(student_class[opt_student] != 2)\n    if solver.check() == unsat:\n        # If unsat, then the option student must be in class 2 when T is in class 3\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Eight new students—R, S, T, V, W, X, Y, Z—are being divided among exactly three classes—class 1, class 2, and class 3. Classes 1 and 2 will gain three new students each; class 3 will gain two new students. The following restrictions apply: R must be added to class 1. S must be added to class 3. Neither S nor W can be added to the same class as Y. V cannot be added to the same class as Z. If T is added to class 1, Z must also be added to class 1.\n\nWhich one of the following must be true?\n\nOptions:\n(A) If T and X are added to class 2, V is added to class 3.\n(B) If V and W are added to class 1, T is added to class 3.\n(C) If V and W are added to class 1, Z is added to class 3.\n(D) If V and X are added to class 1, W is added to class 3.\n(E) If Y and Z are added to class 2, X is added to class 2.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['R', 'S', 'T', 'V', 'W', 'X', 'Y', 'Z']\nclasses = [1, 2, 3]\n\n# Create a variable for each student representing their class assignment (1, 2, or 3)\nstudent_class = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student's class must be 1, 2, or 3\nfor s in students:\n    solver.add(And(student_class[s] >= 1, student_class[s] <= 3))\n\n# Classes 1 and 2 have exactly 3 students each; class 3 has exactly 2 students\nfor c in classes:\n    count_c = Sum([If(student_class[s] == c, 1, 0) for s in students])\n    if c == 3:\n        solver.add(count_c == 2)\n    else:\n        solver.add(count_c == 3)\n\n# R must be added to class 1\nsolver.add(student_class['R'] == 1)\n\n# S must be added to class 3\nsolver.add(student_class['S'] == 3)\n\n# Neither S nor W can be added to the same class as Y\nsolver.add(student_class['S'] != student_class['Y'])\nsolver.add(student_class['W'] != student_class['Y'])\n\n# V cannot be added to the same class as Z\nsolver.add(student_class['V'] != student_class['Z'])\n\n# If T is added to class 1, Z must also be added to class 1\nsolver.add(Implies(student_class['T'] == 1, student_class['Z'] == 1))\n\n# OPTION CHECKING\noptions = [\n    # (A) If T and X are added to class 2, V is added to class 3.\n    (And(student_class['T'] == 2, student_class['X'] == 2), student_class['V'] == 3),\n\n    # (B) If V and W are added to class 1, T is added to class 3.\n    (And(student_class['V'] == 1, student_class['W'] == 1), student_class['T'] == 3),\n\n    # (C) If V and W are added to class 1, Z is added to class 3.\n    (And(student_class['V'] == 1, student_class['W'] == 1), student_class['Z'] == 3),\n\n    # (D) If V and X are added to class 1, W is added to class 3.\n    (And(student_class['V'] == 1, student_class['X'] == 1), student_class['W'] == 3),\n\n    # (E) If Y and Z are added to class 2, X is added to class 2.\n    (And(student_class['Y'] == 2, student_class['Z'] == 2), student_class['X'] == 2),\n]\n\nfor i, (hypothesis, conclusion) in enumerate(options):\n    solver.push()\n    # Add hypothesis\n    solver.add(hypothesis)\n    # Add negation of conclusion to check if conclusion must be true\n    solver.add(Not(conclusion))\n    if solver.check() == unsat:\n        # Conclusion must be true whenever hypothesis is true\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Four lions—F, G, H, J—and two tigers—K and M—will be assigned to exactly six stalls, one animal per stall. The stalls are arranged as follows: First Row: 1 2 3 Second Row: 4 5 6 The only stalls that face each other are stalls 1 and 4, stalls 2 and 5, and stalls 3 and 6. The following conditions apply: The tigers' stalls cannot face each other. A lion must be assigned to stall 1. H must be assigned to stall 6. J must be assigned to a stall numbered one higher than K's stall. K cannot be assigned to the stall that faces H's stall.\n\nWhich one of the following must be true?\n\nOptions:\n(A) F is assigned to an even-numbered stall.\n(B) F is assigned to stall 1.\n(C) J is assigned to stall 2 or else stall 3.\n(D) J is assigned to stall 3 or else stall 4.\n(E) K is assigned to stall 2 or else stall 4.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nanimals = ['F', 'G', 'H', 'J', 'K', 'M']\nlions = ['F', 'G', 'H', 'J']\ntigers = ['K', 'M']\nstalls = [1, 2, 3, 4, 5, 6]\n\n# Create Int variables for each animal representing their stall assignment\nstall_vars = {a: Int(a) for a in animals}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each animal assigned to exactly one stall between 1 and 6\nfor a in animals:\n    solver.add(And(stall_vars[a] >= 1, stall_vars[a] <= 6))\n\n# All animals occupy different stalls\nsolver.add(Distinct([stall_vars[a] for a in animals]))\n\n# The only stalls that face each other: (1,4), (2,5), (3,6)\nfacing_pairs = [(1,4), (2,5), (3,6)]\n\ndef are_facing(s1, s2):\n    return Or([And(s1 == p[0], s2 == p[1]) for p in facing_pairs] +\n              [And(s1 == p[1], s2 == p[0]) for p in facing_pairs])\n\n# The tigers' stalls cannot face each other\nsolver.add(Not(are_facing(stall_vars['K'], stall_vars['M'])))\n\n# A lion must be assigned to stall 1\n# So at least one of F,G,H,J is assigned to stall 1\nlion_stall1 = Or([stall_vars[lion] == 1 for lion in lions])\nsolver.add(lion_stall1)\n\n# H must be assigned to stall 6\nsolver.add(stall_vars['H'] == 6)\n\n# J must be assigned to a stall numbered one higher than K's stall\nsolver.add(stall_vars['J'] == stall_vars['K'] + 1)\n\n# K cannot be assigned to the stall that faces H's stall\n# H is at 6, so K cannot be at the stall facing 6, which is 3\nsolver.add(stall_vars['K'] != 3)\n\n# OPTION CHECKING\noptions = {\n    'A': Or([stall_vars['F'] == 2, stall_vars['F'] == 4, stall_vars['F'] == 6]),\n    'B': stall_vars['F'] == 1,\n    'C': Or(stall_vars['J'] == 2, stall_vars['J'] == 3),\n    'D': Or(stall_vars['J'] == 3, stall_vars['J'] == 4),\n    'E': Or(stall_vars['K'] == 2, stall_vars['K'] == 4),\n}\n\n# We want to find which option MUST be true\n# That means the negation of the option is UNSAT with the constraints\n\nfor letter, cond in options.items():\n    solver.push()\n    # Add negation of option condition\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Four lions—F, G, H, J—and two tigers—K and M—will be assigned to exactly six stalls, one animal per stall. The stalls are arranged as follows: First Row: 1 2 3 Second Row: 4 5 6 The only stalls that face each other are stalls 1 and 4, stalls 2 and 5, and stalls 3 and 6. The following conditions apply: The tigers' stalls cannot face each other. A lion must be assigned to stall 1. H must be assigned to stall 6. J must be assigned to a stall numbered one higher than K's stall. K cannot be assigned to the stall that faces H's stall.\n\nWhich one of the following could be true?\n\nOptions:\n(A) F's stall is numbered one higher than J's stall.\n(B) H's stall faces M's stall.\n(C) J is assigned to stall 4.\n(D) K's stall faces J's stall.\n(E) K's stall is in a different row than J's stall.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nanimals = ['F', 'G', 'H', 'J', 'K', 'M']\nlions = ['F', 'G', 'H', 'J']\ntigers = ['K', 'M']\nstalls = [1, 2, 3, 4, 5, 6]\n\n# Create Z3 Int variables for each animal's stall assignment\nstall_vars = {a: Int(a) for a in animals}\n\n# Helper: stalls that face each other\nfacing_pairs = [(1, 4), (2, 5), (3, 6)]\nfacing_map = {}\nfor s1, s2 in facing_pairs:\n    facing_map[s1] = s2\n    facing_map[s2] = s1\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each animal assigned to a stall 1..6\nfor a in animals:\n    solver.add(And(stall_vars[a] >= 1, stall_vars[a] <= 6))\n\n# All animals in distinct stalls\nsolver.add(Distinct([stall_vars[a] for a in animals]))\n\n# Tigers cannot face each other\n# So for tigers K and M, their stalls cannot be facing pairs\n# i.e. not (stall_K faces stall_M)\nstall_K = stall_vars['K']\nstall_M = stall_vars['M']\n# Create condition that stall_K and stall_M are facing\nfaces_KM = Or([And(stall_K == s1, stall_M == s2) for (s1, s2) in facing_pairs] +\n              [And(stall_K == s2, stall_M == s1) for (s1, s2) in facing_pairs])\nsolver.add(Not(faces_KM))\n\n# A lion must be assigned to stall 1\n# So one of F,G,H,J is in stall 1\nlions_stalls = [stall_vars[a] for a in lions]\nsolver.add(Or([ls == 1 for ls in lions_stalls]))\n\n# H must be assigned to stall 6\nsolver.add(stall_vars['H'] == 6)\n\n# J must be assigned to a stall numbered one higher than K's stall\nsolver.add(stall_vars['J'] == stall_vars['K'] + 1)\n\n# K cannot be assigned to the stall that faces H's stall\n# H is in stall 6, which faces stall 3\nsolver.add(stall_vars['K'] != facing_map[6])  # facing_map[6] == 3\n\n# OPTION CHECKING\n\noptions = [\n    # (A) F's stall is numbered one higher than J's stall.\n    stall_vars['F'] == stall_vars['J'] + 1,\n\n    # (B) H's stall faces M's stall.\n    Or([And(stall_vars['H'] == s1, stall_vars['M'] == s2) for (s1, s2) in facing_pairs] +\n       [And(stall_vars['H'] == s2, stall_vars['M'] == s1) for (s1, s2) in facing_pairs]),\n\n    # (C) J is assigned to stall 4.\n    stall_vars['J'] == 4,\n\n    # (D) K's stall faces J's stall.\n    Or([And(stall_vars['K'] == s1, stall_vars['J'] == s2) for (s1, s2) in facing_pairs] +\n       [And(stall_vars['K'] == s2, stall_vars['J'] == s1) for (s1, s2) in facing_pairs]),\n\n    # (E) K's stall is in a different row than J's stall.\n    # Rows: 1,2,3 first row; 4,5,6 second row\n    # Different row means one stall in {1,2,3} and the other in {4,5,6}\n    Or(\n        And(stall_vars['K'] <= 3, stall_vars['J'] >= 4),\n        And(stall_vars['K'] >= 4, stall_vars['J'] <= 3)\n    )\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Four lions—F, G, H, J—and two tigers—K and M—will be assigned to exactly six stalls, one animal per stall. The stalls are arranged as follows: First Row: 1 2 3 Second Row: 4 5 6 The only stalls that face each other are stalls 1 and 4, stalls 2 and 5, and stalls 3 and 6. The following conditions apply: The tigers' stalls cannot face each other. A lion must be assigned to stall 1. H must be assigned to stall 6. J must be assigned to a stall numbered one higher than K's stall. K cannot be assigned to the stall that faces H's stall.\n\nIf J is assigned to stall 3, which one of the following could be true?\n\nOptions:\n(A) F is assigned to stall 2.\n(B) F is assigned to stall 4.\n(C) G is assigned to stall 1.\n(D) G is assigned to stall 4.\n(E) M is assigned to stall 5.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Animals\nlions = ['F', 'G', 'H', 'J']\ntigers = ['K', 'M']\nanimals = lions + tigers\n\n# Stalls 1-6\nstalls = list(range(1, 7))\n\n# Create Int variables for each animal representing their stall assignment\nstall_of = {a: Int(a) for a in animals}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each animal assigned to exactly one stall in 1..6\nfor a in animals:\n    solver.add(And(stall_of[a] >= 1, stall_of[a] <= 6))\n\n# All animals assigned to distinct stalls\nsolver.add(Distinct([stall_of[a] for a in animals]))\n\n# The tigers' stalls cannot face each other\n# Facing pairs: (1,4), (2,5), (3,6)\n# So for tigers K and M, their stalls cannot be facing pairs\n# That means (stall_of[K], stall_of[M]) cannot be any of (1,4), (4,1), (2,5), (5,2), (3,6), (6,3)\nfacing_pairs = [(1,4), (4,1), (2,5), (5,2), (3,6), (6,3)]\nfor pair in facing_pairs:\n    solver.add(Or(stall_of['K'] != pair[0], stall_of['M'] != pair[1]))\n\n# A lion must be assigned to stall 1\n# Lions: F, G, H, J\n# So stall 1 is assigned to one of the lions\nlion_in_1 = Or([stall_of[lion] == 1 for lion in lions])\nsolver.add(lion_in_1)\n\n# H must be assigned to stall 6\nsolver.add(stall_of['H'] == 6)\n\n# J must be assigned to a stall numbered one higher than K's stall\nsolver.add(stall_of['J'] == stall_of['K'] + 1)\n\n# K cannot be assigned to the stall that faces H's stall\n# H is in stall 6, which faces stall 3\nsolver.add(stall_of['K'] != 3)\n\n# OPTION CHECKING\n# Given: J is assigned to stall 3\n# Add this constraint for all options checked\nsolver.push()\nsolver.add(stall_of['J'] == 3)\n\noptions = {\n    'A': stall_of['F'] == 2,\n    'B': stall_of['F'] == 4,\n    'C': stall_of['G'] == 1,\n    'D': stall_of['G'] == 4,\n    'E': stall_of['M'] == 5,\n}\n\nfor option_letter, option_constraint in options.items():\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()\n\nsolver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.\n\nIf there is one ranch house directly opposite another ranch house, which one of the following could be true?\n\nOptions:\n(A) House 8 is a ranch house.\n(B) House 7 is a split-level house.\n(C) House 4 is a Tudor house.\n(D) House 2 is a split-level house.\n(E) House 1 is a ranch house.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nhouses = [1, 2, 3, 4, 5, 6, 7, 8]\nstyles = ['ranch', 'split', 'tudor']\nstyle_indices = {style: i for i, style in enumerate(styles)}\n\n# Create Z3 Int variables for each house's style\nhouse_style = {h: Int(f'h{h}') for h in houses}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each house style must be one of the style indices\nfor h in houses:\n    solver.add(And(house_style[h] >= 0, house_style[h] < len(styles)))\n\n# Adjacent houses must have different styles\n# Adjacent houses on the same side: 1-3, 3-5, 5-7 and 2-4, 4-6, 6-8\nadjacent_pairs = [(1,3), (3,5), (5,7), (2,4), (4,6), (6,8)]\nfor (h1, h2) in adjacent_pairs:\n    solver.add(house_style[h1] != house_style[h2])\n\n# No split-level house faces another split-level house\n# Facing pairs: (1,2), (3,4), (5,6), (7,8)\nfacing_pairs = [(1,2), (3,4), (5,6), (7,8)]\nfor (h1, h2) in facing_pairs:\n    split = style_indices['split']\n    solver.add(Or(house_style[h1] != split, house_style[h2] != split))\n\n# Every ranch house has at least one Tudor house adjacent to it\n# Adjacent houses for each house:\n# House 1 adjacent to 3\n# House 3 adjacent to 1 and 5\n# House 5 adjacent to 3 and 7\n# House 7 adjacent to 5\n# House 2 adjacent to 4\n# House 4 adjacent to 2 and 6\n# House 6 adjacent to 4 and 8\n# House 8 adjacent to 6\n\nadjacency = {\n    1: [3],\n    3: [1, 5],\n    5: [3, 7],\n    7: [5],\n    2: [4],\n    4: [2, 6],\n    6: [4, 8],\n    8: [6]\n}\n\ntudor = style_indices['tudor']\nranch = style_indices['ranch']\n\nfor h in houses:\n    # If house h is ranch, then at least one adjacent house is Tudor\n    adj = adjacency[h]\n    if adj:\n        adj_tudor_conditions = [house_style[a] == tudor for a in adj]\n        solver.add(Implies(house_style[h] == ranch, Or(adj_tudor_conditions)))\n\n# House 3 is a ranch house\nsolver.add(house_style[3] == ranch)\n\n# House 6 is a split-level house\nsolver.add(house_style[6] == style_indices['split'])\n\n# There is one ranch house directly opposite another ranch house\n# So there exists exactly one facing pair where both houses are ranch\n# Count how many facing pairs are both ranch\nranch_opposite_pairs = []\nfor (h1, h2) in facing_pairs:\n    both_ranch = And(house_style[h1] == ranch, house_style[h2] == ranch)\n    ranch_opposite_pairs.append(both_ranch)\n\n# Exactly one such pair\nsolver.add(Sum([If(cond, 1, 0) for cond in ranch_opposite_pairs]) == 1)\n\n# OPTION CHECKING\noptions = {\n    'A': house_style[8] == ranch,\n    'B': house_style[7] == style_indices['split'],\n    'C': house_style[4] == tudor,\n    'D': house_style[2] == style_indices['split'],\n    'E': house_style[1] == ranch\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.\n\nIf house 4 is a Tudor house, then it could be true that house\n\nOptions:\n(A) 1 is a Tudor house\n(B) 2 is a Tudor house\n(C) 5 is a ranch house\n(D) 7 is a Tudor house\n(E) 8 is a ranch house",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Houses on one side: 1,3,5,7\n# Houses on opposite side: 2,4,6,8\nhouses = [1, 2, 3, 4, 5, 6, 7, 8]\nstyles = ['ranch', 'split-level', 'tudor']\nstyle_indices = {name: i for i, name in enumerate(styles)}\n\n# Create Z3 Int variables for each house style\nhouse_style = {h: Int(f'house_{h}_style') for h in houses}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each house style is one of the three styles (0=ranch,1=split-level,2=tudor)\nfor h in houses:\n    solver.add(And(house_style[h] >= 0, house_style[h] < len(styles)))\n\n# Adjacent houses are of different styles\n# Adjacent pairs on same side: (1,3), (3,5), (5,7) and (2,4), (4,6), (6,8)\nadjacent_pairs = [(1,3), (3,5), (5,7), (2,4), (4,6), (6,8)]\nfor (h1,h2) in adjacent_pairs:\n    solver.add(house_style[h1] != house_style[h2])\n\n# No split-level house faces another split-level house\n# Facing pairs: (1,2), (3,4), (5,6), (7,8)\nfor (h1,h2) in [(1,2), (3,4), (5,6), (7,8)]:\n    # If h1 is split-level then h2 is not split-level and vice versa\n    solver.add(Or(house_style[h1] != style_indices['split-level'], house_style[h2] != style_indices['split-level']))\n\n# Every ranch house has at least one Tudor house adjacent to it\n# Adjacent houses for each house:\n# House 1 adjacent: 3 (same side), 2 (facing)\n# House 2 adjacent: 4 (same side), 1 (facing)\n# House 3 adjacent: 1,5 (same side), 4 (facing)\n# House 4 adjacent: 2,6 (same side), 3 (facing)\n# House 5 adjacent: 3,7 (same side), 6 (facing)\n# House 6 adjacent: 4,8 (same side), 5 (facing)\n# House 7 adjacent: 5 (same side), 8 (facing)\n# House 8 adjacent: 6 (same side), 7 (facing)\n\nadjacency = {\n    1: [3, 2],\n    2: [4, 1],\n    3: [1, 5, 4],\n    4: [2, 6, 3],\n    5: [3, 7, 6],\n    6: [4, 8, 5],\n    7: [5, 8],\n    8: [6, 7]\n}\n\nfor h in houses:\n    # If house h is ranch, then at least one adjacent house is Tudor\n    ranch_cond = house_style[h] == style_indices['ranch']\n    # For adjacent houses, create list of Tudor conditions\n    t_conditions = [house_style[adj] == style_indices['tudor'] for adj in adjacency[h]]\n    # At least one adjacent is Tudor\n    adj_tudor_cond = Or(t_conditions)\n    solver.add(Implies(ranch_cond, adj_tudor_cond))\n\n# House 3 is ranch\nsolver.add(house_style[3] == style_indices['ranch'])\n\n# House 6 is split-level\nsolver.add(house_style[6] == style_indices['split-level'])\n\n# OPTION CHECKING\n# If house 4 is Tudor, then check which option can be true\n# Add constraint house 4 is Tudor\nsolver.add(house_style[4] == style_indices['tudor'])\n\noptions = {\n    'A': house_style[1] == style_indices['tudor'],\n    'B': house_style[2] == style_indices['tudor'],\n    'C': house_style[5] == style_indices['ranch'],\n    'D': house_style[7] == style_indices['tudor'],\n    'E': house_style[8] == style_indices['ranch']\n}\n\nfor opt_letter, opt_condition in options.items():\n    solver.push()\n    solver.add(opt_condition)\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.\n\nOn the street, there could be exactly\n\nOptions:\n(A) one ranch house\n(B) one Tudor house\n(C) two Tudor houses\n(D) four ranch houses\n(E) five ranch houses",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Houses: 1,3,5,7 on one side; 2,4,6,8 on opposite side\nhouses = [1, 2, 3, 4, 5, 6, 7, 8]\n\n# Styles: 0 = ranch, 1 = split-level, 2 = Tudor\nstyles = ['ranch', 'split-level', 'Tudor']\n\n# Create Z3 Int variables for each house's style\nhouse_style = {h: Int(f'h{h}_style') for h in houses}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each house must have a valid style index\nfor h in houses:\n    solver.add(And(house_style[h] >= 0, house_style[h] <= 2))\n\n# Adjacent houses on the same side are different styles\n# Adjacent pairs on side 1: (1,3), (3,5), (5,7)\nsolver.add(house_style[1] != house_style[3])\nsolver.add(house_style[3] != house_style[5])\nsolver.add(house_style[5] != house_style[7])\n\n# Adjacent houses on side 2: (2,4), (4,6), (6,8)\nsolver.add(house_style[2] != house_style[4])\nsolver.add(house_style[4] != house_style[6])\nsolver.add(house_style[6] != house_style[8])\n\n# No split-level house faces another split-level house\n# Facing pairs: (1,2), (3,4), (5,6), (7,8)\nfor h1, h2 in [(1,2), (3,4), (5,6), (7,8)]:\n    # If one is split-level (1), the other is not split-level\n    s1_split = house_style[h1] == 1\n    s2_split = house_style[h2] == 1\n    solver.add(Not(And(s1_split, s2_split)))\n\n# Every ranch house has at least one Tudor house adjacent to it\n# Adjacent houses for each house:\n# House 1 adjacent to 3 and faces 2\n# House 3 adjacent to 1 and 5 and faces 4\n# House 5 adjacent to 3 and 7 and faces 6\n# House 7 adjacent to 5 and faces 8\n# House 2 adjacent to 4 and faces 1\n# House 4 adjacent to 2 and 6 and faces 3\n# House 6 adjacent to 4 and 8 and faces 5\n# House 8 adjacent to 6 and faces 7\n\nadjacent = {\n    1: [3, 2],\n    3: [1, 5, 4],\n    5: [3, 7, 6],\n    7: [5, 8],\n    2: [4, 1],\n    4: [2, 6, 3],\n    6: [4, 8, 5],\n    8: [6, 7]\n}\n\nfor h in houses:\n    is_ranch = house_style[h] == 0\n    # Check if at least one adjacent house is Tudor (2)\n    adj_tudor_conditions = [house_style[adj] == 2 for adj in adjacent[h]]\n    has_tudor_adjacent = Or(adj_tudor_conditions)\n    # If ranch, then has at least one Tudor adjacent\n    solver.add(Implies(is_ranch, has_tudor_adjacent))\n\n# House 3 is ranch (0)\nsolver.add(house_style[3] == 0)\n\n# House 6 is split-level (1)\nsolver.add(house_style[6] == 1)\n\n# OPTION CHECKING\n# Options:\n# (A) one ranch house\n# (B) one Tudor house\n# (C) two Tudor houses\n# (D) four ranch houses\n# (E) five ranch houses\n\n# Count number of ranch houses\nranch_count = Sum([If(house_style[h] == 0, 1, 0) for h in houses])\ntudor_count = Sum([If(house_style[h] == 2, 1, 0)])\n\noptions = [\n    ranch_count == 1,\n    tudor_count == 1,\n    tudor_count == 2,\n    ranch_count == 4,\n    ranch_count == 5\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "On an undeveloped street, a developer will simultaneously build four houses on one side, numbered consecutively 1, 3, 5, and 7, and fos on the opposite side, numbered consecutively 2, 4, 6, and 8. Houses 2, 4, 6, and 8 will face houses 1, 3, 5, and 7, respectively. Each house will be exactly one of three styles—ranch, split-level, or Tudor—according to the following conditions: Adjacent houses are of different styles. No split-level house faces another split-level house. Every ranch house has at least one Tudor house adjacent to it. House 3 is a ranch house. House 6 is a split-level house.\n\nIf no house faces a house of the same style, then it must be true that house\n\nOptions:\n(A) 1 is a split-level house\n(B) 1 is a Tudor house\n(C) 2 is a ranch house\n(D) 2 is a split-level house\n(E) 4 is a Tudor house",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Houses: 1,3,5,7 on one side; 2,4,6,8 on the opposite side\nhouses = [1, 2, 3, 4, 5, 6, 7, 8]\n\n# Styles enumeration\nstyles = ['ranch', 'split-level', 'tudor']\nstyle_indices = {s: i for i, s in enumerate(styles)}\n\n# Create Z3 Int variables for each house style\nhouse_style = {}\nfor h in houses:\n    house_style[h] = Int(f'style_{h}')\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each house style is one of the three styles\nfor h in houses:\n    solver.add(And(house_style[h] >= 0, house_style[h] < len(styles)))\n\n# Adjacent houses on the same side (1-3,3-5,5-7 and 2-4,4-6,6-8) are different styles\nadjacent_pairs = [(1,3), (3,5), (5,7), (2,4), (4,6), (6,8)]\nfor (h1,h2) in adjacent_pairs:\n    solver.add(house_style[h1] != house_style[h2])\n\n# No split-level house faces another split-level house\n# Facing pairs: (1,2), (3,4), (5,6), (7,8)\nfacing_pairs = [(1,2), (3,4), (5,6), (7,8)]\nfor (h1,h2) in facing_pairs:\n    # If h1 is split-level, then h2 is not split-level, and vice versa\n    split_level = style_indices['split-level']\n    solver.add(Or(house_style[h1] != split_level, house_style[h2] != split_level))\n\n# Every ranch house has at least one Tudor house adjacent to it\n# Adjacent houses for each house:\n# House 1 adjacent: house 3 (only)\n# House 3 adjacent: houses 1 and 5\n# House 5 adjacent: houses 3 and 7\n# House 7 adjacent: house 5 (only)\n# House 2 adjacent: house 4 (only)\n# House 4 adjacent: houses 2 and 6\n# House 6 adjacent: houses 4 and 8\n# House 8 adjacent: house 6 (only)\nadjacency = {\n    1: [3],\n    3: [1,5],\n    5: [3,7],\n    7: [5],\n    2: [4],\n    4: [2,6],\n    6: [4,8],\n    8: [6]\n}\n\nranch = style_indices['ranch']\ntudor = style_indices['tudor']\n\nfor h in houses:\n    # If house h is ranch, then at least one adjacent house is Tudor\n    adj = adjacency[h]\n    if len(adj) > 0:\n        adj_tudor_conditions = [house_style[a] == tudor for a in adj]\n        solver.add(Implies(house_style[h] == ranch, Or(adj_tudor_conditions)))\n    else:\n        # No adjacent houses, so no constraint needed\n        pass\n\n# House 3 is ranch\nsolver.add(house_style[3] == ranch)\n\n# House 6 is split-level\nsolver.add(house_style[6] == style_indices['split-level'])\n\n# Additional condition: No house faces a house of the same style\nfor (h1,h2) in facing_pairs:\n    solver.add(house_style[h1] != house_style[h2])\n\n# OPTION CHECKING\n\noptions = {\n    'A': house_style[1] == style_indices['split-level'],\n    'B': house_style[1] == style_indices['tudor'],\n    'C': house_style[2] == style_indices['ranch'],\n    'D': house_style[2] == style_indices['split-level'],\n    'E': house_style[4] == style_indices['tudor']\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        # Check if adding the negation leads to unsat, meaning this must be true\n        solver.pop()\n        solver.push()\n        solver.add(Not(cond))\n        if solver.check() == unsat:\n            print(f\"'{letter}'\")\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Within a tennis league each of five teams occupies one of five positions, numbered 1 through 5 in order of rank, with number 1 as the highest position. The teams are initially in the order R, J, S, M, L, with R in position 1. Teams change positions only when a lower-positioned team defeats a higher-positioned team. The rules are as follows: Matches are played alternately in odd-position rounds and in even-position rounds. In an odd-position round, teams in positions 3 and 5 play against teams positioned immediately above them. In an even-position round, teams in positions 2 and 4 play against teams positioned immediately above them. When a lower-positioned team defeats a higher-positioned team, the two teams switch positions after the round is completed.\n\nWhich one of the following could be the order of teams, from position 1 through position 5 respectively, after exactly one round of even-position matches if no odd-position round has yet been played?\n\nOptions:\n(A) J, R, M, L, S\n(B) J, R, S, L, M\n(C) R, J, M, L, S\n(D) R, J, M, S, L\n(E) R, S, J, L, M",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nteams = ['R', 'J', 'S', 'M', 'L']\npositions = [0, 1, 2, 3, 4]  # zero-based indices for positions 1 to 5\n\n# Initial order: R(1), J(2), S(3), M(4), L(5)\n# Represent the order after one even-position round as a list of team variables\n# order[i] = index of team at position i (0-based)\norder = [Int(f'pos_{i+1}') for i in positions]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each position must have a valid team index\nfor i in positions:\n    solver.add(And(order[i] >= 0, order[i] < len(teams)))\n\n# All positions must have distinct teams\nsolver.add(Distinct(order))\n\n# Initial order mapping team -> position\ninitial_pos = { 'R':0, 'J':1, 'S':2, 'M':3, 'L':4 }\n\n# One round of even-position matches played, no odd-position rounds yet.\n# Even-position round means teams in positions 2 and 4 (1-based) play against the teams immediately above them.\n# That is:\n# Position 2 plays position 1\n# Position 4 plays position 3\n# Only if the lower-positioned team wins, they swap positions.\n\n# Since no odd rounds played, initial order before this round is:\n# pos 1: R (0)\n# pos 2: J (1)\n# pos 3: S (2)\n# pos 4: M (3)\n# pos 5: L (4)\n\n# Matches in this round: (pos2 vs pos1), (pos4 vs pos3)\n# pos2 = position 1 (0-based)\n# pos1 = position 0 (0-based)\n# pos4 = position 3 (0-based)\n# pos3 = position 2 (0-based)\n\n# Define variables to represent whether each lower-positioned team won\n# lower team at pos2 is J (1), above is R (0)\n# lower team at pos4 is M (3), above is S (2)\n\n# For each match, if lower team wins, positions swap; else positions remain same.\n\n# To model this, we consider all possible combinations of wins:\n\n# Possible outcomes:\n# - Neither wins (no swaps)\n# - Only J wins (swap pos1 and pos2)\n# - Only M wins (swap pos3 and pos4)\n# - Both win (swap pos1 and pos2, and swap pos3 and pos4)\n\n# We create four possible orders corresponding to these outcomes.\n\n# Function to swap positions in a list\ndef swap_positions(lst, i, j):\n    res = lst[:]\n    res[i], res[j] = res[j], res[i]\n    return res\n\n# Initial order list of team indices\ninit_order = [initial_pos[t] for t in teams]\n\n# Generate all possible orders after one even-position round\norders_after_round = []\n\n# Neither wins\norders_after_round.append(init_order)\n\n# Only J wins (swap pos0 and pos1)\norders_after_round.append(swap_positions(init_order, 0, 1))\n\n# Only M wins (swap pos2 and pos3)\norders_after_round.append(swap_positions(init_order, 2, 3))\n\n# Both win (swap pos0 and pos1, then swap pos2 and pos3)\nboth_swapped = swap_positions(init_order, 0, 1)\nboth_swapped = swap_positions(both_swapped, 2, 3)\norders_after_round.append(both_swapped)\n\n# Constraint: the order after the round must be one of these possible orders\npossible_orders = [And([order[i] == orders_after_round[j][i] for i in positions]) for j in range(len(orders_after_round))]\nsolver.add(Or(possible_orders))\n\n# OPTION CHECKING\n\noptions = [\n    ['J', 'R', 'M', 'L', 'S'],  # A\n    ['J', 'R', 'S', 'L', 'M'],  # B\n    ['R', 'J', 'M', 'L', 'S'],  # C\n    ['R', 'J', 'M', 'S', 'L'],  # D\n    ['R', 'S', 'J', 'L', 'M']   # E\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that order matches this option\n    opt_indices = [initial_pos[t] for t in opt]\n    solver.add(And([order[pos] == opt_indices[pos] for pos in positions]))\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Within a tennis league each of five teams occupies one of five positions, numbered 1 through 5 in order of rank, with number 1 as the highest position. The teams are initially in the order R, J, S, M, L, with R in position 1. Teams change positions only when a lower-positioned team defeats a higher-positioned team. The rules are as follows: Matches are played alternately in odd-position rounds and in even-position rounds. In an odd-position round, teams in positions 3 and 5 play against teams positioned immediately above them. In an even-position round, teams in positions 2 and 4 play against teams positioned immediately above them. When a lower-positioned team defeats a higher-positioned team, the two teams switch positions after the round is completed.\n\nIf exactly two rounds of matches have been played, beginning with an odd-position round, and if the lower-positioned teams have won every match in those two rounds, then each of the following must be true EXCEPT:\n\nOptions:\n(A) L is one position higher than J.\n(B) R is one position higher than L.\n(C) S is one position higher than R.\n(D) J is in position 4.\n(E) M is in position 3.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nteams = ['R', 'J', 'S', 'M', 'L']\npositions = [1, 2, 3, 4, 5]\n\n# Create variables for the positions of each team after two rounds\n# Positions are integers from 1 to 5\npos = {t: Int(t) for t in teams}\n\nsolver = Solver()\n\n# Initial positions:\n# R=1, J=2, S=3, M=4, L=5\ninitial_pos = {'R': 1, 'J': 2, 'S': 3, 'M': 4, 'L': 5}\n\n# Positions must be between 1 and 5\nfor t in teams:\n    solver.add(And(pos[t] >= 1, pos[t] <= 5))\n\n# All positions distinct\nsolver.add(Distinct([pos[t] for t in teams]))\n\n# Model the two rounds of matches and the effects\n\n# Initial order:\n# pos_init: R=1, J=2, S=3, M=4, L=5\n# Round 1: odd-position round\n# Matches:\n# - team in position 3 plays team immediately above (position 2)\n# - team in position 5 plays team immediately above (position 4)\n# Lower-position team wins => they swap positions\n\n# After round 1, define intermediate positions\npos1 = {t: Int(t + \"_1\") for t in teams}\nfor t in teams:\n    solver.add(And(pos1[t] >= 1, pos1[t] <= 5))\nsolver.add(Distinct([pos1[t] for t in teams]))\n\n# Round 2: even-position round\n# Matches:\n# - team in position 2 plays team immediately above (position 1)\n# - team in position 4 plays team immediately above (position 3)\n# Lower-position team wins => they swap positions\n\npos2 = {t: Int(t + \"_2\") for t in teams}\nfor t in teams:\n    solver.add(And(pos2[t] >= 1, pos2[t] <= 5))\nsolver.add(Distinct([pos2[t] for t in teams]))\n\n# Helper function to find which team is at a given position\n# We will model the matches by constraints on positions\n\n# We know initial positions:\n# pos_init: R=1, J=2, S=3, M=4, L=5\n\n# Round 1 (odd-position):\n# Matches:\n# - Position 3 vs Position 2\n# - Position 5 vs Position 4\n# Lower-position team wins and swaps positions\n\n# Identify teams at positions 2,3,4,5 initially:\n# pos_init_inv = {1:'R',2:'J',3:'S',4:'M',5:'L'}\n\n# For round 1, teams at positions 2,3,4,5 are J,S,M,L respectively\n\n# After round 1:\n# The matches:\n# Match A: S (pos 3) vs J (pos 2) => S wins => S and J swap positions\n# Match B: L (pos 5) vs M (pos 4) => L wins => L and M swap positions\n\n# So after round 1:\n# R stays at 1\n# J and S swap positions: J=3, S=2\n# M and L swap positions: M=5, L=4\n\nsolver.add(pos1['R'] == 1)\nsolver.add(pos1['J'] == 3)\nsolver.add(pos1['S'] == 2)\nsolver.add(pos1['M'] == 5)\nsolver.add(pos1['L'] == 4)\n\n# Round 2 (even-position):\n# Matches:\n# - Position 2 vs Position 1\n# - Position 4 vs Position 3\n# Lower-position team wins => swap positions\n\n# From pos1, teams at positions 1 to 5 are:\n# position 1: team with pos1[t] == 1\n# position 2: team with pos1[t] == 2\n# position 3: team with pos1[t] == 3\n# position 4: team with pos1[t] == 4\n# position 5: team with pos1[t] == 5\n\n# Identify teams at positions 1,2,3,4 after round 1:\n# pos1:\n# R=1\n# S=2\n# J=3\n# L=4\n# M=5\n\n# Matches in round 2:\n# Match C: position 2 (S) vs position 1 (R)\n# Match D: position 4 (L) vs position 3 (J)\n\n# Lower-position team wins => swap positions\n\n# So after round 2:\n# Match C: S wins => S and R swap positions\n# Match D: L wins => L and J swap positions\n\n# So after round 2:\n# S=1\n# R=2\n# L=3\n# J=4\n# M=5 (unchanged)\n\nsolver.add(pos2['S'] == 1)\nsolver.add(pos2['R'] == 2)\nsolver.add(pos2['L'] == 3)\nsolver.add(pos2['J'] == 4)\nsolver.add(pos2['M'] == 5)\n\n# OPTION CHECKING\n\noptions = [\n    # (A) L is one position higher than J.\n    # L position +1 == J position\n    lambda: pos2['L'] + 1 == pos2['J'],\n\n    # (B) R is one position higher than L.\n    # R position +1 == L position\n    lambda: pos2['R'] + 1 == pos2['L'],\n\n    # (C) S is one position higher than R.\n    # S position +1 == R position\n    lambda: pos2['S'] + 1 == pos2['R'],\n\n    # (D) J is in position 4.\n    lambda: pos2['J'] == 4,\n\n    # (E) M is in position 3.\n    lambda: pos2['M'] == 3,\n]\n\n# Exactly two rounds played, lower-positioned team wins every match\n# The final positions are as modeled above (pos2)\n\n# We want to find which of these statements is NOT necessarily true\n# So test each option's negation with the model\n# The one whose negation is SAT is the EXCEPT answer\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add negation of the option\n    solver.add(Not(option()))\n    if solver.check() == sat:\n        # This option can be false, so it's the EXCEPT answer\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Within a tennis league each of five teams occupies one of five positions, numbered 1 through 5 in order of rank, with number 1 as the highest position. The teams are initially in the order R, J, S, M, L, with R in position 1. Teams change positions only when a lower-positioned team defeats a higher-positioned team. The rules are as follows: Matches are played alternately in odd-position rounds and in even-position rounds. In an odd-position round, teams in positions 3 and 5 play against teams positioned immediately above them. In an even-position round, teams in positions 2 and 4 play against teams positioned immediately above them. When a lower-positioned team defeats a higher-positioned team, the two teams switch positions after the round is completed.\n\nIf after exactly three rounds of matches M is in position 4, and J and L have won all of their matches, then which one of the following can be true?\n\nOptions:\n(A) J is in position 2.\n(B) J is in position 3.\n(C) L is in position 2.\n(D) R is in position 1.\n(E) S is in position 3.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nteams = ['R', 'J', 'S', 'M', 'L']\npositions = [1, 2, 3, 4, 5]\n\n# Create variables for team positions after each round (0 = initial, 1, 2, 3)\n# pos[round][team] = position of team at that round\npos = dict()\nfor r in range(4):\n    pos[r] = dict()\n    for t in teams:\n        pos[r][t] = Int(f'pos_{r}_{t}')\n\nsolver = Solver()\n\n# Initial positions (round 0)\n# R in position 1, then J=2, S=3, M=4, L=5\nsolver.add(pos[0]['R'] == 1)\nsolver.add(pos[0]['J'] == 2)\nsolver.add(pos[0]['S'] == 3)\nsolver.add(pos[0]['M'] == 4)\nsolver.add(pos[0]['L'] == 5)\n\n# Positions are always between 1 and 5 inclusive\nfor r in range(4):\n    for t in teams:\n        solver.add(And(pos[r][t] >= 1, pos[r][t] <= 5))\n\n# At each round, positions are a permutation of 1..5 (no duplicates)\nfor r in range(4):\n    solver.add(Distinct([pos[r][t] for t in teams]))\n\n# Helper function to get team at a given position at a given round\ndef team_at_position(r, p):\n    # returns a list of Bool expressions: team_at_position is True iff pos[r][team] == p\n    return [pos[r][t] == p for t in teams]\n\n# Helper function to get team name at position p at round r (used for constraints)\n# We can use this by checking which team has pos[r][team] == p\n\n# Matches are played alternately in odd-position rounds and even-position rounds:\n# Round 1: odd-position round (1)\n# Round 2: even-position round (2)\n# Round 3: odd-position round (3)\n\n# In odd-position rounds, teams in positions 3 and 5 play against teams immediately above them (positions 2 and 4)\n# In even-position rounds, teams in positions 2 and 4 play against teams immediately above them (positions 1 and 3)\n\n# When a lower-positioned team defeats a higher-positioned team, they switch positions after the round.\n\n# J and L have won all their matches (in all rounds where they play)\n\n# After exactly 3 rounds, M is in position 4\nsolver.add(pos[3]['M'] == 4)\n\n# Model the matches and results, and positions update after each round\n\n# We'll model the matches and winners for each round\n\n# For each round, identify the matches and the teams playing\n\n# We'll create variables for each match winner: winner_roundX_matchY = team index (0..4)\n\nteam_index = {t: i for i, t in enumerate(teams)}\n\n# For each round, matches and players\n\n# Round 1 (odd-position round): teams in positions 3 and 5 play against teams immediately above them\n# Matches: pos3 vs pos2, pos5 vs pos4\n# So matches: (pos2, pos3), (pos4, pos5)\n# Lower-positioned teams are pos3 and pos5 (3 and 5 > 2 and 4), so pos3 plays pos2, pos5 plays pos4\n\n# Round 2 (even-position round): teams in positions 2 and 4 play against teams immediately above them\n# Matches: pos2 vs pos1, pos4 vs pos3\n# Lower-positioned teams are pos2 and pos4 (2 and 4 > 1 and 3)\n\n# Round 3 (odd-position round): same as round 1\n\n# We'll create variables for winners of each match in each round: winner_roundX_matchY\n\n# For each match, we know the two teams playing by their positions at round r-1\n\n# Important: We need to find which teams are at these positions at round r-1\n\n# Create helper function to get team at a position at a round: returns a variable representing the team index\n\ndef team_at_pos_var(r, p):\n    # returns Int variable representing the team at position p at round r\n    # We create a variable and add constraints linking it to pos[r][team]\n    v = Int(f'team_at_pos_{r}_{p}')\n    # Constrain v to be one of the team indices\n    solver.add(And(v >= 0, v < len(teams)))\n    # Exactly one team has pos[r][team] == p, so v == team_index[team]\n    # Link v to pos[r][team]\n    # For each team, if v == team_index[team] then pos[r][team] == p\n    # This is encoded using Or and And:\n    conds = []\n    for t in teams:\n        conds.append(And(v == team_index[t], pos[r][t] == p))\n    solver.add(Or(conds))\n    return v\n\n# Create variables for winners of each match\n\n# Round 1 matches:\n# Match 1: pos3 vs pos2\n# Match 2: pos5 vs pos4\n\nwinner_r1_m1 = Int('winner_r1_m1')\nwinner_r1_m2 = Int('winner_r1_m2')\n\nsolver.add(And(winner_r1_m1 >= 0, winner_r1_m1 < len(teams)))\nsolver.add(And(winner_r1_m2 >= 0, winner_r1_m2 < len(teams)))\n\n# Round 2 matches:\n# Match 1: pos2 vs pos1\n# Match 2: pos4 vs pos3\n\nwinner_r2_m1 = Int('winner_r2_m1')\nwinner_r2_m2 = Int('winner_r2_m2')\n\nsolver.add(And(winner_r2_m1 >= 0, winner_r2_m1 < len(teams)))\nsolver.add(And(winner_r2_m2 >= 0, winner_r2_m2 < len(teams)))\n\n# Round 3 matches:\n# Same as round 1\n\nwinner_r3_m1 = Int('winner_r3_m1')\nwinner_r3_m2 = Int('winner_r3_m2')\n\nsolver.add(And(winner_r3_m1 >= 0, winner_r3_m1 < len(teams)))\nsolver.add(And(winner_r3_m2 >= 0, winner_r3_m2 < len(teams)))\n\n# For each match, the two teams playing are at positions specified at previous round\n\n# Round 1 matches players (positions at round 0)\nr = 0\nr1_m1_pos_lower = 3\nr1_m1_pos_higher = 2\nr1_m2_pos_lower = 5\nr1_m2_pos_higher = 4\n\nr1_m1_lower_team = team_at_pos_var(r, r1_m1_pos_lower)\nr1_m1_higher_team = team_at_pos_var(r, r1_m1_pos_higher)\nr1_m2_lower_team = team_at_pos_var(r, r1_m2_pos_lower)\nr1_m2_higher_team = team_at_pos_var(r, r1_m2_pos_higher)\n\n# Round 2 matches players (positions at round 1)\nr = 1\nr2_m1_pos_lower = 2\nr2_m1_pos_higher = 1\nr2_m2_pos_lower = 4\nr2_m2_pos_higher = 3\n\nr2_m1_lower_team = team_at_pos_var(r, r2_m1_pos_lower)\nr2_m1_higher_team = team_at_pos_var(r, r2_m1_pos_higher)\nr2_m2_lower_team = team_at_pos_var(r, r2_m2_pos_lower)\nr2_m2_higher_team = team_at_pos_var(r, r2_m2_pos_higher)\n\n# Round 3 matches players (positions at round 2)\nr = 2\nr3_m1_pos_lower = 3\nr3_m1_pos_higher = 2\nr3_m2_pos_lower = 5\nr3_m2_pos_higher = 4\n\nr3_m1_lower_team = team_at_pos_var(r, r3_m1_pos_lower)\nr3_m1_higher_team = team_at_pos_var(r, r3_m1_pos_higher)\nr3_m2_lower_team = team_at_pos_var(r, r3_m2_pos_lower)\nr3_m2_higher_team = team_at_pos_var(r, r3_m2_pos_higher)\n\n# Constraint: winners must be one of the two teams playing\nsolver.add(Or(winner_r1_m1 == r1_m1_lower_team, winner_r1_m1 == r1_m1_higher_team))\nsolver.add(Or(winner_r1_m2 == r1_m2_lower_team, winner_r1_m2 == r1_m2_higher_team))\nsolver.add(Or(winner_r2_m1 == r2_m1_lower_team, winner_r2_m1 == r2_m1_higher_team))\nsolver.add(Or(winner_r2_m2 == r2_m2_lower_team, winner_r2_m2 == r2_m2_higher_team))\nsolver.add(Or(winner_r3_m1 == r3_m1_lower_team, winner_r3_m1 == r3_m1_higher_team))\nsolver.add(Or(winner_r3_m2 == r3_m2_lower_team, winner_r3_m2 == r3_m2_higher_team))\n\n# J and L have won all their matches they played\n# So if J or L played in a match, they must be the winner of that match\n\ndef team_played_in_match(team_idx, lower_team, higher_team):\n    return Or(lower_team == team_idx, higher_team == team_idx)\n\n# Round 1\nfor team_name in ['J', 'L']:\n    idx = team_index[team_name]\n    # If team played in match 1\n    played_m1 = team_played_in_match(idx, r1_m1_lower_team, r1_m1_higher_team)\n    # If played, winner is team\n    solver.add(Implies(played_m1, winner_r1_m1 == idx))\n\n    # If played in match 2\n    played_m2 = team_played_in_match(idx, r1_m2_lower_team, r1_m2_higher_team)\n    solver.add(Implies(played_m2, winner_r1_m2 == idx))\n\n# Round 2\nfor team_name in ['J', 'L']:\n    idx = team_index[team_name]\n    played_m1 = team_played_in_match(idx, r2_m1_lower_team, r2_m1_higher_team)\n    solver.add(Implies(played_m1, winner_r2_m1 == idx))\n\n    played_m2 = team_played_in_match(idx, r2_m2_lower_team, r2_m2_higher_team)\n    solver.add(Implies(played_m2, winner_r2_m2 == idx))\n\n# Round 3\nfor team_name in ['J', 'L']:\n    idx = team_index[team_name]\n    played_m1 = team_played_in_match(idx, r3_m1_lower_team, r3_m1_higher_team)\n    solver.add(Implies(played_m1, winner_r3_m1 == idx))\n\n    played_m2 = team_played_in_match(idx, r3_m2_lower_team, r3_m2_higher_team)\n    solver.add(Implies(played_m2, winner_r3_m2 == idx))\n\n# Positions update after each round according to match results\n\n# The rule: when a lower-positioned team defeats a higher-positioned team, they switch positions after the round.\n\n# We'll write a helper function to add constraints for position changes after a round\n\ndef add_position_update_constraints(r, winner_m1, lower_m1_pos, higher_m1_pos, winner_m2, lower_m2_pos, higher_m2_pos):\n    # For round r, update pos[r+1] based on pos[r] and winners\n\n    # Get teams at positions for round r\n    lower_team_m1 = team_at_pos_var(r, lower_m1_pos)\n    higher_team_m1 = team_at_pos_var(r, higher_m1_pos)\n    lower_team_m2 = team_at_pos_var(r, lower_m2_pos)\n    higher_team_m2 = team_at_pos_var(r, higher_m2_pos)\n\n    for t in teams:\n        t_idx = team_index[t]\n        # For each team, determine pos[r+1][t]\n\n        # Start with default: position unchanged\n        # We'll add constraints for position changes\n\n        # Conditions for switching positions for match 1\n        cond_m1 = And(winner_m1 == lower_team_m1, Or(t_idx == lower_team_m1, t_idx == higher_team_m1))\n        # Conditions for switching positions for match 2\n        cond_m2 = And(winner_m2 == lower_team_m2, Or(t_idx == lower_team_m2, t_idx == higher_team_m2))\n\n        # If team not involved in matches, position unchanged\n        involved_m1 = Or(t_idx == lower_team_m1, t_idx == higher_team_m1)\n        involved_m2 = Or(t_idx == lower_team_m2, t_idx == higher_team_m2)\n        involved = Or(involved_m1, involved_m2)\n\n        # We'll define position after round r+1 for team t as variable pos[r+1][t]\n        # Create expressions for new position\n\n        # For match 1 switch:\n        # If winner is lower_team_m1, they swap positions\n        # So lower_team_m1 gets higher_m1_pos, higher_team_m1 gets lower_m1_pos\n\n        # For match 2 switch:\n        # Similarly\n\n        # Build conditions for pos[r+1][t]\n\n        # Case 1: team involved in match 1 and winner is lower team => swap positions\n        # Case 2: team involved in match 2 and winner is lower team => swap positions\n        # Case 3: else position unchanged\n\n        pos_r_t = pos[r][t]\n\n        # Create expressions for new position\n\n        # For match 1 swap\n        pos_after_m1 = If(And(winner_m1 == lower_team_m1, t_idx == lower_team_m1), higher_m1_pos,\n                          If(And(winner_m1 == lower_team_m1, t_idx == higher_team_m1), lower_m1_pos,\n                             pos_r_t))\n\n        # For match 2 swap\n        pos_after_m2 = If(And(winner_m2 == lower_team_m2, t_idx == lower_team_m2), higher_m2_pos,\n                          If(And(winner_m2 == lower_team_m2, t_idx == higher_team_m2), lower_m2_pos,\n                             pos_after_m1))\n\n        # Add constraint for pos[r+1][t]\n        solver.add(pos[r+1][t] == pos_after_m2)\n\n# Add position update constraints for round 0->1\nadd_position_update_constraints(0, winner_r1_m1, r1_m1_pos_lower, r1_m1_pos_higher,\n                                   winner_r1_m2, r1_m2_pos_lower, r1_m2_pos_higher)\n\n# For round 1->2\nadd_position_update_constraints(1, winner_r2_m1, r2_m1_pos_lower, r2_m1_pos_higher,\n                                   winner_r2_m2, r2_m2_pos_lower, r2_m2_pos_higher)\n\n# For round 2->3\nadd_position_update_constraints(2, winner_r3_m1, r3_m1_pos_lower, r3_m1_pos_higher,\n                                   winner_r3_m2, r3_m2_pos_lower, r3_m2_pos_higher)\n\n# Now we check the options, add constraints for each option and check satisfiability\n\noptions = {\n    'A': pos[3]['J'] == 2,\n    'B': pos[3]['J'] == 3,\n    'C': pos[3]['L'] == 2,\n    'D': pos[3]['R'] == 1,\n    'E': pos[3]['S'] == 3,\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "On Wednesday a physician will have exactly one appointment with seven patients—P, Q, R, S, T, U, W—one patient per appointment. The schedule of appointments, chronologically numbered 1 through 7, must meet the following conditions: Q's appointment is at some time before W's appointment. U's appointment is at some time before P's appointment. Either R or T has appointment 3. S's appointment is either the appointment immediately before or the appointment immediately after R's appointment.\n\nWhich one of the following is an acceptable schedule of appointments in order from 1 to 7?\n\nOptions:\n(A) Q, S, R, P, W, U, T\n(B) Q, U, W, S, R, T, P\n(C) S, Q, R, T, W, U, P\n(D) T, U, R, S, W, P, Q\n(E) U, Q, T, P, R, S, W",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npatients = ['P', 'Q', 'R', 'S', 'T', 'U', 'W']\nappointments = list(range(1, 8))  # 1 through 7\n\n# Create a Z3 Int variable for each patient representing their appointment time\nschedule = {p: Int(p) for p in patients}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each appointment time is between 1 and 7\nfor p in patients:\n    solver.add(And(schedule[p] >= 1, schedule[p] <= 7))\n\n# All patients have distinct appointment times\nsolver.add(Distinct([schedule[p] for p in patients]))\n\n# Q's appointment is before W's appointment\nsolver.add(schedule['Q'] < schedule['W'])\n\n# U's appointment is before P's appointment\nsolver.add(schedule['U'] < schedule['P'])\n\n# Either R or T has appointment 3\nr_is_3 = schedule['R'] == 3\nt_is_3 = schedule['T'] == 3\nsolver.add(Or(r_is_3, t_is_3))\n\n# S's appointment is immediately before or immediately after R's appointment\ndiff_SR = schedule['S'] - schedule['R']\nsolver.add(Or(diff_SR == 1, diff_SR == -1))\n\n# OPTION CHECKING\noptions = [\n    ['Q', 'S', 'R', 'P', 'W', 'U', 'T'],  # A\n    ['Q', 'U', 'W', 'S', 'R', 'T', 'P'],  # B\n    ['S', 'Q', 'R', 'T', 'W', 'U', 'P'],  # C\n    ['T', 'U', 'R', 'S', 'W', 'P', 'Q'],  # D\n    ['U', 'Q', 'T', 'P', 'R', 'S', 'W']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that the patients appear in the given order from appointment 1 to 7\n    for time, patient in enumerate(option, start=1):\n        solver.add(schedule[patient] == time)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "On Wednesday a physician will have exactly one appointment with seven patients—P, Q, R, S, T, U, W—one patient per appointment. The schedule of appointments, chronologically numbered 1 through 7, must meet the following conditions: Q's appointment is at some time before W's appointment. U's appointment is at some time before P's appointment. Either R or T has appointment 3. S's appointment is either the appointment immediately before or the appointment immediately after R's appointment.\n\nIf W has appointment 2 and P has appointment 5, then which one of the following must be true?\n\nOptions:\n(A) R has appointment 6.\n(B) S has appointment 4.\n(C) S has appointment 7.\n(D) U has appointment 1.\n(E) U has appointment 4.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npatients = ['P', 'Q', 'R', 'S', 'T', 'U', 'W']\nappointments = range(1, 8)  # 1 through 7\n\n# Create Z3 Int variables for each patient representing their appointment number\nappt = {p: Int(p) for p in patients}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each appointment number is between 1 and 7\nfor p in patients:\n    solver.add(And(appt[p] >= 1, appt[p] <= 7))\n\n# All appointment numbers are distinct\nsolver.add(Distinct([appt[p] for p in patients]))\n\n# Q's appointment is before W's appointment\nsolver.add(appt['Q'] < appt['W'])\n\n# U's appointment is before P's appointment\nsolver.add(appt['U'] < appt['P'])\n\n# Either R or T has appointment 3\nsolver.add(Or(appt['R'] == 3, appt['T'] == 3))\n\n# S's appointment is immediately before or after R's appointment\nsolver.add(Or(appt['S'] == appt['R'] + 1, appt['S'] == appt['R'] - 1))\n\n# Given: W has appointment 2 and P has appointment 5\nsolver.add(appt['W'] == 2)\nsolver.add(appt['P'] == 5)\n\n# OPTION CHECKING\noptions = {\n    'A': appt['R'] == 6,\n    'B': appt['S'] == 4,\n    'C': appt['S'] == 7,\n    'D': appt['U'] == 1,\n    'E': appt['U'] == 4,\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    # Check if condition must be true: add negation and see if unsat\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "On Wednesday a physician will have exactly one appointment with seven patients—P, Q, R, S, T, U, W—one patient per appointment. The schedule of appointments, chronologically numbered 1 through 7, must meet the following conditions: Q's appointment is at some time before W's appointment. U's appointment is at some time before P's appointment. Either R or T has appointment 3. S's appointment is either the appointment immediately before or the appointment immediately after R's appointment.\n\nIf U's appointment is immediately after T's appointment and immediately before R's appointment, then which one of the following must be true?\n\nOptions:\n(A) Q's appointment is at some time before P's appointment.\n(B) S's appointment is at some time before P's appointment.\n(C) S's appointment is immediately before Q's appointment.\n(D) W's appointment is immediately before P's appointment.\n(E) W's appointment is at some time before S's appointment.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npatients = ['P', 'Q', 'R', 'S', 'T', 'U', 'W']\n\n# Create Z3 Int variables for each patient's appointment time (1 through 7)\nappt = {p: Int(p) for p in patients}\n\nsolver = Solver()\n\n# Each appointment time is between 1 and 7\nfor p in patients:\n    solver.add(And(appt[p] >= 1, appt[p] <= 7))\n\n# All appointments are at distinct times\nsolver.add(Distinct([appt[p] for p in patients]))\n\n# CONSTRAINTS from the problem\n\n# Q's appointment is before W's appointment\nsolver.add(appt['Q'] < appt['W'])\n\n# U's appointment is before P's appointment\nsolver.add(appt['U'] < appt['P'])\n\n# Either R or T has appointment 3\nsolver.add(Or(appt['R'] == 3, appt['T'] == 3))\n\n# S's appointment is immediately before or immediately after R's appointment\nsolver.add(Or(appt['S'] == appt['R'] - 1, appt['S'] == appt['R'] + 1))\n\n# Additional condition for the question:\n# U's appointment is immediately after T's appointment and immediately before R's appointment\nsolver.add(appt['U'] == appt['T'] + 1)\nsolver.add(appt['U'] == appt['R'] - 1)\n\n# OPTION CHECKING\noptions = [\n    appt['Q'] < appt['P'],               # (A) Q's appointment is before P's appointment\n    appt['S'] < appt['P'],               # (B) S's appointment is before P's appointment\n    appt['S'] == appt['Q'] - 1,          # (C) S's appointment is immediately before Q's appointment\n    appt['W'] == appt['P'] - 1,          # (D) W's appointment is immediately before P's appointment\n    appt['W'] < appt['S']                # (E) W's appointment is before S's appointment\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "On Wednesday a physician will have exactly one appointment with seven patients—P, Q, R, S, T, U, W—one patient per appointment. The schedule of appointments, chronologically numbered 1 through 7, must meet the following conditions: Q's appointment is at some time before W's appointment. U's appointment is at some time before P's appointment. Either R or T has appointment 3. S's appointment is either the appointment immediately before or the appointment immediately after R's appointment.\n\nIf P's appointment is immediately before S's appointment, then each of the following could be true EXCEPT:\n\nOptions:\n(A) R's appointment is immediately before W's appointment.\n(B) T's appointment is immediately before Q's appointment.\n(C) U's appointment is immediately before P's appointment.\n(D) U's appointment is immediately before Q's appointment.\n(E) W's appointment is immediately before T's appointment.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npatients = ['P', 'Q', 'R', 'S', 'T', 'U', 'W']\nindices = {p: i for i, p in enumerate(patients)}\n\n# Create Z3 Int variables for appointment times (1 through 7)\nappt = {p: Int(p) for p in patients}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each appointment time is between 1 and 7\nfor p in patients:\n    solver.add(And(appt[p] >= 1, appt[p] <= 7))\n\n# All appointments are distinct\nsolver.add(Distinct([appt[p] for p in patients]))\n\n# Q's appointment is before W's appointment\nsolver.add(appt['Q'] < appt['W'])\n\n# U's appointment is before P's appointment\nsolver.add(appt['U'] < appt['P'])\n\n# Either R or T has appointment 3\nr_is_3 = appt['R'] == 3\nt_is_3 = appt['T'] == 3\nsolver.add(Or([r_is_3, t_is_3]))\n\n# S's appointment is immediately before or after R's appointment\nsolver.add(Or(appt['S'] == appt['R'] + 1, appt['S'] == appt['R'] - 1))\n\n# P's appointment is immediately before S's appointment (given condition)\nsolver.add(appt['P'] + 1 == appt['S'])\n\n# OPTION CHECKING\n\n# Define option-specific constraints (immediate before conditions)\noptions = {\n    'A': appt['R'] + 1 == appt['W'],  # R immediately before W\n    'B': appt['T'] + 1 == appt['Q'],  # T immediately before Q\n    'C': appt['U'] + 1 == appt['P'],  # U immediately before P\n    'D': appt['U'] + 1 == appt['Q'],  # U immediately before Q\n    'E': appt['W'] + 1 == appt['T'],  # W immediately before T\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        # Option could be true\n        solver.pop()\n    else:\n        # Option cannot be true, print and break\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "On Wednesday a physician will have exactly one appointment with seven patients—P, Q, R, S, T, U, W—one patient per appointment. The schedule of appointments, chronologically numbered 1 through 7, must meet the following conditions: Q's appointment is at some time before W's appointment. U's appointment is at some time before P's appointment. Either R or T has appointment 3. S's appointment is either the appointment immediately before or the appointment immediately after R's appointment.\n\nIf T's appointment is immediately after P's appointment and immediately before W's appointment, then which one of the following must be true?\n\nOptions:\n(A) W's appointment is at some time before R's appointment.\n(B) U's appointment is at some time before R's appointment.\n(C) S's appointment is at some time before U's appointment.\n(D) R's appointment is at some time before P's appointment.\n(E) Q's appointment is at some time before S's appointment.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npatients = ['P', 'Q', 'R', 'S', 'T', 'U', 'W']\nindices = {p: Int(p) for p in patients}\n\n# Solver instance\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each appointment time is between 1 and 7\nfor p in patients:\n    solver.add(indices[p] >= 1, indices[p] <= 7)\n\n# All appointments are distinct\nsolver.add(Distinct([indices[p] for p in patients]))\n\n# Q's appointment is before W's appointment\nsolver.add(indices['Q'] < indices['W'])\n\n# U's appointment is before P's appointment\nsolver.add(indices['U'] < indices['P'])\n\n# Either R or T has appointment 3\nr_is_3 = indices['R'] == 3\nt_is_3 = indices['T'] == 3\nsolver.add(Or([r_is_3, t_is_3]))\n\n# S's appointment is immediately before or after R's appointment\nsolver.add(Or(indices['S'] == indices['R'] + 1, indices['S'] == indices['R'] - 1))\n\n# Given condition: T's appointment is immediately after P's appointment and immediately before W's appointment\nsolver.add(indices['T'] == indices['P'] + 1)\nsolver.add(indices['T'] == indices['W'] - 1)\n\n# OPTION CHECKING\noptions = [\n    indices['W'] < indices['R'],  # A\n    indices['U'] < indices['R'],  # B\n    indices['S'] < indices['U'],  # C\n    indices['R'] < indices['P'],  # D\n    indices['Q'] < indices['S']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add negation of option to check if option must be true\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.\n\nWhich one of the following is a group of three employees who can be assigned together to the Sales Committee?\n\nOptions:\n(A) F, G, and H\n(B) F, G, and M\n(C) G, K, and L\n(D) H, K, and L\n(E) K, L, and M",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['F', 'G', 'H', 'K', 'L', 'M']\nofficers = ['F', 'G', 'H']\nsupervisors = ['K', 'L', 'M']\ncommittees = ['Policy', 'Quality', 'Sales']\n\n# Create variables: assign[e][c] = Bool indicating if employee e is assigned to committee c\nassign = {}\nfor e in employees:\n    for c in committees:\n        assign[(e, c)] = Bool(f\"{e}_{c}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each employee must be assigned to at least one committee\nfor e in employees:\n    solver.add(Or([assign[(e, c)] for c in committees]))\n\n# 2. Each committee must have exactly three employees\nfor c in committees:\n    assigned_to_c = [If(assign[(e, c)], 1, 0) for e in employees]\n    solver.add(Sum(assigned_to_c) == 3)\n\n# 3. Each committee must have at least one officer assigned\nfor c in committees:\n    officer_assigned = [assign[(o, c)] for o in officers]\n    solver.add(Or(officer_assigned))\n\n# 4. All three officers must be assigned to the Policy Committee\nfor o in officers:\n    solver.add(assign[(o, 'Policy')])\n\n# 5. G cannot be assigned to the same committee as L\nfor c in committees:\n    solver.add(Not(And(assign[('G', c)], assign[('L', c)])))\n\n# 6. K must be assigned to the Sales Committee\nsolver.add(assign[('K', 'Sales')])\n\n# OPTION CHECKING\n\noptions = {\n    'A': ['F', 'G', 'H'],\n    'B': ['F', 'G', 'M'],\n    'C': ['G', 'K', 'L'],\n    'D': ['H', 'K', 'L'],\n    'E': ['K', 'L', 'M']\n}\n\nfor letter, group in options.items():\n    solver.push()\n    # The group is assigned to Sales committee\n    # All three employees in group assigned to Sales\n    for e in group:\n        solver.add(assign[(e, 'Sales')])\n    # The other employees not in group assigned to Sales are not assigned\n    others = [e for e in employees if e not in group]\n    for e in others:\n        solver.add(Not(assign[(e, 'Sales')]))\n    # Check if this is satisfiable with all other constraints\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.\n\nIf H is assigned to exactly one committee, and if no committee has both F and M assigned to it, then it must be true that\n\nOptions:\n(A) G and M are both assigned to the Quality Committee\n(B) K and L are both assigned to the Sales Committee\n(C) K is assigned to exactly two committees\n(D) L is assigned to exactly two committees\n(E) M is assigned to exactly two committees",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['F', 'G', 'H', 'K', 'L', 'M']\nofficers = ['F', 'G', 'H']\nsupervisors = ['K', 'L', 'M']\ncommittees = ['Policy', 'Quality', 'Sales']\n\n# Create a dictionary of Bool variables: assigned[(employee, committee)] = True if employee is assigned to committee\nassigned = {}\nfor e in employees:\n    for c in committees:\n        assigned[(e, c)] = Bool(f\"{e}_{c}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each committee has exactly three employees assigned\nfor c in committees:\n    committee_members = [assigned[(e, c)] for e in employees]\n    solver.add(Sum([If(m, 1, 0) for m in committee_members]) == 3)\n\n# 2) Each employee must be assigned to at least one committee\nfor e in employees:\n    employee_committees = [assigned[(e, c)] for c in committees]\n    solver.add(Or(employee_committees))\n\n# 3) Each committee must have at least one officer assigned to it\nfor c in committees:\n    committee_officers = [assigned[(o, c)] for o in officers]\n    solver.add(Or(committee_officers))\n\n# 4) All three officers must be assigned to the Policy Committee\nfor o in officers:\n    solver.add(assigned[(o, 'Policy')])\n\n# 5) G cannot be assigned to the same committee as L\nfor c in committees:\n    solver.add(Not(And(assigned[('G', c)], assigned[('L', c)])))\n\n# 6) K must be assigned to the Sales Committee\nsolver.add(assigned[('K', 'Sales')])\n\n# Additional conditions from the problem statement:\n\n# H is assigned to exactly one committee\nh_assignments = [assigned[('H', c)] for c in committees]\nsolver.add(Sum([If(h, 1, 0) for h in h_assignments]) == 1)\n\n# No committee has both F and M assigned to it\nfor c in committees:\n    solver.add(Not(And(assigned[('F', c)], assigned[('M', c)])))\n\n# OPTION CHECKING\n# Define option conditions as functions returning Z3 BoolExpr\n\ndef option_A():\n    # G and M both assigned to Quality Committee\n    return And(assigned[('G', 'Quality')], assigned[('M', 'Quality')])\n\ndef option_B():\n    # K and L both assigned to Sales Committee\n    return And(assigned[('K', 'Sales')], assigned[('L', 'Sales')])\n\ndef option_C():\n    # K is assigned to exactly two committees\n    k_assignments = [assigned[('K', c)] for c in committees]\n    return Sum([If(k, 1, 0) for k in k_assignments]) == 2\n\ndef option_D():\n    # L is assigned to exactly two committees\n    l_assignments = [assigned[('L', c)] for c in committees]\n    return Sum([If(l, 1, 0) for l in l_assignments]) == 2\n\ndef option_E():\n    # M is assigned to exactly two committees\n    m_assignments = [assigned[('M', c)] for c in committees]\n    return Sum([If(m, 1, 0) for m in m_assignments]) == 2\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\n# Test each option: add the negation of the option and check if the model is still satisfiable.\n# If negation is unsat, then option must be true.\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(Not(opt()))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.\n\nWhich one of the following CANNOT be true?\n\nOptions:\n(A) F is assigned to exactly one committee.\n(B) G is assigned to exactly three committees.\n(C) H is assigned to exactly three committees.\n(D) K is assigned to exactly one committee.\n(E) L is assigned to exactly two committees.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['F', 'G', 'H', 'K', 'L', 'M']\nofficers = ['F', 'G', 'H']\nsupervisors = ['K', 'L', 'M']\ncommittees = ['Policy', 'Quality', 'Sales']\n\n# Create variables: assigned[e][c] = Bool indicating if employee e assigned to committee c\nassigned = {}\nfor e in employees:\n    for c in committees:\n        assigned[(e, c)] = Bool(f'{e}_{c}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each committee has exactly 3 employees\nfor c in committees:\n    committee_employees = [assigned[(e, c)] for e in employees]\n    solver.add(Sum([If(x, 1, 0) for x in committee_employees]) == 3)\n\n# Each employee assigned to at least one committee\nfor e in employees:\n    employee_committees = [assigned[(e, c)] for c in committees]\n    solver.add(Sum([If(x, 1, 0) for x in employee_committees]) >= 1)\n\n# Each committee has at least one officer assigned\nfor c in committees:\n    committee_officers = [assigned[(o, c)] for o in officers]\n    solver.add(Or(committee_officers))\n\n# All three officers assigned to Policy\nfor o in officers:\n    solver.add(assigned[(o, 'Policy')])\n\n# G and L cannot be assigned to the same committee\nfor c in committees:\n    solver.add(Or(Not(assigned[('G', c)]), Not(assigned[('L', c)])))\n\n# K must be assigned to Sales\nsolver.add(assigned[('K', 'Sales')])\n\n# Exactly three employees per committee already added above\n\n# OPTION CHECKING\noptions = {\n    'A': lambda: Sum([If(assigned[('F', c)], 1, 0) for c in committees]) == 1,\n    'B': lambda: Sum([If(assigned[('G', c)], 1, 0) for c in committees]) == 3,\n    'C': lambda: Sum([If(assigned[('H', c)], 1, 0) for c in committees]) == 3,\n    'D': lambda: Sum([If(assigned[('K', c)], 1, 0) for c in committees]) == 1,\n    'E': lambda: Sum([If(assigned[('L', c)], 1, 0) for c in committees]) == 2,\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond())\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.\n\nIf F is assigned to exactly three committees, and G is assigned to exactly two committees, then which one of the following must be true?\n\nOptions:\n(A) G is assigned to the Quality Committee.\n(B) G is assigned to the Sales Committee.\n(C) K is assigned to the Quality Committee.\n(D) L is assigned to the Sales Committee.\n(E) M is assigned to the Quality Committee.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['F', 'G', 'H', 'K', 'L', 'M']\ncommittees = ['Policy', 'Quality', 'Sales']\n\n# Create a dictionary of Bool variables: assigned[(employee, committee)] == True if employee assigned to committee\nassigned = dict()\nfor e in employees:\n    for c in committees:\n        assigned[(e, c)] = Bool(f\"{e}_{c}\")\n\n# Helper function to get list of assigned variables for an employee or committee\ndef assigned_to_employee(e):\n    return [assigned[(e, c)] for c in committees]\n\ndef assigned_to_committee(c):\n    return [assigned[(e, c)] for e in employees]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each committee has exactly 3 employees\nfor c in committees:\n    solver.add(Sum([If(assigned[(e, c)], 1, 0) for e in employees]) == 3)\n\n# Each employee assigned to at least one committee\nfor e in employees:\n    solver.add(Sum([If(assigned[(e, c)], 1, 0) for c in committees]) >= 1)\n\n# Each committee must have at least one officer assigned\nofficers = ['F', 'G', 'H']\nfor c in committees:\n    solver.add(Sum([If(assigned[(o, c)], 1, 0) for o in officers]) >= 1)\n\n# All three officers assigned to Policy Committee\nfor o in officers:\n    solver.add(assigned[(o, 'Policy')])\n\n# G cannot be assigned to the same committee as L\nfor c in committees:\n    solver.add(Or(Not(assigned[('G', c)]), Not(assigned[('L', c)])))\n\n# K must be assigned to Sales Committee\nsolver.add(assigned[('K', 'Sales')])\n\n# F assigned to exactly 3 committees\nsolver.add(Sum([If(assigned[('F', c)], 1, 0) for c in committees]) == 3)\n\n# G assigned to exactly 2 committees\nsolver.add(Sum([If(assigned[('G', c)], 1, 0) for c in committees]) == 2)\n\n# OPTION CHECKING\noptions = [\n    ('A', assigned[('G', 'Quality')]),  # G is assigned to Quality\n    ('B', assigned[('G', 'Sales')]),    # G is assigned to Sales\n    ('C', assigned[('K', 'Quality')]),  # K is assigned to Quality\n    ('D', assigned[('L', 'Sales')]),    # L is assigned to Sales\n    ('E', assigned[('M', 'Quality')]),  # M is assigned to Quality\n]\n\nfor letter, cond in options:\n    solver.push()\n    # Add condition that the option is false (negate the option)\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        # If negation leads to unsat, option must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.\n\nWhich one of the following is a group of three employees who can be assigned together to the Quality Committee?\n\nOptions:\n(A) F, G, and H\n(B) F, G, and K\n(C) G, H, and K\n(D) G, K, and L\n(E) H, L, and M",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['F', 'G', 'H', 'K', 'L', 'M']\ncommittees = ['Policy', 'Quality', 'Sales']\n\n# Create variables: assign[e][c] = Bool indicating if employee e is in committee c\nassign = {}\nfor e in employees:\n    for c in committees:\n        assign[(e, c)] = Bool(f\"{e}_{c}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each committee has exactly 3 employees\nfor c in committees:\n    members = [assign[(e, c)] for e in employees]\n    solver.add(Sum([If(m, 1, 0) for m in members]) == 3)\n\n# Each employee assigned to at least one committee\nfor e in employees:\n    assigned_committees = [assign[(e, c)] for c in committees]\n    solver.add(Or(assigned_committees))\n\n# Each committee has at least one officer assigned\nofficers = ['F', 'G', 'H']\nfor c in committees:\n    officers_in_c = [assign[(o, c)] for o in officers]\n    solver.add(Or(officers_in_c))\n\n# All three officers assigned to Policy committee\nfor o in officers:\n    solver.add(assign[(o, 'Policy')])\n\n# G cannot be assigned to same committee as L\nfor c in committees:\n    solver.add(Or(Not(assign[('G', c)]), Not(assign[('L', c)])))\n\n# K must be assigned to Sales committee\nsolver.add(assign[('K', 'Sales')])\n\n# OPTION CHECKING\noptions = [\n    ['F', 'G', 'H'],\n    ['F', 'G', 'K'],\n    ['G', 'H', 'K'],\n    ['G', 'K', 'L'],\n    ['H', 'L', 'M']\n]\n\nfor i, group in enumerate(options):\n    solver.push()\n    # The group employees assigned to Quality committee\n    for e in employees:\n        if e in group:\n            solver.add(assign[(e, 'Quality')])\n        else:\n            solver.add(Not(assign[(e, 'Quality')]))\n    # Check if satisfiable\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.\n\nIf L is assigned to exactly two committees, which of the following must be true?\n\nOptions:\n(A) F is assigned to the Sales Committee.\n(B) G is assigned to the Sales Committee.\n(C) H is assigned to the Quality Committee.\n(D) K is assigned to the Quality Committee.\n(E) M is assigned to the Quality Committee.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['F', 'G', 'H', 'K', 'L', 'M']\nofficers = ['F', 'G', 'H']\nsupervisors = ['K', 'L', 'M']\ncommittees = ['Policy', 'Quality', 'Sales']\n\n# Create variables: assigned[e][c] = Bool indicating if employee e is assigned to committee c\nassigned = {}\nfor e in employees:\n    for c in committees:\n        assigned[(e, c)] = Bool(f\"{e}_{c}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1. Each committee has exactly 3 employees\nfor c in committees:\n    committee_employees = [assigned[(e, c)] for e in employees]\n    solver.add(Sum([If(x, 1, 0) for x in committee_employees]) == 3)\n\n# 2. Each employee assigned to at least one committee\nfor e in employees:\n    employee_committees = [assigned[(e, c)] for c in committees]\n    solver.add(Or(employee_committees))\n\n# 3. Each committee has at least one officer\nfor c in committees:\n    committee_officers = [assigned[(o, c)] for o in officers]\n    solver.add(Or(committee_officers))\n\n# 4. All three officers assigned to Policy committee\nfor o in officers:\n    solver.add(assigned[(o, 'Policy')])\n\n# 5. G cannot be assigned to the same committee as L\nfor c in committees:\n    solver.add(Or(Not(assigned[('G', c)]), Not(assigned[('L', c)])))\n\n# 6. K must be assigned to Sales committee\nsolver.add(assigned[('K', 'Sales')])\n\n# 7. L is assigned to exactly two committees\nl_assignments = [assigned[('L', c)] for c in committees]\nsolver.add(Sum([If(x, 1, 0) for x in l_assignments]) == 2)\n\n# OPTION CHECKING\noptions = [\n    ('A', assigned[('F', 'Sales')]),\n    ('B', assigned[('G', 'Sales')]),\n    ('C', assigned[('H', 'Quality')]),\n    ('D', assigned[('K', 'Quality')]),\n    ('E', assigned[('M', 'Quality')])\n]\n\nfor letter, cond in options:\n    solver.push()\n    # Add negation of option condition to check if it can be false\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six employees—officers F, G, and H, and supervisors K, L, and M—must be assigned to exactly three committees—Policy, Quality, and Sales—with exactly three employees per committee. Committee assignments must conform to the following conditions: Each committee must have at least one officer assigned to it. Each employee must be assigned to at least one committee. All three officers must be assigned to the Policy Committee. G cannot be assigned to the same committee as L. K must be assigned to the Sales Committee.\n\nWhich one of the following CANNOT be true?\n\nOptions:\n(A) F and G are each assigned to exactly one committee.\n(B) F and H are each assigned to exactly one committee.\n(C) G and H are each assigned to exactly one committee.\n(D) F and M are both assigned to the Sales Committee.\n(E) G and K are both assigned to the Quality Committee.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['F', 'G', 'H', 'K', 'L', 'M']\ncommittees = ['Policy', 'Quality', 'Sales']\n\n# Create assignment variables: assign[e][c] = Bool indicating if employee e is assigned to committee c\nassign = dict()\nfor e in employees:\n    assign[e] = dict()\n    for c in committees:\n        assign[e][c] = Bool(f\"{e}_{c}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each committee must have exactly 3 employees assigned\nfor c in committees:\n    count_c = Sum([If(assign[e][c], 1, 0) for e in employees])\n    solver.add(count_c == 3)\n\n# Each employee must be assigned to at least one committee\nfor e in employees:\n    assigned_somewhere = Or([assign[e][c] for c in committees])\n    solver.add(assigned_somewhere)\n\n# Each committee must have at least one officer assigned\nofficers = ['F', 'G', 'H']\nfor c in committees:\n    has_officer = Or([assign[o][c] for o in officers])\n    solver.add(has_officer)\n\n# All three officers must be assigned to the Policy Committee\nfor o in officers:\n    solver.add(assign[o]['Policy'])\n\n# G cannot be assigned to the same committee as L\nfor c in committees:\n    solver.add(Not(And(assign['G'][c], assign['L'][c])))\n\n# K must be assigned to the Sales Committee\nsolver.add(assign['K']['Sales'])\n\n# OPTION CHECKING\n# Define helper to add option-specific constraints and check satisfiability\n\ndef check_option(option_letter):\n    solver.push()\n    if option_letter == 'A':\n        # (A) F and G are each assigned to exactly one committee.\n        count_F = Sum([If(assign['F'][c], 1, 0) for c in committees])\n        count_G = Sum([If(assign['G'][c], 1, 0) for c in committees])\n        solver.add(count_F == 1)\n        solver.add(count_G == 1)\n    elif option_letter == 'B':\n        # (B) F and H are each assigned to exactly one committee.\n        count_F = Sum([If(assign['F'][c], 1, 0) for c in committees])\n        count_H = Sum([If(assign['H'][c], 1, 0) for c in committees])\n        solver.add(count_F == 1)\n        solver.add(count_H == 1)\n    elif option_letter == 'C':\n        # (C) G and H are each assigned to exactly one committee.\n        count_G = Sum([If(assign['G'][c], 1, 0) for c in committees])\n        count_H = Sum([If(assign['H'][c], 1, 0) for c in committees])\n        solver.add(count_G == 1)\n        solver.add(count_H == 1)\n    elif option_letter == 'D':\n        # (D) F and M are both assigned to the Sales Committee.\n        solver.add(assign['F']['Sales'])\n        solver.add(assign['M']['Sales'])\n    elif option_letter == 'E':\n        # (E) G and K are both assigned to the Quality Committee.\n        solver.add(assign['G']['Quality'])\n        solver.add(assign['K']['Quality'])\n    else:\n        solver.pop()\n        return False\n\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\nfor opt in options:\n    if not check_option(opt):\n        print(f\"'{opt}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\n\nVladimir must eat which one of the following foods?\n\nOptions:\n(A) fish\n(B) hot cakes\n(C) macaroni\n(D) omelet\n(E) poached eggs",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Meals\nmeals = ['breakfast', 'lunch', 'dinner', 'snack']\n\n# Foods per meal\nbreakfast_foods = ['hot cakes', 'poached eggs', 'omelet']\nlunch_foods = ['fish', 'hot cakes', 'macaroni', 'omelet']\ndinner_foods = ['fish', 'hot cakes', 'macaroni', 'omelet']\nsnack_foods = ['fish', 'omelet']\n\n# Map meals to their possible foods\nmeal_foods = {\n    'breakfast': breakfast_foods,\n    'lunch': lunch_foods,\n    'dinner': dinner_foods,\n    'snack': snack_foods\n}\n\n# Create indices for foods per meal for Vladimir and Wendy\n# Vladimir and Wendy variables: Vladimir_meal, Wendy_meal store the index of the food eaten at that meal\nVladimir = {}\nWendy = {}\n\nfor meal in meals:\n    Vladimir[meal] = Int(f'V_{meal}')\n    Wendy[meal] = Int(f'W_{meal}')\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# 1) Domain constraints: each meal's food choice must be valid index for that meal's foods\nfor meal in meals:\n    foods = meal_foods[meal]\n    solver.add(And(Vladimir[meal] >= 0, Vladimir[meal] < len(foods)))\n    solver.add(And(Wendy[meal] >= 0, Wendy[meal] < len(foods)))\n\n# 2) Neither Vladimir nor Wendy eats the same kind of food more than once during the day\n# Vladimir's foods distinct\nsolver.add(Distinct([Vladimir[m] for m in meals]))\n# Wendy's foods distinct\nsolver.add(Distinct([Wendy[m] for m in meals]))\n\n# 3) At no meal does Vladimir eat the same kind of food as Wendy\nfor meal in meals:\n    solver.add(Vladimir[meal] != Wendy[meal])\n\n# 4) Wendy eats omelet for lunch\n# Find index of 'omelet' in lunch_foods\nomelet_index_lunch = lunch_foods.index('omelet')\nsolver.add(Wendy['lunch'] == omelet_index_lunch)\n\n# OPTION CHECKING\n\n# Options:\n# (A) fish\n# (B) hot cakes\n# (C) macaroni\n# (D) omelet\n# (E) poached eggs\n\n# We want to find which food Vladimir must eat (i.e., is forced to eat) at some meal.\n# The question is: Vladimir must eat which one of the following foods?\n# The puzzle does not specify the meal for the answer, so presumably it's about one meal or overall.\n\n# The problem is standard LSAT style: the answer is a single food that Vladimir must eat (somewhere during the day).\n\n# We'll check each option: add constraint Vladimir eats that food at some meal and check if the model is satisfiable\n# However, the question is \"Vladimir must eat which one\" meaning that food must be eaten in all models satisfying constraints.\n\n# So the correct approach is:\n# For each option, check if there exists a model where Vladimir does NOT eat that food at any meal.\n# If such model exists, then Vladimir does NOT have to eat that food.\n# If no such model exists, Vladimir must eat that food.\n\n# Define a helper to check if Vladimir can avoid eating a specific food anywhere.\n\ndef can_vladimir_avoid(food_name):\n    solver.push()\n    # For each meal, Vladimir[meal] != index of food_name in that meal's foods if food_name is available at that meal\n    # If food_name is not available at that meal, no constraint needed for that meal\n    avoid_constraints = []\n    for meal in meals:\n        foods = meal_foods[meal]\n        if food_name in foods:\n            food_index = foods.index(food_name)\n            avoid_constraints.append(Vladimir[meal] != food_index)\n        else:\n            # food not available at this meal, so no constraint needed\n            pass\n    solver.add(And(avoid_constraints))\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\noptions = ['fish', 'hot cakes', 'macaroni', 'omelet', 'poached eggs']\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\n# Vladimir must eat the food if he cannot avoid it\nfor i, food in enumerate(options):\n    if not can_vladimir_avoid(food):\n        print(f\"'{option_letters[i]}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "On Tuesday Vladimir and Wendy each eat exactly four separate meals: breakfast, lunch, dinner, and a snack. The following is all that is known about what they eat during that day: At no meal does Vladimir eat the same kind of food as Wendy. Neither of them eats the same kind of food more than once during the day. For breakfast, each eats exactly one of the following: hot cakes, poached eggs, or omelet. For lunch, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For dinner, each eats exactly one of the following: fish, hot cakes, macaroni, or omelet. For a snack, each eats exactly one of the following: fish or omelet. Wendy eats an omelet for lunch.\n\nIf both Vladimir and Wendy eat macaroni on Tuesday, then which one of the following statements could be true?\n\nOptions:\n(A) Vladimir eats fish for lunch.\n(B) Vladimir eats hot cakes for lunch.\n(C) Vladimir eats macaroni for dinner.\n(D) Wendy eats hot cakes for breakfast.\n(E) Wendy eats hot cakes for dinner.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Meals\nmeals = ['breakfast', 'lunch', 'dinner', 'snack']\n\n# Foods per meal\nfoods_per_meal = {\n    'breakfast': ['hot_cakes', 'poached_eggs', 'omelet'],\n    'lunch': ['fish', 'hot_cakes', 'macaroni', 'omelet'],\n    'dinner': ['fish', 'hot_cakes', 'macaroni', 'omelet'],\n    'snack': ['fish', 'omelet']\n}\n\n# Persons\npersons = ['Vladimir', 'Wendy']\n\n# Map foods to indices for each meal\nfood_indices = dict()\nfor meal in meals:\n    food_indices[meal] = {food: idx for idx, food in enumerate(foods_per_meal[meal])}\n\n# Create Z3 variables for each person and meal\n# Variables represent the index of the food eaten at that meal\nfood_vars = dict()\nfor p in persons:\n    food_vars[p] = dict()\n    for meal in meals:\n        food_vars[p][meal] = Int(f'{p}_{meal}')\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each food variable must be within the valid indices for that meal\nfor p in persons:\n    for meal in meals:\n        solver.add(And(food_vars[p][meal] >= 0, food_vars[p][meal] < len(foods_per_meal[meal])))\n\n# Neither Vladimir nor Wendy eats the same kind of food more than once during the day\n# For each person, the foods eaten at different meals must be distinct\nfor p in persons:\n    solver.add(Distinct([food_vars[p][meal] for meal in meals]))\n\n# At no meal does Vladimir eat the same kind of food as Wendy\nfor meal in meals:\n    solver.add(food_vars['Vladimir'][meal] != food_vars['Wendy'][meal])\n\n# Wendy eats an omelet for lunch\nomelet_index_wendy_lunch = food_indices['lunch']['omelet']\nsolver.add(food_vars['Wendy']['lunch'] == omelet_index_wendy_lunch)\n\n# Additional condition for option checking:\n# Both Vladimir and Wendy eat macaroni on Tuesday\n# We don't know which meal macaroni is eaten by Vladimir and Wendy\n# The problem states \"If both Vladimir and Wendy eat macaroni on Tuesday\"\n# Since macaroni is available only for lunch and dinner, we will encode that Vladimir eats macaroni at some meal,\n# and Wendy eats macaroni at some meal.\n# But Wendy's lunch is omelet, so Wendy cannot eat macaroni for lunch.\n# So Wendy must eat macaroni for dinner (only other meal with macaroni)\n# Vladimir can eat macaroni for lunch or dinner\n\n# macaroni indices for lunch and dinner\nmacaroni_index_lunch = food_indices['lunch']['macaroni']\nmacaroni_index_dinner = food_indices['dinner']['macaroni']\n\n# Wendy macaroni meal must be dinner because lunch is omelet for Wendy\nsolver.add(food_vars['Wendy']['dinner'] == macaroni_index_dinner)\n\n# Vladimir macaroni can be lunch or dinner\n# Vladimir eats macaroni either at lunch or dinner\nvlad_macaroni_lunch = food_vars['Vladimir']['lunch'] == macaroni_index_lunch\nvlad_macaroni_dinner = food_vars['Vladimir']['dinner'] == macaroni_index_dinner\nsolver.add(Or([vlad_macaroni_lunch, vlad_macaroni_dinner]))\n\n# OPTION CHECKING\n\n# Options:\n# (A) Vladimir eats fish for lunch.\n# (B) Vladimir eats hot cakes for lunch.\n# (C) Vladimir eats macaroni for dinner.\n# (D) Wendy eats hot cakes for breakfast.\n# (E) Wendy eats hot cakes for dinner.\n\n# Food indices needed for options\nfish_index_lunch = food_indices['lunch'].get('fish', None)\nhot_cakes_index_lunch = food_indices['lunch'].get('hot_cakes', None)\nmacaroni_index_dinner = food_indices['dinner'].get('macaroni', None)\nhot_cakes_index_breakfast = food_indices['breakfast'].get('hot_cakes', None)\nhot_cakes_index_dinner = food_indices['dinner'].get('hot_cakes', None)\n\noptions = [\n    ('A', food_vars['Vladimir']['lunch'] == fish_index_lunch),\n    ('B', food_vars['Vladimir']['lunch'] == hot_cakes_index_lunch),\n    ('C', food_vars['Vladimir']['dinner'] == macaroni_index_dinner),\n    ('D', food_vars['Wendy']['breakfast'] == hot_cakes_index_breakfast),\n    ('E', food_vars['Wendy']['dinner'] == hot_cakes_index_dinner)\n]\n\nfor letter, condition in options:\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Eight people—Jack, Karen, Laura, Mark, Nick, Owen, Peggy, and Ruth—will be placed on two four-person teams—X and Y—for a relay race that is run in four successive legs: first, second, third, and fourth. The teams race concurrently. Each team member runs exactly one of the legs, one team member per leg, according to the following conditions: Jack is on the same team as Karen. Karen is not on the same team as Nick. Ruth runs an earlier leg of the race than Peggy runs, whether or not they are on the same team as each other. Mark and Nick are both on team Y. Neither Jack nor Mark runs third. Karen and Laura both run second. Owen runs fourth.\n\nWhich one of the following must be true?\n\nOptions:\n(A) If Jack and Owen are assigned to the same team as each other, Jack runs first.\n(B) If Jack and Peggy are assigned to the same team as each other, Jack runs fourth.\n(C) If Jack and Ruth are assigned to the same team as each other, Ruth runs third.\n(D) If Mark and Owen are assigned to the same team as each other, Mark runs fourth.\n(E) If Mark and Ruth are assigned to the same team as each other, Ruth runs third.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Jack', 'Karen', 'Laura', 'Mark', 'Nick', 'Owen', 'Peggy', 'Ruth']\nteams = ['X', 'Y']\nlegs = [1, 2, 3, 4]\n\n# Map people to indices for convenience\np_idx = {p: i for i, p in enumerate(people)}\nt_idx = {t: i for i, t in enumerate(teams)}\n\n# Variables:\n# team[p] = 0 or 1 for team X or Y\nteam = [Int(f'team_{p}') for p in people]\n\n# leg[p] = 1..4 for the leg number\nleg = [Int(f'leg_{p}') for p in people]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Teams must be 0 or 1\nfor p in people:\n    solver.add(Or(team[p_idx[p]] == 0, team[p_idx[p]] == 1))\n\n# Legs must be 1..4\nfor p in people:\n    solver.add(And(leg[p_idx[p]] >= 1, leg[p_idx[p]] <= 4))\n\n# Each team has exactly 4 members\nteamX_count = Sum([If(team[i] == 0, 1, 0) for i in range(len(people))])\nteamY_count = Sum([If(team[i] == 1, 1, 0) for i in range(len(people))])\nsolver.add(teamX_count == 4)\nsolver.add(teamY_count == 4)\n\n# Each team member runs exactly one leg, one per leg, no duplicates on same team\nfor t_val in [0, 1]:\n    # Collect legs for team t_val\n    legs_on_team = [If(team[i] == t_val, leg[i], 0) for i in range(len(people))]\n    # Filter legs on that team (non-zero)\n    legs_filtered = [leg[i] for i in range(len(people)) if team[i] == t_val]  # cannot use Python filter on z3\n    # Instead, add Distinct for legs of those on team t_val\n    # But we must do it with z3 expressions:\n    # So create list of leg[i] where team[i] == t_val\n    # We can do this by:\n    # For each person, create a variable leg_if_on_team or 0 if not on team\n    # Then filter out zeros and add Distinct only on those > 0\n    # But Distinct needs expressions, so we add constraints:\n    # We add Distinct on legs of people on team t_val:\n    # So first build list of legs for people on team t_val:\n    legs_team = [leg[i] for i in range(len(people)) if True]  # all legs\n    # But we need to restrict to those people on team t_val\n    # So use a trick: add constraints that legs of those on team t_val are distinct\n    # Let's collect indices of people on team t_val:\n    indices_on_team = [i for i in range(len(people))]\n    # We add Distinct with conditional constraints:\n    # For each pair i,j with i<j, if both on team t_val then leg[i] != leg[j]\n    for i in range(len(people)):\n        for j in range(i + 1, len(people)):\n            solver.add(Implies(And(team[i] == t_val, team[j] == t_val), leg[i] != leg[j]))\n\n# Jack is on the same team as Karen\nsolver.add(team[p_idx['Jack']] == team[p_idx['Karen']])\n\n# Karen is not on the same team as Nick\nsolver.add(team[p_idx['Karen']] != team[p_idx['Nick']])\n\n# Ruth runs an earlier leg than Peggy (Ruth's leg < Peggy's leg)\nsolver.add(leg[p_idx['Ruth']] < leg[p_idx['Peggy']])\n\n# Mark and Nick are both on team Y (team 1)\nsolver.add(team[p_idx['Mark']] == 1)\nsolver.add(team[p_idx['Nick']] == 1)\n\n# Neither Jack nor Mark runs third\nsolver.add(leg[p_idx['Jack']] != 3)\nsolver.add(leg[p_idx['Mark']] != 3)\n\n# Karen and Laura both run second\nsolver.add(leg[p_idx['Karen']] == 2)\nsolver.add(leg[p_idx['Laura']] == 2)\n\n# Owen runs fourth\nsolver.add(leg[p_idx['Owen']] == 4)\n\n# OPTION CHECKING\n\noptions = [\n    # (A) If Jack and Owen are assigned to the same team as each other, Jack runs first.\n    (team[p_idx['Jack']] == team[p_idx['Owen']], leg[p_idx['Jack']] == 1),\n\n    # (B) If Jack and Peggy are assigned to the same team as each other, Jack runs fourth.\n    (team[p_idx['Jack']] == team[p_idx['Peggy']], leg[p_idx['Jack']] == 4),\n\n    # (C) If Jack and Ruth are assigned to the same team as each other, Ruth runs third.\n    (team[p_idx['Jack']] == team[p_idx['Ruth']], leg[p_idx['Ruth']] == 3),\n\n    # (D) If Mark and Owen are assigned to the same team as each other, Mark runs fourth.\n    (team[p_idx['Mark']] == team[p_idx['Owen']], leg[p_idx['Mark']] == 4),\n\n    # (E) If Mark and Ruth are assigned to the same team as each other, Ruth runs third.\n    (team[p_idx['Mark']] == team[p_idx['Ruth']], leg[p_idx['Ruth']] == 3),\n]\n\ncorrect_option = None\n\nfor i, (cond, consequence) in enumerate(options):\n    solver.push()\n    # Add condition that the if-part is true\n    solver.add(cond)\n    # Add negation of the then-part to check if it can be false\n    solver.add(Not(consequence))\n    if solver.check() == unsat:\n        # If unsat, then the implication must be true in all models\n        correct_option = chr(65 + i)\n        solver.pop()\n        break\n    solver.pop()\n\nprint(f\"'{correct_option}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Eight people—Jack, Karen, Laura, Mark, Nick, Owen, Peggy, and Ruth—will be placed on two four-person teams—X and Y—for a relay race that is run in four successive legs: first, second, third, and fourth. The teams race concurrently. Each team member runs exactly one of the legs, one team member per leg, according to the following conditions: Jack is on the same team as Karen. Karen is not on the same team as Nick. Ruth runs an earlier leg of the race than Peggy runs, whether or not they are on the same team as each other. Mark and Nick are both on team Y. Neither Jack nor Mark runs third. Karen and Laura both run second. Owen runs fourth.\n\nIf Ruth is assigned to team X, which one of the following is a complete and accurate list of the legs that she could run?\n\nOptions:\n(A) first\n(B) second\n(C) first, second\n(D) first, third\n(E) second, third",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Jack', 'Karen', 'Laura', 'Mark', 'Nick', 'Owen', 'Peggy', 'Ruth']\nteams = ['X', 'Y']  # Represent as 0 (X) and 1 (Y)\nlegs = ['first', 'second', 'third', 'fourth']  # Represent as 0,1,2,3\n\n# Create variables for each person: team assignment (0 or 1) and leg assignment (0 to 3)\nteam_vars = {p: Int(f'team_{p}') for p in people}\nleg_vars = {p: Int(f'leg_{p}') for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Teams must be 0 or 1\nfor p in people:\n    solver.add(And(team_vars[p] >= 0, team_vars[p] <= 1))\n\n# Legs must be from 0 to 3\nfor p in people:\n    solver.add(And(leg_vars[p] >= 0, leg_vars[p] <= 3))\n\n# Each team has exactly four people\n# Count number of people on team X (0) and team Y (1)\nteam_x_count = Sum([If(team_vars[p] == 0, 1, 0) for p in people])\nteam_y_count = Sum([If(team_vars[p] == 1, 1, 0) for p in people])\nsolver.add(team_x_count == 4)\nsolver.add(team_y_count == 4)\n\n# Each team member runs exactly one leg, one member per leg\n# For each team, legs assigned must be distinct\n# For team X:\nteam_x_people = [p for p in people]  # list of all people, filter by team in constraints\n# For team Y:\nteam_y_people = [p for p in people]\n\n# To enforce distinct legs per team, we do:\n# For team X: legs of people on team X must be distinct\n# For team Y: legs of people on team Y must be distinct\n\n# Since team assignments are variables, we use conditional distinctness\n# We'll create lists of leg variables for each team filtered by team assignment\n\n# To do this, we create auxiliary variables for legs on each team, and enforce distinctness on those legs\n\n# Collect legs of people on team X\nlegs_team_x = [If(team_vars[p] == 0, leg_vars[p], -1) for p in people]\n# Collect legs of people on team Y\nlegs_team_y = [If(team_vars[p] == 1, leg_vars[p], -1) for p in people]\n\n# We want to ensure legs assigned to team X members are distinct ignoring -1\n# Similarly for team Y\n\n# Define a function to enforce distinctness ignoring -1\ndef distinct_ignore_minus_one(vars_list):\n    # Extract variables that are not -1\n    filtered_vars = []\n    for v in vars_list:\n        # Create a boolean variable indicating if v != -1\n        is_assigned = v != -1\n        filtered_vars.append((v, is_assigned))\n    # We cannot directly do Distinct with conditions, so we enforce pairwise:\n    # For every pair (v1,v2), if both assigned, then v1 != v2\n    constraints = []\n    n = len(filtered_vars)\n    for i in range(n):\n        for j in range(i+1, n):\n            v1, assigned1 = filtered_vars[i]\n            v2, assigned2 = filtered_vars[j]\n            c = Implies(And(assigned1, assigned2), v1 != v2)\n            constraints.append(c)\n    return constraints\n\nsolver.add(distinct_ignore_minus_one(legs_team_x))\nsolver.add(distinct_ignore_minus_one(legs_team_y))\n\n# Additional constraints from the problem:\n\n# 1. Jack is on the same team as Karen.\nsolver.add(team_vars['Jack'] == team_vars['Karen'])\n\n# 2. Karen is not on the same team as Nick.\nsolver.add(team_vars['Karen'] != team_vars['Nick'])\n\n# 3. Ruth runs an earlier leg of the race than Peggy runs, whether or not they are on the same team as each other.\nsolver.add(leg_vars['Ruth'] < leg_vars['Peggy'])\n\n# 4. Mark and Nick are both on team Y.\nsolver.add(team_vars['Mark'] == 1)\nsolver.add(team_vars['Nick'] == 1)\n\n# 5. Neither Jack nor Mark runs third.\nsolver.add(leg_vars['Jack'] != 2)\nsolver.add(leg_vars['Mark'] != 2)\n\n# 6. Karen and Laura both run second.\nsolver.add(leg_vars['Karen'] == 1)\nsolver.add(leg_vars['Laura'] == 1)\n\n# 7. Owen runs fourth.\nsolver.add(leg_vars['Owen'] == 3)\n\n# OPTION CHECKING\n\n# We want to check for the possible legs Ruth can run if Ruth is assigned to team X (team 0)\n# So we add constraint Ruth's team = 0\nsolver.add(team_vars['Ruth'] == 0)\n\n# Now check which legs Ruth can run (0 to 3)\npossible_legs = []\nfor l in range(4):\n    solver.push()\n    solver.add(leg_vars['Ruth'] == l)\n    if solver.check() == sat:\n        possible_legs.append(l)\n    solver.pop()\n\n# Map legs indices to letters for options:\n# Options:\n# (A) first -> leg 0 only\n# (B) second -> leg 1 only\n# (C) first, second -> legs 0 or 1\n# (D) first, third -> legs 0 or 2\n# (E) second, third -> legs 1 or 2\n\n# Check which option matches possible_legs exactly\n\noption_legs = {\n    'A': [0],\n    'B': [1],\n    'C': [0,1],\n    'D': [0,2],\n    'E': [1,2],\n}\n\nfor option, legs_list in option_legs.items():\n    # Check if possible_legs is exactly legs_list (order doesn't matter)\n    if sorted(possible_legs) == sorted(legs_list):\n        print(f\"'{option}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Eight people—Jack, Karen, Laura, Mark, Nick, Owen, Peggy, and Ruth—will be placed on two four-person teams—X and Y—for a relay race that is run in four successive legs: first, second, third, and fourth. The teams race concurrently. Each team member runs exactly one of the legs, one team member per leg, according to the following conditions: Jack is on the same team as Karen. Karen is not on the same team as Nick. Ruth runs an earlier leg of the race than Peggy runs, whether or not they are on the same team as each other. Mark and Nick are both on team Y. Neither Jack nor Mark runs third. Karen and Laura both run second. Owen runs fourth.\n\nIf Owen and Ruth are assigned to the same team as each other, which one of the following must be true?\n\nOptions:\n(A) Mark runs fourth.\n(B) Nick runs first.\n(C) Nick runs fourth.\n(D) Peggy runs first.\n(E) Peggy runs fourth.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Jack', 'Karen', 'Laura', 'Mark', 'Nick', 'Owen', 'Peggy', 'Ruth']\nteams = ['X', 'Y']\nlegs = ['first', 'second', 'third', 'fourth']\n\n# Map teams and legs to indices\nteam_idx = {t: i for i, t in enumerate(teams)}\nleg_idx = {l: i for i, l in enumerate(legs)}\n\n# Create variables for each person: team assignment (0 for X, 1 for Y) and leg (0-3)\nteam = {p: Int(f'team_{p}') for p in people}\nleg = {p: Int(f'leg_{p}') for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person is assigned to a valid team and leg\nfor p in people:\n    solver.add(And(team[p] >= 0, team[p] < len(teams)))\n    solver.add(And(leg[p] >= 0, leg[p] < len(legs)))\n\n# Each team has exactly four members\nfor t in teams:\n    count_team_t = Sum([If(team[p] == team_idx[t], 1, 0) for p in people])\n    solver.add(count_team_t == 4)\n\n# Each team has exactly one person running each leg (legs 0-3)\nfor t in teams:\n    for l in legs:\n        count_team_t_leg_l = Sum([If(And(team[p] == team_idx[t], leg[p] == leg_idx[l]), 1, 0) for p in people])\n        solver.add(count_team_t_leg_l == 1)\n\n# Jack is on the same team as Karen\nsolver.add(team['Jack'] == team['Karen'])\n\n# Karen is not on the same team as Nick\nsolver.add(team['Karen'] != team['Nick'])\n\n# Ruth runs an earlier leg than Peggy (regardless of team)\nsolver.add(leg['Ruth'] < leg['Peggy'])\n\n# Mark and Nick are both on team Y (team index 1)\nsolver.add(team['Mark'] == team_idx['Y'])\nsolver.add(team['Nick'] == team_idx['Y'])\n\n# Neither Jack nor Mark runs third (leg index 2)\nsolver.add(leg['Jack'] != leg_idx['third'])\nsolver.add(leg['Mark'] != leg_idx['third'])\n\n# Karen and Laura both run second (leg index 1)\nsolver.add(leg['Karen'] == leg_idx['second'])\nsolver.add(leg['Laura'] == leg_idx['second'])\n\n# Owen runs fourth (leg index 3)\nsolver.add(leg['Owen'] == leg_idx['fourth'])\n\n# Additional constraints from the problem:\n# One person per leg per team already ensured above\n\n# Condition for the question: Owen and Ruth are on the same team\nsolver.add(team['Owen'] == team['Ruth'])\n\n# OPTION CHECKING\n\n# Define option constraints\noptions = [\n    leg['Mark'] == leg_idx['fourth'],  # A\n    leg['Nick'] == leg_idx['first'],   # B\n    leg['Nick'] == leg_idx['fourth'],  # C\n    leg['Peggy'] == leg_idx['first'],  # D\n    leg['Peggy'] == leg_idx['fourth'], # E\n]\n\nfor i, option_constraint in enumerate(options):\n    solver.push()\n    solver.add(Not(option_constraint))\n    if solver.check() == unsat:\n        # If negation is unsat, option_constraint must be true in all solutions\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Eight people—Jack, Karen, Laura, Mark, Nick, Owen, Peggy, and Ruth—will be placed on two four-person teams—X and Y—for a relay race that is run in four successive legs: first, second, third, and fourth. The teams race concurrently. Each team member runs exactly one of the legs, one team member per leg, according to the following conditions: Jack is on the same team as Karen. Karen is not on the same team as Nick. Ruth runs an earlier leg of the race than Peggy runs, whether or not they are on the same team as each other. Mark and Nick are both on team Y. Neither Jack nor Mark runs third. Karen and Laura both run second. Owen runs fourth.\n\nIf Ruth and Peggy are assigned to the same team as each other, which one of the following must be true?\n\nOptions:\n(A) Jack runs first.\n(B) Mark runs fourth.\n(C) Nick runs third.\n(D) Peggy runs third.\n(E) Ruth runs first.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# People\npeople = ['Jack', 'Karen', 'Laura', 'Mark', 'Nick', 'Owen', 'Peggy', 'Ruth']\nindices = {p: i for i, p in enumerate(people)}\n\n# Teams: 0 = X, 1 = Y\nteams = [Int(p + '_team') for p in people]\n\n# Legs: 0 = first, 1 = second, 2 = third, 3 = fourth\nlegs = [Int(p + '_leg') for p in people]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each team variable is 0 or 1\nfor t in teams:\n    solver.add(Or(t == 0, t == 1))\n\n# Each leg variable is between 0 and 3\nfor l in legs:\n    solver.add(And(l >= 0, l <= 3))\n\n# Each team has exactly four members (4 people assigned team 0, 4 assigned team 1)\nsolver.add(Sum([If(t == 0, 1, 0) for t in teams]) == 4)\nsolver.add(Sum([If(t == 1, 1, 0) for t in teams]) == 4)\n\n# Each team has exactly one runner per leg\n\n# For each team and each leg, exactly one person runs that leg on that team\nfor team_val in [0,1]:\n    for leg_val in range(4):\n        count = Sum([If(And(teams[i] == team_val, legs[i] == leg_val), 1, 0) for i in range(len(people))])\n        solver.add(count == 1)\n\n# Jack is on the same team as Karen\nsolver.add(teams[indices['Jack']] == teams[indices['Karen']])\n\n# Karen is not on the same team as Nick\nsolver.add(teams[indices['Karen']] != teams[indices['Nick']])\n\n# Ruth runs an earlier leg than Peggy runs\nsolver.add(legs[indices['Ruth']] < legs[indices['Peggy']])\n\n# Mark and Nick are both on team Y (team 1)\nsolver.add(teams[indices['Mark']] == 1)\nsolver.add(teams[indices['Nick']] == 1)\n\n# Neither Jack nor Mark runs third (leg 2)\nsolver.add(legs[indices['Jack']] != 2)\nsolver.add(legs[indices['Mark']] != 2)\n\n# Karen and Laura both run second (leg 1)\nsolver.add(legs[indices['Karen']] == 1)\nsolver.add(legs[indices['Laura']] == 1)\n\n# Owen runs fourth (leg 3)\nsolver.add(legs[indices['Owen']] == 3)\n\n# OPTION CHECKING\n\noptions = [\n    ('A', 'Jack runs first'),\n    ('B', 'Mark runs fourth'),\n    ('C', 'Nick runs third'),\n    ('D', 'Peggy runs third'),\n    ('E', 'Ruth runs first')\n]\n\n# We are told: If Ruth and Peggy are assigned to the same team as each other,\n# so add constraint teams[Ruth] == teams[Peggy]\n\nsolver.add(teams[indices['Ruth']] == teams[indices['Peggy']])\n\n# We want to find which option must be true, i.e., the option is true in all models satisfying constraints.\n\n# So for each option, check if negation is satisfiable:\n# If negation is satisfiable, option is not necessarily true.\n# If negation is unsat, option must be true.\n\nfor letter, desc in options:\n    solver.push()\n    # Add negation of option\n    if letter == 'A':\n        # Jack runs first -> negation: Jack does not run first (legs[Jack] != 0)\n        solver.add(legs[indices['Jack']] != 0)\n    elif letter == 'B':\n        # Mark runs fourth -> negation: Mark does not run fourth (legs[Mark] != 3)\n        solver.add(legs[indices['Mark']] != 3)\n    elif letter == 'C':\n        # Nick runs third -> negation: Nick does not run third (legs[Nick] != 2)\n        solver.add(legs[indices['Nick']] != 2)\n    elif letter == 'D':\n        # Peggy runs third -> negation: Peggy does not run third (legs[Peggy] != 2)\n        solver.add(legs[indices['Peggy']] != 2)\n    elif letter == 'E':\n        # Ruth runs first -> negation: Ruth does not run first (legs[Ruth] != 0)\n        solver.add(legs[indices['Ruth']] != 0)\n\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A contractor is scheduling construction of seven decks—F, G, H, J, K, L, and M—during a seven-week period: week 1 through week 7. Because of customers' requirements, exactly one deck must be built each week according to the following conditions: G must be built at some time before K is built. L must be built either immediately before or immediately after M is built. F must be built during week 5. J must be built during week 2 or week 6.\n\nWhich one of the following is an acceptable construction schedule for the decks, in order from the deck built in week 1 to that built in week 7?\n\nOptions:\n(A) G, K, H, M, F, J, L\n(B) H, G, L, M, F, K, J\n(C) H, J, G, F, M, L, K\n(D) H, M, L, G, F, J, K\n(E) K, J, H, G, F, M, L",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndecks = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\nweeks = list(range(1, 8))\n\n# Create Int variables for each deck representing the week it is built\ndeck_week = {d: Int(d) for d in decks}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each deck is assigned to a valid week 1 through 7\nfor d in decks:\n    solver.add(And(deck_week[d] >= 1, deck_week[d] <= 7))\n\n# All decks are built in distinct weeks\nsolver.add(Distinct([deck_week[d] for d in decks]))\n\n# G must be built before K\nsolver.add(deck_week['G'] < deck_week['K'])\n\n# L must be built immediately before or immediately after M\ndiff_LM = Abs(deck_week['L'] - deck_week['M'])\nsolver.add(Or(diff_LM == 1))\n\n# F must be built during week 5\nsolver.add(deck_week['F'] == 5)\n\n# J must be built during week 2 or week 6\nsolver.add(Or(deck_week['J'] == 2, deck_week['J'] == 6))\n\n# OPTION CHECKING\n\noptions = [\n    ['G', 'K', 'H', 'M', 'F', 'J', 'L'],  # A\n    ['H', 'G', 'L', 'M', 'F', 'K', 'J'],  # B\n    ['H', 'J', 'G', 'F', 'M', 'L', 'K'],  # C\n    ['H', 'M', 'L', 'G', 'F', 'J', 'K'],  # D\n    ['K', 'J', 'H', 'G', 'F', 'M', 'L'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that deck d is built in week w according to option\n    # option[0] is deck built in week 1, option[1] in week 2, etc.\n    for w, d in enumerate(option, start=1):\n        solver.add(deck_week[d] == w)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A contractor is scheduling construction of seven decks—F, G, H, J, K, L, and M—during a seven-week period: week 1 through week 7. Because of customers' requirements, exactly one deck must be built each week according to the following conditions: G must be built at some time before K is built. L must be built either immediately before or immediately after M is built. F must be built during week 5. J must be built during week 2 or week 6.\n\nIf G is built at some time after F is built, which one of the following must be true?\n\nOptions:\n(A) G is built during week 7.\n(B) H is built during week 1.\n(C) J is built during week 6.\n(D) L is built during week 3.\n(E) M is built during week 1.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndecks = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\nweeks = range(1, 8)  # Weeks 1 through 7\n\n# Create Z3 Int variables for each deck representing the week it is built\ndeck_week = {d: Int(d) for d in decks}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each deck must be built in a valid week 1-7\nfor d in decks:\n    solver.add(And(deck_week[d] >= 1, deck_week[d] <= 7))\n\n# All decks must be built in different weeks (one deck per week)\nsolver.add(Distinct([deck_week[d] for d in decks]))\n\n# G must be built before K\nsolver.add(deck_week['G'] < deck_week['K'])\n\n# L must be immediately before or immediately after M\ndiff_LM = Abs(deck_week['L'] - deck_week['M'])\nsolver.add(Or(diff_LM == 1))\n\n# F must be built during week 5\nsolver.add(deck_week['F'] == 5)\n\n# J must be built during week 2 or week 6\nsolver.add(Or(deck_week['J'] == 2, deck_week['J'] == 6))\n\n# Additional condition for the question:\n# G is built after F (F is week 5), so G's week > 5\nsolver.add(deck_week['G'] > deck_week['F'])\n\n# OPTION CHECKING\n# Define the options as constraints\noptions = [\n    deck_week['G'] == 7,       # (A) G is built during week 7\n    deck_week['H'] == 1,       # (B) H is built during week 1\n    deck_week['J'] == 6,       # (C) J is built during week 6\n    deck_week['L'] == 3,       # (D) L is built during week 3\n    deck_week['M'] == 1        # (E) M is built during week 1\n]\n\nfor i, option_constraint in enumerate(options):\n    solver.push()\n    solver.add(Not(option_constraint))  # Check if option is NOT necessarily true\n    if solver.check() == unsat:\n        # If the negation is unsat, option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A contractor is scheduling construction of seven decks—F, G, H, J, K, L, and M—during a seven-week period: week 1 through week 7. Because of customers' requirements, exactly one deck must be built each week according to the following conditions: G must be built at some time before K is built. L must be built either immediately before or immediately after M is built. F must be built during week 5. J must be built during week 2 or week 6.\n\nIf G is built during week 4, then there are exactly how many acceptable orders any one of which could be the order in which the seven decks are built?\n\nOptions:\n(A) one\n(B) two\n(C) three\n(D) four\n(E) five",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndecks = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\nweeks = list(range(1, 8))\n\n# Create Z3 Int variables for the week each deck is built\ndeck_week = {d: Int(d) for d in decks}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each deck is scheduled in a week between 1 and 7\nfor d in decks:\n    solver.add(And(deck_week[d] >= 1, deck_week[d] <= 7))\n\n# All decks must be built in distinct weeks\nsolver.add(Distinct([deck_week[d] for d in decks]))\n\n# F must be built during week 5\nsolver.add(deck_week['F'] == 5)\n\n# J must be built during week 2 or week 6\nsolver.add(Or(deck_week['J'] == 2, deck_week['J'] == 6))\n\n# G must be built before K\nsolver.add(deck_week['G'] < deck_week['K'])\n\n# L must be built immediately before or immediately after M\ndiff_LM = Abs(deck_week['L'] - deck_week['M'])\nsolver.add(Or(diff_LM == 1))\n\n# Additional condition for this problem: G is built during week 4\nsolver.add(deck_week['G'] == 4)\n\n# OPTION CHECKING\n# We want to find how many acceptable orders exist under these constraints\n\n# We will enumerate all solutions and count them\n\ndef get_model_solution(m):\n    # Return a tuple of deck weeks in order of decks list\n    return tuple(m[deck_week[d]].as_long() for d in decks)\n\nsolutions = []\nwhile solver.check() == sat:\n    m = solver.model()\n    sol = get_model_solution(m)\n    if sol not in solutions:\n        solutions.append(sol)\n    # Add constraint to exclude this solution in next iteration\n    solver.add(Or([deck_week[d] != m[deck_week[d]] for d in decks]))\n\n# Number of acceptable orders is length of solutions\nnum_solutions = len(solutions)\n\n# Map number of solutions to options\n# Options: (A) 1, (B) 2, (C) 3, (D) 4, (E) 5\noption_map = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E'}\n\n# Print only the letter of the correct answer option\nprint(f\"'{option_map[num_solutions]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of five salespeople—F, G, H, I, and J—will present a different one of a company's products—L, M, N, O, and P—at a convention running from Monday through Wednesday. Exactly two products will be presented on Monday, exactly one on Tuesday, and exactly two on Wednesday. The scheduling of presentations is governed by the following conditions: F cannot present a product on the same day as H. Either I or else J must present product N on Tuesday. G must present a product on the day that product O is presented, whether or not G is the salesperson who presents product O.\n\nWhich one of the following must be true?\n\nOptions:\n(A) If F presents a product on Monday, then G presents product O.\n(B) If I presents a product on Tuesday, then J presents a product on Monday.\n(C) If J presents a product on Tuesday, then G presents a product on Monday.\n(D) If both F and J present products on Monday, then H presents product O.\n(E) If both H and I present products on Wednesday, then product O is presented on Monday.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsalespeople = ['F', 'G', 'H', 'I', 'J']\nproducts = ['L', 'M', 'N', 'O', 'P']\ndays = ['Monday', 'Tuesday', 'Wednesday']\n\n# Map days to indices for clarity\nday_indices = {day: i for i, day in enumerate(days)}\nproduct_indices = {p: i for i, p in enumerate(products)}\nsales_indices = {s: i for i, s in enumerate(salespeople)}\n\n# Variables:\n# Assign day to each salesperson: Int in [0..2] representing Monday, Tuesday, Wednesday\nday_of = {s: Int(f'day_{s}') for s in salespeople}\n# Assign product to each salesperson: Int in [0..4] representing L, M, N, O, P\nproduct_of = {s: Int(f'product_{s}') for s in salespeople}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each salesperson assigned a valid day\nfor s in salespeople:\n    solver.add(And(day_of[s] >= 0, day_of[s] < 3))\n\n# 2) Each salesperson assigned a valid product\nfor s in salespeople:\n    solver.add(And(product_of[s] >= 0, product_of[s] < 5))\n\n# 3) All products are distinct (one per salesperson)\nsolver.add(Distinct([product_of[s] for s in salespeople]))\n\n# 4) Exactly two products presented on Monday, exactly one on Tuesday, exactly two on Wednesday\n# Count number of salespeople assigned to each day\ndef count_day(d):\n    return Sum([If(day_of[s] == d, 1, 0) for s in salespeople])\n\nsolver.add(count_day(day_indices['Monday']) == 2)\nsolver.add(count_day(day_indices['Tuesday']) == 1)\nsolver.add(count_day(day_indices['Wednesday']) == 2)\n\n# 5) F cannot present a product on the same day as H\nsolver.add(day_of['F'] != day_of['H'])\n\n# 6) Either I or else J must present product N on Tuesday\n# product N index\nN_idx = product_indices['N']\nTuesday_idx = day_indices['Tuesday']\n# I or J presents N on Tuesday: (day_of[I] == Tuesday and product_of[I] == N) OR (day_of[J] == Tuesday and product_of[J] == N)\ncond_I_N_Tuesday = And(day_of['I'] == Tuesday_idx, product_of['I'] == N_idx)\ncond_J_N_Tuesday = And(day_of['J'] == Tuesday_idx, product_of['J'] == N_idx)\nsolver.add(Or(cond_I_N_Tuesday, cond_J_N_Tuesday))\n\n# 7) G must present a product on the day that product O is presented,\n# whether or not G is the salesperson who presents product O.\n# product O index\nO_idx = product_indices['O']\n# Find the day that product O is presented: day of the salesperson who presents product O\n# We do not know who presents O, but exactly one salesperson presents it.\n# So we find the day_of for the person who has product O\n# We create a variable day_O_presented for the day product O is presented\nday_O_presented = Int('day_O_presented')\nsolver.add(And(day_O_presented >= 0, day_O_presented < 3))\n\n# Link day_O_presented to the day of the salesperson who presents product O\n# For each salesperson s:\n# If product_of[s] == O_idx then day_of[s] == day_O_presented\n# Exactly one s satisfies product_of[s] == O_idx, so:\nsolver.add(Or([And(product_of[s] == O_idx, day_of[s] == day_O_presented) for s in salespeople]))\n\n# G must present a product on day_O_presented\nsolver.add(day_of['G'] == day_O_presented)\n\n# OPTION CHECKING\noptions = [\n    # (A) If F presents a product on Monday, then G presents product O.\n    # If day_of[F] == Monday then product_of[G] == O_idx\n    lambda: Implies(day_of['F'] == day_indices['Monday'], product_of['G'] == O_idx),\n\n    # (B) If I presents a product on Tuesday, then J presents a product on Monday.\n    # If day_of[I] == Tuesday then day_of[J] == Monday\n    lambda: Implies(day_of['I'] == day_indices['Tuesday'], day_of['J'] == day_indices['Monday']),\n\n    # (C) If J presents a product on Tuesday, then G presents a product on Monday.\n    # If day_of[J] == Tuesday then day_of[G] == Monday\n    lambda: Implies(day_of['J'] == day_indices['Tuesday'], day_of['G'] == day_indices['Monday']),\n\n    # (D) If both F and J present products on Monday, then H presents product O.\n    # If (day_of[F] == Monday and day_of[J] == Monday) then product_of[H] == O_idx\n    lambda: Implies(And(day_of['F'] == day_indices['Monday'], day_of['J'] == day_indices['Monday']), product_of['H'] == O_idx),\n\n    # (E) If both H and I present products on Wednesday, then product O is presented on Monday.\n    # If (day_of[H] == Wednesday and day_of[I] == Wednesday) then day_O_presented == Monday\n    lambda: Implies(And(day_of['H'] == day_indices['Wednesday'], day_of['I'] == day_indices['Wednesday']), day_O_presented == day_indices['Monday']),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add negation of the option to check if it is always true (must be true)\n    solver.add(Not(option()))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of five salespeople—F, G, H, I, and J—will present a different one of a company's products—L, M, N, O, and P—at a convention running from Monday through Wednesday. Exactly two products will be presented on Monday, exactly one on Tuesday, and exactly two on Wednesday. The scheduling of presentations is governed by the following conditions: F cannot present a product on the same day as H. Either I or else J must present product N on Tuesday. G must present a product on the day that product O is presented, whether or not G is the salesperson who presents product O.\n\nIf salespeople H and I present products on Monday, which one of the following must be true?\n\nOptions:\n(A) F presents product M.\n(B) G presents product L.\n(C) I presents product N.\n(D) Product O is presented on Wednesday.\n(E) Product P is presented on Wednesday.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsalespeople = ['F', 'G', 'H', 'I', 'J']\nproducts = ['L', 'M', 'N', 'O', 'P']\ndays = ['Monday', 'Tuesday', 'Wednesday']\n\nnum_salespeople = len(salespeople)\nnum_products = len(products)\nnum_days = len(days)\n\n# Variables:\n# day_of_sp[s] = day index (0=Mon,1=Tue,2=Wed) when salesperson s presents\nday_of_sp = {s: Int(f'day_of_{s}') for s in salespeople}\n\n# product_of_sp[s] = product index (0..4) that s presents\nproduct_of_sp = {s: Int(f'product_of_{s}') for s in salespeople}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each salesperson presents exactly one product and one day\nfor s in salespeople:\n    solver.add(And(day_of_sp[s] >= 0, day_of_sp[s] < num_days))\n    solver.add(And(product_of_sp[s] >= 0, product_of_sp[s] < num_products))\n\n# 2) All products are distinct (each product presented exactly once)\nsolver.add(Distinct([product_of_sp[s] for s in salespeople]))\n\n# 3) Exactly two products on Monday, one on Tuesday, two on Wednesday\n# Count how many salespeople present on each day\nfor d in range(num_days):\n    count_on_day = Sum([If(day_of_sp[s] == d, 1, 0) for s in salespeople])\n    if d == 0:  # Monday\n        solver.add(count_on_day == 2)\n    elif d == 1:  # Tuesday\n        solver.add(count_on_day == 1)\n    else:  # Wednesday\n        solver.add(count_on_day == 2)\n\n# 4) F cannot present on the same day as H\nsolver.add(day_of_sp['F'] != day_of_sp['H'])\n\n# 5) Either I or else J must present product N on Tuesday\n# product N index:\nidx_N = products.index('N')\nidx_O = products.index('O')\n\n# I or J must present product N on Tuesday\ncond_I_N_Tue = And(product_of_sp['I'] == idx_N, day_of_sp['I'] == 1)\ncond_J_N_Tue = And(product_of_sp['J'] == idx_N, day_of_sp['J'] == 1)\nsolver.add(Or(cond_I_N_Tue, cond_J_N_Tue))\n\n# 6) G must present a product on the day that product O is presented,\n# whether or not G presents product O.\n# Find the day product O is presented:\n# Let day_of_O be the day the product O is presented by whoever presents it\n# So day_of_O = day_of_sp[s] where product_of_sp[s] == idx_O\n# We can encode this by:\n# For all s: if product_of_sp[s] == idx_O then day_of_sp[s] == day_of_O\n# But day_of_O is not a variable, so use:\n# For all s: if product_of_sp[s] == idx_O then day_of_sp[s] == day_of_sp_G\n# and day_of_sp_G is day_of_sp['G']\n# So day_of_sp['G'] == day_of_O\n\n# Enforce that day_of_sp['G'] == day_of_O\n# day_of_O is day_of_sp[s] for the s with product_of_sp[s] == idx_O\n# So day_of_sp['G'] == day_of_sp[s] where product_of_sp[s] == idx_O\n# We encode:\n# For all s: If product_of_sp[s] == idx_O then day_of_sp[s] == day_of_sp['G']\n# And there must be exactly one s with product_of_sp[s] == idx_O\n\n# Enforce exactly one s with product_of_sp[s] == idx_O\nsolver.add(Sum([If(product_of_sp[s] == idx_O, 1, 0) for s in salespeople]) == 1)\n\n# For all s:\nfor s in salespeople:\n    solver.add(Implies(product_of_sp[s] == idx_O, day_of_sp[s] == day_of_sp['G']))\n\n# 7) Given: H and I present products on Monday\nsolver.add(day_of_sp['H'] == 0)\nsolver.add(day_of_sp['I'] == 0)\n\n# OPTION CHECKING\noptions = {\n    'A': product_of_sp['F'] == products.index('M'),\n    'B': product_of_sp['G'] == products.index('L'),\n    'C': product_of_sp['I'] == products.index('N'),\n    'D': Or([And(product_of_sp[s] == idx_O, day_of_sp[s] == 2) for s in salespeople]),\n    'E': Or([And(product_of_sp[s] == products.index('P'), day_of_sp[s] == 2) for s in salespeople]),\n}\n\n# For each option, check if it must be true\n# To check if an option must be true, we check if adding its negation is UNSAT\nfor letter, condition in options.items():\n    solver.push()\n    # Add negation of the condition\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        # Condition must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of five salespeople—F, G, H, I, and J—will present a different one of a company's products—L, M, N, O, and P—at a convention running from Monday through Wednesday. Exactly two products will be presented on Monday, exactly one on Tuesday, and exactly two on Wednesday. The scheduling of presentations is governed by the following conditions: F cannot present a product on the same day as H. Either I or else J must present product N on Tuesday. G must present a product on the day that product O is presented, whether or not G is the salesperson who presents product O.\n\nIf G presents product P on Wednesday, then any of the following could be true EXCEPT:\n\nOptions:\n(A) H presents product O.\n(B) I presents product N.\n(C) I presents product O.\n(D) F makes a presentation on Monday.\n(E) F makes a presentation on Wednesday.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsalespeople = ['F', 'G', 'H', 'I', 'J']\nproducts = ['L', 'M', 'N', 'O', 'P']\ndays = ['Monday', 'Tuesday', 'Wednesday']\n\nnum_salespeople = len(salespeople)\nnum_products = len(products)\nnum_days = len(days)\n\n# Map salespeople and products to indices\nsp_idx = {sp: i for i, sp in enumerate(salespeople)}\npr_idx = {pr: i for i, pr in enumerate(products)}\nday_idx = {d: i for i, d in enumerate(days)}\n\n# Variables:\n# salespeople_present_product[sp] = product index presented by sp\nsalespeople_present_product = [Int(f\"sp_pr_{sp}\") for sp in salespeople]\n# salespeople_present_day[sp] = day index of presentation by sp\nsalespeople_present_day = [Int(f\"sp_day_{sp}\") for sp in salespeople]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each salesperson presents exactly one product (values valid)\nfor var in salespeople_present_product:\n    solver.add(And(var >= 0, var < num_products))\n\n# Each salesperson presents on exactly one day (values valid)\nfor var in salespeople_present_day:\n    solver.add(And(var >= 0, var < num_days))\n\n# All products are presented exactly once (distinct products for all salespeople)\nsolver.add(Distinct(salespeople_present_product))\n\n# Exactly two products on Monday, one on Tuesday, two on Wednesday\n# Count how many salespeople present on each day\ncount_monday = Sum([If(salespeople_present_day[i] == day_idx['Monday'], 1, 0) for i in range(num_salespeople)])\ncount_tuesday = Sum([If(salespeople_present_day[i] == day_idx['Tuesday'], 1, 0) for i in range(num_salespeople)])\ncount_wednesday = Sum([If(salespeople_present_day[i] == day_idx['Wednesday'], 1, 0) for i in range(num_salespeople)])\n\nsolver.add(count_monday == 2)\nsolver.add(count_tuesday == 1)\nsolver.add(count_wednesday == 2)\n\n# F cannot present a product on the same day as H\nsolver.add(salespeople_present_day[sp_idx['F']] != salespeople_present_day[sp_idx['H']])\n\n# Either I or else J must present product N on Tuesday\n# Find which salesperson presents N\nN_product = pr_idx['N']\nI_sp = sp_idx['I']\nJ_sp = sp_idx['J']\nN_presenter_conditions = []\n\n# I presents N on Tuesday\ncond_I = And(salespeople_present_product[I_sp] == N_product,\n             salespeople_present_day[I_sp] == day_idx['Tuesday'])\n\n# J presents N on Tuesday\ncond_J = And(salespeople_present_product[J_sp] == N_product,\n             salespeople_present_day[J_sp] == day_idx['Tuesday'])\n\nsolver.add(Or(cond_I, cond_J))\n\n# G must present a product on the day that product O is presented,\n# whether or not G is the salesperson who presents product O.\n\nO_product = pr_idx['O']\nG_sp = sp_idx['G']\n\n# Find day of product O presentation\n# Find day of G presentation\n# Enforce they are equal\n\n# Create variable for day of product O presentation\nO_day = Int('O_day')\nsolver.add(And(O_day >= 0, O_day < num_days))\n\n# Link O_day to the day of the salesperson who presents O\n# For each salesperson i, if salespeople_present_product[i] == O_product then salespeople_present_day[i] == O_day\nfor i in range(num_salespeople):\n    solver.add(Implies(salespeople_present_product[i] == O_product,\n                       salespeople_present_day[i] == O_day))\n\n# G's presentation day equals O_day\nsolver.add(salespeople_present_day[G_sp] == O_day)\n\n# OPTION CHECKING\n\n# We are told: If G presents product P on Wednesday,\n# then any of the following could be true EXCEPT:\n\n# So add the condition that G presents product P on Wednesday\nP_product = pr_idx['P']\nG_presents_P = salespeople_present_product[G_sp] == P_product\nG_on_Wednesday = salespeople_present_day[G_sp] == day_idx['Wednesday']\n\nbase_condition = And(G_presents_P, G_on_Wednesday)\n\noptions = [\n    # (A) H presents product O.\n    And(salespeople_present_product[sp_idx['H']] == O_product),\n    # (B) I presents product N.\n    And(salespeople_present_product[I_sp] == N_product),\n    # (C) I presents product O.\n    And(salespeople_present_product[I_sp] == O_product),\n    # (D) F makes a presentation on Monday.\n    And(salespeople_present_day[sp_idx['F']] == day_idx['Monday']),\n    # (E) F makes a presentation on Wednesday.\n    And(salespeople_present_day[sp_idx['F']] == day_idx['Wednesday']),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add base condition and option condition\n    solver.add(base_condition)\n    solver.add(option)\n    result = solver.check()\n    if result == unsat:\n        # This option cannot be true if G presents P on Wednesday\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of five salespeople—F, G, H, I, and J—will present a different one of a company's products—L, M, N, O, and P—at a convention running from Monday through Wednesday. Exactly two products will be presented on Monday, exactly one on Tuesday, and exactly two on Wednesday. The scheduling of presentations is governed by the following conditions: F cannot present a product on the same day as H. Either I or else J must present product N on Tuesday. G must present a product on the day that product O is presented, whether or not G is the salesperson who presents product O.\n\nIf products M and P are presented on Monday, which one of the following could be true?\n\nOptions:\n(A) G presents product P.\n(B) I presents product O.\n(C) J presents product L.\n(D) F presents a product on Monday.\n(E) G presents a product on Monday.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsalespeople = ['F', 'G', 'H', 'I', 'J']\nproducts = ['L', 'M', 'N', 'O', 'P']\ndays = ['Mon', 'Tue', 'Wed']\n\n# Map entities to indices\nsp_idx = {sp: i for i, sp in enumerate(salespeople)}\nprod_idx = {pr: i for i, pr in enumerate(products)}\nday_idx = {d: i for i, d in enumerate(days)}\n\n# Variables:\n# salesperson_product[s] = product index presented by salesperson s\nsalesperson_product = [Int(f'sp_prod_{s}') for s in salespeople]\n# salesperson_day[s] = day index when salesperson s presents\nsalesperson_day = [Int(f'sp_day_{s}') for s in salespeople]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each salesperson presents exactly one product (0..4)\nfor sp in range(5):\n    solver.add(And(salesperson_product[sp] >= 0, salesperson_product[sp] < 5))\n\n# All products are presented exactly once (distinct products)\nsolver.add(Distinct(salesperson_product))\n\n# Each salesperson presents exactly one day (0..2)\nfor sp in range(5):\n    solver.add(And(salesperson_day[sp] >= 0, salesperson_day[sp] < 3))\n\n# Exactly two products on Monday, one on Tuesday, two on Wednesday\n# Count how many salespeople present on each day\nmon_count = Sum([If(salesperson_day[sp] == day_idx['Mon'], 1, 0) for sp in range(5)])\ntue_count = Sum([If(salesperson_day[sp] == day_idx['Tue'], 1, 0) for sp in range(5)])\nwed_count = Sum([If(salesperson_day[sp] == day_idx['Wed'], 1, 0) for sp in range(5)])\n\nsolver.add(mon_count == 2)\nsolver.add(tue_count == 1)\nsolver.add(wed_count == 2)\n\n# F cannot present on the same day as H\nsolver.add(salesperson_day[sp_idx['F']] != salesperson_day[sp_idx['H']])\n\n# Either I or else J must present product N on Tuesday\n# Find who presents N\n# We create a helper array: is_N[s] = Bool if salesperson s presents N\nis_N = [salesperson_product[sp] == prod_idx['N'] for sp in range(5)]\n# We create a helper array: is_Tue[s] = Bool if salesperson s presents on Tuesday\nis_Tue = [salesperson_day[sp] == day_idx['Tue'] for sp in range(5)]\n\n# Find which salesperson presents N on Tuesday:\n# Exactly one salesperson presents N (already guaranteed by distinct products)\n# So the one that presents N must be either I or J and must be on Tuesday\n# So ( (I presents N) & (I on Tue) ) OR ( (J presents N) & (J on Tue) )\nsolver.add(Or(And(is_N[sp_idx['I']], is_Tue[sp_idx['I']]),\n              And(is_N[sp_idx['J']], is_Tue[sp_idx['J']])))\n\n# G must present a product on the day that product O is presented,\n# whether or not G is the salesperson who presents product O.\n# So the day G presents must be the same as the day the salesperson who presents product O presents.\n# Find who presents product O:\nis_O = [salesperson_product[sp] == prod_idx['O'] for sp in range(5)]\n# The day product O is presented is the day of the salesperson who presents O.\n# We create an Int variable for day_O:\nday_O = Int('day_O')\n# day_O must be one of 0..2\nsolver.add(And(day_O >= 0, day_O < 3))\n# Enforce day_O equals the day of the salesperson who presents O\n# Exactly one salesperson presents O, so:\nfor sp in range(5):\n    solver.add(If(is_O[sp], day_O == salesperson_day[sp], True))\n# G's day equals day_O\nsolver.add(salesperson_day[sp_idx['G']] == day_O)\n\n# Products M and P are presented on Monday\n# So the salespeople presenting M and P must have day == Monday (0)\nfor sp in range(5):\n    solver.add(If(Or(salesperson_product[sp] == prod_idx['M'],\n                     salesperson_product[sp] == prod_idx['P']),\n                  salesperson_day[sp] == day_idx['Mon'],\n                  True))\n\n# OPTION CHECKING\noptions = [\n    # (A) G presents product P.\n    salesperson_product[sp_idx['G']] == prod_idx['P'],\n    # (B) I presents product O.\n    salesperson_product[sp_idx['I']] == prod_idx['O'],\n    # (C) J presents product L.\n    salesperson_product[sp_idx['J']] == prod_idx['L'],\n    # (D) F presents a product on Monday.\n    salesperson_day[sp_idx['F']] == day_idx['Mon'],\n    # (E) G presents a product on Monday.\n    salesperson_day[sp_idx['G']] == day_idx['Mon'],\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.\n\nIf F and G are assigned rooms that have exactly one room between them, which one of the following is the list of department members each of whom could be assigned to the intervening room?\n\nOptions:\n(A) Q, R\n(B) Q, S\n(C) Q, V\n(D) R, W\n(E) S, V",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['F', 'G', 'Q', 'R', 'S', 'V', 'W']\nrooms = [101, 102, 103, 104, 105, 106, 107]\n\n# Create a Z3 Int variable for each member's room assignment\nroom_vars = {m: Int(m) for m in members}\n\nsolver = Solver()\n\n# Each member assigned to a valid room number\nfor m in members:\n    solver.add(And(room_vars[m] >= 101, room_vars[m] <= 107))\n\n# All members assigned to distinct rooms\nsolver.add(Distinct([room_vars[m] for m in members]))\n\n# Professors: F, G\nprofessors = ['F', 'G']\n# Lecturers: Q, R, S\nlecturers = ['Q', 'R', 'S']\n# Instructors: V, W\ninstructors = ['V', 'W']\n\n# Neither professor assigned room 101 or 107\nfor p in professors:\n    solver.add(And(room_vars[p] != 101, room_vars[p] != 107))\n\n# Neither instructor is assigned a room next to a professor's room\n# For each instructor and professor, rooms can't be adjacent\nfor instr in instructors:\n    for prof in professors:\n        diff = Abs(room_vars[instr] - room_vars[prof])\n        solver.add(diff != 1)\n\n# G is not assigned a room next to R's room\nsolver.add(Abs(room_vars['G'] - room_vars['R']) != 1)\n\n# W is not assigned a room next to V's room unless R is also assigned a room next to V's room\n# This means:\n# If W and V are adjacent, then R and V must be adjacent\n# Otherwise no restriction\nadj_WV = Abs(room_vars['W'] - room_vars['V']) == 1\nadj_RV = Abs(room_vars['R'] - room_vars['V']) == 1\nsolver.add(Implies(adj_WV, adj_RV))\n\n# Additional constraint from the question:\n# F and G are assigned rooms that have exactly one room between them\n# i.e. the difference between their rooms is 2 (since rooms are consecutive integers)\ndiff_FG = Abs(room_vars['F'] - room_vars['G'])\nsolver.add(diff_FG == 2)\n\n# We want to find which members could be assigned to the intervening room between F and G\n# The intervening room is the room between F and G, i.e., the room number between their two rooms\n\n# Define the intervening room number as an integer variable\nintervening_room = Int('intervening_room')\n\n# The intervening room is exactly between F and G\n# Since difference is 2, intervening room is min(F,G)+1\n# So intervening_room = If(F < G, F+1, G+1)\nsolver.add(intervening_room == If(room_vars['F'] < room_vars['G'], room_vars['F'] + 1, room_vars['G'] + 1))\n\n# Now, for each option, we check if both members in the option can be assigned to the intervening room\n# Since only one member can be assigned per room, only one member can be assigned to intervening_room\n# So the question is: which members could be assigned to the intervening room?\n# The question asks: which list of members each of whom could be assigned to the intervening room?\n# So for each option, both members must be possible assignments to the intervening room (i.e., there is a solution where the member is assigned to the intervening room)\n\noptions = {\n    'A': ['Q', 'R'],\n    'B': ['Q', 'S'],\n    'C': ['Q', 'V'],\n    'D': ['R', 'W'],\n    'E': ['S', 'V']\n}\n\n# Function to check if a given member can be assigned to the intervening room under all constraints\ndef can_member_be_in_intervening_room(member):\n    solver.push()\n    # Add constraint that member is assigned to intervening_room\n    solver.add(room_vars[member] == intervening_room)\n    # Check satisfiability\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# For each option, check if both members can be assigned to the intervening room (separately)\nfor option_letter, members_list in options.items():\n    first_member = members_list[0]\n    second_member = members_list[1]\n    first_possible = can_member_be_in_intervening_room(first_member)\n    second_possible = can_member_be_in_intervening_room(second_member)\n    if first_possible and second_possible:\n        print(f\"'{option_letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.\n\nWhich one of the following is a possible assignment of rooms for members R, V, and W?\n\nOptions:\n(A) 101: V; 102: W; 103: R\n(B) 101: V; 102: W, 104: R\n(C) 101: V; 103: W; 104: R\n(D) 103: W; 104: V; 106: R\n(E) 105: R; 106: W; 107: V",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['F', 'G', 'Q', 'R', 'S', 'V', 'W']\nrooms = list(range(101, 108))  # Rooms 101 through 107\n\n# Create Int variables for each member representing their assigned room\nroom_vars = {m: Int(m) for m in members}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each member assigned a room within 101 to 107\nfor m in members:\n    solver.add(And(room_vars[m] >= 101, room_vars[m] <= 107))\n\n# All assigned rooms are distinct\nsolver.add(Distinct([room_vars[m] for m in members]))\n\n# Neither professor is assigned room 101 or 107\nfor prof in ['F', 'G']:\n    solver.add(And(room_vars[prof] != 101, room_vars[prof] != 107))\n\n# Neither instructor is assigned a room next to a professor's room\n# Instructors: V, W; Professors: F, G\nfor instr in ['V', 'W']:\n    for prof in ['F', 'G']:\n        diff = Abs(room_vars[instr] - room_vars[prof])\n        solver.add(diff != 1)\n\n# G is not assigned a room next to R's room\nsolver.add(Abs(room_vars['G'] - room_vars['R']) != 1)\n\n# W is not assigned a room next to V's room unless R is also assigned a room next to V's room\n# Express as: If W next to V then R next to V\nw_v_diff = Abs(room_vars['W'] - room_vars['V'])\nr_v_diff = Abs(room_vars['R'] - room_vars['V'])\nsolver.add(Or(w_v_diff != 1, r_v_diff == 1))\n\n# OPTION CHECKING\noptions = {\n    'A': {'R': 103, 'V': 101, 'W': 102},\n    'B': {'R': 104, 'V': 101, 'W': 102},\n    'C': {'R': 104, 'V': 101, 'W': 103},\n    'D': {'R': 106, 'V': 104, 'W': 103},\n    'E': {'R': 105, 'V': 107, 'W': 106},\n}\n\nfor opt_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add constraints for this option's R, V, W assignments\n    solver.add(room_vars['R'] == options[opt_letter]['R'])\n    solver.add(room_vars['V'] == options[opt_letter]['V'])\n    solver.add(room_vars['W'] == options[opt_letter]['W'])\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.\n\nIf R is assigned room 104, which one of the following must be assigned either room 103 or else room 105?\n\nOptions:\n(A) F\n(B) G\n(C) Q\n(D) V\n(E) W",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['F', 'G', 'Q', 'R', 'S', 'V', 'W']\nmember_indices = {m: i for i, m in enumerate(members)}\nrooms = list(range(101, 108))  # Rooms 101 to 107\nroom_indices = {r: i for i, r in enumerate(rooms)}\n\n# Create Z3 Int variables for each member's room index (0-based for rooms 101-107)\nroom_vars = {m: Int(m) for m in members}\n\n# Helper function to get room number from index\ndef room_num(idx):\n    return rooms[idx]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each member assigned a room index from 0 to 6 (corresponding to rooms 101-107)\nfor m in members:\n    solver.add(And(room_vars[m] >= 0, room_vars[m] < 7))\n\n# All members assigned different rooms\nsolver.add(Distinct([room_vars[m] for m in members]))\n\n# Professors and their roles\nprofessors = ['F', 'G']\nlecturers = ['Q', 'R', 'S']\ninstructors = ['V', 'W']\n\n# Neither professor assigned room 101 or 107 (indices 0 or 6)\nfor p in professors:\n    solver.add(And(room_vars[p] != 0, room_vars[p] != 6))\n\n# Neither instructor is assigned a room next to a professor's room.\n# That means for each instructor I and each professor P:\n# abs(room_vars[I] - room_vars[P]) != 1\nfor i in instructors:\n    for p in professors:\n        diff = room_vars[i] - room_vars[p]\n        solver.add(Or(diff != 1, diff != -1))  # This is not correct: should be abs(diff) != 1\n# Fix: use Or(abs(diff) != 1)\nfor i in instructors:\n    for p in professors:\n        diff = room_vars[i] - room_vars[p]\n        solver.add(Abs(diff) != 1)\n\n# G is not assigned a room next to R's room\ndiff_GR = room_vars['G'] - room_vars['R']\nsolver.add(Abs(diff_GR) != 1)\n\n# W is not assigned a room next to V's room unless R is also assigned a room next to V's room.\n# That means:\n# If W next to V then R next to V\n# Or equivalently:\n# If W next to V then R next to V\n# So: (Abs(W - V) == 1) => (Abs(R - V) == 1)\nW_V_diff = room_vars['W'] - room_vars['V']\nR_V_diff = room_vars['R'] - room_vars['V']\nsolver.add(Implies(Abs(W_V_diff) == 1, Abs(R_V_diff) == 1))\n\n# Condition: R is assigned room 104 (room 104 is index 3)\nsolver.add(room_vars['R'] == 3)\n\n# OPTION CHECKING\n# We want to check for each option (A-E) if that member must be assigned either room 103 or 105\n# Rooms 103 and 105 correspond to indices 2 and 4\n\n# For each option, check if it is possible that that member is NOT assigned room 103 or 105\n# If it's impossible, then that member must be assigned room 103 or 105\n\noptions = ['F', 'G', 'Q', 'V', 'W']\nfor i, m in enumerate(options):\n    solver.push()\n    # Add constraint that member m is NOT assigned room 103 or 105\n    solver.add(And(room_vars[m] != 2, room_vars[m] != 4))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.\n\nWhich one of the following CANNOT be assigned room 104?\n\nOptions:\n(A) F\n(B) G\n(C) Q\n(D) S\n(E) V",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['F', 'G', 'Q', 'R', 'S', 'V', 'W']\nroles = {'F': 'professor', 'G': 'professor', 'Q': 'lecturer', 'R': 'lecturer', 'S': 'lecturer', 'V': 'instructor', 'W': 'instructor'}\nrooms = list(range(101, 108))  # 101 to 107 inclusive\n\n# Create Z3 Int variables for each member representing their room number\nroom_vars = {m: Int(m) for m in members}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each member assigned a room in 101..107\nfor m in members:\n    solver.add(And(room_vars[m] >= 101, room_vars[m] <= 107))\n\n# All assigned rooms are distinct\nsolver.add(Distinct([room_vars[m] for m in members]))\n\n# Neither professor assigned room 101 or 107\nfor p in ['F', 'G']:\n    solver.add(room_vars[p] != 101)\n    solver.add(room_vars[p] != 107)\n\n# Helper function: rooms are next to each other if their numbers differ by 1\ndef next_to(x, y):\n    return Or(room_vars[x] == room_vars[y] + 1, room_vars[x] == room_vars[y] - 1)\n\n# Neither instructor is assigned a room next to a professor's room\nfor instr in ['V', 'W']:\n    for prof in ['F', 'G']:\n        solver.add(Not(next_to(instr, prof)))\n\n# G is not assigned a room next to R's room\nsolver.add(Not(next_to('G', 'R')))\n\n# W is not assigned a room next to V's room unless R is also assigned a room next to V's room\nW_V_next = next_to('W', 'V')\nR_V_next = next_to('R', 'V')\nsolver.add(Implies(W_V_next, R_V_next))\n\n# OPTION CHECKING\noptions = ['F', 'G', 'Q', 'S', 'V']\n\nfor i, option_member in enumerate(options):\n    solver.push()\n    # Add constraint that option_member is assigned room 104\n    solver.add(room_vars[option_member] == 104)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.\n\nIf no two faculty members of the same rank are assigned adjacent rooms, which one of the following must be true?\n\nOptions:\n(A) F is assigned either room 103 or else room 104.\n(B) Q is assigned either room 102 or else room 106.\n(C) R is assigned either room 102 or else room 105.\n(D) S is assigned either room 104 or else room 105.\n(E) V is assigned either room 101 or else room 107.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nmembers = ['F', 'G', 'Q', 'R', 'S', 'V', 'W']\nprofessors = ['F', 'G']\nlecturers = ['Q', 'R', 'S']\ninstructors = ['V', 'W']\nrooms = list(range(101, 108))  # 101 to 107 inclusive\n\n# Create Z3 Int variables for each member's room assignment\nroom_vars = {m: Int(m) for m in members}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each member assigned to a room in 101..107\nfor m in members:\n    solver.add(And(room_vars[m] >= 101, room_vars[m] <= 107))\n\n# All rooms assigned are distinct\nsolver.add(Distinct([room_vars[m] for m in members]))\n\n# Neither professor assigned room 101 or 107\nfor p in professors:\n    solver.add(room_vars[p] != 101)\n    solver.add(room_vars[p] != 107)\n\n# No two faculty members of the same rank are assigned adjacent rooms\n# Adjacent rooms differ by 1\ndef no_adjacent_same_rank(rank_list):\n    for i in range(len(rank_list)):\n        for j in range(i+1, len(rank_list)):\n            m1 = rank_list[i]\n            m2 = rank_list[j]\n            diff = Abs(room_vars[m1] - room_vars[m2])\n            solver.add(diff != 1)\n\nno_adjacent_same_rank(professors)\nno_adjacent_same_rank(lecturers)\nno_adjacent_same_rank(instructors)\n\n# Neither instructor is assigned a room next to a professor's room\nfor instr in instructors:\n    for prof in professors:\n        diff = Abs(room_vars[instr] - room_vars[prof])\n        solver.add(diff != 1)\n\n# G is not assigned a room next to R's room\nsolver.add(Abs(room_vars['G'] - room_vars['R']) != 1)\n\n# W is not assigned a room next to V's room unless R is also assigned a room next to V's room.\n# This can be expressed as:\n# If W next to V then R next to V\n# i.e. (|W - V| == 1) => (|R - V| == 1)\nW_V_adj = Abs(room_vars['W'] - room_vars['V']) == 1\nR_V_adj = Abs(room_vars['R'] - room_vars['V']) == 1\nsolver.add(Implies(W_V_adj, R_V_adj))\n\n# OPTION CHECKING\n\noptions = {\n    'A': Or(room_vars['F'] == 103, room_vars['F'] == 104),\n    'B': Or(room_vars['Q'] == 102, room_vars['Q'] == 106),\n    'C': Or(room_vars['R'] == 102, room_vars['R'] == 105),\n    'D': Or(room_vars['S'] == 104, room_vars['S'] == 105),\n    'E': Or(room_vars['V'] == 101, room_vars['V'] == 107),\n}\n\n# We must find which option must be true in all solutions\n# So for each option, check if the negation is satisfiable with the constraints\n# The option that must be true is the one whose negation is unsat\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(Not(options[letter]))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "The seven members of an academic department are each to be assigned a different room as an office. The department members are professors F and G, lecturers Q, R, and S, and instructors V and W. The available rooms are seven consecutive rooms along one side of a straight hallway numbered sequentially 101 through 107. The assignment must conform to the following conditions: Neither instructor is assigned a room next to a professor's room. Neither professor is assigned room 101 and neither professor is assigned room 107. G is not assigned a room next to R's room. W is not assigned a room next to V's room unless R is also assigned a room next to V's room.\n\nIf F and G are not assigned rooms that are next to each other, which one of the following CANNOT be assigned room 107?\n\nOptions:\n(A) W\n(B) V\n(C) S\n(D) R\n(E) Q",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['F', 'G', 'Q', 'R', 'S', 'V', 'W']\nrooms = list(range(101, 108))  # 101 to 107\n\n# Create Z3 Int variables for each member's room assignment\nroom_vars = {m: Int(m) for m in members}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each member assigned a room from 101 to 107\nfor m in members:\n    solver.add(And(room_vars[m] >= 101, room_vars[m] <= 107))\n\n# All members assigned distinct rooms\nsolver.add(Distinct([room_vars[m] for m in members]))\n\n# Neither professor assigned room 101 or 107\nsolver.add(room_vars['F'] != 101)\nsolver.add(room_vars['F'] != 107)\nsolver.add(room_vars['G'] != 101)\nsolver.add(room_vars['G'] != 107)\n\n# Neither instructor assigned room next to a professor's room\n# Professors: F, G; Instructors: V, W\nprofessors = ['F', 'G']\ninstructors = ['V', 'W']\n\nfor i in instructors:\n    for p in professors:\n        diff = Abs(room_vars[i] - room_vars[p])\n        solver.add(diff != 1)\n\n# G is not assigned a room next to R's room\nsolver.add(Abs(room_vars['G'] - room_vars['R']) != 1)\n\n# W is not assigned a room next to V's room unless R is also assigned a room next to V's room\n# This is equivalent to: If W next to V then R next to V\ncond1 = Abs(room_vars['W'] - room_vars['V']) == 1\ncond2 = Abs(room_vars['R'] - room_vars['V']) == 1\nsolver.add(Implies(cond1, cond2))\n\n# F and G are NOT assigned rooms next to each other\nsolver.add(Abs(room_vars['F'] - room_vars['G']) != 1)\n\n# OPTION CHECKING\n# Check which option CANNOT be assigned room 107\n\noptions = ['W', 'V', 'S', 'R', 'Q']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that opt is assigned room 107\n    solver.add(room_vars[opt] == 107)\n    check_result = solver.check()\n    if check_result == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.\n\nWhich one of the following is an acceptable selection of rugs for the exhibition?\n\nOptions:\n(A) one oval silk rug, one oval wool rug, and two rectangular wool rugs\n(B) one oval silk rug, one rectangular wool rug, and two rectangular silk rugs\n(C) two oval wool rugs, one rectangular silk rug, and two rectangular wool rugs\n(D) two oval wool rugs, one rectangular silk rug, and one rectangular wool rug\n(E) two rectangular silk rugs and three rectangular wool rugs",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Rugs categories:\n# Indexing rugs: 0-7\n# 0: Oval Wool 1 (OW1)\n# 1: Oval Wool 2 (OW2)\n# 2: Rectangular Wool 1 (RW1)\n# 3: Rectangular Wool 2 (RW2)\n# 4: Rectangular Wool 3 (RW3)\n# 5: Oval Silk (OS)\n# 6: Rectangular Silk 1 (RS1)\n# 7: Rectangular Silk 2 (RS2)\n\nrugs = ['OW1', 'OW2', 'RW1', 'RW2', 'RW3', 'OS', 'RS1', 'RS2']\n\n# Create a Bool variable for each rug indicating if it is selected\nselected = [Bool(r) for r in rugs]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Total number of rugs selected between 4 and 6 inclusive\ntotal_selected = Sum([If(s, 1, 0) for s in selected])\nsolver.add(total_selected >= 4, total_selected <= 6)\n\n# At least two oval rugs selected\n# Oval rugs indices: 0,1,5\noval_selected = [selected[0], selected[1], selected[5]]\nnum_oval = Sum([If(s, 1, 0) for s in oval_selected])\nsolver.add(num_oval >= 2)\n\n# Number of wool rugs selected between 2 and 3 inclusive\n# Wool rugs indices: 0,1,2,3,4\nwool_selected = [selected[i] for i in [0,1,2,3,4]]\nnum_wool = Sum([If(s, 1, 0) for s in wool_selected])\nsolver.add(num_wool >= 2, num_wool <= 3)\n\n# If oval silk rug selected (index 5), at least one rectangular silk rug selected (indices 6 or 7)\noval_silk_selected = selected[5]\nrect_silk_selected = [selected[6], selected[7]]\nnum_rect_silk = Sum([If(s, 1, 0) for s in rect_silk_selected])\nsolver.add(Implies(oval_silk_selected, num_rect_silk >= 1))\n\n# OPTION CHECKING\n# Define the options as selection lists (Bool values for each rug)\n# Each option is a list of selected rugs by name\n\noptions = {\n    'A': ['OS', 'OW1', 'RW1', 'RW2'],           # one oval silk, one oval wool, two rectangular wool\n    'B': ['OS', 'RW1', 'RS1', 'RS2'],           # one oval silk, one rectangular wool, two rectangular silk\n    'C': ['OW1', 'OW2', 'RS1', 'RW1', 'RW2'],   # two oval wool, one rectangular silk, two rectangular wool\n    'D': ['OW1', 'OW2', 'RS1', 'RW1'],           # two oval wool, one rectangular silk, one rectangular wool\n    'E': ['RS1', 'RS2', 'RW1', 'RW2', 'RW3']    # two rectangular silk, three rectangular wool\n}\n\nfor opt_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add constraints to match exactly the selection in the option\n    option_selection = options[opt_letter]\n    for i, rug in enumerate(rugs):\n        if rug in option_selection:\n            solver.add(selected[i] == True)\n        else:\n            solver.add(selected[i] == False)\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.\n\nIf three wool rugs are selected, then any of the following could be a complete and accurate list of the other rugs selected EXCEPT:\n\nOptions:\n(A) one oval silk rug\n(B) one rectangular silk rug\n(C) two rectangular silk rugs\n(D) one oval silk rug and one rectangular silk rug\n(E) one oval silk rug and two rectangular silk rugs",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Rugs categories:\n# Rugs: 8 rugs total\n# 0: Oval Wool 1\n# 1: Oval Wool 2\n# 2: Rectangular Wool 1\n# 3: Rectangular Wool 2\n# 4: Rectangular Wool 3\n# 5: Oval Silk\n# 6: Rectangular Silk 1\n# 7: Rectangular Silk 2\n\nrugs = list(range(8))\n\n# Create selection variables: 1 if selected, 0 if not\nselected = [Int(f'sel_{i}') for i in rugs]\n\nsolver = Solver()\n\n# Each selected[i] is 0 or 1\nfor var in selected:\n    solver.add(Or(var == 0, var == 1))\n\n# Total selected between 4 and 6\ntotal_selected = Sum(selected)\nsolver.add(total_selected >= 4, total_selected <= 6)\n\n# At least two oval rugs selected: oval rugs are indices 0,1,5\noval_selected = Sum([selected[i] for i in [0,1,5]])\nsolver.add(oval_selected >= 2)\n\n# Wool rugs: indices 0,1,2,3,4\nwool_selected = Sum([selected[i] for i in [0,1,2,3,4]])\nsolver.add(wool_selected >= 2, wool_selected <= 3)\n\n# If oval silk (5) is selected, at least one rectangular silk (6 or 7) must be selected\nrect_silk_selected = Sum([selected[6], selected[7]])\noval_silk_selected = selected[5]\nsolver.add(Implies(oval_silk_selected == 1, rect_silk_selected >= 1))\n\n# We want to check the options for the case when 3 wool rugs are selected.\n# For each option, we add constraints that the \"other rugs selected\" match the option,\n# and check if the selection is possible.\n\n# Helper function to check if a model matches the option for the \"other rugs\"\ndef check_option(option_index):\n    solver.push()\n    # Add constraint: wool_selected == 3\n    solver.add(wool_selected == 3)\n\n    # The \"other rugs selected\" are the non-wool rugs selected.\n    # Non-wool rugs indices: 5 (oval silk), 6 (rectangular silk 1), 7 (rectangular silk 2)\n    # The options specify which of these are selected.\n\n    # First, set non-wool selected count = total_selected - wool_selected\n    non_wool_selected = Sum([selected[i] for i in [5,6,7]])\n    solver.add(non_wool_selected == total_selected - 3)\n\n    # Define each option's non-wool selection:\n    # (A) one oval silk rug\n    # (B) one rectangular silk rug\n    # (C) two rectangular silk rugs\n    # (D) one oval silk rug and one rectangular silk rug\n    # (E) one oval silk rug and two rectangular silk rugs\n\n    # We will encode each option as constraints on selected[5], selected[6], selected[7]\n\n    if option_index == 0:  # A\n        # one oval silk rug selected, no rectangular silk\n        solver.add(selected[5] == 1)\n        solver.add(selected[6] == 0)\n        solver.add(selected[7] == 0)\n    elif option_index == 1:  # B\n        # one rectangular silk rug selected, no oval silk\n        # either selected[6] == 1 and selected[7] == 0\n        # or selected[6] == 0 and selected[7] == 1\n        solver.add(selected[5] == 0)\n        solver.add(Or([And(selected[6] == 1, selected[7] == 0),\n                       And(selected[6] == 0, selected[7] == 1)]))\n    elif option_index == 2:  # C\n        # two rectangular silk rugs selected, no oval silk\n        solver.add(selected[5] == 0)\n        solver.add(selected[6] == 1)\n        solver.add(selected[7] == 1)\n    elif option_index == 3:  # D\n        # one oval silk and one rectangular silk\n        # rectangular silk can be either 6 or 7\n        solver.add(selected[5] == 1)\n        solver.add(selected[6] + selected[7] == 1)\n    else:  # E\n        # one oval silk and two rectangular silk\n        solver.add(selected[5] == 1)\n        solver.add(selected[6] == 1)\n        solver.add(selected[7] == 1)\n\n    # Check if the constraints are satisfiable\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\n# Check each option\noptions = ['A', 'B', 'C', 'D', 'E']\nfor i, opt in enumerate(options):\n    if not check_option(i):\n        print(f\"'{opt}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.\n\nThe rugs selected for the exhibition can include any of the following EXCEPT:\n\nOptions:\n(A) one oval silk rug\n(B) two oval wool rugs\n(C) three oval rugs\n(D) two rectangular wool rugs\n(E) three rectangular wool rugs",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Rugs categories and indices\nrugs = ['OW1', 'OW2', 'RW1', 'RW2', 'RW3', 'OS', 'RS1', 'RS2']\n\n# Create selection variables: 1 if selected, 0 if not\nselected = {r: Int(r) for r in rugs}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each selected variable is 0 or 1\nfor r in rugs:\n    solver.add(Or(selected[r] == 0, selected[r] == 1))\n\n# Total number of selected rugs between 4 and 6\ntotal_selected = Sum([selected[r] for r in rugs])\nsolver.add(And(total_selected >= 4, total_selected <= 6))\n\n# At least two oval rugs selected (OW1, OW2, OS)\noval_rugs = ['OW1', 'OW2', 'OS']\noval_selected = Sum([selected[r] for r in oval_rugs])\nsolver.add(oval_selected >= 2)\n\n# Number of wool rugs selected between 2 and 3\n# Wool rugs: OW1, OW2, RW1, RW2, RW3\nwool_rugs = ['OW1', 'OW2', 'RW1', 'RW2', 'RW3']\nwool_selected = Sum([selected[r] for r in wool_rugs])\nsolver.add(And(wool_selected >= 2, wool_selected <= 3))\n\n# If oval silk rug (OS) selected, at least one rectangular silk rug selected (RS1 or RS2)\nrectangular_silk = ['RS1', 'RS2']\nrect_silk_selected = Sum([selected[r] for r in rectangular_silk])\nsolver.add(Implies(selected['OS'] == 1, rect_silk_selected >= 1))\n\n# OPTION CHECKING\n\n# Define a function to check if an option is possible\ndef check_option(option_constraints):\n    solver.push()\n    for c in option_constraints:\n        solver.add(c)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# (A) one oval silk rug\n# Means OS selected == 1\noption_A = [selected['OS'] == 1]\n\n# (B) two oval wool rugs\n# OW1 + OW2 == 2\noption_B = [selected['OW1'] + selected['OW2'] == 2]\n\n# (C) three oval rugs\n# sum of OW1, OW2, OS == 3\noption_C = [Sum([selected[r] for r in oval_rugs]) == 3]\n\n# (D) two rectangular wool rugs\n# sum of RW1, RW2, RW3 == 2\noption_D = [selected['RW1'] + selected['RW2'] + selected['RW3'] == 2]\n\n# (E) three rectangular wool rugs\n# sum of RW1, RW2, RW3 == 3\noption_E = [selected['RW1'] + selected['RW2'] + selected['RW3'] == 3]\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\n# The question asks which option CANNOT be included, so the option that is UNSAT\n\nfor i, opt in enumerate(options):\n    if not check_option(opt):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.\n\nIf only one silk rug is selected for the exhibition, then the other rugs selected must be a group made up of\n\nOptions:\n(A) one oval rug and two rectangular rugs\n(B) two oval rugs and one rectangular rug\n(C) two oval rugs and two rectangular rugs\n(D) two oval rugs and three rectangular rugs\n(E) three rectangular rugs",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Rugs:\n# 0: Oval Wool 1\n# 1: Oval Wool 2\n# 2: Rectangular Wool 1\n# 3: Rectangular Wool 2\n# 4: Rectangular Wool 3\n# 5: Oval Silk\n# 6: Rectangular Silk 1\n# 7: Rectangular Silk 2\n\nrugs = list(range(8))\n\n# Create a Bool variable for each rug indicating if it is selected\nselected = [Bool(f'selected_{i}') for i in rugs]\n\n# Categories for rugs\n# Oval rugs: 0,1,5\noval_rugs = [0,1,5]\n\n# Rectangular rugs: 2,3,4,6,7\nrectangular_rugs = [2,3,4,6,7]\n\n# Wool rugs: 0,1,2,3,4\nwool_rugs = [0,1,2,3,4]\n\n# Silk rugs: 5,6,7\nsilk_rugs = [5,6,7]\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Total number of rugs selected is at least 4 and at most 6\ntotal_selected = Sum([If(selected[i],1,0) for i in rugs])\nsolver.add(total_selected >= 4)\nsolver.add(total_selected <= 6)\n\n# At least two oval rugs must be selected\noval_selected = Sum([If(selected[i],1,0) for i in oval_rugs])\nsolver.add(oval_selected >= 2)\n\n# Number of wool rugs selected can be neither less than two nor more than three\nwool_selected = Sum([If(selected[i],1,0) for i in wool_rugs])\nsolver.add(wool_selected >= 2)\nsolver.add(wool_selected <= 3)\n\n# If the oval silk rug (5) is selected, at least one rectangular silk rug (6 or 7) must be selected\nrectangular_silk_selected = Sum([If(selected[i],1,0) for i in [6,7]])\noval_silk_selected = selected[5]\nsolver.add(Implies(oval_silk_selected, rectangular_silk_selected >= 1))\n\n# OPTION CHECKING\n\n# We want to find which option can be true if only one silk rug is selected.\n# So add constraint that exactly one silk rug is selected\nsilk_selected = Sum([If(selected[i],1,0) for i in silk_rugs])\nsolver.add(silk_selected == 1)\n\n# The other rugs selected (non-silk) must match the pattern in each option.\n\n# Non-silk rugs are: 0,1,2,3,4\nnon_silk_rugs = [0,1,2,3,4]\n\n# Count selected non-silk oval rugs (0,1)\nnon_silk_oval = [0,1]\nnon_silk_rectangular = [2,3,4]\n\ndef check_option(option_oval_count, option_rectangular_count):\n    solver.push()\n    # Count how many non-silk oval rugs selected\n    count_oval = Sum([If(selected[i],1,0) for i in non_silk_oval])\n    # Count how many non-silk rectangular rugs selected\n    count_rect = Sum([If(selected[i],1,0) for i in non_silk_rectangular])\n    # Add constraints for option\n    solver.add(count_oval == option_oval_count)\n    solver.add(count_rect == option_rectangular_count)\n    # Check satisfiability\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# Options:\n# (A) one oval rug and two rectangular rugs\n# (B) two oval rugs and one rectangular rug\n# (C) two oval rugs and two rectangular rugs\n# (D) two oval rugs and three rectangular rugs\n# (E) three rectangular rugs\n\noptions = [\n    (1,2),\n    (2,1),\n    (2,2),\n    (2,3),\n    (0,3)\n]\n\nfor i, (oval_c, rect_c) in enumerate(options):\n    if check_option(oval_c, rect_c):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.\n\nIf exactly four rugs are selected, then the rugs selected could be\n\nOptions:\n(A) one oval rug and three rectangular wool rugs\n(B) two oval rugs and two rectangular wool rugs\n(C) three oval rugs and one rectangular silk rug\n(D) three oval rugs and one rectangular wool rug\n(E) two rectangular silk rugs and two rectangular wool rugs",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Rugs: 8 rugs in total\n# 0,1: oval wool (OW)\n# 2,3,4: rectangular wool (RW)\n# 5: oval silk (OS)\n# 6,7: rectangular silk (RS)\n\nrugs = ['OW0', 'OW1', 'RW0', 'RW1', 'RW2', 'OS', 'RS0', 'RS1']\n\n# Create Bool variables for each rug: True if selected, False otherwise\nselected = {r: Bool(r) for r in rugs}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly 4 rugs selected\nsolver.add(Sum([If(selected[r], 1, 0) for r in rugs]) == 4)\n\n# At least two oval rugs selected\noval_rugs = ['OW0', 'OW1', 'OS']\nsolver.add(Sum([If(selected[r], 1, 0) for r in oval_rugs]) >= 2)\n\n# Number of wool rugs selected between 2 and 3 inclusive\nwool_rugs = ['OW0', 'OW1', 'RW0', 'RW1', 'RW2']\nnum_wool = Sum([If(selected[r], 1, 0) for r in wool_rugs])\nsolver.add(num_wool >= 2)\nsolver.add(num_wool <= 3)\n\n# If oval silk rug is selected, at least one rectangular silk rug must be selected\noval_silk = selected['OS']\nrect_silk = [selected['RS0'], selected['RS1']]\nrect_silk_selected = Sum([If(r, 1, 0) for r in rect_silk])\nsolver.add(Implies(oval_silk, rect_silk_selected >= 1))\n\n# OPTION CHECKING\n\n# Define options as constraints for selection sets\n\n# Option A: one oval rug and three rectangular wool rugs\n# count oval rugs == 1\n# count rectangular wool rugs == 3\n# total 4 rugs (already enforced)\n# oval rugs: OW0, OW1, OS\n# rectangular wool rugs: RW0, RW1, RW2\ndef optionA():\n    oval_count = Sum([If(selected[r], 1, 0) for r in oval_rugs])\n    rectangular_wool = ['RW0', 'RW1', 'RW2']\n    rect_wool_count = Sum([If(selected[r], 1, 0) for r in rectangular_wool])\n    return And(oval_count == 1, rect_wool_count == 3)\n\n# Option B: two oval rugs and two rectangular wool rugs\ndef optionB():\n    oval_count = Sum([If(selected[r], 1, 0) for r in oval_rugs])\n    rectangular_wool = ['RW0', 'RW1', 'RW2']\n    rect_wool_count = Sum([If(selected[r], 1, 0) for r in rectangular_wool])\n    return And(oval_count == 2, rect_wool_count == 2)\n\n# Option C: three oval rugs and one rectangular silk rug\ndef optionC():\n    oval_count = Sum([If(selected[r], 1, 0) for r in oval_rugs])\n    rectangular_silk = ['RS0', 'RS1']\n    rect_silk_count = Sum([If(selected[r], 1, 0) for r in rectangular_silk])\n    return And(oval_count == 3, rect_silk_count == 1)\n\n# Option D: three oval rugs and one rectangular wool rug\ndef optionD():\n    oval_count = Sum([If(selected[r], 1, 0) for r in oval_rugs])\n    rectangular_wool = ['RW0', 'RW1', 'RW2']\n    rect_wool_count = Sum([If(selected[r], 1, 0) for r in rectangular_wool])\n    return And(oval_count == 3, rect_wool_count == 1)\n\n# Option E: two rectangular silk rugs and two rectangular wool rugs\ndef optionE():\n    rectangular_silk = ['RS0', 'RS1']\n    rect_silk_count = Sum([If(selected[r], 1, 0) for r in rectangular_silk])\n    rectangular_wool = ['RW0', 'RW1', 'RW2']\n    rect_wool_count = Sum([If(selected[r], 1, 0) for r in rectangular_wool])\n    return And(rect_silk_count == 2, rect_wool_count == 2)\n\noptions = [optionA, optionB, optionC, optionD, optionE]\n\nfor i, option_func in enumerate(options):\n    solver.push()\n    solver.add(option_func())\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "The coordinator of an exhibition will select at least four and at most six rugs from a group of eight rugs made up of two oval wool rugs, three rectangular wool rugs, one oval silk rug, and two rectangular silk rugs according to the following conditions: At least two oval rugs must be selected. The number of wool rugs selected can be neither less than two nor more than three. If the oval silk rug is selected, at least one rectangular silk rug must be selected.\n\nIf all three silk rugs are selected, then each of the following could be a complete and accurate list of the other rugs selected EXCEPT:\n\nOptions:\n(A) one oval wool rug\n(B) two oval wool rugs\n(C) one oval wool rug and one rectangular wool rug\n(D) one oval wool rug and two rectangular wool rugs\n(E) two oval wool rugs and one rectangular wool rug",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Rugs indices:\n# 0: Oval Wool 1 (OW1)\n# 1: Oval Wool 2 (OW2)\n# 2: Rectangular Wool 1 (RW1)\n# 3: Rectangular Wool 2 (RW2)\n# 4: Rectangular Wool 3 (RW3)\n# 5: Oval Silk (OS)\n# 6: Rectangular Silk 1 (RS1)\n# 7: Rectangular Silk 2 (RS2)\n\nrugs = ['OW1', 'OW2', 'RW1', 'RW2', 'RW3', 'OS', 'RS1', 'RS2']\nnum_rugs = len(rugs)\n\n# Create Bool variables for each rug: True if selected, False otherwise\nselected = [Bool(r) for r in rugs]\n\n# Helper sets for categories\noval_indices = [0, 1, 5]  # OW1, OW2, OS\nwool_indices = [0, 1, 2, 3, 4]  # OW1, OW2, RW1, RW2, RW3\nsilk_indices = [5, 6, 7]  # OS, RS1, RS2\nrectangular_indices = [2, 3, 4, 6, 7]  # RW1, RW2, RW3, RS1, RS2\nrectangular_silk_indices = [6, 7]  # RS1, RS2\n\n# CONSTRAINTS\nsolver = Solver()\n\n# At least four and at most six rugs selected\ntotal_selected = Sum([If(selected[i], 1, 0) for i in range(num_rugs)])\nsolver.add(total_selected >= 4)\nsolver.add(total_selected <= 6)\n\n# At least two oval rugs selected\noval_selected = Sum([If(selected[i], 1, 0) for i in oval_indices])\nsolver.add(oval_selected >= 2)\n\n# Number of wool rugs selected between 2 and 3\nwool_selected = Sum([If(selected[i], 1, 0) for i in wool_indices])\nsolver.add(wool_selected >= 2)\nsolver.add(wool_selected <= 3)\n\n# If the oval silk rug is selected, at least one rectangular silk rug must be selected\noval_silk_selected = selected[5]\nrect_silk_selected = Sum([If(selected[i], 1, 0) for i in rectangular_silk_indices])\nsolver.add(Implies(oval_silk_selected, rect_silk_selected >= 1))\n\n# Given: All three silk rugs are selected\nsolver.add(selected[5] == True)  # OS\nsolver.add(selected[6] == True)  # RS1\nsolver.add(selected[7] == True)  # RS2\n\n# OPTION CHECKING\n\n# Each option is a possible complete list of the other rugs selected (besides the 3 silk rugs)\n# We test if the option can be true together with all constraints\n\n# Options:\n# (A) one oval wool rug\n# (B) two oval wool rugs\n# (C) one oval wool rug and one rectangular wool rug\n# (D) one oval wool rug and two rectangular wool rugs\n# (E) two oval wool rugs and one rectangular wool rug\n\n# For each option, we add constraints that the selected non-silk rugs correspond exactly to the option's description\n\n# Define helper function to reset non-silk selections and set according to option\ndef test_option(solver, option):\n    # Clear non-silk selections first\n    non_silk_indices = [i for i in range(num_rugs) if i not in silk_indices]\n    for i in non_silk_indices:\n        solver.add(Or(selected[i] == True, selected[i] == False))\n    # Remove previous assumptions about non-silk selections by pushing and popping outside\n    # We'll do push and pop in main loop\n\n    # Count how many non-silk rugs selected\n    non_silk_selected = Sum([If(selected[i], 1, 0) for i in non_silk_indices])\n\n    # The number of non-silk rugs selected must be total selected minus 3 (silk rugs)\n    # total_selected - 3 = number of non-silk selected\n    solver.add(non_silk_selected == total_selected - 3)\n\n    # Count oval wool selected (OW1 and OW2)\n    oval_wool_indices = [0, 1]\n    oval_wool_selected = Sum([If(selected[i], 1, 0) for i in oval_wool_indices])\n\n    # Count rectangular wool selected (RW1, RW2, RW3)\n    rectangular_wool_indices = [2, 3, 4]\n    rectangular_wool_selected = Sum([If(selected[i], 1, 0) for i in rectangular_wool_indices])\n\n    # Apply option constraints:\n    if option == 'A':\n        # one oval wool rug\n        solver.add(oval_wool_selected == 1)\n        solver.add(rectangular_wool_selected == 0)\n    elif option == 'B':\n        # two oval wool rugs\n        solver.add(oval_wool_selected == 2)\n        solver.add(rectangular_wool_selected == 0)\n    elif option == 'C':\n        # one oval wool rug and one rectangular wool rug\n        solver.add(oval_wool_selected == 1)\n        solver.add(rectangular_wool_selected == 1)\n    elif option == 'D':\n        # one oval wool rug and two rectangular wool rugs\n        solver.add(oval_wool_selected == 1)\n        solver.add(rectangular_wool_selected == 2)\n    elif option == 'E':\n        # two oval wool rugs and one rectangular wool rug\n        solver.add(oval_wool_selected == 2)\n        solver.add(rectangular_wool_selected == 1)\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\nfor i, option in enumerate(options):\n    solver.push()\n    test_option(solver, option)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{option}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "During a period of six consecutive days—day 1 through day 6—each of exactly six factories—F, G, H, J, Q, and R—will be inspected. During this period, each of the factories will be inspected exactly once, one factory per day. The schedule for the inspections must conform to the following conditions: F is inspected on either day 1 or day 6. J is inspected on an earlier day than Q is inspected. Q is inspected on the day immediately before R is inspected. If G is inspected on day 3, Q is inspected on day 5.\n\nWhich one of the following could be a list of the factories in the order of their scheduled inspections, from day 1 thought day 6?\n\nOptions:\n(A) F, Q, R, H, J, G\n(B) G, H, J, Q, R, F\n(C) G, J, Q, H, R, F\n(D) G, J, Q, R, F, H\n(E) J, H, G, Q, R, F",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfactories = ['F', 'G', 'H', 'J', 'Q', 'R']\ndays = range(1, 7)\n\n# Create a variable for each factory representing the inspection day\nfactory_days = {f: Int(f) for f in factories}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each factory is inspected exactly once on one of the days 1 through 6\nfor f in factories:\n    solver.add(And(factory_days[f] >= 1, factory_days[f] <= 6))\n\n# All factories inspected on different days\nsolver.add(Distinct([factory_days[f] for f in factories]))\n\n# F is inspected on either day 1 or day 6\nsolver.add(Or(factory_days['F'] == 1, factory_days['F'] == 6))\n\n# J is inspected on an earlier day than Q\nsolver.add(factory_days['J'] < factory_days['Q'])\n\n# Q is inspected on the day immediately before R\nsolver.add(factory_days['Q'] + 1 == factory_days['R'])\n\n# If G is inspected on day 3, Q is inspected on day 5\ng_day_3 = factory_days['G'] == 3\nq_day_5 = factory_days['Q'] == 5\nsolver.add(Implies(g_day_3, q_day_5))\n\n# OPTION CHECKING\noptions = [\n    ['F', 'Q', 'R', 'H', 'J', 'G'],  # A\n    ['G', 'H', 'J', 'Q', 'R', 'F'],  # B\n    ['G', 'J', 'Q', 'H', 'R', 'F'],  # C\n    ['G', 'J', 'Q', 'R', 'F', 'H'],  # D\n    ['J', 'H', 'G', 'Q', 'R', 'F'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this option: factory_days[f] == day index + 1\n    for day_index, factory in enumerate(option):\n        solver.add(factory_days[factory] == day_index + 1)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "During a period of six consecutive days—day 1 through day 6—each of exactly six factories—F, G, H, J, Q, and R—will be inspected. During this period, each of the factories will be inspected exactly once, one factory per day. The schedule for the inspections must conform to the following conditions: F is inspected on either day 1 or day 6. J is inspected on an earlier day than Q is inspected. Q is inspected on the day immediately before R is inspected. If G is inspected on day 3, Q is inspected on day 5.\n\nWhich one of the following must be false?\n\nOptions:\n(A) The inspection of G is scheduled for day 4.\n(B) The inspection of H is scheduled for day 6.\n(C) The inspection of J is scheduled for day 4.\n(D) The inspection of Q is scheduled for day 3.\n(E) The inspection of R is scheduled for day 2.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfactories = ['F', 'G', 'H', 'J', 'Q', 'R']\ndays = range(1, 7)\n\n# Create Int variables for each factory representing the inspection day\ninspection_day = {f: Int(f) for f in factories}\n\nsolver = Solver()\n\n# Each factory is inspected exactly once on a day from 1 to 6\nfor f in factories:\n    solver.add(And(inspection_day[f] >= 1, inspection_day[f] <= 6))\n\n# All inspections occur on different days\nsolver.add(Distinct([inspection_day[f] for f in factories]))\n\n# CONSTRAINTS\n# F is inspected on either day 1 or day 6\nsolver.add(Or(inspection_day['F'] == 1, inspection_day['F'] == 6))\n\n# J is inspected on an earlier day than Q\nsolver.add(inspection_day['J'] < inspection_day['Q'])\n\n# Q is inspected immediately before R\nsolver.add(inspection_day['Q'] + 1 == inspection_day['R'])\n\n# If G is inspected on day 3, then Q is inspected on day 5\n# This is an implication: G on day 3 => Q on day 5\nsolver.add(Implies(inspection_day['G'] == 3, inspection_day['Q'] == 5))\n\n# OPTION CHECKING\n# We test each option by adding the option as a constraint and checking if the model is satisfiable.\n# If satisfiable, the option can be true; if unsatisfiable, the option must be false.\n\noptions = {\n    'A': inspection_day['G'] == 4,\n    'B': inspection_day['H'] == 6,\n    'C': inspection_day['J'] == 4,\n    'D': inspection_day['Q'] == 3,\n    'E': inspection_day['R'] == 2,\n}\n\nfor option_letter, option_constraint in options.items():\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == unsat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "During a period of six consecutive days—day 1 through day 6—each of exactly six factories—F, G, H, J, Q, and R—will be inspected. During this period, each of the factories will be inspected exactly once, one factory per day. The schedule for the inspections must conform to the following conditions: F is inspected on either day 1 or day 6. J is inspected on an earlier day than Q is inspected. Q is inspected on the day immediately before R is inspected. If G is inspected on day 3, Q is inspected on day 5.\n\nThe inspection of which one of the following CANNOT be scheduled for day 5 ?\n\nOptions:\n(A) G\n(B) H\n(C) J\n(D) Q\n(E) R",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfactories = ['F', 'G', 'H', 'J', 'Q', 'R']\ndays = range(1, 7)  # Days 1 to 6\n\n# Create Int variables for each factory representing the day it is inspected\ninspection_day = {f: Int(f) for f in factories}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each factory is inspected exactly once on a day between 1 and 6\nfor f in factories:\n    solver.add(And(inspection_day[f] >= 1, inspection_day[f] <= 6))\n\n# All inspection days are distinct (one factory per day)\nsolver.add(Distinct([inspection_day[f] for f in factories]))\n\n# F is inspected on either day 1 or day 6\nsolver.add(Or(inspection_day['F'] == 1, inspection_day['F'] == 6))\n\n# J is inspected on an earlier day than Q\nsolver.add(inspection_day['J'] < inspection_day['Q'])\n\n# Q is inspected on the day immediately before R\nsolver.add(inspection_day['Q'] + 1 == inspection_day['R'])\n\n# If G is inspected on day 3, then Q is inspected on day 5\n# This is an implication: (G == 3) => (Q == 5)\nsolver.add(Implies(inspection_day['G'] == 3, inspection_day['Q'] == 5))\n\n# OPTION CHECKING\noptions = ['G', 'H', 'J', 'Q', 'R']\n\nfor i, f in enumerate(options):\n    solver.push()\n    # Add constraint that factory f is inspected on day 5\n    solver.add(inspection_day[f] == 5)\n    check_result = solver.check()\n    if check_result == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "During a period of six consecutive days—day 1 through day 6—each of exactly six factories—F, G, H, J, Q, and R—will be inspected. During this period, each of the factories will be inspected exactly once, one factory per day. The schedule for the inspections must conform to the following conditions: F is inspected on either day 1 or day 6. J is inspected on an earlier day than Q is inspected. Q is inspected on the day immediately before R is inspected. If G is inspected on day 3, Q is inspected on day 5.\n\nThe inspection scheduled for day 3 and day 5, respectively, could be those of\n\nOptions:\n(A) G and H\n(B) G and R\n(C) H and G\n(D) R and J\n(E) R and H",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfactories = ['F', 'G', 'H', 'J', 'Q', 'R']\ndays = range(1, 7)  # Days 1 through 6\n\n# Create Z3 Int variables for each factory's inspection day\ninspection_day = {f: Int(f) for f in factories}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each factory is inspected exactly once on one of the six days\nfor f in factories:\n    solver.add(And(inspection_day[f] >= 1, inspection_day[f] <= 6))\n\n# All factories inspected on distinct days\nsolver.add(Distinct([inspection_day[f] for f in factories]))\n\n# F is inspected on day 1 or day 6\nsolver.add(Or(inspection_day['F'] == 1, inspection_day['F'] == 6))\n\n# J is inspected earlier than Q\nsolver.add(inspection_day['J'] < inspection_day['Q'])\n\n# Q is inspected immediately before R\nsolver.add(inspection_day['Q'] + 1 == inspection_day['R'])\n\n# If G is inspected on day 3, then Q is inspected on day 5\n# This is an implication: (G == 3) => (Q == 5)\nsolver.add(Implies(inspection_day['G'] == 3, inspection_day['Q'] == 5))\n\n# OPTION CHECKING\n# Options: each is a tuple (day3_factory, day5_factory)\noptions = [\n    ('G', 'H'),  # A\n    ('G', 'R'),  # B\n    ('H', 'G'),  # C\n    ('R', 'J'),  # D\n    ('R', 'H')   # E\n]\n\nfor i, (day3_f, day5_f) in enumerate(options):\n    solver.push()\n    # Add constraints for the option: day 3 and day 5 inspections\n    solver.add(inspection_day[day3_f] == 3)\n    solver.add(inspection_day[day5_f] == 5)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "During a period of six consecutive days—day 1 through day 6—each of exactly six factories—F, G, H, J, Q, and R—will be inspected. During this period, each of the factories will be inspected exactly once, one factory per day. The schedule for the inspections must conform to the following conditions: F is inspected on either day 1 or day 6. J is inspected on an earlier day than Q is inspected. Q is inspected on the day immediately before R is inspected. If G is inspected on day 3, Q is inspected on day 5.\n\nIf the inspection of R is scheduled for the day immediately before the inspection of F, which one of the following must be true about the schedule?\n\nOptions:\n(A) The inspection of either G or H is scheduled for day 1.\n(B) The inspection of either G or J is scheduled for day 1.\n(C) The inspection of either G or J is scheduled for day 2.\n(D) The inspection of either H or J is scheduled for day 3.\n(E) The inspection of either H or J is scheduled for day 4.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfactories = ['F', 'G', 'H', 'J', 'Q', 'R']\ndays = range(1, 7)\n\n# Create Z3 Int variables for each factory's inspection day\ninspection_day = {}\nfor f in factories:\n    inspection_day[f] = Int(f)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each factory is inspected exactly once on a day from 1 to 6\nfor f in factories:\n    solver.add(And(inspection_day[f] >= 1, inspection_day[f] <= 6))\n# All inspection days are distinct\nsolver.add(Distinct([inspection_day[f] for f in factories]))\n\n# F is inspected on either day 1 or day 6\nsolver.add(Or(inspection_day['F'] == 1, inspection_day['F'] == 6))\n\n# J is inspected on an earlier day than Q\nsolver.add(inspection_day['J'] < inspection_day['Q'])\n\n# Q is inspected the day immediately before R\nsolver.add(inspection_day['Q'] + 1 == inspection_day['R'])\n\n# If G is inspected on day 3, then Q is inspected on day 5\n# This is an implication: (G=3) => (Q=5)\nsolver.add(Implies(inspection_day['G'] == 3, inspection_day['Q'] == 5))\n\n# Additional condition given in the question:\n# The inspection of R is scheduled for the day immediately before the inspection of F\nsolver.add(inspection_day['R'] + 1 == inspection_day['F'])\n\n# OPTION CHECKING\n\noptions = [\n    Or(inspection_day['G'] == 1, inspection_day['H'] == 1),  # A\n    Or(inspection_day['G'] == 1, inspection_day['J'] == 1),  # B\n    Or(inspection_day['G'] == 2, inspection_day['J'] == 2),  # C\n    Or(inspection_day['H'] == 3, inspection_day['J'] == 3),  # D\n    Or(inspection_day['H'] == 4, inspection_day['J'] == 4),  # E\n]\n\n# Check each option: add the negation of the option and see if the problem is unsat\n# If negation of option is unsat, option must be true in all models\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "During a period of six consecutive days—day 1 through day 6—each of exactly six factories—F, G, H, J, Q, and R—will be inspected. During this period, each of the factories will be inspected exactly once, one factory per day. The schedule for the inspections must conform to the following conditions: F is inspected on either day 1 or day 6. J is inspected on an earlier day than Q is inspected. Q is inspected on the day immediately before R is inspected. If G is inspected on day 3, Q is inspected on day 5.\n\nIf the inspection of G is scheduled for the day immediately before the inspection of Q, which one of the following could be true?\n\nOptions:\n(A) The inspection of G is scheduled for day 5.\n(B) The inspection of H is scheduled for day 6.\n(C) The inspection of J is scheduled for day 2.\n(D) The inspection of Q is scheduled for day 4.\n(E) The inspection of R is scheduled for day 3.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfactories = ['F', 'G', 'H', 'J', 'Q', 'R']\ndays = range(1, 7)\n\n# Create a variable for each factory representing the day it is inspected\ninspection_day = {}\nfor f in factories:\n    inspection_day[f] = Int(f)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each factory inspected on a day from 1 to 6\nfor f in factories:\n    solver.add(And(inspection_day[f] >= 1, inspection_day[f] <= 6))\n\n# All inspections occur on different days\nsolver.add(Distinct([inspection_day[f] for f in factories]))\n\n# F is inspected on either day 1 or day 6\nsolver.add(Or(inspection_day['F'] == 1, inspection_day['F'] == 6))\n\n# J is inspected on an earlier day than Q\nsolver.add(inspection_day['J'] < inspection_day['Q'])\n\n# Q is inspected the day immediately before R\nsolver.add(inspection_day['Q'] + 1 == inspection_day['R'])\n\n# If G is inspected on day 3, Q is inspected on day 5\nsolver.add(Implies(inspection_day['G'] == 3, inspection_day['Q'] == 5))\n\n# Additional condition from the question:\n# The inspection of G is scheduled for the day immediately before the inspection of Q\nsolver.add(inspection_day['G'] + 1 == inspection_day['Q'])\n\n# OPTION CHECKING\noptions = {\n    'A': inspection_day['G'] == 5,\n    'B': inspection_day['H'] == 6,\n    'C': inspection_day['J'] == 2,\n    'D': inspection_day['Q'] == 4,\n    'E': inspection_day['R'] == 3\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "In a theater company, four two-day workshops—Lighting, Production, Rehearsals, and Staging—are conducted over the course of five days, Monday through Friday. The workshops are conducted in a manner consistent with the following constraints: The two days on which a given workshop is in session are consecutive. On each of the five days, at least one, but no more than two, of the workshops are in session. The workshops on Production and Rehearsals begin no earlier than the day immediately following the second day of the workshop on Lighting.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Only one workshop is in session on Thursday.\n(B) Only one workshop is in session on Friday.\n(C) The workshop on Rehearsals is in session on Tuesday.\n(D) The workshop on Staging is in session on Thursday.\n(E) The workshops in Rehearsals and Production are both in session on Wednesday.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']\nworkshops = ['Lighting', 'Production', 'Rehearsals', 'Staging']\n\n# Variables: start day (0-based index) for each workshop; since each workshop lasts 2 consecutive days,\n# start day must be in [0..3] (Mon to Thu)\nstart = {w: Int(w) for w in workshops}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each workshop starts on a day from 0 to 3 (Mon to Thu)\nfor w in workshops:\n    solver.add(And(start[w] >= 0, start[w] <= 3))\n\n# On each day, number of workshops in session is at least 1 and at most 2\nfor d in range(5):\n    # For each workshop, check if d is in [start, start+1]\n    in_session = []\n    for w in workshops:\n        in_w = And(start[w] <= d, d <= start[w] + 1)\n        in_session.append(in_w)\n    count_in_session = Sum([If(cond, 1, 0) for cond in in_session])\n    solver.add(And(count_in_session >= 1, count_in_session <= 2))\n\n# The workshops on Production and Rehearsals begin no earlier than the day immediately following\n# the second day of the workshop on Lighting.\n# Lighting days: start[Lighting], start[Lighting]+1\n# Production and Rehearsals start day >= start[Lighting] + 2\nsolver.add(start['Production'] >= start['Lighting'] + 2)\nsolver.add(start['Rehearsals'] >= start['Lighting'] + 2)\n\n# OPTION CHECKING\n\noptions = {\n    'A': 'Only one workshop is in session on Thursday.',\n    'B': 'Only one workshop is in session on Friday.',\n    'C': 'The workshop on Rehearsals is in session on Tuesday.',\n    'D': 'The workshop on Staging is in session on Thursday.',\n    'E': 'The workshops in Rehearsals and Production are both in session on Wednesday.'\n}\n\nfor letter, desc in options.items():\n    solver.push()\n    if letter == 'A':\n        # Only one workshop on Thursday (day 3)\n        d = 3\n        in_session = []\n        for w in workshops:\n            cond = And(start[w] <= d, d <= start[w] + 1)\n            in_session.append(cond)\n        count_on_thu = Sum([If(cond, 1, 0) for cond in in_session])\n        solver.add(count_on_thu == 1)\n    elif letter == 'B':\n        # Only one workshop on Friday (day 4)\n        d = 4\n        in_session = []\n        for w in workshops:\n            cond = And(start[w] <= d, d <= start[w] + 1)\n            in_session.append(cond)\n        count_on_fri = Sum([If(cond, 1, 0) for cond in in_session])\n        solver.add(count_on_fri == 1)\n    elif letter == 'C':\n        # Rehearsals is in session on Tuesday (day 1)\n        d = 1\n        cond = And(start['Rehearsals'] <= d, d <= start['Rehearsals'] + 1)\n        solver.add(cond)\n    elif letter == 'D':\n        # Staging is in session on Thursday (day 3)\n        d = 3\n        cond = And(start['Staging'] <= d, d <= start['Staging'] + 1)\n        solver.add(cond)\n    elif letter == 'E':\n        # Rehearsals and Production both in session on Wednesday (day 2)\n        d = 2\n        cond_reh = And(start['Rehearsals'] <= d, d <= start['Rehearsals'] + 1)\n        cond_prod = And(start['Production'] <= d, d <= start['Production'] + 1)\n        solver.add(And(cond_reh, cond_prod))\n\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "In a theater company, four two-day workshops—Lighting, Production, Rehearsals, and Staging—are conducted over the course of five days, Monday through Friday. The workshops are conducted in a manner consistent with the following constraints: The two days on which a given workshop is in session are consecutive. On each of the five days, at least one, but no more than two, of the workshops are in session. The workshops on Production and Rehearsals begin no earlier than the day immediately following the second day of the workshop on Lighting.\n\nIf the workshop on Production is in session on Wednesday, which one of the following must be true?\n\nOptions:\n(A) The workshop on Lighting is in session on Monday.\n(B) The workshop on Rehearsals is in session on Wednesday.\n(C) The workshop on Staging is in session on Thursday .\n(D) The workshop on Staging is in session on Monday.\n(E) The workshop on Staging is in session on Wednesday.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']\nday_indices = {day: i for i, day in enumerate(days)}\n\nworkshops = ['Lighting', 'Production', 'Rehearsals', 'Staging']\n\n# Each workshop runs for two consecutive days, represented by the start day index (0 to 3)\nstart_day = {w: Int(w) for w in workshops}\n\n# Helper function to get the days a workshop is in session (two consecutive days)\ndef workshop_days(w):\n    s = start_day[w]\n    return [s, s + 1]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each workshop starts on a day 0 to 3 (Monday to Thursday) so that it can run 2 consecutive days\nfor w in workshops:\n    solver.add(And(start_day[w] >= 0, start_day[w] <= 3))\n\n# 2. On each of the five days, at least one but no more than two workshops are in session\nfor d in range(5):\n    in_session = []\n    for w in workshops:\n        s = start_day[w]\n        # Workshop w is in session on day d if d == s or d == s+1\n        in_session.append(Or(d == s, d == s + 1))\n    count_in_session = Sum([If(cond, 1, 0) for cond in in_session])\n    solver.add(And(count_in_session >= 1, count_in_session <= 2))\n\n# 3. The workshops on Production and Rehearsals begin no earlier than the day immediately following the second day of Lighting\n# Lighting runs on days start_day['Lighting'] and start_day['Lighting'] +1\n# So Production and Rehearsals start day >= Lighting start day + 2\nsolver.add(start_day['Production'] >= start_day['Lighting'] + 2)\nsolver.add(start_day['Rehearsals'] >= start_day['Lighting'] + 2)\n\n# OPTION CHECKING\n\n# The question: If Production is in session on Wednesday (day 2)\n# Production runs on start_day['Production'] and start_day['Production'] +1\n# So Wednesday (2) must be either start_day['Production'] or start_day['Production']+1\n# That means start_day['Production'] == 1 or 2\n\n# We test each option by adding the condition that Production is in session on Wednesday\n# and the negation of the option, then check if the model is satisfiable.\n# If unsat, then the option must be true.\n\n# Add condition that Production is in session on Wednesday\nsolver.push()\nproduction_in_wed = Or(start_day['Production'] == 1, start_day['Production'] == 2)\nsolver.add(production_in_wed)\n\noptions = {\n    'A': # The workshop on Lighting is in session on Monday.\n        # Lighting runs on start_day['Lighting'] and start_day['Lighting']+1\n        # Monday is day 0, so either start_day['Lighting'] == 0 or start_day['Lighting'] +1 == 0\n        # Since start_day['Lighting'] >= 0, start_day['Lighting'] +1 == 0 means start_day['Lighting'] == -1 (impossible)\n        # So Lighting must start on day 0 to be in session on Monday\n        start_day['Lighting'] == 0,\n\n    'B': # The workshop on Rehearsals is in session on Wednesday.\n        # Rehearsals runs on start_day['Rehearsals'] and start_day['Rehearsals']+1\n        # Wednesday is day 2\n        Or(start_day['Rehearsals'] == 2, start_day['Rehearsals'] == 1),\n\n    'C': # The workshop on Staging is in session on Thursday.\n        # Thursday is day 3\n        Or(start_day['Staging'] == 3, start_day['Staging'] == 2),\n\n    'D': # The workshop on Staging is in session on Monday.\n        # Monday is day 0\n        Or(start_day['Staging'] == 0, start_day['Staging'] == -1), # -1 invalid, so effectively start_day['Staging'] == 0\n\n    'E': # The workshop on Staging is in session on Wednesday.\n        # Wednesday is day 2\n        Or(start_day['Staging'] == 2, start_day['Staging'] == 1),\n}\n\nfor letter, option_constraint in options.items():\n    solver.push()\n    # Add negation of option constraint to test if option must be true\n    solver.add(Not(option_constraint))\n    if solver.check() == unsat:\n        # If unsat, option must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()\n\nsolver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "In a theater company, four two-day workshops—Lighting, Production, Rehearsals, and Staging—are conducted over the course of five days, Monday through Friday. The workshops are conducted in a manner consistent with the following constraints: The two days on which a given workshop is in session are consecutive. On each of the five days, at least one, but no more than two, of the workshops are in session. The workshops on Production and Rehearsals begin no earlier than the day immediately following the second day of the workshop on Lighting.\n\nIf the workshop on production is the only workshop in session on Friday, which one of the following must be false?\n\nOptions:\n(A) The workshop on Lighting is in session both on Tuesday and on Wednesday.\n(B) The workshop on Rehearsals is in session both on Wednesday and on Thursday.\n(C) The workshop on Staging is in session both on Monday and on Tuesday.\n(D) The workshop on Lighting is in session on the same two days as is the workshop on Staging.\n(E) The workshop on Rehearsals is in session on a day when the workshop on Staging is also in session.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']\nworkshops = ['Lighting', 'Production', 'Rehearsals', 'Staging']\n\n# Each workshop has a start day (0-based index for Monday=0 to Thursday=3, since workshop lasts 2 days)\nstart = {w: Int(w) for w in workshops}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each workshop lasts exactly 2 consecutive days, so start day must be between 0 and 3 inclusive\nfor w in workshops:\n    solver.add(And(start[w] >= 0, start[w] <= 3))\n\n# 2) On each day, at least one and at most two workshops are in session\n# Define for each day which workshops are in session\n# A workshop w is in session on day d if start[w] <= d <= start[w] + 1\nin_session = {}\nfor w in workshops:\n    in_session[w] = [Bool(f\"{w}_{d}\") for d in range(5)]\n    for d in range(5):\n        # in_session if day d is start[w] or start[w]+1\n        cond = Or(start[w] == d, start[w] + 1 == d)\n        solver.add(in_session[w][d] == cond)\n\nfor d in range(5):\n    # Count how many workshops are in session on day d\n    count = Sum([If(in_session[w][d], 1, 0) for w in workshops])\n    solver.add(count >= 1)\n    solver.add(count <= 2)\n\n# 3) The workshops on Production and Rehearsals begin no earlier than the day immediately following the second day of the workshop on Lighting\n# Lighting lasts days start[Lighting], start[Lighting]+1\n# Production and Rehearsals start no earlier than start[Lighting]+2\nlighting_end_plus_one = start['Lighting'] + 2\nsolver.add(start['Production'] >= lighting_end_plus_one)\nsolver.add(start['Rehearsals'] >= lighting_end_plus_one)\n\n# 4) The workshop on Production is the only workshop in session on Friday (day 4)\n# Production is in session on Friday\nsolver.add(in_session['Production'][4] == True)\n# No other workshop is in session on Friday\nfor w in workshops:\n    if w != 'Production':\n        solver.add(in_session[w][4] == False)\n\n# OPTION CHECKING\n\noptions = [\n    # (A) The workshop on Lighting is in session both on Tuesday (1) and on Wednesday (2).\n    And(in_session['Lighting'][1], in_session['Lighting'][2]),\n    # (B) The workshop on Rehearsals is in session both on Wednesday (2) and on Thursday (3).\n    And(in_session['Rehearsals'][2], in_session['Rehearsals'][3]),\n    # (C) The workshop on Staging is in session both on Monday (0) and on Tuesday (1).\n    And(in_session['Staging'][0], in_session['Staging'][1]),\n    # (D) The workshop on Lighting is in session on the same two days as is the workshop on Staging.\n    # Same two days means start[Lighting] == start[Staging]\n    start['Lighting'] == start['Staging'],\n    # (E) The workshop on Rehearsals is in session on a day when the workshop on Staging is also in session.\n    # There exists a day d where both rehearsals and staging are in session\n    Or([And(in_session['Rehearsals'][d], in_session['Staging'][d]) for d in range(5)])\n]\n\n# We want to find which option MUST be FALSE.\n# So we check for each option if it can be TRUE given all constraints.\n# The one that cannot be TRUE is the answer.\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        # Option can be true, so it is not necessarily false\n        solver.pop()\n    else:\n        # Option cannot be true, so it must be false\n        solver.pop()\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "In a theater company, four two-day workshops—Lighting, Production, Rehearsals, and Staging—are conducted over the course of five days, Monday through Friday. The workshops are conducted in a manner consistent with the following constraints: The two days on which a given workshop is in session are consecutive. On each of the five days, at least one, but no more than two, of the workshops are in session. The workshops on Production and Rehearsals begin no earlier than the day immediately following the second day of the workshop on Lighting.\n\nIf the workshop on Lighting is the only workshop in session on Monday, which one of the following could be true?\n\nOptions:\n(A) The workshops on Rehearsals and Staging are both in session on Tuesday.\n(B) The workshop on Rehearsals is the only workshop in session on Wednesday.\n(C) The workshop on Staging is the only workshop in session on Wednesday.\n(D) The workshops on Staging and Rehearsals are both in session on Wednesday and on Thursday.\n(E) The workshops on Staging and Production are both in session on Thursday.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']\nworkshops = ['Lighting', 'Production', 'Rehearsals', 'Staging']\n\n# Create variables: start day for each workshop (0-based index for Monday=0)\nstart = {w: Int(w) for w in workshops}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each workshop lasts 2 consecutive days, so start day must be 0..3 (since day+1 must be <=4)\nfor w in workshops:\n    solver.add(And(start[w] >= 0, start[w] <= 3))\n\n# On each day, count how many workshops are in session (day in [start[w], start[w]+1])\n# For each day, number of workshops in session >=1 and <=2\nfor d in range(5):\n    in_session = []\n    for w in workshops:\n        in_session.append(And(start[w] <= d, d <= start[w] + 1))\n    count = Sum([If(cond, 1, 0) for cond in in_session])\n    solver.add(And(count >= 1, count <= 2))\n\n# The workshops on Production and Rehearsals begin no earlier than the day immediately following the second day of Lighting\n# Lighting days: start['Lighting'], start['Lighting']+1\n# Production and Rehearsals start >= start['Lighting'] + 2\nsolver.add(start['Production'] >= start['Lighting'] + 2)\nsolver.add(start['Rehearsals'] >= start['Lighting'] + 2)\n\n# The workshop on Lighting is the only workshop in session on Monday (day 0)\n# So on day 0, only Lighting is in session\n# So Lighting must be in session on day 0: start['Lighting'] <= 0 <= start['Lighting'] + 1\nsolver.add(And(start['Lighting'] <= 0, 0 <= start['Lighting'] + 1))\n# For other workshops, day 0 is not in their session days\nfor w in workshops:\n    if w != 'Lighting':\n        solver.add(Or(start[w] > 0, start[w] + 1 < 0))  # day 0 not in their session\n\n# OPTION CHECKING\n\n# Define helper function to check if a workshop is in session on a given day\ndef in_session_on_day(w, d):\n    return And(start[w] <= d, d <= start[w] + 1)\n\noptions = [\n    # (A) The workshops on Rehearsals and Staging are both in session on Tuesday.\n    And(in_session_on_day('Rehearsals', 1), in_session_on_day('Staging', 1)),\n    # (B) The workshop on Rehearsals is the only workshop in session on Wednesday.\n    And(in_session_on_day('Rehearsals', 2),\n        # No other workshop on Wed\n        Not(in_session_on_day('Lighting', 2)),\n        Not(in_session_on_day('Production', 2)),\n        Not(in_session_on_day('Staging', 2))),\n    # (C) The workshop on Staging is the only workshop in session on Wednesday.\n    And(in_session_on_day('Staging', 2),\n        Not(in_session_on_day('Lighting', 2)),\n        Not(in_session_on_day('Production', 2)),\n        Not(in_session_on_day('Rehearsals', 2))),\n    # (D) The workshops on Staging and Rehearsals are both in session on Wednesday and on Thursday.\n    And(in_session_on_day('Staging', 2), in_session_on_day('Rehearsals', 2),\n        in_session_on_day('Staging', 3), in_session_on_day('Rehearsals', 3)),\n    # (E) The workshops on Staging and Production are both in session on Thursday.\n    And(in_session_on_day('Staging', 3), in_session_on_day('Production', 3))\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.\n\nWhich one of the following is an acceptable assignment of people to boat I ?\n\nOptions:\n(A) F, G, H, X\n(B) F, H, W, Y\n(C) F, H, Y, Z\n(D) F, V, W, X\n(E) G, H, X, Y",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['F', 'G', 'H', 'V', 'W', 'X', 'Y', 'Z']\nadults = ['F', 'G', 'H']\nchildren = ['V', 'W', 'X', 'Y', 'Z']\nboats = [1, 2]\n\n# Create a dictionary of Int variables representing the boat assignment for each person\n# 1 means assigned to boat 1, 2 means assigned to boat 2\nassign = {p: Int(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person must be assigned to either boat 1 or boat 2\nfor p in people:\n    solver.add(Or(assign[p] == 1, assign[p] == 2))\n\n# Each boat has exactly four people\n# Count how many are assigned to boat 1 and boat 2\nboat1_count = Sum([If(assign[p] == 1, 1, 0) for p in people])\nboat2_count = Sum([If(assign[p] == 2, 1, 0) for p in people])\nsolver.add(boat1_count == 4)\nsolver.add(boat2_count == 4)\n\n# Each boat has at least one adult\nboat1_adult_count = Sum([If(And(assign[a] == 1, a in adults), 1, 0) for a in adults])\nboat2_adult_count = Sum([If(And(assign[a] == 2, a in adults), 1, 0) for a in adults])\nsolver.add(boat1_adult_count >= 1)\nsolver.add(boat2_adult_count >= 1)\n\n# If F is assigned to boat 2, G is assigned to boat 2\nsolver.add(Implies(assign['F'] == 2, assign['G'] == 2))\n\n# If V is assigned to boat 1, W is assigned to boat 2\nsolver.add(Implies(assign['V'] == 1, assign['W'] == 2))\n\n# X and Z are assigned to different boats\nsolver.add(assign['X'] != assign['Z'])\n\n# OPTION CHECKING\noptions = {\n    'A': ['F', 'G', 'H', 'X'],\n    'B': ['F', 'H', 'W', 'Y'],\n    'C': ['F', 'H', 'Y', 'Z'],\n    'D': ['F', 'V', 'W', 'X'],\n    'E': ['G', 'H', 'X', 'Y']\n}\n\nfor opt, boat1_people in options.items():\n    solver.push()\n    # Add constraints that these people are assigned to boat 1\n    for p in people:\n        if p in boat1_people:\n            solver.add(assign[p] == 1)\n        else:\n            solver.add(assign[p] == 2)\n    if solver.check() == sat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.\n\nIf F is assigned to boat 2, which one of the following is a pair of people who could be assigned to the same boat as each other?\n\nOptions:\n(A) F and Y\n(B) G and H\n(C) G and Y\n(D) V and W\n(E) Y and Z",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['F', 'G', 'H', 'V', 'W', 'X', 'Y', 'Z']\nadults = ['F', 'G', 'H']\nchildren = ['V', 'W', 'X', 'Y', 'Z']\n\n# Create Z3 Int variables for boat assignments: 1 or 2\nboat = {p: Int(p) for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person assigned to boat 1 or boat 2\nfor p in people:\n    solver.add(Or(boat[p] == 1, boat[p] == 2))\n\n# Each boat has exactly 4 people\nsolver.add(Sum([If(boat[p] == 1, 1, 0) for p in people]) == 4)\nsolver.add(Sum([If(boat[p] == 2, 1, 0) for p in people]) == 4)\n\n# Each boat has at least one adult\nsolver.add(Sum([If(And(boat[p] == 1, p in adults), 1, 0) for p in people]) >= 1)\nsolver.add(Sum([If(And(boat[p] == 2, p in adults), 1, 0) for p in people]) >= 1)\n\n# If F is assigned to boat 2, G is assigned to boat 2\nsolver.add(Implies(boat['F'] == 2, boat['G'] == 2))\n\n# If V is assigned to boat 1, W is assigned to boat 2\nsolver.add(Implies(boat['V'] == 1, boat['W'] == 2))\n\n# X and Z are assigned to different boats\nsolver.add(boat['X'] != boat['Z'])\n\n# OPTION CHECKING\n\n# Given condition: F is assigned to boat 2\nsolver.add(boat['F'] == 2)\n\noptions = {\n    'A': ('F', 'Y'),\n    'B': ('G', 'H'),\n    'C': ('G', 'Y'),\n    'D': ('V', 'W'),\n    'E': ('Y', 'Z')\n}\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    p1, p2 = options[opt]\n    # Add constraint that p1 and p2 are on the same boat\n    solver.add(boat[p1] == boat[p2])\n    if solver.check() == sat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.\n\nIf exactly three children are assigned to boat 1, which one of the following is a pair of people who could both be assigned to boat 2?\n\nOptions:\n(A) F and H\n(B) G and Y\n(C) H and W\n(D) V and W\n(E) W and Y",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['F', 'G', 'H', 'V', 'W', 'X', 'Y', 'Z']\nadults = ['F', 'G', 'H']\nchildren = ['V', 'W', 'X', 'Y', 'Z']\n\n# Assign each person to a boat: 1 or 2\nassignment = {p: Int(p) for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person assigned to boat 1 or boat 2\nfor p in people:\n    solver.add(Or(assignment[p] == 1, assignment[p] == 2))\n\n# Each boat has exactly 4 people\n# Count people assigned to boat 1 and boat 2\nboat1_count = Sum([If(assignment[p] == 1, 1, 0) for p in people])\nboat2_count = Sum([If(assignment[p] == 2, 1, 0) for p in people])\nsolver.add(boat1_count == 4)\nsolver.add(boat2_count == 4)\n\n# Each boat has at least one adult\nboat1_adults = Sum([If(And(assignment[a] == 1, a in adults), 1, 0) for a in adults])\nboat2_adults = Sum([If(And(assignment[a] == 2, a in adults), 1, 0) for a in adults])\nsolver.add(boat1_adults >= 1)\nsolver.add(boat2_adults >= 1)\n\n# If F is assigned to boat 2, G is assigned to boat 2\nsolver.add(Implies(assignment['F'] == 2, assignment['G'] == 2))\n\n# If V is assigned to boat 1, W is assigned to boat 2\nsolver.add(Implies(assignment['V'] == 1, assignment['W'] == 2))\n\n# X and Z are assigned to different boats\nsolver.add(assignment['X'] != assignment['Z'])\n\n# Exactly three children assigned to boat 1\nboat1_children_count = Sum([If(assignment[c] == 1, 1, 0) for c in children])\nsolver.add(boat1_children_count == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': ['F', 'H'],\n    'B': ['G', 'Y'],\n    'C': ['H', 'W'],\n    'D': ['V', 'W'],\n    'E': ['W', 'Y']\n}\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add constraint that both people in the pair are assigned to boat 2\n    p1, p2 = options[opt]\n    solver.add(assignment[p1] == 2)\n    solver.add(assignment[p2] == 2)\n    if solver.check() == sat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.\n\nIf G is assigned to boat 1, which one of the following must be true?\n\nOptions:\n(A) H is assigned to boat 2.\n(B) V is assigned to boat 2.\n(C) Exactly one adult is assigned to boat 1.\n(D) Exactly two adults are assigned to boat 2.\n(E) Exactly two children are assigned to boat 2.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# People: Adults and Children\nadults = ['F', 'G', 'H']\nchildren = ['V', 'W', 'X', 'Y', 'Z']\npeople = adults + children\n\n# Boats: 0 for boat 1, 1 for boat 2\nboats = [0, 1]\n\n# Variables: For each person, an Int variable indicating assigned boat (0 or 1)\nassign = {p: Int(p) for p in people}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person assigned to exactly one boat: 0 or 1\nfor p in people:\n    solver.add(Or([assign[p] == b for b in boats]))\n\n# Exactly four people per boat\n# Sum of people assigned to boat 1 == 4\nsolver.add(Sum([If(assign[p] == 0, 1, 0) for p in people]) == 4)\n# Sum of people assigned to boat 2 == 4\nsolver.add(Sum([If(assign[p] == 1, 1, 0) for p in people]) == 4)\n\n# Each boat has at least one adult\n# Adults on boat 1 >= 1\nsolver.add(Sum([If(assign[a] == 0, 1, 0) for a in adults]) >= 1)\n# Adults on boat 2 >= 1\nsolver.add(Sum([If(assign[a] == 1, 1, 0) for a in adults]) >= 1)\n\n# If F is assigned to boat 2, G is assigned to boat 2\nsolver.add(Implies(assign['F'] == 1, assign['G'] == 1))\n\n# If V is assigned to boat 1, W is assigned to boat 2\nsolver.add(Implies(assign['V'] == 0, assign['W'] == 1))\n\n# X and Z are assigned to different boats\nsolver.add(assign['X'] != assign['Z'])\n\n# Given condition for question: G is assigned to boat 1\nsolver.add(assign['G'] == 0)\n\n# OPTION CHECKING\n\noptions = {\n    'A': assign['H'] == 1,  # H is assigned to boat 2\n    'B': assign['V'] == 1,  # V is assigned to boat 2\n    'C': Sum([If(assign[a] == 0, 1, 0) for a in adults]) == 1,  # Exactly one adult on boat 1\n    'D': Sum([If(assign[a] == 1, 1, 0) for a in adults]) == 2,  # Exactly two adults on boat 2\n    'E': Sum([If(assign[c] == 1, 1, 0) for c in children]) == 2  # Exactly two children on boat 2\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    # Add negation of option condition to check if option must be true\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.\n\nIf H is assigned to a different boat than Y, which one of the following must be assigned to boat 1?\n\nOptions:\n(A) F\n(B) G\n(C) H\n(D) V\n(E) Y",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['F', 'G', 'H', 'V', 'W', 'X', 'Y', 'Z']\nadults = ['F', 'G', 'H']\nchildren = ['V', 'W', 'X', 'Y', 'Z']\n\n# 0 for boat 1, 1 for boat 2\nassign = {p: Int(p) for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person assigned to boat 1 or boat 2\nfor p in people:\n    solver.add(Or(assign[p] == 0, assign[p] == 1))\n\n# Each boat has exactly 4 people\nboat1_count = Sum([If(assign[p] == 0, 1, 0) for p in people])\nboat2_count = Sum([If(assign[p] == 1, 1, 0) for p in people])\nsolver.add(boat1_count == 4)\nsolver.add(boat2_count == 4)\n\n# Each boat has at least one adult\nboat1_adult_count = Sum([If(assign[a] == 0, 1, 0) for a in adults])\nboat2_adult_count = Sum([If(assign[a] == 1, 1, 0) for a in adults])\nsolver.add(boat1_adult_count >= 1)\nsolver.add(boat2_adult_count >= 1)\n\n# If F is assigned to boat 2, G is assigned to boat 2\nsolver.add(Implies(assign['F'] == 1, assign['G'] == 1))\n\n# If V is assigned to boat 1, W is assigned to boat 2\nsolver.add(Implies(assign['V'] == 0, assign['W'] == 1))\n\n# X and Z are assigned to different boats\nsolver.add(assign['X'] != assign['Z'])\n\n# H is assigned to a different boat than Y\nsolver.add(assign['H'] != assign['Y'])\n\n# OPTION CHECKING\noptions = ['F', 'G', 'H', 'V', 'Y']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that option is NOT assigned to boat 1 (to test if it must be assigned to boat 1)\n    solver.add(assign[opt] != 0)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of two boats, boat 1 and boat 2, will be assigned exactly four people. Exactly eight people, three adults—F, G, and H—and five children—V, W, X, Y, and Z—must be assigned to the boats according to the following conditions: Each boat is assigned at least one adult. If F is assigned to boat 2, G is assigned to boat 2. If V is assigned to boat 1, W is assigned to boat 2. X and Z are assigned to different boats.\n\nIf exactly one adult is assigned to boat 1, which one of the following must be true?\n\nOptions:\n(A) F is assigned to boat 1.\n(B) G is assigned to boat 2.\n(C) H is assigned to boat 2.\n(D) V is assigned to boat 1.\n(E) Z is assigned to boat 2.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['F', 'G', 'H', 'V', 'W', 'X', 'Y', 'Z']\nadults = ['F', 'G', 'H']\nchildren = ['V', 'W', 'X', 'Y', 'Z']\n\n# Boats: 1 or 2\n# Create variables: boat_assignment[p] = 1 or 2\nboat_assignment = {p: Int(p) for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person assigned to boat 1 or 2\nfor p in people:\n    solver.add(Or(boat_assignment[p] == 1, boat_assignment[p] == 2))\n\n# Each boat has exactly 4 people\n# Count number of people assigned to boat 1 and boat 2\nboat1_count = Sum([If(boat_assignment[p] == 1, 1, 0) for p in people])\nboat2_count = Sum([If(boat_assignment[p] == 2, 1, 0) for p in people])\nsolver.add(boat1_count == 4)\nsolver.add(boat2_count == 4)\n\n# Each boat has at least one adult\nboat1_adults = [If(boat_assignment[a] == 1, 1, 0) for a in adults]\nboat2_adults = [If(boat_assignment[a] == 2, 1, 0) for a in adults]\nsolver.add(Sum(boat1_adults) >= 1)\nsolver.add(Sum(boat2_adults) >= 1)\n\n# If F is assigned to boat 2, G is assigned to boat 2\nsolver.add(Implies(boat_assignment['F'] == 2, boat_assignment['G'] == 2))\n\n# If V is assigned to boat 1, W is assigned to boat 2\nsolver.add(Implies(boat_assignment['V'] == 1, boat_assignment['W'] == 2))\n\n# X and Z are assigned to different boats\nsolver.add(boat_assignment['X'] != boat_assignment['Z'])\n\n# Exactly one adult is assigned to boat 1\nsolver.add(Sum(boat1_adults) == 1)\n\n# OPTION CHECKING\n# Options:\n# (A) F is assigned to boat 1.\n# (B) G is assigned to boat 2.\n# (C) H is assigned to boat 2.\n# (D) V is assigned to boat 1.\n# (E) Z is assigned to boat 2.\n\noptions = [\n    boat_assignment['F'] == 1,\n    boat_assignment['G'] == 2,\n    boat_assignment['H'] == 2,\n    boat_assignment['V'] == 1,\n    boat_assignment['Z'] == 2,\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each of nine students—Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, and Paul—will be assigned to exactly one of three panels: Oceans, Recycling, and Wetlands. Exactly three of the students will be assigned to each panel. The assignment of students to panels must meet the following conditions: Faith is assigned to the same panel as Gregory. Kenji is assigned to the same panel as Marcus. Faith is not assigned to the same panel as Paul. Gregory is not assigned to the same panel as Harlan. Jennifer is not assigned to the same panel as Kenji. Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel.\n\nWhich one of the following is an acceptable assignment of students to the panels?\n\nOptions:\n(A) Oceans: Faith, Gregory, Jennifer Recycling: Kenji, Lisa, Nari Wetlands: Harlan, Marcus, Paul\n(B) Oceans: Faith, Jennifer, Lisa Recycling: Harlan, Kenji, Marcus Wetlands: Gregory, Nari, Paul\n(C) Oceans: Harlan, Kenji, Marcus Recycling: Faith, Gregory, Jennifer Wetlands: Lisa, Nari, Paul\n(D) Oceans: Jennifer, Kenji, Marcus Recycling: Faith, Gregory, Nari Wetlands: Harlan, Lisa, Paul\n(E) Oceans: Kenji, Marcus, Paul Recycling: Harlan, Jennifer, Nari Wetlands: Faith, Gregory, Lisa",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Faith', 'Gregory', 'Harlan', 'Jennifer', 'Kenji', 'Lisa', 'Marcus', 'Nari', 'Paul']\npanels = ['Oceans', 'Recycling', 'Wetlands']\n\n# Create a variable for each student representing their panel assignment (0,1,2)\npanel_vars = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student assigned to a valid panel index\nfor s in students:\n    solver.add(And(panel_vars[s] >= 0, panel_vars[s] < len(panels)))\n\n# Exactly three students per panel\nfor p in range(len(panels)):\n    count_p = Sum([If(panel_vars[s] == p, 1, 0) for s in students])\n    solver.add(count_p == 3)\n\n# Faith is assigned to the same panel as Gregory\nsolver.add(panel_vars['Faith'] == panel_vars['Gregory'])\n\n# Kenji is assigned to the same panel as Marcus\nsolver.add(panel_vars['Kenji'] == panel_vars['Marcus'])\n\n# Faith is not assigned to the same panel as Paul\nsolver.add(panel_vars['Faith'] != panel_vars['Paul'])\n\n# Gregory is not assigned to the same panel as Harlan\nsolver.add(panel_vars['Gregory'] != panel_vars['Harlan'])\n\n# Jennifer is not assigned to the same panel as Kenji\nsolver.add(panel_vars['Jennifer'] != panel_vars['Kenji'])\n\n# Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel\noceans = panels.index('Oceans')\n# This means: if Paul != Oceans then Harlan != Oceans\nsolver.add(Implies(panel_vars['Paul'] != oceans, panel_vars['Harlan'] != oceans))\n\n# OPTION CHECKING\n\noptions = [\n    # (A)\n    {\n        'Oceans': ['Faith', 'Gregory', 'Jennifer'],\n        'Recycling': ['Kenji', 'Lisa', 'Nari'],\n        'Wetlands': ['Harlan', 'Marcus', 'Paul']\n    },\n    # (B)\n    {\n        'Oceans': ['Faith', 'Jennifer', 'Lisa'],\n        'Recycling': ['Harlan', 'Kenji', 'Marcus'],\n        'Wetlands': ['Gregory', 'Nari', 'Paul']\n    },\n    # (C)\n    {\n        'Oceans': ['Harlan', 'Kenji', 'Marcus'],\n        'Recycling': ['Faith', 'Gregory', 'Jennifer'],\n        'Wetlands': ['Lisa', 'Nari', 'Paul']\n    },\n    # (D)\n    {\n        'Oceans': ['Jennifer', 'Kenji', 'Marcus'],\n        'Recycling': ['Faith', 'Gregory', 'Nari'],\n        'Wetlands': ['Harlan', 'Lisa', 'Paul']\n    },\n    # (E)\n    {\n        'Oceans': ['Kenji', 'Marcus', 'Paul'],\n        'Recycling': ['Harlan', 'Jennifer', 'Nari'],\n        'Wetlands': ['Faith', 'Gregory', 'Lisa']\n    }\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this option\n    for p_name in panels:\n        p_index = panels.index(p_name)\n        for s in students:\n            if s in option[p_name]:\n                solver.add(panel_vars[s] == p_index)\n            else:\n                solver.add(panel_vars[s] != p_index)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of nine students—Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, and Paul—will be assigned to exactly one of three panels: Oceans, Recycling, and Wetlands. Exactly three of the students will be assigned to each panel. The assignment of students to panels must meet the following conditions: Faith is assigned to the same panel as Gregory. Kenji is assigned to the same panel as Marcus. Faith is not assigned to the same panel as Paul. Gregory is not assigned to the same panel as Harlan. Jennifer is not assigned to the same panel as Kenji. Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel.\n\nIf Marcus and Paul are both assigned to the Wetlands panel, which one of the following must be true?\n\nOptions:\n(A) Harlan is assigned to the Recycling panel.\n(B) Jennifer is assigned to the Oceans panel.\n(C) Kenji is assigned to the Recycling panel.\n(D) Lisa is assigned to the Wetlands panel.\n(E) Nari is assigned to the Oceans panel.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Faith', 'Gregory', 'Harlan', 'Jennifer', 'Kenji', 'Lisa', 'Marcus', 'Nari', 'Paul']\npanels = ['Oceans', 'Recycling', 'Wetlands']\n\n# Map students to Int variables representing panel indices\npanel_indices = {p: i for i, p in enumerate(panels)}\nstudent_vars = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student assigned to a valid panel index\nfor s in students:\n    solver.add(And(student_vars[s] >= 0, student_vars[s] < len(panels)))\n\n# Exactly three students per panel\nfor i in range(len(panels)):\n    count_in_panel = Sum([If(student_vars[s] == i, 1, 0) for s in students])\n    solver.add(count_in_panel == 3)\n\n# Faith is assigned to the same panel as Gregory\nsolver.add(student_vars['Faith'] == student_vars['Gregory'])\n\n# Kenji is assigned to the same panel as Marcus\nsolver.add(student_vars['Kenji'] == student_vars['Marcus'])\n\n# Faith is not assigned to the same panel as Paul\nsolver.add(student_vars['Faith'] != student_vars['Paul'])\n\n# Gregory is not assigned to the same panel as Harlan\nsolver.add(student_vars['Gregory'] != student_vars['Harlan'])\n\n# Jennifer is not assigned to the same panel as Kenji\nsolver.add(student_vars['Jennifer'] != student_vars['Kenji'])\n\n# Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel\noceans_idx = panel_indices['Oceans']\nsolver.add(Implies(student_vars['Paul'] != oceans_idx, student_vars['Harlan'] != oceans_idx))\n\n# Given condition: Marcus and Paul are both assigned to Wetlands panel\nwetlands_idx = panel_indices['Wetlands']\nsolver.add(student_vars['Marcus'] == wetlands_idx)\nsolver.add(student_vars['Paul'] == wetlands_idx)\n\n# OPTION CHECKING\noptions = [\n    ('A', student_vars['Harlan'] == panel_indices['Recycling']),\n    ('B', student_vars['Jennifer'] == panel_indices['Oceans']),\n    ('C', student_vars['Kenji'] == panel_indices['Recycling']),\n    ('D', student_vars['Lisa'] == panel_indices['Wetlands']),\n    ('E', student_vars['Nari'] == panel_indices['Oceans']),\n]\n\nfor letter, condition in options:\n    solver.push()\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of nine students—Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, and Paul—will be assigned to exactly one of three panels: Oceans, Recycling, and Wetlands. Exactly three of the students will be assigned to each panel. The assignment of students to panels must meet the following conditions: Faith is assigned to the same panel as Gregory. Kenji is assigned to the same panel as Marcus. Faith is not assigned to the same panel as Paul. Gregory is not assigned to the same panel as Harlan. Jennifer is not assigned to the same panel as Kenji. Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel.\n\nWhich one of the following is a pair of students who could be assigned to the same panel as each other?\n\nOptions:\n(A) Faith and Harlan\n(B) Gregory and Paul\n(C) Harlan and Marcus\n(D) Faith and Marcus\n(E) Jennifer and Marcus",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Faith', 'Gregory', 'Harlan', 'Jennifer', 'Kenji', 'Lisa', 'Marcus', 'Nari', 'Paul']\npanels = ['Oceans', 'Recycling', 'Wetlands']\n\n# Create Z3 variables: each student's panel assignment as an Int (0,1,2)\nassign = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# Each student assigned to a valid panel index\nfor s in students:\n    solver.add(And(assign[s] >= 0, assign[s] < len(panels)))\n\n# Exactly three students per panel\nfor p in range(len(panels)):\n    count_p = Sum([If(assign[s] == p, 1, 0) for s in students])\n    solver.add(count_p == 3)\n\n# CONSTRAINTS\n\n# Faith is assigned to the same panel as Gregory\nsolver.add(assign['Faith'] == assign['Gregory'])\n\n# Kenji is assigned to the same panel as Marcus\nsolver.add(assign['Kenji'] == assign['Marcus'])\n\n# Faith is not assigned to the same panel as Paul\nsolver.add(assign['Faith'] != assign['Paul'])\n\n# Gregory is not assigned to the same panel as Harlan\nsolver.add(assign['Gregory'] != assign['Harlan'])\n\n# Jennifer is not assigned to the same panel as Kenji\nsolver.add(assign['Jennifer'] != assign['Kenji'])\n\n# Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel\n# This means: if Paul != Oceans then Harlan != Oceans\noceans = 0\nsolver.add(Implies(assign['Paul'] != oceans, assign['Harlan'] != oceans))\n\n# OPTION CHECKING\n\noptions = [\n    ('Faith', 'Harlan'),    # A\n    ('Gregory', 'Paul'),    # B\n    ('Harlan', 'Marcus'),   # C\n    ('Faith', 'Marcus'),    # D\n    ('Jennifer', 'Marcus')  # E\n]\n\nfor i, (s1, s2) in enumerate(options):\n    solver.push()\n    # Add constraint that s1 and s2 are assigned to the same panel\n    solver.add(assign[s1] == assign[s2])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of nine students—Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, and Paul—will be assigned to exactly one of three panels: Oceans, Recycling, and Wetlands. Exactly three of the students will be assigned to each panel. The assignment of students to panels must meet the following conditions: Faith is assigned to the same panel as Gregory. Kenji is assigned to the same panel as Marcus. Faith is not assigned to the same panel as Paul. Gregory is not assigned to the same panel as Harlan. Jennifer is not assigned to the same panel as Kenji. Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel.\n\nIf Kenji and Paul are both assigned to the Recycling panel, which one of the following could be true?\n\nOptions:\n(A) Faith is assigned to the Wetlands panel.\n(B) Gregory is assigned to the Recycling panel.\n(C) Harlan is assigned to the Oceans panel.\n(D) Jennifer is assigned to the Wetlands panel.\n(E) Lisa is assigned to the Recycling panel.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Faith', 'Gregory', 'Harlan', 'Jennifer', 'Kenji', 'Lisa', 'Marcus', 'Nari', 'Paul']\npanels = ['Oceans', 'Recycling', 'Wetlands']\n\n# Map student names to Z3 Int variables representing their panel assignments\nstudent_panel = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student assigned to a valid panel index\nfor s in students:\n    solver.add(And(student_panel[s] >= 0, student_panel[s] < len(panels)))\n\n# Exactly three students per panel\nfor p in range(len(panels)):\n    count_in_panel = Sum([If(student_panel[s] == p, 1, 0) for s in students])\n    solver.add(count_in_panel == 3)\n\n# Faith is assigned to the same panel as Gregory\nsolver.add(student_panel['Faith'] == student_panel['Gregory'])\n\n# Kenji is assigned to the same panel as Marcus\nsolver.add(student_panel['Kenji'] == student_panel['Marcus'])\n\n# Faith is not assigned to the same panel as Paul\nsolver.add(student_panel['Faith'] != student_panel['Paul'])\n\n# Gregory is not assigned to the same panel as Harlan\nsolver.add(student_panel['Gregory'] != student_panel['Harlan'])\n\n# Jennifer is not assigned to the same panel as Kenji\nsolver.add(student_panel['Jennifer'] != student_panel['Kenji'])\n\n# Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel\noceans = panels.index('Oceans')\nharlan_oceans = student_panel['Harlan'] == oceans\npaul_oceans = student_panel['Paul'] == oceans\nsolver.add(Implies(Not(paul_oceans), Not(harlan_oceans)))\n\n# Kenji and Paul are both assigned to the Recycling panel\nrecycling = panels.index('Recycling')\nsolver.add(student_panel['Kenji'] == recycling)\nsolver.add(student_panel['Paul'] == recycling)\n\n# OPTION CHECKING\noptions = {\n    'A': student_panel['Faith'] == panels.index('Wetlands'),\n    'B': student_panel['Gregory'] == recycling,\n    'C': student_panel['Harlan'] == oceans,\n    'D': student_panel['Jennifer'] == panels.index('Wetlands'),\n    'E': student_panel['Lisa'] == recycling\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of nine students—Faith, Gregory, Harlan, Jennifer, Kenji, Lisa, Marcus, Nari, and Paul—will be assigned to exactly one of three panels: Oceans, Recycling, and Wetlands. Exactly three of the students will be assigned to each panel. The assignment of students to panels must meet the following conditions: Faith is assigned to the same panel as Gregory. Kenji is assigned to the same panel as Marcus. Faith is not assigned to the same panel as Paul. Gregory is not assigned to the same panel as Harlan. Jennifer is not assigned to the same panel as Kenji. Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel.\n\nEach of the following is a pair of students who could be assigned to the same panel as each other EXCEPT:\n\nOptions:\n(A) Gregory and Kenji\n(B) Gregory and Lisa\n(C) Kenji and Nari\n(D) Lisa and Marcus\n(E) Lisa and Paul",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Faith', 'Gregory', 'Harlan', 'Jennifer', 'Kenji', 'Lisa', 'Marcus', 'Nari', 'Paul']\npanels = ['Oceans', 'Recycling', 'Wetlands']\n\n# Create Z3 Int variables for each student representing their panel assignment (0,1,2)\npanel_vars = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student assigned to a valid panel index\nfor s in students:\n    solver.add(And(panel_vars[s] >= 0, panel_vars[s] < len(panels)))\n\n# Exactly 3 students per panel\nfor p in range(len(panels)):\n    count_in_panel = Sum([If(panel_vars[s] == p, 1, 0) for s in students])\n    solver.add(count_in_panel == 3)\n\n# Faith is assigned to the same panel as Gregory\nsolver.add(panel_vars['Faith'] == panel_vars['Gregory'])\n\n# Kenji is assigned to the same panel as Marcus\nsolver.add(panel_vars['Kenji'] == panel_vars['Marcus'])\n\n# Faith is not assigned to the same panel as Paul\nsolver.add(panel_vars['Faith'] != panel_vars['Paul'])\n\n# Gregory is not assigned to the same panel as Harlan\nsolver.add(panel_vars['Gregory'] != panel_vars['Harlan'])\n\n# Jennifer is not assigned to the same panel as Kenji\nsolver.add(panel_vars['Jennifer'] != panel_vars['Kenji'])\n\n# Harlan is not assigned to the Oceans panel if Paul is not assigned to the Oceans panel\noceans = panels.index('Oceans')\npaul_in_oceans = panel_vars['Paul'] == oceans\nharlan_in_oceans = panel_vars['Harlan'] == oceans\n# If Paul is NOT in oceans, then Harlan is NOT in oceans\nsolver.add(Implies(Not(paul_in_oceans), Not(harlan_in_oceans)))\n\n# OPTION CHECKING\n# Pairs to test if they can be assigned to the same panel\noptions = [\n    ('Gregory', 'Kenji'),  # A\n    ('Gregory', 'Lisa'),   # B\n    ('Kenji', 'Nari'),     # C\n    ('Lisa', 'Marcus'),    # D\n    ('Lisa', 'Paul')       # E\n]\n\nfor i, (s1, s2) in enumerate(options):\n    solver.push()\n    # Add constraint that s1 and s2 are assigned to the same panel\n    solver.add(panel_vars[s1] == panel_vars[s2])\n    if solver.check() == sat:\n        # They can be assigned to the same panel, so NOT the EXCEPT option\n        solver.pop()\n    else:\n        # They cannot be assigned to the same panel, this is the EXCEPT option\n        print(f\"'{chr(65 + i)}'\")\n        break\n    # No need to pop here because we already popped if sat\n\n",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of seven travelers—Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, and Underwood—will be assigned to exactly one of nine airplane seats. The seats are numbered from 1 through 9 and arranged in rows as follows: Front row: 1 2 3 Middle row: 4 5 6 Last row: 7 8 9 Only seats in the same row as each other are immediately beside each other. Seat assignments must meet the following conditions: Oribe's seat is in the last row. Paulsen's seat is immediately beside Rosen's seat and also immediately beside an unassigned seat. Rosen's seat is in the row immediately behind the row in which Norris' seat is located. Neither Semonelli nor Underwood is seated immediately beside Norris.\n\nWhich one of the following is a pair of travelers who could be assigned to seats 2 and 8, respectively?\n\nOptions:\n(A) Norris, Semonelli\n(B) Oribe, Underwood\n(C) Paulsen, Oribe\n(D) Rosen, Semonelli\n(E) Underwood, Tan",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntravelers = ['Norris', 'Oribe', 'Paulsen', 'Rosen', 'Semonelli', 'Tan', 'Underwood']\nseats = list(range(1, 10))  # 1 through 9\n\n# Create a mapping from traveler to assigned seat\nseat_of = {t: Int(t) for t in travelers}\n\n# Helper to get row of a seat\ndef row(seat):\n    # Seats 1-3 front, 4-6 middle, 7-9 last\n    return If(And(seat >= 1, seat <= 3), 1,\n           If(And(seat >= 4, seat <= 6), 2,\n           If(And(seat >= 7, seat <= 9), 3, 0)))\n\n# Helper to check if two seats are immediately beside each other (same row and adjacent seat numbers)\ndef beside(s1, s2):\n    return And(row(s1) == row(s2), Abs(s1 - s2) == 1)\n\n# Helper to check if seat is in last row\ndef is_last_row(seat):\n    return And(seat >= 7, seat <= 9)\n\n# Helper to check if seat is in middle row\ndef is_middle_row(seat):\n    return And(seat >= 4, seat <= 6)\n\n# Helper to check if seat is in front row\ndef is_front_row(seat):\n    return And(seat >= 1, seat <= 3)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each traveler is assigned exactly one seat in 1..9\nfor t in travelers:\n    solver.add(And(seat_of[t] >= 1, seat_of[t] <= 9))\n\n# No two travelers share the same seat\nsolver.add(Distinct([seat_of[t] for t in travelers]))\n\n# Oribe's seat is in the last row\nsolver.add(is_last_row(seat_of['Oribe']))\n\n# Paulsen's seat is immediately beside Rosen's seat\nsolver.add(beside(seat_of['Paulsen'], seat_of['Rosen']))\n\n# Paulsen's seat is immediately beside an unassigned seat\n# Unassigned seats = seats 1..9 except those assigned to travelers\n# So Paulsen must have at least one adjacent seat that is unassigned\n\n# First, define the set of assigned seats (variables)\nassigned_seats = [seat_of[t] for t in travelers]\n\n# We will check for each side of Paulsen's seat if it is in range and unassigned\n# Define unassigned seats as those in 1..9 not assigned to travelers\n# So for Paulsen's seat s, the adjacent seats are s-1 and s+1 if they exist and in same row\n\n# We'll define a helper function to check if a seat number x is unassigned\ndef unassigned(seat_num):\n    # seat_num is an Int value, so check that seat_num is not equal to any assigned seat\n    return And(seat_num >= 1, seat_num <= 9,\n               And([seat_num != s for s in assigned_seats]))\n\n# Paulsen's seat sP and Rosen's seat sR are beside each other, so sP and sR are adjacent seats in the same row\n# We want to check if Paulsen's seat is immediately beside an unassigned seat\n\n# We must check if sP - 1 or sP + 1 is in same row as sP and unassigned\n\nsP = seat_of['Paulsen']\n\n# Adjacent seats to sP that are in the same row\nadj_left = sP - 1\nadj_right = sP + 1\n\n# Conditions for adj_left and adj_right to be in the same row as sP\nadj_left_same_row = And(adj_left >= 1, adj_left <= 9, row(adj_left) == row(sP))\nadj_right_same_row = And(adj_right >= 1, adj_right <= 9, row(adj_right) == row(sP))\n\n# Unassigned seat on left or right\nunassigned_left = And(adj_left_same_row, unassigned(adj_left))\nunassigned_right = And(adj_right_same_row, unassigned(adj_right))\n\nsolver.add(Or(unassigned_left, unassigned_right))\n\n# Rosen's seat is in the row immediately behind the row in which Norris' seat is located\n# Rows: 1 (front), 2 (middle), 3 (last)\n# Rosen's row = Norris' row + 1\nrow_Rosen = row(seat_of['Rosen'])\nrow_Norris = row(seat_of['Norris'])\nsolver.add(row_Rosen == row_Norris + 1)\n\n# Neither Semonelli nor Underwood is seated immediately beside Norris\nsolver.add(Not(beside(seat_of['Semonelli'], seat_of['Norris'])))\nsolver.add(Not(beside(seat_of['Underwood'], seat_of['Norris'])))\n\n# OPTION CHECKING\noptions = [\n    ('A', ('Norris', 'Semonelli')),\n    ('B', ('Oribe', 'Underwood')),\n    ('C', ('Paulsen', 'Oribe')),\n    ('D', ('Rosen', 'Semonelli')),\n    ('E', ('Underwood', 'Tan')),\n]\n\nfor letter, (trav1, trav2) in options:\n    solver.push()\n    solver.add(seat_of[trav1] == 2)\n    solver.add(seat_of[trav2] == 8)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of seven travelers—Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, and Underwood—will be assigned to exactly one of nine airplane seats. The seats are numbered from 1 through 9 and arranged in rows as follows: Front row: 1 2 3 Middle row: 4 5 6 Last row: 7 8 9 Only seats in the same row as each other are immediately beside each other. Seat assignments must meet the following conditions: Oribe's seat is in the last row. Paulsen's seat is immediately beside Rosen's seat and also immediately beside an unassigned seat. Rosen's seat is in the row immediately behind the row in which Norris' seat is located. Neither Semonelli nor Underwood is seated immediately beside Norris.\n\nIf Semonelli and Underwood are not assigned to seats in the same row as each other, which one of the following must be false?\n\nOptions:\n(A) Norris is assigned to seat 2.\n(B) Paulsen is assigned to seat 5.\n(C) Rosen is assigned to seat 4.\n(D) Tan is assigned to seat 2.\n(E) Underwood is assigned to seat 1.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntravelers = ['Norris', 'Oribe', 'Paulsen', 'Rosen', 'Semonelli', 'Tan', 'Underwood']\nseats = list(range(1, 10))\n\n# Rows mapping\nfront_row = [1, 2, 3]\nmiddle_row = [4, 5, 6]\nlast_row = [7, 8, 9]\n\n# Map seat to row index: 0=front,1=middle,2=last\nseat_to_row = {}\nfor s in front_row:\n    seat_to_row[s] = 0\nfor s in middle_row:\n    seat_to_row[s] = 1\nfor s in last_row:\n    seat_to_row[s] = 2\n\n# Variables: seat assignment for each traveler\nseat_vars = {}\nfor t in travelers:\n    seat_vars[t] = Int(t)\n    \nsolver = Solver()\n\n# Each traveler assigned to a seat 1..9\nfor t in travelers:\n    solver.add(And(seat_vars[t] >= 1, seat_vars[t] <= 9))\n\n# All travelers assigned to distinct seats\nsolver.add(Distinct([seat_vars[t] for t in travelers]))\n\n# Helper functions\ndef row_of(seat_expr):\n    # Returns row index (0,1,2) for seat_expr\n    # We need to encode this as a piecewise function in Z3\n    return If(And(seat_expr >= 1, seat_expr <= 3), 0,\n           If(And(seat_expr >= 4, seat_expr <= 6), 1,\n           If(And(seat_expr >= 7, seat_expr <= 9), 2,\n              -1)))  # invalid seat\n\ndef immediate_beside(s1, s2):\n    # s1 and s2 are seat numbers\n    # They are immediately beside if:\n    # - same row\n    # - seat numbers differ by 1\n    same_row = row_of(s1) == row_of(s2)\n    diff_1 = Or(s1 == s2 + 1, s1 == s2 - 1)\n    return And(same_row, diff_1)\n\ndef assigned_seats():\n    # Returns list of seat variables assigned\n    return [seat_vars[t] for t in travelers]\n\n# CONSTRAINTS\n\n# 1) Oribe's seat is in the last row\nsolver.add(Or([seat_vars['Oribe'] == s for s in last_row]))\n\n# 2) Paulsen's seat is immediately beside Rosen's seat and also immediately beside an unassigned seat\n# Define unassigned seats: seats 1..9 except assigned seats\n# We will model unassigned seats by checking for seats not assigned to any traveler\nassigned = [seat_vars[t] for t in travelers]\n\n# Paulsen immediately beside Rosen\nsolver.add(immediate_beside(seat_vars['Paulsen'], seat_vars['Rosen']))\n\n# There exists an unassigned seat immediately beside Paulsen's seat\n# That means there is at least one seat s in 1..9 such that:\n# - s is immediately beside Paulsen's seat\n# - s is not assigned to any traveler\n\nunassigned_seat_found = []\nfor s in seats:\n    beside = immediate_beside(seat_vars['Paulsen'], IntVal(s))\n    not_assigned = And([seat_vars[t] != s for t in travelers])\n    unassigned_seat_found.append(And(beside, not_assigned))\n\nsolver.add(Or(unassigned_seat_found))\n\n# 3) Rosen's seat is in the row immediately behind the row in which Norris' seat is located\n# That means row_of(Rosen) == row_of(Norris) + 1\nsolver.add(row_of(seat_vars['Rosen']) == row_of(seat_vars['Norris']) + 1)\n\n# 4) Neither Semonelli nor Underwood is seated immediately beside Norris\nsolver.add(Not(immediate_beside(seat_vars['Semonelli'], seat_vars['Norris'])))\nsolver.add(Not(immediate_beside(seat_vars['Underwood'], seat_vars['Norris'])))\n\n# 5) Semonelli and Underwood are not assigned to seats in the same row as each other\nsolver.add(row_of(seat_vars['Semonelli']) != row_of(seat_vars['Underwood']))\n\n# OPTION CHECKING\n# Options:\n# (A) Norris is assigned to seat 2.\n# (B) Paulsen is assigned to seat 5.\n# (C) Rosen is assigned to seat 4.\n# (D) Tan is assigned to seat 2.\n# (E) Underwood is assigned to seat 1.\n\noptions = [\n    ('A', seat_vars['Norris'] == 2),\n    ('B', seat_vars['Paulsen'] == 5),\n    ('C', seat_vars['Rosen'] == 4),\n    ('D', seat_vars['Tan'] == 2),\n    ('E', seat_vars['Underwood'] == 1)\n]\n\nfor letter, cond in options:\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        # Option can be true, so not necessarily false\n        solver.pop()\n    else:\n        # Option must be false, print and break\n        print(f\"'{letter}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of seven travelers—Norris, Oribe, Paulsen, Rosen, Semonelli, Tan, and Underwood—will be assigned to exactly one of nine airplane seats. The seats are numbered from 1 through 9 and arranged in rows as follows: Front row: 1 2 3 Middle row: 4 5 6 Last row: 7 8 9 Only seats in the same row as each other are immediately beside each other. Seat assignments must meet the following conditions: Oribe's seat is in the last row. Paulsen's seat is immediately beside Rosen's seat and also immediately beside an unassigned seat. Rosen's seat is in the row immediately behind the row in which Norris' seat is located. Neither Semonelli nor Underwood is seated immediately beside Norris.\n\nIf Semonelli is assigned to a seat in the same row as Underwood, which one of the following travelers could be assigned to a seat immediately beside one of the unassigned seats?\n\nOptions:\n(A) Oribe\n(B) Rosen\n(C) Semonelli\n(D) Tan\n(E) Underwood",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntravelers = ['Norris', 'Oribe', 'Paulsen', 'Rosen', 'Semonelli', 'Tan', 'Underwood']\nseats = list(range(1, 10))  # Seats 1 through 9\n\n# Rows mapping\nfront_row = [1, 2, 3]\nmiddle_row = [4, 5, 6]\nlast_row = [7, 8, 9]\n\n# Map seat to row for quick lookup\nseat_to_row = {}\nfor s in front_row:\n    seat_to_row[s] = 'front'\nfor s in middle_row:\n    seat_to_row[s] = 'middle'\nfor s in last_row:\n    seat_to_row[s] = 'last'\n\n# Create Z3 Int variables for each traveler seat assignment\nseat_vars = {traveler: Int(traveler) for traveler in travelers}\n\n# Create a set of all seats for convenience\nall_seats = seats\n\n# Set of assigned seats (variables)\nassigned_seats = [seat_vars[t] for t in travelers]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each traveler assigned to exactly one seat in 1..9\nfor t in travelers:\n    solver.add(And(seat_vars[t] >= 1, seat_vars[t] <= 9))\n\n# All assigned seats are distinct\nsolver.add(Distinct(assigned_seats))\n\n# Oribe's seat is in the last row\nsolver.add(Or([seat_vars['Oribe'] == s for s in last_row]))\n\n# Paulsen's seat is immediately beside Rosen's seat and also immediately beside an unassigned seat\n# Define adjacency function: seats immediately beside each other are seats next to each other in the same row\n\ndef adjacent_seats(s):\n    # Returns list of seats immediately beside seat s\n    row = seat_to_row[s]\n    if row == 'front':\n        row_seats = front_row\n    elif row == 'middle':\n        row_seats = middle_row\n    else:\n        row_seats = last_row\n    idx = row_seats.index(s)\n    adj = []\n    if idx > 0:\n        adj.append(row_seats[idx - 1])\n    if idx < len(row_seats) - 1:\n        adj.append(row_seats[idx + 1])\n    return adj\n\n# For Paulsen and Rosen adjacency:\n# Paulsen's seat adjacent to Rosen's seat\n# Paulsen's seat adjacent to an unassigned seat (a seat not assigned to any traveler)\n\n# First, define unassigned seats as those not assigned to any traveler\n# Since there are 9 seats and 7 travelers, 2 seats remain unassigned\n\n# We will represent unassigned seats as those seats not assigned to any traveler\n\n# Helper function to build Or conditions for adjacency\ndef is_adjacent(s1, s2):\n    # s1 and s2 are Z3 Int variables or constants\n    # Check if s1 and s2 are adjacent seats\n    # Because adjacency is symmetric, check if s2 is in adjacent_seats(s1)\n    # Since s1 and s2 are variables, we need to encode adjacency as constraints\n    # We'll precompute all adjacent seat pairs and encode that s1,s2 must be one of those pairs\n\n    adj_pairs = []\n    for seat_a in seats:\n        for seat_b in adjacent_seats(seat_a):\n            adj_pairs.append((seat_a, seat_b))\n            adj_pairs.append((seat_b, seat_a))\n    # Create Or of equalities\n    conds = []\n    for (a, b) in adj_pairs:\n        conds.append(And(s1 == a, s2 == b))\n    return Or(conds)\n\n# Paulsen's seat adjacent to Rosen's seat\nsolver.add(is_adjacent(seat_vars['Paulsen'], seat_vars['Rosen']))\n\n# Paulsen's seat adjacent to an unassigned seat\n# Define unassigned seats as those seats not assigned to any traveler\n# We don't have explicit variables for unassigned seats, so we encode that there exists a seat u in seats,\n# u != any assigned seat, and u adjacent to Paulsen's seat\n\n# Create a variable for the unassigned seat adjacent to Paulsen\nu_seat = Int('u_seat')\nsolver.add(And(u_seat >= 1, u_seat <= 9))\n\n# u_seat is adjacent to Paulsen's seat\nsolver.add(is_adjacent(seat_vars['Paulsen'], u_seat))\n\n# u_seat is not assigned to any traveler\nfor t in travelers:\n    solver.add(u_seat != seat_vars[t])\n\n# Rosen's seat is in the row immediately behind the row in which Norris' seat is located\n# Rows order: front (1), middle (2), last (3)\nrow_order = {'front': 1, 'middle': 2, 'last': 3}\n\n# We encode the row of Rosen's seat and Norris' seat\ndef row_of_seat(s):\n    # s is Z3 Int variable or constant\n    # Return Int variable for row number\n    # We'll create a function that maps seat to row number\n    # Since seat is variable, we encode as:\n    # row = 1 if s in front_row\n    # row = 2 if s in middle_row\n    # row = 3 if s in last_row\n    return If(Or([s == seat for seat in front_row]), 1,\n              If(Or([s == seat for seat in middle_row]), 2,\n                 3))\n\nrosen_row = Int('rosen_row')\nnorris_row = Int('norris_row')\nsolver.add(rosen_row == row_of_seat(seat_vars['Rosen']))\nsolver.add(norris_row == row_of_seat(seat_vars['Norris']))\n\n# Rosen's row is immediately behind Norris' row => rosen_row == norris_row + 1\nsolver.add(rosen_row == norris_row + 1)\n\n# Neither Semonelli nor Underwood is seated immediately beside Norris\nsolver.add(Not(is_adjacent(seat_vars['Semonelli'], seat_vars['Norris'])))\nsolver.add(Not(is_adjacent(seat_vars['Underwood'], seat_vars['Norris'])))\n\n# Additional constraint from question: Semonelli is assigned to a seat in the same row as Underwood\nsemonelli_row = Int('semonelli_row')\nunderwood_row = Int('underwood_row')\nsolver.add(semonelli_row == row_of_seat(seat_vars['Semonelli']))\nsolver.add(underwood_row == row_of_seat(seat_vars['Underwood']))\nsolver.add(semonelli_row == underwood_row)\n\n# OPTION CHECKING\n# We want to check which traveler could be assigned to a seat immediately beside one of the unassigned seats\n\n# The unassigned seats are those not assigned to any traveler\n\n# For each option, we add a constraint that the traveler's seat is adjacent to at least one unassigned seat\n\noptions = ['Oribe', 'Rosen', 'Semonelli', 'Tan', 'Underwood']\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, traveler_option in enumerate(options):\n    solver.push()\n\n    # Create a variable for an unassigned seat adjacent to the traveler_option's seat\n    unassigned_adj_seat = Int('unassigned_adj_seat')\n    solver.add(And(unassigned_adj_seat >= 1, unassigned_adj_seat <= 9))\n\n    # unassigned_adj_seat is adjacent to traveler's seat\n    solver.add(is_adjacent(seat_vars[traveler_option], unassigned_adj_seat))\n\n    # unassigned_adj_seat is not assigned to any traveler\n    for t in travelers:\n        solver.add(unassigned_adj_seat != seat_vars[t])\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.\n\nWhich one of the following could be a complete and accurate list of the areas of expenditure reduced by the committee?\n\nOptions:\n(A) G, L, M, N, W\n(B) G, L, M, P, W\n(C) G, M, N, R, W\n(D) G, M, P, R, S\n(E) L, M, R, S, W",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nareas = ['G', 'L', 'M', 'N', 'P', 'R', 'S', 'W']\narea_vars = {a: Bool(a) for a in areas}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly five areas are reduced\nnum_reduced = Sum([If(area_vars[a], 1, 0) for a in areas])\nsolver.add(num_reduced == 5)\n\n# If both G and S are reduced, W is also reduced: (G ∧ S) → W\ngs_reduced = And(area_vars['G'], area_vars['S'])\nsolver.add(Implies(gs_reduced, area_vars['W']))\n\n# If N is reduced, neither R nor S is reduced: N → ¬R ∧ ¬S\nn_reduced = area_vars['N']\nsolver.add(Implies(n_reduced, And(Not(area_vars['R']), Not(area_vars['S']))))\n\n# If P is reduced, L is not reduced: P → ¬L\np_reduced = area_vars['P']\nsolver.add(Implies(p_reduced, Not(area_vars['L'])))\n\n# Of L, M, and R, exactly two are reduced\nlmr_vars = [area_vars['L'], area_vars['M'], area_vars['R']]\nlmr_sum = Sum([If(v, 1, 0) for v in lmr_vars])\nsolver.add(lmr_sum == 2)\n\n# OPTION CHECKING\noptions = {\n    'A': ['G', 'L', 'M', 'N', 'W'],\n    'B': ['G', 'L', 'M', 'P', 'W'],\n    'C': ['G', 'M', 'N', 'R', 'W'],\n    'D': ['G', 'M', 'P', 'R', 'S'],\n    'E': ['L', 'M', 'R', 'S', 'W'],\n}\n\nfor letter, reduced_list in options.items():\n    solver.push()\n    # Add constraints that exactly these areas are reduced\n    for a in areas:\n        if a in reduced_list:\n            solver.add(area_vars[a] == True)\n        else:\n            solver.add(area_vars[a] == False)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.\n\nIf W is reduced, which one of the following could be a complete and accurate list of the four other areas of expenditure to be reduced?\n\nOptions:\n(A) G, M, P, S\n(B) L, M, N, R\n(C) L, M, P, S\n(D) M, N, P, S\n(E) M, P, R, S",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nareas = ['G', 'L', 'M', 'N', 'P', 'R', 'S', 'W']\narea_vars = {a: Bool(a) for a in areas}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly 5 areas are reduced\nsolver.add(Sum([If(area_vars[a], 1, 0) for a in areas]) == 5)\n\n# If both G and S are reduced, W is also reduced: (G and S) => W\ngs_reduced = And(area_vars['G'], area_vars['S'])\nsolver.add(Implies(gs_reduced, area_vars['W']))\n\n# If N is reduced, neither R nor S is reduced: N => (not R and not S)\nn_reduced = area_vars['N']\nsolver.add(Implies(n_reduced, And(Not(area_vars['R']), Not(area_vars['S']))))\n\n# If P is reduced, L is not reduced: P => not L\np_reduced = area_vars['P']\nsolver.add(Implies(p_reduced, Not(area_vars['L'])))\n\n# Exactly two of L, M, and R are reduced\nlm_r = [area_vars['L'], area_vars['M'], area_vars['R']]\nsolver.add(Sum([If(x, 1, 0) for x in lm_r]) == 2)\n\n# W is reduced\nsolver.add(area_vars['W'] == True)\n\n# OPTION CHECKING\noptions = {\n    'A': ['G', 'M', 'P', 'S'],\n    'B': ['L', 'M', 'N', 'R'],\n    'C': ['L', 'M', 'P', 'S'],\n    'D': ['M', 'N', 'P', 'S'],\n    'E': ['M', 'P', 'R', 'S']\n}\n\nfor letter, other_areas in options.items():\n    solver.push()\n    # The four other areas in the option are reduced\n    for a in other_areas:\n        solver.add(area_vars[a] == True)\n    # The remaining areas not in the option or W are not reduced\n    not_reduced_areas = [a for a in areas if a not in other_areas + ['W']]\n    for a in not_reduced_areas:\n        solver.add(area_vars[a] == False)\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.\n\nIf P is reduced, which one of the following is a pair of areas of expenditure both of which must be reduced?\n\nOptions:\n(A) G, M\n(B) M, R\n(C) N, R\n(D) R, S\n(E) S, W",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nareas = ['G', 'L', 'M', 'N', 'P', 'R', 'S', 'W']\narea_vars = {a: Bool(a) for a in areas}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly five areas are reduced\nsolver.add(Sum([If(area_vars[a], 1, 0) for a in areas]) == 5)\n\n# If both G and S are reduced, W is also reduced: (G ∧ S) → W\nG_and_S = And(area_vars['G'], area_vars['S'])\nsolver.add(Implies(G_and_S, area_vars['W']))\n\n# If N is reduced, neither R nor S is reduced: N → ¬R ∧ ¬S\nsolver.add(Implies(area_vars['N'], And(Not(area_vars['R']), Not(area_vars['S']))))\n\n# If P is reduced, L is not reduced: P → ¬L\nsolver.add(Implies(area_vars['P'], Not(area_vars['L'])))\n\n# Exactly two of L, M, R are reduced\nLMR = [area_vars[a] for a in ['L', 'M', 'R']]\nsolver.add(Sum([If(x, 1, 0) for x in LMR]) == 2)\n\n# OPTION CHECKING\n# We are asked: If P is reduced, which pair must both be reduced?\n# So add P reduced constraint\nsolver.add(area_vars['P'] == True)\n\noptions = {\n    'A': ('G', 'M'),\n    'B': ('M', 'R'),\n    'C': ('N', 'R'),\n    'D': ('R', 'S'),\n    'E': ('S', 'W'),\n}\n\nfor letter, (a1, a2) in options.items():\n    solver.push()\n    # Check if there is a solution with P reduced but this pair not both reduced\n    # So add constraint that not both are reduced: ¬(a1 ∧ a2) = ¬a1 ∨ ¬a2\n    solver.add(Or(Not(area_vars[a1]), Not(area_vars[a2])))\n    if solver.check() == unsat:\n        # Cannot have a solution without both reduced, so both must be reduced\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.\n\nIf both L and S are reduced, which one of the following could be a pair of areas of expenditure both of which are reduced?\n\nOptions:\n(A) G, M\n(B) G, P\n(C) N, R\n(D) N, W\n(E) P, S",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nareas = ['G', 'L', 'M', 'N', 'P', 'R', 'S', 'W']\narea_vars = {a: Bool(a) for a in areas}  # True if reduced, False otherwise\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly five areas are reduced\nreduced_list = [If(area_vars[a], 1, 0) for a in areas]\nsolver.add(Sum(reduced_list) == 5)\n\n# If both G and S are reduced, W is also reduced\ng_and_s = And(area_vars['G'], area_vars['S'])\nsolver.add(Implies(g_and_s, area_vars['W']))\n\n# If N is reduced, neither R nor S is reduced\nn_reduced = area_vars['N']\nsolver.add(Implies(n_reduced, And(Not(area_vars['R']), Not(area_vars['S']))))\n\n# If P is reduced, L is not reduced\np_reduced = area_vars['P']\nsolver.add(Implies(p_reduced, Not(area_vars['L'])))\n\n# Of L, M, and R, exactly two are reduced\nlm_r_list = [If(area_vars[a], 1, 0) for a in ['L', 'M', 'R']]\nsolver.add(Sum(lm_r_list) == 2)\n\n# Given: Both L and S are reduced\nsolver.add(area_vars['L'])\nsolver.add(area_vars['S'])\n\n# OPTION CHECKING\noptions = {\n    'A': ('G', 'M'),\n    'B': ('G', 'P'),\n    'C': ('N', 'R'),\n    'D': ('N', 'W'),\n    'E': ('P', 'S'),\n}\n\nfor letter, (a1, a2) in options.items():\n    solver.push()\n    # Both areas in the option are reduced\n    solver.add(area_vars[a1])\n    solver.add(area_vars[a2])\n\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.\n\nIf R is not reduced, which one of the following must be true?\n\nOptions:\n(A) G is reduced.\n(B) N is not reduced.\n(C) P is reduced.\n(D) S is reduced.\n(E) W is not reduced.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nareas = ['G', 'L', 'M', 'N', 'P', 'R', 'S', 'W']\narea_vars = {a: Bool(a) for a in areas}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly five areas are reduced\nsolver.add(Sum([If(area_vars[a], 1, 0) for a in areas]) == 5)\n\n# If both G and S are reduced, W is also reduced: (G and S) => W\ngs_reduced = And(area_vars['G'], area_vars['S'])\nsolver.add(Implies(gs_reduced, area_vars['W']))\n\n# If N is reduced, neither R nor S is reduced: N => (not R and not S)\nsolver.add(Implies(area_vars['N'], And(Not(area_vars['R']), Not(area_vars['S']))))\n\n# If P is reduced, L is not reduced: P => not L\nsolver.add(Implies(area_vars['P'], Not(area_vars['L'])))\n\n# Of the three areas L, M, and R, exactly two are reduced\nl_m_r_sum = Sum([If(area_vars[a], 1, 0) for a in ['L', 'M', 'R']])\nsolver.add(l_m_r_sum == 2)\n\n# Given condition: R is not reduced\nsolver.add(Not(area_vars['R']))\n\n# OPTION CHECKING\noptions = {\n    'A': area_vars['G'],         # G is reduced\n    'B': Not(area_vars['N']),    # N is not reduced\n    'C': area_vars['P'],         # P is reduced\n    'D': area_vars['S'],         # S is reduced\n    'E': Not(area_vars['W'])     # W is not reduced\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    # Check if the negation of the condition is possible (to test if condition must be true)\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A university library budget committee must reduce exactly five of eight areas of expenditure—G, L, M, N, P, R, S, and W—in accordance with the following conditions: If both G and S are reduced, W is also reduced. If N is reduced, neither R nor S is reduced. If P is reduced, L is not reduced. Of the three areas L, M, and R, exactly two are reduced.\n\nWhich one of the following areas must be reduced?\n\nOptions:\n(A) G\n(B) L\n(C) N\n(D) P\n(E) W",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nareas = ['G', 'L', 'M', 'N', 'P', 'R', 'S', 'W']\narea_vars = {a: Bool(a) for a in areas}  # True means reduced\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly five of eight areas are reduced\nsolver.add(Sum([If(area_vars[a], 1, 0) for a in areas]) == 5)\n\n# If both G and S are reduced, W is also reduced: (G and S) -> W\nGS = And(area_vars['G'], area_vars['S'])\nsolver.add(Implies(GS, area_vars['W']))\n\n# If N is reduced, neither R nor S is reduced: N -> (not R and not S)\nsolver.add(Implies(area_vars['N'], And(Not(area_vars['R']), Not(area_vars['S']))))\n\n# If P is reduced, L is not reduced: P -> not L\nsolver.add(Implies(area_vars['P'], Not(area_vars['L'])))\n\n# Of L, M, and R, exactly two are reduced\nLMR = [area_vars['L'], area_vars['M'], area_vars['R']]\nsolver.add(Sum([If(x, 1, 0) for x in LMR]) == 2)\n\n# OPTION CHECKING\noptions = ['G', 'L', 'N', 'P', 'W']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Check if it's possible that this area is NOT reduced\n    solver.add(Not(area_vars[opt]))\n    if solver.check() == unsat:\n        # If not reduced leads to unsat, it must be reduced\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A jeweler makes a single strand of beads by threading onto a string in a single direction from a clasp a series of solid-colored beads. Each bead is either green, orange, purple, red, or yellow. The resulting strand satisfies the following specifications: If a purple bead is adjacent to a yellow bead, any bead that immediately follows and any bead that immediately precedes that pair must be red. Any pair of beads adjacent to each other that are the same color as each other must be green. No orange bead can be adjacent to any red bead. Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n\nIf the strand has exactly eight beads, which one of the following is an acceptable order, starting from the clasp, for the eight beads?\n\nOptions:\n(A) green, red, purple, yellow, red, orange, green, purple\n(B) orange, yellow, red, red, yellow, purple, red, green\n(C) purple, yellow, red, green, green, orange, yellow, orange\n(D) red, orange, red, yellow, purple, green, yellow, green\n(E) red, yellow, purple, red, green, red, green, green",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'orange', 'purple', 'red', 'yellow']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Strand length\nn = 8\n\n# Create Z3 variables for each bead position\nbeads = [Int(f'bead_{i}') for i in range(n)]\n\nsolver = Solver()\n\n# Each bead must be a valid color index\nfor b in beads:\n    solver.add(And(b >= 0, b < len(colors)))\n\n# Helper functions for color checks\ndef is_color(bead_var, color_name):\n    return bead_var == color_indices[color_name]\n\n# CONSTRAINTS\n\n# 1) If a purple bead is adjacent to a yellow bead, any bead that immediately follows and any bead \n# that immediately precedes that pair must be red.\n\n# We need to check every adjacent pair (i, i+1)\nfor i in range(n-1):\n    bead1 = beads[i]\n    bead2 = beads[i+1]\n    # Condition for purple-yellow or yellow-purple pair\n    purple_yellow_pair = Or(\n        And(is_color(bead1, 'purple'), is_color(bead2, 'yellow')),\n        And(is_color(bead1, 'yellow'), is_color(bead2, 'purple'))\n    )\n    # If purple-yellow pair at i,i+1 then bead at i-1 (if exists) and bead at i+2 (if exists) must be red\n    if i - 1 >= 0:\n        solver.add(Implies(purple_yellow_pair, is_color(beads[i-1], 'red')))\n    if i + 2 < n:\n        solver.add(Implies(purple_yellow_pair, is_color(beads[i+2], 'red')))\n\n# 2) Any pair of beads adjacent to each other that are the same color as each other must be green.\n# So if beads[i] == beads[i+1] then that color must be green\nfor i in range(n-1):\n    bead1 = beads[i]\n    bead2 = beads[i+1]\n    same_color = bead1 == bead2\n    # If same color, then must be green\n    solver.add(Implies(same_color, is_color(bead1, 'green')))\n\n# 3) No orange bead can be adjacent to any red bead.\nfor i in range(n-1):\n    bead1 = beads[i]\n    bead2 = beads[i+1]\n    # If bead1 is orange, bead2 not red; if bead1 is red, bead2 not orange\n    no_orange_red_adjacent = And(\n        Implies(is_color(bead1, 'orange'), Not(is_color(bead2, 'red'))),\n        Implies(is_color(bead1, 'red'), Not(is_color(bead2, 'orange')))\n    )\n    solver.add(no_orange_red_adjacent)\n\n# 4) Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n# Since the strand has exactly 8 beads, the entire strand must contain at least one bead of each color.\nfor c in colors:\n    solver.add(Or([is_color(beads[i], c) for i in range(n)]))\n\n# OPTION CHECKING\noptions = [\n    ['green', 'red', 'purple', 'yellow', 'red', 'orange', 'green', 'purple'],  # A\n    ['orange', 'yellow', 'red', 'red', 'yellow', 'purple', 'red', 'green'],    # B\n    ['purple', 'yellow', 'red', 'green', 'green', 'orange', 'yellow', 'orange'], # C\n    ['red', 'orange', 'red', 'yellow', 'purple', 'green', 'yellow', 'green'],  # D\n    ['red', 'yellow', 'purple', 'red', 'green', 'red', 'green', 'green']       # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this option: each bead fixed to the option color index\n    for pos in range(n):\n        solver.add(beads[pos] == color_indices[option[pos]])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A jeweler makes a single strand of beads by threading onto a string in a single direction from a clasp a series of solid-colored beads. Each bead is either green, orange, purple, red, or yellow. The resulting strand satisfies the following specifications: If a purple bead is adjacent to a yellow bead, any bead that immediately follows and any bead that immediately precedes that pair must be red. Any pair of beads adjacent to each other that are the same color as each other must be green. No orange bead can be adjacent to any red bead. Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n\nIf an orange bead is the fourth bead from the clasp, which one of the following is a pair that could be the second and third beads, respectively?\n\nOptions:\n(A) green, orange\n(B) green, red\n(C) purple, purple\n(D) yellow, green\n(E) yellow, purple",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'orange', 'purple', 'red', 'yellow']\ncolor_index = {c: i for i, c in enumerate(colors)}\n\n# Strand length: minimum 8 beads (since conditions mention any 8 consecutive beads)\n# We'll model exactly 8 beads since constraints apply to 8 consecutive beads\nN = 8\n\n# Create variables for each bead position (0-based index from the clasp)\nbeads = [Int(f'bead_{i}') for i in range(N)]\n\nsolver = Solver()\n\n# Each bead color index between 0 and 4\nfor b in beads:\n    solver.add(And(b >= 0, b < len(colors)))\n\n# Constraint: If a purple bead is adjacent to a yellow bead,\n# then any bead immediately before and immediately after that pair must be red.\n\n# For each adjacent pair (i, i+1), check if beads[i] and beads[i+1] are purple and yellow in either order\n# Then beads[i-1] and beads[i+2] (if in range) must be red\nfor i in range(N-1):\n    pair_purple_yellow = Or(\n        And(beads[i] == color_index['purple'], beads[i+1] == color_index['yellow']),\n        And(beads[i] == color_index['yellow'], beads[i+1] == color_index['purple'])\n    )\n    # If pair_purple_yellow and i-1 in range => beads[i-1] == red\n    if i-1 >= 0:\n        solver.add(Implies(pair_purple_yellow, beads[i-1] == color_index['red']))\n    # If pair_purple_yellow and i+2 in range => beads[i+2] == red\n    if i+2 < N:\n        solver.add(Implies(pair_purple_yellow, beads[i+2] == color_index['red']))\n\n# Constraint: Any pair of beads adjacent to each other that are the same color must be green.\n# So if beads[i] == beads[i+1], then that color must be green.\nfor i in range(N-1):\n    same_color = beads[i] == beads[i+1]\n    solver.add(Implies(same_color, beads[i] == color_index['green']))\n\n# Constraint: No orange bead can be adjacent to any red bead.\nfor i in range(N-1):\n    adj_orange_red = Or(\n        And(beads[i] == color_index['orange'], beads[i+1] == color_index['red']),\n        And(beads[i] == color_index['red'], beads[i+1] == color_index['orange'])\n    )\n    solver.add(Not(adj_orange_red))\n\n# Constraint: Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n# Since strand length is 8, the entire strand must have all colors at least once.\nfor c in colors:\n    color_c = color_index[c]\n    solver.add(Sum([If(beads[i] == color_c, 1, 0) for i in range(N)]) >= 1)\n\n# Given: An orange bead is the fourth bead from the clasp (index 3)\nsolver.add(beads[3] == color_index['orange'])\n\n# OPTION CHECKING\noptions = [\n    ('green', 'orange'),  # A\n    ('green', 'red'),     # B\n    ('purple', 'purple'), # C\n    ('yellow', 'green'),  # D\n    ('yellow', 'purple')  # E\n]\n\n# The pair is the second and third beads respectively (indices 1 and 2)\nfor i, (c1, c2) in enumerate(options):\n    solver.push()\n    solver.add(beads[1] == color_index[c1])\n    solver.add(beads[2] == color_index[c2])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A jeweler makes a single strand of beads by threading onto a string in a single direction from a clasp a series of solid-colored beads. Each bead is either green, orange, purple, red, or yellow. The resulting strand satisfies the following specifications: If a purple bead is adjacent to a yellow bead, any bead that immediately follows and any bead that immediately precedes that pair must be red. Any pair of beads adjacent to each other that are the same color as each other must be green. No orange bead can be adjacent to any red bead. Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n\nIf on an eight-bead strand the second, third, and fourth beads from the clasp are red, green, and yellow, respectively, and the sixth and seventh beads are purple and red, respectively, then which one of the following must be true?\n\nOptions:\n(A) The first bead is purple.\n(B) The fifth bead is green.\n(C) The fifth bead is orange.\n(D) The eighth bead is orange.\n(E) The eighth bead is yellow.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'orange', 'purple', 'red', 'yellow']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\nstrand_length = 8\nbeads = [Int(f'bead_{i+1}') for i in range(strand_length)]\n\nsolver = Solver()\n\n# Each bead color must be valid index\nfor b in beads:\n    solver.add(And(b >= 0, b < len(colors)))\n\n# Given fixed beads:\n# 2nd bead is red\nsolver.add(beads[1] == color_indices['red'])\n# 3rd bead is green\nsolver.add(beads[2] == color_indices['green'])\n# 4th bead is yellow\nsolver.add(beads[3] == color_indices['yellow'])\n# 6th bead is purple\nsolver.add(beads[5] == color_indices['purple'])\n# 7th bead is red\nsolver.add(beads[6] == color_indices['red'])\n\n# CONSTRAINTS\n\n# 1) If a purple bead is adjacent to a yellow bead,\n#    any bead that immediately follows and any bead that immediately precedes that pair must be red.\n# So for every adjacent pair (i, i+1):\n# if (bead_i == purple and bead_i+1 == yellow) or (bead_i == yellow and bead_i+1 == purple):\n# then bead_i-1 and bead_i+2 must be red if they exist.\n\nfor i in range(strand_length - 1):\n    bead_i = beads[i]\n    bead_next = beads[i+1]\n    pair_is_purple_yellow = Or(\n        And(bead_i == color_indices['purple'], bead_next == color_indices['yellow']),\n        And(bead_i == color_indices['yellow'], bead_next == color_indices['purple'])\n    )\n    # Preceding bead index\n    precedes_index = i - 1\n    # Following bead index\n    follows_index = i + 2\n\n    # If pair is purple-yellow or yellow-purple\n    # then bead at precedes_index and follows_index (if exist) must be red\n    conds = []\n    if precedes_index >= 0:\n        conds.append(beads[precedes_index] == color_indices['red'])\n    if follows_index < strand_length:\n        conds.append(beads[follows_index] == color_indices['red'])\n    if conds:\n        solver.add(Implies(pair_is_purple_yellow, And(conds)))\n\n# 2) Any pair of beads adjacent to each other that are the same color as each other must be green.\n# So if bead_i == bead_i+1 then bead_i == green\nfor i in range(strand_length - 1):\n    solver.add(Implies(beads[i] == beads[i+1], beads[i] == color_indices['green']))\n\n# 3) No orange bead can be adjacent to any red bead.\n# So for every adjacent pair (i, i+1):\n# not (bead_i == orange and bead_i+1 == red) and not (bead_i == red and bead_i+1 == orange)\nfor i in range(strand_length - 1):\n    cond1 = And(beads[i] == color_indices['orange'], beads[i+1] == color_indices['red'])\n    cond2 = And(beads[i] == color_indices['red'], beads[i+1] == color_indices['orange'])\n    solver.add(Not(Or(cond1, cond2)))\n\n# 4) Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n# Since strand length is 8, the entire strand must include at least one of each color.\nfor c in colors:\n    c_idx = color_indices[c]\n    # At least one bead equals c_idx\n    solver.add(Or([beads[i] == c_idx for i in range(strand_length)]))\n\n# OPTION CHECKING\noptions = [\n    ('A', beads[0] == color_indices['purple']),  # first bead is purple\n    ('B', beads[4] == color_indices['green']),   # fifth bead is green\n    ('C', beads[4] == color_indices['orange']),  # fifth bead is orange\n    ('D', beads[7] == color_indices['orange']),  # eighth bead is orange\n    ('E', beads[7] == color_indices['yellow']),  # eighth bead is yellow\n]\n\nfor letter, cond in options:\n    solver.push()\n    solver.add(Not(cond))  # check if option can be false\n    if solver.check() == unsat:\n        # If negation leads to unsat, option must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A jeweler makes a single strand of beads by threading onto a string in a single direction from a clasp a series of solid-colored beads. Each bead is either green, orange, purple, red, or yellow. The resulting strand satisfies the following specifications: If a purple bead is adjacent to a yellow bead, any bead that immediately follows and any bead that immediately precedes that pair must be red. Any pair of beads adjacent to each other that are the same color as each other must be green. No orange bead can be adjacent to any red bead. Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n\nIf on a six-bead strand the first and second beads from the clasp are purple and yellow, respectively, then the fifth and sixth beads CANNOT be\n\nOptions:\n(A) green and orange, respectively\n(B) orange and green, respectively\n(C) orange and yellow, respectively\n(D) purple and orange, respectively\n(E) yellow and purple, respectively",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'orange', 'purple', 'red', 'yellow']\ncolor_idx = {c: i for i, c in enumerate(colors)}\n\nstrand_length = 6\nbeads = [Int(f'bead_{i}') for i in range(strand_length)]\n\nsolver = Solver()\n\n# Each bead color is an integer index from 0 to 4\nfor b in beads:\n    solver.add(And(b >= 0, b < len(colors)))\n\n# CONSTRAINTS\n\n# 1) If a purple bead is adjacent to a yellow bead,\n#    any bead that immediately follows and any bead that immediately precedes that pair must be red.\n# We check pairs (i, i+1) for purple-yellow or yellow-purple pairs.\nfor i in range(strand_length - 1):\n    bead_i = beads[i]\n    bead_i1 = beads[i+1]\n\n    # Condition for purple-yellow or yellow-purple pair:\n    purple_yellow_pair = Or(\n        And(bead_i == color_idx['purple'], bead_i1 == color_idx['yellow']),\n        And(bead_i == color_idx['yellow'], bead_i1 == color_idx['purple'])\n    )\n\n    # If such pair exists, then bead before and after must be red if they exist\n    # bead before: i-1\n    # bead after: i+2\n    if i - 1 >= 0:\n        solver.add(Implies(purple_yellow_pair, beads[i-1] == color_idx['red']))\n    if i + 2 < strand_length:\n        solver.add(Implies(purple_yellow_pair, beads[i+2] == color_idx['red']))\n\n# 2) Any pair of beads adjacent to each other that are the same color must be green.\n# So if beads[i] == beads[i+1], then that color must be green.\nfor i in range(strand_length - 1):\n    same_color = beads[i] == beads[i+1]\n    solver.add(Implies(same_color, beads[i] == color_idx['green']))\n\n# 3) No orange bead can be adjacent to any red bead.\nfor i in range(strand_length - 1):\n    bead_i = beads[i]\n    bead_i1 = beads[i+1]\n    # If one is orange, the other cannot be red\n    solver.add(Not(Or(\n        And(bead_i == color_idx['orange'], bead_i1 == color_idx['red']),\n        And(bead_i == color_idx['red'], bead_i1 == color_idx['orange'])\n    )))\n\n# 4) Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n# The strand length is 6, so this constraint is trivially satisfied (no 8 consecutive beads).\n# So no constraint needed here.\n\n# Given: first bead is purple, second bead is yellow\nsolver.add(beads[0] == color_idx['purple'])\nsolver.add(beads[1] == color_idx['yellow'])\n\n# OPTION CHECKING\noptions = [\n    (color_idx['green'], color_idx['orange']),   # A: 5th green, 6th orange\n    (color_idx['orange'], color_idx['green']),   # B: 5th orange, 6th green\n    (color_idx['orange'], color_idx['yellow']),  # C: 5th orange, 6th yellow\n    (color_idx['purple'], color_idx['orange']),  # D: 5th purple, 6th orange\n    (color_idx['yellow'], color_idx['purple']),  # E: 5th yellow, 6th purple\n]\n\nfor i, (fifth, sixth) in enumerate(options):\n    solver.push()\n    solver.add(beads[4] == fifth)\n    solver.add(beads[5] == sixth)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A jeweler makes a single strand of beads by threading onto a string in a single direction from a clasp a series of solid-colored beads. Each bead is either green, orange, purple, red, or yellow. The resulting strand satisfies the following specifications: If a purple bead is adjacent to a yellow bead, any bead that immediately follows and any bead that immediately precedes that pair must be red. Any pair of beads adjacent to each other that are the same color as each other must be green. No orange bead can be adjacent to any red bead. Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n\nIf on a nine-bead strand the first and fourth beads from the clasp are purple, and the second and fifth beads are yellow, which one of the following could be true?\n\nOptions:\n(A) The seventh bead is orange.\n(B) The eighth bead is green.\n(C) The eighth bead is red.\n(D) The ninth bead is red.\n(E) The ninth bead is yellow.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'orange', 'purple', 'red', 'yellow']\ncolor_idx = {c: i for i, c in enumerate(colors)}\nn = 9  # number of beads\n\n# Create Z3 Int variables for each bead's color\nbeads = [Int(f'bead_{i+1}') for i in range(n)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each bead color is within valid indices\nfor b in beads:\n    solver.add(And(b >= 0, b < len(colors)))\n\n# Given fixed colors:\n# 1st bead is purple\nsolver.add(beads[0] == color_idx['purple'])\n# 4th bead is purple\nsolver.add(beads[3] == color_idx['purple'])\n# 2nd bead is yellow\nsolver.add(beads[1] == color_idx['yellow'])\n# 5th bead is yellow\nsolver.add(beads[4] == color_idx['yellow'])\n\n# Constraint 1:\n# If a purple bead is adjacent to a yellow bead,\n# any bead that immediately follows and any bead that immediately precedes that pair must be red.\n# For all adjacent pairs i,i+1:\nfor i in range(n-1):\n    bead_i = beads[i]\n    bead_ip1 = beads[i+1]\n    # Check if purple-yellow or yellow-purple adjacent pair\n    purple_yellow = Or(\n        And(bead_i == color_idx['purple'], bead_ip1 == color_idx['yellow']),\n        And(bead_i == color_idx['yellow'], bead_ip1 == color_idx['purple'])\n    )\n    # If such pair, then bead before i (if any) and bead after i+1 (if any) must be red\n    if i - 1 >= 0:\n        solver.add(Implies(purple_yellow, beads[i-1] == color_idx['red']))\n    else:\n        # If no bead before i, then no constraint on that side\n        pass\n    if i + 2 < n:\n        solver.add(Implies(purple_yellow, beads[i+2] == color_idx['red']))\n    else:\n        # If no bead after i+1, no constraint on that side\n        pass\n\n# Constraint 2:\n# Any pair of beads adjacent to each other that are the same color must be green.\n# For all adjacent pairs i,i+1:\nfor i in range(n-1):\n    # If beads are same color, then that color must be green\n    same_color = beads[i] == beads[i+1]\n    solver.add(Implies(same_color, beads[i] == color_idx['green']))\n\n# Constraint 3:\n# No orange bead can be adjacent to any red bead.\nfor i in range(n-1):\n    bead_i = beads[i]\n    bead_ip1 = beads[i+1]\n    # If one is orange and the other is red, forbid\n    solver.add(Not(Or(\n        And(bead_i == color_idx['orange'], bead_ip1 == color_idx['red']),\n        And(bead_i == color_idx['red'], bead_ip1 == color_idx['orange'])\n    )))\n\n# Constraint 4:\n# Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n# There are 2 such portions in 9 beads: beads 1-8 and beads 2-9\nfor start in [0,1]:\n    segment = beads[start:start+8]\n    for c in colors:\n        c_i = color_idx[c]\n        # At least one bead in segment is color c\n        solver.add(Or([b == c_i for b in segment]))\n\n# OPTION CHECKING\noptions = ['A', 'B', 'C', 'D', 'E']\n# (A) The seventh bead is orange.\n# (B) The eighth bead is green.\n# (C) The eighth bead is red.\n# (D) The ninth bead is red.\n# (E) The ninth bead is yellow.\n\noption_constraints = [\n    beads[6] == color_idx['orange'],\n    beads[7] == color_idx['green'],\n    beads[7] == color_idx['red'],\n    beads[8] == color_idx['red'],\n    beads[8] == color_idx['yellow'],\n]\n\nfor i, oc in enumerate(option_constraints):\n    solver.push()\n    solver.add(oc)\n    if solver.check() == sat:\n        print(f\"'{options[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A jeweler makes a single strand of beads by threading onto a string in a single direction from a clasp a series of solid-colored beads. Each bead is either green, orange, purple, red, or yellow. The resulting strand satisfies the following specifications: If a purple bead is adjacent to a yellow bead, any bead that immediately follows and any bead that immediately precedes that pair must be red. Any pair of beads adjacent to each other that are the same color as each other must be green. No orange bead can be adjacent to any red bead. Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n\nIf on an eight-bead strand the first, second, third, and fourth beads from the clasp are red, yellow, green, and red, respectively, then the fifth and sixth beads CANNOT be\n\nOptions:\n(A) green and orange, respectively\n(B) green and purple, respectively\n(C) purple and orange, respectively\n(D) purple and yellow, respectively\n(E) yellow and orange, respectively",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\ncolors = ['green', 'orange', 'purple', 'red', 'yellow']\ncolor_idx = {c: i for i, c in enumerate(colors)}\n\n# Strand length is 8 beads\nstrand_length = 8\n\n# Create variables for each bead position: 0-based indexing\nbeads = [Int(f'bead_{i}') for i in range(strand_length)]\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each bead color index must be valid\nfor b in beads:\n    solver.add(And(b >= 0, b < len(colors)))\n\n# Given beads 1 to 4 (0-based: 0 to 3)\nsolver.add(beads[0] == color_idx['red'])\nsolver.add(beads[1] == color_idx['yellow'])\nsolver.add(beads[2] == color_idx['green'])\nsolver.add(beads[3] == color_idx['red'])\n\n# Constraint 1:\n# If a purple bead is adjacent to a yellow bead,\n# any bead that immediately follows and any bead that immediately precedes that pair must be red.\n\n# Check all adjacent pairs for purple-yellow adjacency in either order\nfor i in range(strand_length - 1):\n    pair_purple_yellow = Or(\n        And(beads[i] == color_idx['purple'], beads[i+1] == color_idx['yellow']),\n        And(beads[i] == color_idx['yellow'], beads[i+1] == color_idx['purple'])\n    )\n    # If pair found, beads immediately before and after must be red (if they exist)\n    if i - 1 >= 0:\n        solver.add(Implies(pair_purple_yellow, beads[i-1] == color_idx['red']))\n    if i + 2 < strand_length:\n        solver.add(Implies(pair_purple_yellow, beads[i+2] == color_idx['red']))\n\n# Constraint 2:\n# Any pair of beads adjacent to each other that are the same color must be green\n# That means if two adjacent beads are equal, then they must be green\n\nfor i in range(strand_length - 1):\n    same_color = beads[i] == beads[i+1]\n    solver.add(Implies(same_color, beads[i] == color_idx['green']))\n\n# Constraint 3:\n# No orange bead can be adjacent to any red bead\n\nfor i in range(strand_length - 1):\n    bead_i_or_red = Or(beads[i] == color_idx['orange'], beads[i+1] == color_idx['orange'])\n    bead_i_red = Or(beads[i] == color_idx['red'], beads[i+1] == color_idx['red'])\n    # If one is orange and the other is red, forbidden\n    solver.add(Not(And(bead_i_or_red, bead_i_red)))\n\n# Constraint 4:\n# Any portion of the strand containing eight consecutive beads must include at least one bead of each color.\n# The strand is length 8, so the entire strand must contain all colors at least once.\n\nfor c in range(len(colors)):\n    solver.add(Or([beads[i] == c for i in range(strand_length)]))\n\n# OPTION CHECKING\n\n# Options: pairs for beads 5 and 6 (0-based: beads[4], beads[5])\noptions = [\n    (color_idx['green'], color_idx['orange']),   # A\n    (color_idx['green'], color_idx['purple']),   # B\n    (color_idx['purple'], color_idx['orange']),  # C\n    (color_idx['purple'], color_idx['yellow']),  # D\n    (color_idx['yellow'], color_idx['orange'])   # E\n]\n\nfor i, (c5, c6) in enumerate(options):\n    solver.push()\n    solver.add(beads[4] == c5)\n    solver.add(beads[5] == c6)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "At an evening concert, a total of six songs—O, P, T, X, Y, and Z—will be performed by three vocalists—George, Helen, and Leslie. The songs will be sung consecutively as solos, and each will be performed exactly once. The following constraints govern the composition of the concert program: Y must be performed earlier than T and earlier than O. P must be performed earlier than Z and later than O. George can perform only X, Y, and Z. Helen can perform only T, P, and X. Leslie can perform only O, P, and X. The vocalist who performs first must be different from the vocalist who performs last.\n\nWhich one of the following is an acceptable schedule for the performance of the songs, in order from the first to last song performed?\n\nOptions:\n(A) X, T, Y, O, P, Z\n(B) X, Z, Y, T, O, P\n(C) Y, O, P, X, T, Z\n(D) Y, P, O, Z, T, X\n(E) Y, X, O, P, Z, T",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nsongs = ['O', 'P', 'T', 'X', 'Y', 'Z']\nvocalists = ['George', 'Helen', 'Leslie']\n\n# Map songs and vocalists to indices\nsong_indices = {s: i for i, s in enumerate(songs)}\nvocalist_indices = {v: i for i, v in enumerate(vocalists)}\n\n# Variables:\n# order[s]: position (0 to 5) of song s in the performance order\norder = {s: Int(f'order_{s}') for s in songs}\n\n# singer[s]: vocalist who sings song s (0=George,1=Helen,2=Leslie)\nsinger = {s: Int(f'singer_{s}') for s in songs}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are between 0 and 5\nfor s in songs:\n    solver.add(And(order[s] >= 0, order[s] < 6))\n\n# All songs have distinct positions\nsolver.add(Distinct([order[s] for s in songs]))\n\n# Vocalist constraints per song\n# George: X,Y,Z\n# Helen: T,P,X\n# Leslie: O,P,X\n\n# Allowed singers per song:\nallowed_singers = {\n    'O': [vocalist_indices['Leslie']],\n    'P': [vocalist_indices['Helen'], vocalist_indices['Leslie']],\n    'T': [vocalist_indices['Helen']],\n    'X': [vocalist_indices['George'], vocalist_indices['Helen'], vocalist_indices['Leslie']],\n    'Y': [vocalist_indices['George']],\n    'Z': [vocalist_indices['George']],\n}\n\nfor s in songs:\n    solver.add(Or([singer[s] == v for v in allowed_singers[s]]))\n\n# Y must be before T and before O\nsolver.add(order['Y'] < order['T'])\nsolver.add(order['Y'] < order['O'])\n\n# P must be after O and before Z\nsolver.add(order['P'] > order['O'])\nsolver.add(order['P'] < order['Z'])\n\n# The vocalist who performs first must be different from the vocalist who performs last\n# Find song at position 0 and song at position 5\n# We can do this by asserting for each song that if order[s]==0 then singer_first = singer[s], similarly for last\nsinger_first = Int('singer_first')\nsinger_last = Int('singer_last')\n\n# For each song s, create condition order[s]==0 => singer_first = singer[s]\nsolver.add(Or([And(order[s] == 0, singer_first == singer[s]) for s in songs]))\nsolver.add(Or([And(order[s] == 5, singer_last == singer[s]) for s in songs]))\n\nsolver.add(singer_first != singer_last)\n\n# OPTION CHECKING\n\noptions = {\n    'A': ['X', 'T', 'Y', 'O', 'P', 'Z'],\n    'B': ['X', 'Z', 'Y', 'T', 'O', 'P'],\n    'C': ['Y', 'O', 'P', 'X', 'T', 'Z'],\n    'D': ['Y', 'P', 'O', 'Z', 'T', 'X'],\n    'E': ['Y', 'X', 'O', 'P', 'Z', 'T'],\n}\n\nfor letter, schedule in options.items():\n    solver.push()\n    # Add constraints that order of each song matches the schedule order\n    # order[song] == position in schedule\n    for pos, song in enumerate(schedule):\n        solver.add(order[song] == pos)\n    # Check if model is satisfiable with these constraints\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "At an evening concert, a total of six songs—O, P, T, X, Y, and Z—will be performed by three vocalists—George, Helen, and Leslie. The songs will be sung consecutively as solos, and each will be performed exactly once. The following constraints govern the composition of the concert program: Y must be performed earlier than T and earlier than O. P must be performed earlier than Z and later than O. George can perform only X, Y, and Z. Helen can perform only T, P, and X. Leslie can perform only O, P, and X. The vocalist who performs first must be different from the vocalist who performs last.\n\nWhich one of the following must be true about the program?\n\nOptions:\n(A) George performs X.\n(B) Helen performs O.\n(C) Helen performs T.\n(D) Leslie performs P.\n(E) Leslie performs X.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Songs and their indices\nsongs = ['O', 'P', 'T', 'X', 'Y', 'Z']\nsong_indices = {song: i for i, song in enumerate(songs)}\n\n# Vocalists and their indices\nvocalists = ['George', 'Helen', 'Leslie']\nvocalist_indices = {v: i for i, v in enumerate(vocalists)}\n\nnum_songs = len(songs)\nnum_vocalists = len(vocalists)\n\n# For each song, define:\n# - position in the program (0 to 5)\n# - vocalist who performs it (0 to 2)\npos = [Int(f'pos_{s}') for s in songs]          # position of each song in the sequence\nsinger = [Int(f'singer_{s}') for s in songs]    # vocalist who sings each song\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are distinct integers from 0 to 5\nfor p in pos:\n    solver.add(And(p >= 0, p < num_songs))\nsolver.add(Distinct(pos))\n\n# Vocalists assigned to songs are valid indices\nfor s in singer:\n    solver.add(And(s >= 0, s < num_vocalists))\n\n# Each song performed exactly once (position uniqueness already ensured)\n# Each position has exactly one song (ensured by Distinct on pos)\n\n# Vocalist-song restrictions:\n# George can perform only X, Y, Z\n# Helen can perform only T, P, X\n# Leslie can perform only O, P, X\n\n# Map vocalist indices for clarity\nG = vocalist_indices['George']\nH = vocalist_indices['Helen']\nL = vocalist_indices['Leslie']\n\n# For each song, constrain the singer:\n# If song is X, singer in {G,H,L} (all can perform X)\n# For other songs, restrict accordingly\n\nfor i, s in enumerate(songs):\n    if s == 'X':\n        # Any vocalist can perform X\n        solver.add(Or([singer[i] == G, singer[i] == H, singer[i] == L]))\n    elif s == 'Y':\n        # Only George\n        solver.add(singer[i] == G)\n    elif s == 'Z':\n        # Only George\n        solver.add(singer[i] == G)\n    elif s == 'T':\n        # Only Helen\n        solver.add(singer[i] == H)\n    elif s == 'P':\n        # Helen or Leslie\n        solver.add(Or(singer[i] == H, singer[i] == L))\n    elif s == 'O':\n        # Only Leslie\n        solver.add(singer[i] == L)\n\n# Order constraints:\n# Y before T and before O\nsolver.add(pos[song_indices['Y']] < pos[song_indices['T']])\nsolver.add(pos[song_indices['Y']] < pos[song_indices['O']])\n\n# P after O and before Z\nsolver.add(pos[song_indices['P']] > pos[song_indices['O']])\nsolver.add(pos[song_indices['P']] < pos[song_indices['Z']])\n\n# The vocalist who performs first must be different from the vocalist who performs last\n# Find which song is at position 0 and which at position 5, then their singers differ\n\n# Create variables for first and last song indices\nfirst_song = Int('first_song')\nlast_song = Int('last_song')\n\nsolver.add(first_song >= 0, first_song < num_songs)\nsolver.add(last_song >= 0, last_song < num_songs)\n\n# first_song is the index of the song performed at position 0\n# last_song is the index of the song performed at position 5\n\n# For each song i: if pos[i] == 0 then first_song == i\nsolver.add(Or([And(pos[i] == 0, first_song == i) for i in range(num_songs)]))\nsolver.add(Or([And(pos[i] == 5, last_song == i) for i in range(num_songs)]))\n\n# The singers of first_song and last_song differ\nfirst_singer = Int('first_singer')\nlast_singer = Int('last_singer')\n\nsolver.add(Or([And(first_song == i, first_singer == singer[i]) for i in range(num_songs)]))\nsolver.add(Or([And(last_song == i, last_singer == singer[i]) for i in range(num_songs)]))\n\nsolver.add(first_singer != last_singer)\n\n# OPTION CHECKING\n\n# Options:\n# (A) George performs X.\n# (B) Helen performs O.\n# (C) Helen performs T.\n# (D) Leslie performs P.\n# (E) Leslie performs X.\n\noptions = []\n\n# A: George performs X\nA = singer[song_indices['X']] == G\noptions.append(A)\n\n# B: Helen performs O\nB = singer[song_indices['O']] == H\noptions.append(B)\n\n# C: Helen performs T\nC = singer[song_indices['T']] == H\noptions.append(C)\n\n# D: Leslie performs P\nD = singer[song_indices['P']] == L\noptions.append(D)\n\n# E: Leslie performs X\nE = singer[song_indices['X']] == L\noptions.append(E)\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add negation of the option to check if it's not necessarily true\n    solver.add(Not(opt))\n    if solver.check() == unsat:\n        # The negation is unsatisfiable => option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "At an evening concert, a total of six songs—O, P, T, X, Y, and Z—will be performed by three vocalists—George, Helen, and Leslie. The songs will be sung consecutively as solos, and each will be performed exactly once. The following constraints govern the composition of the concert program: Y must be performed earlier than T and earlier than O. P must be performed earlier than Z and later than O. George can perform only X, Y, and Z. Helen can perform only T, P, and X. Leslie can perform only O, P, and X. The vocalist who performs first must be different from the vocalist who performs last.\n\nIf Y is performed first, the songs performed second, third, and fourth, respectively, could be\n\nOptions:\n(A) T, X, and O\n(B) T, Z, and O\n(C) X, O, and P\n(D) X, P, and Z\n(E) X, T, and O",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsongs = ['O', 'P', 'T', 'X', 'Y', 'Z']\nvocalists = ['George', 'Helen', 'Leslie']\n\nsong_indices = {s: i for i, s in enumerate(songs)}\nvocalist_indices = {v: i for i, v in enumerate(vocalists)}\n\n# Position of each song: integer 0..5\npos = {s: Int(f'pos_{s}') for s in songs}\n\n# Vocalist performing each song: integer 0..2\nvocalist = {s: Int(f'vocalist_{s}') for s in songs}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are between 0 and 5\nfor s in songs:\n    solver.add(And(pos[s] >= 0, pos[s] <= 5))\n\n# All positions are distinct (each song performed exactly once)\nsolver.add(Distinct([pos[s] for s in songs]))\n\n# Vocalists are between 0 and 2\nfor s in songs:\n    solver.add(And(vocalist[s] >= 0, vocalist[s] <= 2))\n\n# Vocalist restrictions\n# George: X, Y, Z only\nfor s in songs:\n    if s not in ['X', 'Y', 'Z']:\n        solver.add(vocalist[s] != vocalist_indices['George'])\n# Helen: T, P, X only\nfor s in songs:\n    if s not in ['T', 'P', 'X']:\n        solver.add(vocalist[s] != vocalist_indices['Helen'])\n# Leslie: O, P, X only\nfor s in songs:\n    if s not in ['O', 'P', 'X']:\n        solver.add(vocalist[s] != vocalist_indices['Leslie'])\n\n# Y must be earlier than T and O\nsolver.add(pos['Y'] < pos['T'])\nsolver.add(pos['Y'] < pos['O'])\n\n# P must be earlier than Z and later than O\nsolver.add(pos['P'] < pos['Z'])\nsolver.add(pos['P'] > pos['O'])\n\n# The vocalist who performs first is different from the vocalist who performs last\n# Find first and last positions\n# First position = 0, last position = 5\n# Find which song is at position 0 and 5\n# Create helper variables for first and last vocalist\nfirst_vocalist = Int('first_vocalist')\nlast_vocalist = Int('last_vocalist')\n\n# For each song, add conditions: if pos[s] == 0 then first_vocalist == vocalist[s]\nsolver.add(Or([And(pos[s] == 0, first_vocalist == vocalist[s]) for s in songs]))\nsolver.add(Or([And(pos[s] == 5, last_vocalist == vocalist[s]) for s in songs]))\n\nsolver.add(first_vocalist != last_vocalist)\n\n# The question: If Y is performed first (pos[Y] == 0),\n# which of the options for songs performed second, third, and fourth respectively could be true?\n\noptions = [\n    ['T', 'X', 'O'],  # A\n    ['T', 'Z', 'O'],  # B\n    ['X', 'O', 'P'],  # C\n    ['X', 'P', 'Z'],  # D\n    ['X', 'T', 'O']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Y is first\n    solver.add(pos['Y'] == 0)\n    # Songs in second, third, fourth positions are option[0], option[1], option[2]\n    solver.add(pos[option[0]] == 1)\n    solver.add(pos[option[1]] == 2)\n    solver.add(pos[option[2]] == 3)\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven students—fourth-year students Kim and Lee; third-year students Pat and Robin; and second-year students Sandy, Terry, and Val—and only those seven, are being assigned to rooms of equal size in a dormitory. Each room assigned must have either one, or two, or three students assigned to it, and will accordingly be called either a single, or a double, or a triple. The seven students are assigned to rooms in accordance with the following conditions: No fourth-year student can be assigned to a triple. No second-year student can be assigned to a single. Lee and Robin must not share the same room. Kim and Pat must share the same room.\n\nWhich one of the following is a combination of rooms to which the seven students could be assigned?\n\nOptions:\n(A) two triples and one single\n(B) one triple and four singles\n(C) three doubles and a single\n(D) two doubles and three singles\n(E) one double and five singles",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Kim', 'Lee', 'Pat', 'Robin', 'Sandy', 'Terry', 'Val']\nyears = {'Kim':4, 'Lee':4, 'Pat':3, 'Robin':3, 'Sandy':2, 'Terry':2, 'Val':2}\n\n# Room size options for each option letter\noption_room_sizes = {\n    'A': [3,3,1],         # two triples and one single\n    'B': [3,1,1,1,1],     # one triple and four singles\n    'C': [2,2,2,1],       # three doubles and a single\n    'D': [2,2,1,1,1],     # two doubles and three singles\n    'E': [2,1,1,1,1,1]    # one double and five singles\n}\n\n# Maximum rooms needed is 6 (for option E)\nmax_rooms = 6\n\n# Create variables: room assignment for each student (integer from 0 to max_rooms-1)\nroom = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student's room must be between 0 and max_rooms-1\nfor s in students:\n    solver.add(And(room[s] >= 0, room[s] < max_rooms))\n\n# Helper function to get list of students in a given room for a model\ndef students_in_room(model, r):\n    return [s for s in students if model.eval(room[s]).as_long() == r]\n\n# OPTION CHECKING\nfor option_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    roomsizes = option_room_sizes[option_letter]\n    n_rooms = len(roomsizes)\n\n    # Restrict room assignments to only rooms 0..n_rooms-1\n    for s in students:\n        solver.add(room[s] < n_rooms)\n\n    # For each room, count how many students assigned to it\n    for r in range(n_rooms):\n        count_in_room = Sum([If(room[s] == r, 1, 0) for s in students])\n        # Room size must match one of the sizes in roomsizes at position r\n        # So count_in_room == roomsizes[r]\n        solver.add(count_in_room == roomsizes[r])\n\n    # No fourth-year student can be assigned to a triple (room of size 3)\n    for r in range(n_rooms):\n        if roomsizes[r] == 3:\n            for s in students:\n                if years[s] == 4:\n                    solver.add(room[s] != r)\n\n    # No second-year student can be assigned to a single (room of size 1)\n    for r in range(n_rooms):\n        if roomsizes[r] == 1:\n            for s in students:\n                if years[s] == 2:\n                    solver.add(room[s] != r)\n\n    # Lee and Robin must not share the same room\n    solver.add(room['Lee'] != room['Robin'])\n\n    # Kim and Pat must share the same room\n    solver.add(room['Kim'] == room['Pat'])\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven students—fourth-year students Kim and Lee; third-year students Pat and Robin; and second-year students Sandy, Terry, and Val—and only those seven, are being assigned to rooms of equal size in a dormitory. Each room assigned must have either one, or two, or three students assigned to it, and will accordingly be called either a single, or a double, or a triple. The seven students are assigned to rooms in accordance with the following conditions: No fourth-year student can be assigned to a triple. No second-year student can be assigned to a single. Lee and Robin must not share the same room. Kim and Pat must share the same room.\n\nIf the room assigned to Robin is a single, which one of the following could be true?\n\nOptions:\n(A) There is exactly one double that has a second-year student assigned to it.\n(B) Lee is assigned to a single.\n(C) Sandy, Pat and one other student are assigned to a triple together.\n(D) Exactly three of the rooms assigned to the students are singles.\n(E) Exactly two of the rooms assigned to the students are doubles.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Kim', 'Lee', 'Pat', 'Robin', 'Sandy', 'Terry', 'Val']\nyears = {'Kim': 4, 'Lee': 4, 'Pat': 3, 'Robin': 3, 'Sandy': 2, 'Terry': 2, 'Val': 2}\n\n# Each student assigned to a room number (0 to 6, max 7 rooms)\nroom_ids = [i for i in range(7)]\nroom = {s: Int(s) for s in students}\n\n# Room sizes: size of room i = number of students assigned to room i\nroom_size = [Int(f\"room_size_{i}\") for i in room_ids]\n\n# Room types: 1=single, 2=double, 3=triple, 0=unused (no students assigned)\n# We will constrain room_size[i] in {0,1,2,3}\n# Only consider rooms with size > 0 as actual rooms\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student assigned to a valid room id 0..6\nfor s in students:\n    solver.add(And(room[s] >= 0, room[s] < 7))\n\n# Define room_size[i] = number of students assigned to room i\nfor i in room_ids:\n    count_i = Sum([If(room[s] == i, 1, 0) for s in students])\n    solver.add(room_size[i] == count_i)\n    # room_size[i] in {0,1,2,3}\n    solver.add(Or(room_size[i] == 0, room_size[i] == 1, room_size[i] == 2, room_size[i] == 3))\n\n# All students assigned exactly one room, so total students = 7\nsolver.add(Sum(room_size) == 7)\n\n# No fourth-year student can be assigned to a triple (room of size 3)\nfor s in ['Kim', 'Lee']:\n    # room_size of room[s] != 3\n    # Use element constraint: room_size[room[s]] != 3\n    # Z3 does not support direct array indexing with variables, so we do:\n    # For i in room_ids: if room[s] == i then room_size[i] != 3\n    conds = [And(room[s] == i, room_size[i] != 3) for i in room_ids]\n    solver.add(Or(conds))\n\n# No second-year student can be assigned to a single (room of size 1)\nfor s in ['Sandy', 'Terry', 'Val']:\n    conds = [And(room[s] == i, room_size[i] != 1) for i in room_ids]\n    solver.add(Or(conds))\n\n# Lee and Robin must not share the same room\nsolver.add(room['Lee'] != room['Robin'])\n\n# Kim and Pat must share the same room\nsolver.add(room['Kim'] == room['Pat'])\n\n# Additional condition: Robin's room is a single\n# Robin assigned to room r, room_size[r] == 1\nconds = [And(room['Robin'] == i, room_size[i] == 1) for i in room_ids]\nsolver.add(Or(conds))\n\n# OPTION CHECKING\n\n# We will check each option by adding its condition and testing satisfiability\n\n# Helper functions:\n\ndef count_rooms_of_size(n):\n    # Count how many rooms have size n (excluding size 0)\n    return Sum([If(room_size[i] == n, 1, 0) for i in room_ids])\n\ndef second_year_in_room(i):\n    # Returns BoolExpr: True if any second-year student assigned to room i\n    return Or([room[s] == i for s in ['Sandy', 'Terry', 'Val']])\n\n# Option (A):\n# There is exactly one double that has a second-year student assigned to it.\n\nsolver.push()\n# Count doubles with second-year student\ndoubles_with_second_year = Sum([If(And(room_size[i] == 2, second_year_in_room(i)), 1, 0) for i in room_ids])\nsolver.add(doubles_with_second_year == 1)\nif solver.check() == sat:\n    print(\"'A'\")\n    solver.pop()\n    exit()\nsolver.pop()\n\n# Option (B):\n# Lee is assigned to a single.\n\nsolver.push()\nconds = [And(room['Lee'] == i, room_size[i] == 1) for i in room_ids]\nsolver.add(Or(conds))\nif solver.check() == sat:\n    print(\"'B'\")\n    solver.pop()\n    exit()\nsolver.pop()\n\n# Option (C):\n# Sandy, Pat and one other student are assigned to a triple together.\n\nsolver.push()\n# Find a room of size 3 that contains Sandy and Pat and one other student\n\n# For each room i of size 3, check if Sandy and Pat and one other student assigned to i\npossible = []\nfor i in room_ids:\n    # room_size[i] == 3\n    # room[Sandy] == i and room[Pat] == i and exists one other student s != Sandy, Pat with room[s] == i\n    others = [s for s in students if s != 'Sandy' and s != 'Pat']\n    others_assigned = [room[s] == i for s in others]\n    one_other = Or(others_assigned)\n    cond = And(room_size[i] == 3, room['Sandy'] == i, room['Pat'] == i, one_other)\n    possible.append(cond)\nsolver.add(Or(possible))\nif solver.check() == sat:\n    print(\"'C'\")\n    solver.pop()\n    exit()\nsolver.pop()\n\n# Option (D):\n# Exactly three of the rooms assigned to the students are singles.\n\nsolver.push()\nsolver.add(count_rooms_of_size(1) == 3)\nif solver.check() == sat:\n    print(\"'D'\")\n    solver.pop()\n    exit()\nsolver.pop()\n\n# Option (E):\n# Exactly two of the rooms assigned to the students are doubles.\n\nsolver.push()\nsolver.add(count_rooms_of_size(2) == 2)\nif solver.check() == sat:\n    print(\"'E'\")\n    solver.pop()\n    exit()\nsolver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Seven students—fourth-year students Kim and Lee; third-year students Pat and Robin; and second-year students Sandy, Terry, and Val—and only those seven, are being assigned to rooms of equal size in a dormitory. Each room assigned must have either one, or two, or three students assigned to it, and will accordingly be called either a single, or a double, or a triple. The seven students are assigned to rooms in accordance with the following conditions: No fourth-year student can be assigned to a triple. No second-year student can be assigned to a single. Lee and Robin must not share the same room. Kim and Pat must share the same room.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Lee is assigned to a single.\n(B) Pat shares a double with another student.\n(C) Robin shares a double with another student.\n(D) Two of the second-year students share a double with each other.\n(E) Neither of the third-year students is assigned to a single.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Kim', 'Lee', 'Pat', 'Robin', 'Sandy', 'Terry', 'Val']\nyears = {'Kim': 4, 'Lee': 4, 'Pat': 3, 'Robin': 3, 'Sandy': 2, 'Terry': 2, 'Val': 2}\n\n# Rooms can be singles, doubles, or triples\nroom_sizes = [1, 2, 3]\n\n# We don't know how many rooms there are, but since max room size is 3 and we have 7 students,\n# minimum rooms needed is 3 (3+3+1), maximum is 7 (all singles).\n# Let's assume 4 rooms (since we have constraints that force some sharing).\n# We'll model room assignment as: each student assigned to a room number 0..3\nnum_rooms = 4\nroom_indices = list(range(num_rooms))\n\n# Create Z3 Int variables for each student's room assignment (room number)\nroom = {s: Int(s) for s in students}\n\n# Create Z3 Int variables for each room's size (1, 2, or 3)\nroom_size = [Int(f'room_size_{i}') for i in room_indices]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student's room assignment must be a valid room index\nfor s in students:\n    solver.add(And(room[s] >= 0, room[s] < num_rooms))\n\n# Each room's size must be 1, 2, or 3\nfor i in room_indices:\n    solver.add(Or([room_size[i] == sz for sz in room_sizes]))\n\n# The number of students assigned to each room must match the room size\nfor i in room_indices:\n    count_in_room = Sum([If(room[s] == i, 1, 0) for s in students])\n    solver.add(room_size[i] == count_in_room)\n\n# No fourth-year student can be assigned to a triple\nfor s in students:\n    if years[s] == 4:\n        # room_size of student's room != 3\n        s_room = room[s]\n        # room_size[s_room] != 3\n        # We cannot index room_size by variable, so use implication:\n        # For each room i: if s_room == i then room_size[i] != 3\n        solver.add(Or([And(s_room == i, room_size[i] != 3) for i in room_indices]))\n\n# No second-year student can be assigned to a single\nfor s in students:\n    if years[s] == 2:\n        s_room = room[s]\n        # For each room i: if s_room == i then room_size[i] != 1\n        solver.add(Or([And(s_room == i, room_size[i] != 1) for i in room_indices]))\n\n# Lee and Robin must not share the same room\nsolver.add(room['Lee'] != room['Robin'])\n\n# Kim and Pat must share the same room\nsolver.add(room['Kim'] == room['Pat'])\n\n# OPTION CHECKING\n\n# Define option constraints as functions\ndef option_A():\n    # Lee is assigned to a single\n    s_room = room['Lee']\n    return Or([And(s_room == i, room_size[i] == 1) for i in room_indices])\n\ndef option_B():\n    # Pat shares a double with another student\n    # Pat's room size is 2\n    s_room = room['Pat']\n    return Or([And(s_room == i, room_size[i] == 2) for i in room_indices])\n\ndef option_C():\n    # Robin shares a double with another student\n    s_room = room['Robin']\n    return Or([And(s_room == i, room_size[i] == 2) for i in room_indices])\n\ndef option_D():\n    # Two of the second-year students share a double with each other\n    # There is a room of size 2 that contains exactly two second-year students\n    # For each room i:\n    #   room_size[i] == 2 and count of second-year students assigned to i == 2\n    res = []\n    second_year_students = [s for s in students if years[s] == 2]\n    for i in room_indices:\n        count_second_year = Sum([If(room[s] == i, 1, 0) for s in second_year_students])\n        cond = And(room_size[i] == 2, count_second_year == 2)\n        res.append(cond)\n    return Or(res)\n\ndef option_E():\n    # Neither of the third-year students is assigned to a single\n    # For Pat and Robin, their rooms are not singles\n    res = []\n    for s in ['Pat', 'Robin']:\n        s_room = room[s]\n        res.append(Or([And(s_room == i, room_size[i] != 1) for i in room_indices]))\n    return And(res)\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\n# Check which option must be true\nfor i, opt_func in enumerate(options):\n    solver.push()\n    # Add negation of option to check if it can be false\n    solver.add(Not(opt_func()))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Seven students—fourth-year students Kim and Lee; third-year students Pat and Robin; and second-year students Sandy, Terry, and Val—and only those seven, are being assigned to rooms of equal size in a dormitory. Each room assigned must have either one, or two, or three students assigned to it, and will accordingly be called either a single, or a double, or a triple. The seven students are assigned to rooms in accordance with the following conditions: No fourth-year student can be assigned to a triple. No second-year student can be assigned to a single. Lee and Robin must not share the same room. Kim and Pat must share the same room.\n\nWhich one of the following could be true?\n\nOptions:\n(A) The two fourth-year students are assigned to singles.\n(B) The two fourth-year students share a double with each other.\n(C) Lee shares a room with a second-year student.\n(D) Lee shares a room with a third-year student\n(E) Pat shares a triple with two other students.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Kim', 'Lee', 'Pat', 'Robin', 'Sandy', 'Terry', 'Val']\nyears = {\n    'Kim': 4,\n    'Lee': 4,\n    'Pat': 3,\n    'Robin': 3,\n    'Sandy': 2,\n    'Terry': 2,\n    'Val': 2\n}\n\n# We will assign each student a room number (integer)\n# The number of rooms is at most 7 (each student alone)\n# Room sizes can be 1, 2, or 3\nmax_rooms = 7\nroom_nums = list(range(max_rooms))\n\n# Create Z3 Int variables for each student's room assignment\nroom = {s: Int(s) for s in students}\n\n# Create Z3 Int variables for each room's size (0 if unused)\nroom_size = [Int(f\"room_size_{i}\") for i in room_nums]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student's room must be a valid room number\nfor s in students:\n    solver.add(And(room[s] >= 0, room[s] < max_rooms))\n\n# Room sizes between 0 and 3 (0 means no one assigned)\nfor i in room_nums:\n    solver.add(And(room_size[i] >= 0, room_size[i] <= 3))\n\n# The room_size[i] must equal the count of students assigned to room i\nfor i in room_nums:\n    count_in_room = Sum([If(room[s] == i, 1, 0) for s in students])\n    solver.add(room_size[i] == count_in_room)\n\n# Each room used must have size 1, 2, or 3 (if room_size[i] > 0)\nfor i in room_nums:\n    solver.add(Or(room_size[i] == 0, room_size[i] == 1, room_size[i] == 2, room_size[i] == 3))\n\n# All students assigned to some room (room_size sum must be 7)\ntotal_assigned = Sum(room_size)\nsolver.add(total_assigned == 7)\n\n# No fourth-year student can be assigned to a triple (room with size 3)\nfor s in students:\n    if years[s] == 4:\n        # For the room that s is assigned to, that room's size != 3\n        # room[s] is the room index, so room_size[room[s]] != 3\n        # We use element array to express this:\n        # Because Z3 does not support direct indexing with variables for Python lists,\n        # we encode with Or over all rooms:\n        no_triple = []\n        for i in room_nums:\n            no_triple.append(Implies(room[s] == i, room_size[i] != 3))\n        solver.add(And(no_triple))\n\n# No second-year student can be assigned to a single (room size 1)\nfor s in students:\n    if years[s] == 2:\n        no_single = []\n        for i in room_nums:\n            no_single.append(Implies(room[s] == i, room_size[i] != 1))\n        solver.add(And(no_single))\n\n# Lee and Robin must not share the same room\nsolver.add(room['Lee'] != room['Robin'])\n\n# Kim and Pat must share the same room\nsolver.add(room['Kim'] == room['Pat'])\n\n# Only those 7 students are assigned (already modeled)\n\n# OPTION CHECKING\n# We will check each option by adding the option-specific constraint and checking satisfiability\n\noptions = [\n    # (A) The two fourth-year students are assigned to singles.\n    # Fourth-year students: Kim and Lee\n    # Both assigned to rooms of size 1\n    And(\n        Or([And(room['Kim'] == i, room_size[i] == 1) for i in room_nums]),\n        Or([And(room['Lee'] == i, room_size[i] == 1) for i in room_nums])\n    ),\n\n    # (B) The two fourth-year students share a double with each other.\n    # Kim and Lee assigned to same room of size 2\n    And(\n        room['Kim'] == room['Lee'],\n        Or([And(room['Kim'] == i, room_size[i] == 2) for i in room_nums])\n    ),\n\n    # (C) Lee shares a room with a second-year student.\n    # Lee and some second-year student share same room\n    Or([\n        And(room['Lee'] == room[s2], s2 != 'Lee') for s2 in students if years[s2] == 2\n    ]),\n\n    # (D) Lee shares a room with a third-year student.\n    # Lee and some third-year student share same room\n    Or([\n        And(room['Lee'] == room[s3], s3 != 'Lee') for s3 in students if years[s3] == 3\n    ]),\n\n    # (E) Pat shares a triple with two other students.\n    # Pat is assigned to a room of size 3\n    Or([And(room['Pat'] == i, room_size[i] == 3) for i in room_nums])\n]\n\nfor i, option_constraint in enumerate(options):\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A worker will insert colored light bulbs into a billboard equipped with exactly three light sockets, which are labeled lights 1, 2, and 3. The worker has three green bulbs, three purple bulbs, and three yellow bulbs. Selection of bulbs for the sockets is governed by the following conditions: Whenever light 1 is purple, light 2 must be yellow. Whenever light 2 is green, light 1 must be green. Whenever light 3 is either purple or yellow, light 2 must be purple.\n\nWhich one of the following could be an accurate list of the colors of light bulbs selected for lights 1, 2, and 3, respectively?\n\nOptions:\n(A) green, green, yellow\n(B) purple, green, green\n(C) purple, purple, green\n(D) yellow, purple, green\n(E) yellow, yellow, yellow",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Define colors and lights\ncolors = ['green', 'purple', 'yellow']\nlights = ['light1', 'light2', 'light3']\n\n# Create Z3 variables for each light's color (integer indices)\nlight_color = {light: Int(light) for light in lights}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each light color must be a valid index\nfor light in lights:\n    solver.add(And(light_color[light] >= 0, light_color[light] < len(colors)))\n\n# Constraints from the problem:\n# Whenever light 1 is purple, light 2 must be yellow.\ncond1 = Implies(light_color['light1'] == colors.index('purple'),\n                light_color['light2'] == colors.index('yellow'))\n\n# Whenever light 2 is green, light 1 must be green.\ncond2 = Implies(light_color['light2'] == colors.index('green'),\n                light_color['light1'] == colors.index('green'))\n\n# Whenever light 3 is either purple or yellow, light 2 must be purple.\ncond3 = Implies(Or(light_color['light3'] == colors.index('purple'),\n                   light_color['light3'] == colors.index('yellow')),\n                light_color['light2'] == colors.index('purple'))\n\nsolver.add(cond1)\nsolver.add(cond2)\nsolver.add(cond3)\n\n# OPTION CHECKING\noptions = [\n    ('A', ['green', 'green', 'yellow']),\n    ('B', ['purple', 'green', 'green']),\n    ('C', ['purple', 'purple', 'green']),\n    ('D', ['yellow', 'purple', 'green']),\n    ('E', ['yellow', 'yellow', 'yellow'])\n]\n\nfor letter, option_colors in options:\n    solver.push()\n    # Add constraints for the option colors\n    for i, light in enumerate(lights):\n        solver.add(light_color[light] == colors.index(option_colors[i]))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A worker will insert colored light bulbs into a billboard equipped with exactly three light sockets, which are labeled lights 1, 2, and 3. The worker has three green bulbs, three purple bulbs, and three yellow bulbs. Selection of bulbs for the sockets is governed by the following conditions: Whenever light 1 is purple, light 2 must be yellow. Whenever light 2 is green, light 1 must be green. Whenever light 3 is either purple or yellow, light 2 must be purple.\n\nIf light 1 is yellow, then any of the following can be true, EXCEPT:\n\nOptions:\n(A) Light 2 is green.\n(B) Light 2 is purple.\n(C) Light 3 is green.\n(D) Light 3 is purple.\n(E) Light 3 is yellow.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'purple', 'yellow']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Create Z3 Int variables for each light socket\nlight1 = Int('light1')\nlight2 = Int('light2')\nlight3 = Int('light3')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each light's color index must be valid\nfor light in [light1, light2, light3]:\n    solver.add(And(light >= 0, light < len(colors)))\n\n# Given conditions:\n# Whenever light 1 is purple, light 2 must be yellow.\ncond1 = Implies(light1 == color_indices['purple'], light2 == color_indices['yellow'])\nsolver.add(cond1)\n\n# Whenever light 2 is green, light 1 must be green.\ncond2 = Implies(light2 == color_indices['green'], light1 == color_indices['green'])\nsolver.add(cond2)\n\n# Whenever light 3 is either purple or yellow, light 2 must be purple.\ncond3 = Implies(Or(light3 == color_indices['purple'], light3 == color_indices['yellow']),\n                light2 == color_indices['purple'])\nsolver.add(cond3)\n\n# OPTION CHECKING\n# If light 1 is yellow, check which options are possible.\n# We want to find the option that CANNOT be true.\n\noptions = [\n    ('A', light2 == color_indices['green']),\n    ('B', light2 == color_indices['purple']),\n    ('C', light3 == color_indices['green']),\n    ('D', light3 == color_indices['purple']),\n    ('E', light3 == color_indices['yellow']),\n]\n\nfor letter, option_constraint in options:\n    solver.push()\n    # Add light1 is yellow\n    solver.add(light1 == color_indices['yellow'])\n    # Add the option-specific constraint\n    solver.add(option_constraint)\n    # Check if satisfiable\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A worker will insert colored light bulbs into a billboard equipped with exactly three light sockets, which are labeled lights 1, 2, and 3. The worker has three green bulbs, three purple bulbs, and three yellow bulbs. Selection of bulbs for the sockets is governed by the following conditions: Whenever light 1 is purple, light 2 must be yellow. Whenever light 2 is green, light 1 must be green. Whenever light 3 is either purple or yellow, light 2 must be purple.\n\nThere is exactly one possible color sequence of the three lights if which one of the following is true?\n\nOptions:\n(A) Light 1 is purple.\n(B) Light 2 is purple.\n(C) Light 2 is yellow.\n(D) Light 3 is purple.\n(E) Light 3 is yellow.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'purple', 'yellow']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Variables for each light socket's color\nlight1 = Int('light1')\nlight2 = Int('light2')\nlight3 = Int('light3')\n\n# Solver instance\nsolver = Solver()\n\n# CONSTRAINTS\n# Each light's color must be a valid index\nfor light in [light1, light2, light3]:\n    solver.add(And(light >= 0, light < len(colors)))\n\n# Conditions:\n# Whenever light 1 is purple, light 2 must be yellow.\ncond1 = Implies(light1 == color_indices['purple'], light2 == color_indices['yellow'])\nsolver.add(cond1)\n\n# Whenever light 2 is green, light 1 must be green.\ncond2 = Implies(light2 == color_indices['green'], light1 == color_indices['green'])\nsolver.add(cond2)\n\n# Whenever light 3 is either purple or yellow, light 2 must be purple.\ncond3 = Implies(Or(light3 == color_indices['purple'], light3 == color_indices['yellow']), light2 == color_indices['purple'])\nsolver.add(cond3)\n\n# OPTION CHECKING\noptions = [\n    (light1 == color_indices['purple']),  # A\n    (light2 == color_indices['purple']),  # B\n    (light2 == color_indices['yellow']),  # C\n    (light3 == color_indices['purple']),  # D\n    (light3 == color_indices['yellow']),  # E\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    # Check if there is exactly one possible color sequence under this option\n    # Find one solution\n    if solver.check() == sat:\n        model = solver.model()\n        # Add constraint to exclude this solution and check if another exists\n        exclude = Or([\n            light1 != model[light1],\n            light2 != model[light2],\n            light3 != model[light3]\n        ])\n        solver.push()\n        solver.add(exclude)\n        second_check = solver.check()\n        solver.pop()\n        if second_check == unsat:\n            print(f\"'{chr(65+i)}'\")\n            solver.pop()\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A worker will insert colored light bulbs into a billboard equipped with exactly three light sockets, which are labeled lights 1, 2, and 3. The worker has three green bulbs, three purple bulbs, and three yellow bulbs. Selection of bulbs for the sockets is governed by the following conditions: Whenever light 1 is purple, light 2 must be yellow. Whenever light 2 is green, light 1 must be green. Whenever light 3 is either purple or yellow, light 2 must be purple.\n\nIf no green bulbs are selected, there are exactly how many possible different color sequences of the three lights?\n\nOptions:\n(A) one\n(B) two\n(C) three\n(D) four\n(E) five",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'purple', 'yellow']\ncolor_indices = {color: i for i, color in enumerate(colors)}\n\n# Variables for each light socket\nlight1 = Int('light1')\nlight2 = Int('light2')\nlight3 = Int('light3')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each light color must be a valid index\nfor light in [light1, light2, light3]:\n    solver.add(And(light >= 0, light < len(colors)))\n\n# Constraints given in the problem\n# Whenever light 1 is purple, light 2 must be yellow\nsolver.add(Implies(light1 == color_indices['purple'], light2 == color_indices['yellow']))\n\n# Whenever light 2 is green, light 1 must be green\nsolver.add(Implies(light2 == color_indices['green'], light1 == color_indices['green']))\n\n# Whenever light 3 is either purple or yellow, light 2 must be purple\nsolver.add(Implies(Or(light3 == color_indices['purple'], light3 == color_indices['yellow']), light2 == color_indices['purple']))\n\n# No green bulbs are selected: none of the lights can be green\nsolver.add(light1 != color_indices['green'])\nsolver.add(light2 != color_indices['green'])\nsolver.add(light3 != color_indices['green'])\n\n# OPTION CHECKING\n# We want to find how many possible different color sequences satisfy the constraints with no green bulbs\n\n# Collect all solutions\nsolutions = []\n\nwhile solver.check() == sat:\n    model = solver.model()\n    seq = (model[light1].as_long(), model[light2].as_long(), model[light3].as_long())\n    solutions.append(seq)\n    # Block this solution to find others\n    solver.add(Or(light1 != seq[0], light2 != seq[1], light3 != seq[2]))\n\n# Count solutions\ncount = len(solutions)\n\n# Map count to options\noption_map = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E'}\n\nprint(f\"'{option_map[count]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A worker will insert colored light bulbs into a billboard equipped with exactly three light sockets, which are labeled lights 1, 2, and 3. The worker has three green bulbs, three purple bulbs, and three yellow bulbs. Selection of bulbs for the sockets is governed by the following conditions: Whenever light 1 is purple, light 2 must be yellow. Whenever light 2 is green, light 1 must be green. Whenever light 3 is either purple or yellow, light 2 must be purple.\n\nIf no two lights are assigned light bulbs that are the same color as each other, then which one of the following could be true?\n\nOptions:\n(A) Light 1 is green, and light 2 is purple.\n(B) Light 1 is green, and light 2 is yellow.\n(C) Light 1 is purple, and light 3 is yellow.\n(D) Light 1 is yellow, and light 2 is green.\n(E) Light 1 is yellow, and light 3 is purple.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'purple', 'yellow']\ncolor_indices = {color: i for i, color in enumerate(colors)}\n\n# Variables for each light socket\nlight1 = Int('light1')\nlight2 = Int('light2')\nlight3 = Int('light3')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each light must be assigned a valid color index\nsolver.add(And(light1 >= 0, light1 < len(colors)))\nsolver.add(And(light2 >= 0, light2 < len(colors)))\nsolver.add(And(light3 >= 0, light3 < len(colors)))\n\n# No two lights have the same color\nsolver.add(Distinct([light1, light2, light3]))\n\n# Whenever light 1 is purple, light 2 must be yellow\ncond1 = Implies(light1 == color_indices['purple'], light2 == color_indices['yellow'])\nsolver.add(cond1)\n\n# Whenever light 2 is green, light 1 must be green\ncond2 = Implies(light2 == color_indices['green'], light1 == color_indices['green'])\nsolver.add(cond2)\n\n# Whenever light 3 is either purple or yellow, light 2 must be purple\ncond3 = Implies(Or(light3 == color_indices['purple'], light3 == color_indices['yellow']), light2 == color_indices['purple'])\nsolver.add(cond3)\n\n# OPTION CHECKING\noptions = [\n    (color_indices['green'], color_indices['purple'], None),  # A: Light 1 green, Light 2 purple\n    (color_indices['green'], color_indices['yellow'], None),  # B: Light 1 green, Light 2 yellow\n    (color_indices['purple'], None, color_indices['yellow']), # C: Light 1 purple, Light 3 yellow\n    (color_indices['yellow'], color_indices['green'], None),  # D: Light 1 yellow, Light 2 green\n    (color_indices['yellow'], None, color_indices['purple'])  # E: Light 1 yellow, Light 3 purple\n]\n\nfor i, (l1_val, l2_val, l3_val) in enumerate(options):\n    solver.push()\n    if l1_val is not None:\n        solver.add(light1 == l1_val)\n    if l2_val is not None:\n        solver.add(light2 == l2_val)\n    if l3_val is not None:\n        solver.add(light3 == l3_val)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "An attorney is scheduling interviews with witnesses for a given week, Monday through Saturday. Two full consecutive days of the week must be reserved for interviewing hostile witnesses. In addition, nonhostile witnesses Q, R, U, X, Y, and Z will each be interviewed exactly once for a full morning or afternoon. The only witnesses who will be interviewed simultaneously with each other are Q and R. The following conditions apply: X must be interviewed on Thursday morning. Q must be interviewed at some time before X. U must be interviewed at some time before R. Z must be interviewed at some time after X and at some time after Y.\n\nIf on Wednesday afternoon and on Monday the attorney conducts no interviews, which one of the following must be true?\n\nOptions:\n(A) Q is interviewed on the same day as U.\n(B) R is interviewed on the same day as Y.\n(C) Y is interviewed at some time before U.\n(D) Y is interviewed at some time before Wednesday.\n(E) Z is interviewed at some time before Friday.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Days: Monday(0) to Saturday(5)\ndays = list(range(6))\nday_names = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n\n# Times: Morning(0), Afternoon(1)\ntimes = [0, 1]\n\n# Witnesses\nwitnesses = ['Q', 'R', 'U', 'X', 'Y', 'Z']\n\n# Variables: For each witness, assign a day (0..5) and time (0..1)\nday_vars = {w: Int(f'day_{w}') for w in witnesses}\ntime_vars = {w: Int(f'time_{w}') for w in witnesses}\n\n# Hostile interview days: two full consecutive days reserved for hostile witnesses\n# We don't know who hostile witnesses are, but only Q and R are interviewed simultaneously\n# Nonhostile witnesses are Q,R,U,X,Y,Z (all). So hostile witnesses not named.\n# The problem states \"Two full consecutive days of the week must be reserved for interviewing hostile witnesses.\"\n# Since only Q and R are interviewed simultaneously, and all witnesses are nonhostile, the hostile interviews are on two full days with no nonhostile interviews.\n# So nonhostile interviews cannot be on those two full consecutive days.\n# So the two full consecutive days for hostile witnesses are days with no nonhostile interviews.\n# So the nonhostile interviews are scheduled on the other 4 days.\n# The problem states Wednesday afternoon and Monday no interviews are conducted.\n# So Monday (day 0) no interviews, Wednesday afternoon (day 2, afternoon) no interviews.\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# 1) Domain constraints\nfor w in witnesses:\n    solver.add(day_vars[w] >= 0, day_vars[w] <= 5)\n    solver.add(time_vars[w] >= 0, time_vars[w] <= 1)\n\n# 2) Each witness is interviewed exactly once (day and time unique per witness)\n# Already guaranteed by single variables per witness\n\n# 3) Only Q and R interviewed simultaneously\n# So if two witnesses have same day and time, they must be Q and R.\nfor w1 in witnesses:\n    for w2 in witnesses:\n        if w1 < w2:\n            same_slot = And(day_vars[w1] == day_vars[w2], time_vars[w1] == time_vars[w2])\n            if {w1, w2} == {'Q', 'R'}:\n                # Q and R can be simultaneous\n                pass\n            else:\n                # No other simultaneous interviews allowed\n                solver.add(Not(same_slot))\n\n# 4) X must be interviewed on Thursday morning\nsolver.add(day_vars['X'] == 3)  # Thursday = day 3\nsolver.add(time_vars['X'] == 0) # morning = 0\n\n# 5) Q must be interviewed at some time before X\n# \"At some time before\" means day/time order before X's day/time\n# Define a function to compare day/time order\ndef before(w1, w2):\n    # w1 before w2 means day1 < day2 or (day1 == day2 and time1 < time2)\n    return Or(day_vars[w1] < day_vars[w2],\n              And(day_vars[w1] == day_vars[w2], time_vars[w1] < time_vars[w2]))\n\nsolver.add(before('Q', 'X'))\n\n# 6) U must be interviewed at some time before R\nsolver.add(before('U', 'R'))\n\n# 7) Z must be interviewed at some time after X and at some time after Y\nsolver.add(before('X', 'Z'))\nsolver.add(before('Y', 'Z'))\n\n# 8) Wednesday afternoon and Monday no interviews\n# Wednesday afternoon = day 2, time 1\n# Monday = day 0, both times\nfor w in witnesses:\n    # No interview on Monday any time\n    solver.add(day_vars[w] != 0)\n    # No interview on Wednesday afternoon\n    solver.add(Not(And(day_vars[w] == 2, time_vars[w] == 1)))\n\n# 9) Two full consecutive days reserved for hostile witnesses\n# These days have no nonhostile interviews scheduled\n# So two consecutive days with no witnesses scheduled\n# Since Monday has no interviews, that is day 0 no interviews\n# Wednesday afternoon no interview, so day 2 afternoon no interview\n# Need to find two consecutive days with no witnesses scheduled at any time\n\n# Let's define a helper function to check if a day has any interviews\n# We'll check that the two consecutive days without interviews exist\n# We encode that there exist two consecutive days d and d+1 such that no witness is scheduled on those days at any time\n# But since the problem states \"Two full consecutive days must be reserved for interviewing hostile witnesses\"\n# So these two days have no nonhostile witnesses scheduled\n\n# We encode that there exists two consecutive days d and d+1 with no witnesses scheduled on those days at all\n\nno_interview_day = [Bool(f'no_interview_day_{d}') for d in days]\n\nfor d in days:\n    # no_interview_day[d] is True iff no witness is scheduled on day d\n    no_witnesses = []\n    for w in witnesses:\n        no_witnesses.append(day_vars[w] != d)\n    solver.add(no_interview_day[d] == And(no_witnesses))\n\n# There must be two consecutive days both no_interview_day == True\ntwo_consec_no_interview = []\nfor d in range(5):\n    two_consec_no_interview.append(And(no_interview_day[d], no_interview_day[d+1]))\nsolver.add(Or(two_consec_no_interview))\n\n# 10) Q and R are interviewed simultaneously\nsolver.add(day_vars['Q'] == day_vars['R'])\nsolver.add(time_vars['Q'] == time_vars['R'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': # Q is interviewed on the same day as U.\n    lambda: day_vars['Q'] == day_vars['U'],\n\n    'B': # R is interviewed on the same day as Y.\n    lambda: day_vars['R'] == day_vars['Y'],\n\n    'C': # Y is interviewed at some time before U.\n    lambda: before('Y', 'U'),\n\n    'D': # Y is interviewed at some time before Wednesday.\n    # Wednesday is day 2\n    lambda: Or([day_vars['Y'] < 2, And(day_vars['Y'] == 2, time_vars['Y'] < 0)]), # time 0 is morning, no time before 0, so just day < 2 suffices\n    # Since time cannot be less than 0, just day < 2 means before Wednesday\n\n    'E': # Z is interviewed at some time before Friday.\n    # Friday = day 4\n    lambda: Or([day_vars['Z'] < 4, And(day_vars['Z'] == 4, time_vars['Z'] < 0)]), # same reasoning as above\n}\n\n# Check each option by adding its condition and checking satisfiability\nfor opt_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(Not(options[opt_letter]()))\n    if solver.check() == unsat:\n        # If adding Not(option) is unsat, option must be true in all models\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "An attorney is scheduling interviews with witnesses for a given week, Monday through Saturday. Two full consecutive days of the week must be reserved for interviewing hostile witnesses. In addition, nonhostile witnesses Q, R, U, X, Y, and Z will each be interviewed exactly once for a full morning or afternoon. The only witnesses who will be interviewed simultaneously with each other are Q and R. The following conditions apply: X must be interviewed on Thursday morning. Q must be interviewed at some time before X. U must be interviewed at some time before R. Z must be interviewed at some time after X and at some time after Y.\n\nIf Z is interviewed on Saturday morning, which one of the following can be true?\n\nOptions:\n(A) Wednesday is a day reserved for interviewing hostile witnesses.\n(B) Friday is a day reserved for interviewing hostile witnesses.\n(C) R is interviewed on Thursday.\n(D) U is interviewed on Tuesday.\n(E) Y is interviewed at some time before Thursday.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Days: Monday(0) through Saturday(5)\ndays = list(range(6))\n\n# Times: Morning(0), Afternoon(1)\ntimes = [0, 1]\n\n# Witnesses: Q, R, U, X, Y, Z\nwitnesses = ['Q', 'R', 'U', 'X', 'Y', 'Z']\n\n# Create variables for each witness's interview day and time\nday_vars = {w: Int(f'day_{w}') for w in witnesses}\ntime_vars = {w: Int(f'time_{w}') for w in witnesses}\n\n# Hostile days: two full consecutive days reserved for hostile witnesses\n# Represented as two consecutive days h1 and h2\nh1 = Int('h1')\nh2 = Int('h2')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each witness's day is between Monday (0) and Saturday (5)\nfor w in witnesses:\n    solver.add(And(day_vars[w] >= 0, day_vars[w] <= 5))\n\n# Each witness's time is Morning (0) or Afternoon (1)\nfor w in witnesses:\n    solver.add(Or(time_vars[w] == 0, time_vars[w] == 1))\n\n# No two witnesses except Q and R are interviewed simultaneously\nfor i in range(len(witnesses)):\n    for j in range(i + 1, len(witnesses)):\n        w1 = witnesses[i]\n        w2 = witnesses[j]\n        if set([w1, w2]) != set(['Q', 'R']):\n            # If same day and same time, then not allowed\n            solver.add(Or(day_vars[w1] != day_vars[w2], time_vars[w1] != time_vars[w2]))\n\n# Q and R are the only witnesses interviewed simultaneously\nsolver.add(day_vars['Q'] == day_vars['R'])\nsolver.add(time_vars['Q'] == time_vars['R'])\n\n# X must be interviewed on Thursday morning\n# Thursday is day 3, morning is 0\nsolver.add(day_vars['X'] == 3)\nsolver.add(time_vars['X'] == 0)\n\n# Q must be interviewed at some time before X\n# Define a function to compare day and time order\ndef before(d1, t1, d2, t2):\n    # d1 < d2 or (d1 == d2 and t1 < t2)\n    return Or(d1 < d2, And(d1 == d2, t1 < t2))\n\nsolver.add(before(day_vars['Q'], time_vars['Q'], day_vars['X'], time_vars['X']))\n\n# U must be interviewed at some time before R\nsolver.add(before(day_vars['U'], time_vars['U'], day_vars['R'], time_vars['R']))\n\n# Z must be interviewed at some time after X and at some time after Y\nsolver.add(before(day_vars['X'], time_vars['X'], day_vars['Z'], time_vars['Z']))\nsolver.add(before(day_vars['Y'], time_vars['Y'], day_vars['Z'], time_vars['Z']))\n\n# Two full consecutive days reserved for interviewing hostile witnesses\n# h1 and h2 are consecutive days, both between 0 and 4 (since h2 = h1 + 1)\nsolver.add(And(h1 >= 0, h1 <= 4))\nsolver.add(h2 == h1 + 1)\n\n# Hostile days (h1 and h2) are full days reserved for hostile witnesses\n# No witnesses Q,R,U,X,Y,Z are interviewed on hostile days\nfor w in witnesses:\n    solver.add(Or(day_vars[w] < h1, day_vars[w] > h2))\n\n# Given: Z is interviewed on Saturday morning\nsolver.add(day_vars['Z'] == 5)\nsolver.add(time_vars['Z'] == 0)\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Wednesday is a day reserved for interviewing hostile witnesses.\n    lambda: solver.add(Or(h1 == 2, h2 == 2)),\n    # (B) Friday is a day reserved for interviewing hostile witnesses.\n    lambda: solver.add(Or(h1 == 4, h2 == 4)),\n    # (C) R is interviewed on Thursday.\n    lambda: solver.add(day_vars['R'] == 3),\n    # (D) U is interviewed on Tuesday.\n    lambda: solver.add(day_vars['U'] == 1),\n    # (E) Y is interviewed at some time before Thursday.\n    lambda: solver.add(day_vars['Y'] < 3),\n]\n\nfor i, add_option in enumerate(options):\n    solver.push()\n    add_option()\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "During a four-week period, each of seven previously unadvertised products—G, H, J, K, L, M, and O—will be advertised. A different pair of these products will be advertised each week. Exactly one of the products will be a member of two of these four pairs. The following constraints must be observed: J is not advertised during a given week unless H is advertised during the immediately preceding week. The product that is advertised during two of the weeks is advertised during week 4 but is not advertised during week 3. G is not advertised during a given week unless either J or else O is also advertised that week. K is advertised during one of the first two weeks. O is one of the products advertised during week 3.\n\nWhich one of the following is a pair of products that CANNOT be advertised during the same week as each other?\n\nOptions:\n(A) H and K\n(B) H and M\n(C) J and O\n(D) K and L\n(E) L and M",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nproducts = ['G', 'H', 'J', 'K', 'L', 'M', 'O']\nweeks = [0, 1, 2, 3]  # 4 weeks indexed 0 to 3\n\n# For each week, two products are advertised (pairs)\n# Create variables: week_pairs[w][0] and week_pairs[w][1] are Ints representing product indices\nweek_pairs = []\nfor w in weeks:\n    p1 = Int(f'w{w}_p1')\n    p2 = Int(f'w{w}_p2')\n    week_pairs.append([p1, p2])\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each product index must be valid\nfor w in weeks:\n    for i in [0, 1]:\n        solver.add(And(week_pairs[w][i] >= 0, week_pairs[w][i] < len(products)))\n\n# The two products in the same week must be different\nfor w in weeks:\n    solver.add(week_pairs[w][0] != week_pairs[w][1])\n\n# All pairs are different pairs (order doesn't matter, so we sort pairs to compare)\n# Collect sorted pairs as tuples for distinctness\ndef sorted_pair_expr(p1, p2):\n    return If(p1 < p2, (p1, p2), (p2, p1))\n\n# We'll create expressions for sorted pairs for each week\nsorted_pairs = []\nfor w in weeks:\n    p1 = week_pairs[w][0]\n    p2 = week_pairs[w][1]\n    # Use auxiliary Ints to hold sorted values\n    low = Int(f'w{w}_low')\n    high = Int(f'w{w}_high')\n    solver.add(low == If(p1 < p2, p1, p2))\n    solver.add(high == If(p1 < p2, p2, p1))\n    sorted_pairs.append((low, high))\n\n# All pairs are distinct (no repeated pairs)\nfor i in range(len(sorted_pairs)):\n    for j in range(i+1, len(sorted_pairs)):\n        solver.add(Or(sorted_pairs[i][0] != sorted_pairs[j][0], sorted_pairs[i][1] != sorted_pairs[j][1]))\n\n# Exactly one product is advertised in two of the four pairs (weeks)\n# Count how many times each product appears in the 8 product slots (2 per week * 4 weeks)\nproduct_counts = [Sum([If(week_pairs[w][0] == i, 1, 0) + If(week_pairs[w][1] == i, 1, 0) for w in weeks]) for i in range(len(products))]\n\n# Exactly one product appears twice, all others appear once\n# One product count == 2, others == 1\none_twice = [product_counts[i] == 2 for i in range(len(products))]\none_once = [product_counts[i] == 1 for i in range(len(products))]\n\n# Sum of all counts must be 8 (2 products per week * 4 weeks)\nsolver.add(Sum(product_counts) == 8)\n\n# Exactly one product count == 2, others == 1\n# Use a constraint: sum of (product_counts[i] == 2) == 1 and all others == 1\ncount_twos = Sum([If(c, 1, 0) for c in one_twice])\nsolver.add(count_twos == 1)\nfor i in range(len(products)):\n    solver.add(Or(one_twice[i], one_once[i]))\n\n# The product advertised twice is advertised during week 4 (week index 3) but not during week 3 (week index 2)\n# Find index of product advertised twice\n# Create an Int variable for the product advertised twice\ntwice_product = Int('twice_product')\nsolver.add(twice_product >= 0, twice_product < len(products))\nfor i in range(len(products)):\n    solver.add(Implies(twice_product == i, product_counts[i] == 2))\n# The twice_product must appear in week 4 (index 3)\nsolver.add(Or(week_pairs[3][0] == twice_product, week_pairs[3][1] == twice_product))\n# The twice_product must NOT appear in week 3 (index 2)\nsolver.add(And(week_pairs[2][0] != twice_product, week_pairs[2][1] != twice_product))\n\n# J is not advertised during a given week unless H is advertised during the immediately preceding week.\n# For weeks 1 to 3 (index 1 to 3)\nJ_idx = products.index('J')\nH_idx = products.index('H')\nfor w in range(1, 4):\n    # If J in week w, then H in week w-1\n    J_in_w = Or(week_pairs[w][0] == J_idx, week_pairs[w][1] == J_idx)\n    H_in_prev = Or(week_pairs[w-1][0] == H_idx, week_pairs[w-1][1] == H_idx)\n    solver.add(Implies(J_in_w, H_in_prev))\n\n# G is not advertised during a given week unless either J or else O is also advertised that week.\nG_idx = products.index('G')\nO_idx = products.index('O')\nfor w in weeks:\n    G_in_w = Or(week_pairs[w][0] == G_idx, week_pairs[w][1] == G_idx)\n    J_in_w = Or(week_pairs[w][0] == J_idx, week_pairs[w][1] == J_idx)\n    O_in_w = Or(week_pairs[w][0] == O_idx, week_pairs[w][1] == O_idx)\n    solver.add(Implies(G_in_w, Or(J_in_w, O_in_w)))\n\n# K is advertised during one of the first two weeks.\nK_idx = products.index('K')\nK_in_week0 = Or(week_pairs[0][0] == K_idx, week_pairs[0][1] == K_idx)\nK_in_week1 = Or(week_pairs[1][0] == K_idx, week_pairs[1][1] == K_idx)\nsolver.add(Or(K_in_week0, K_in_week1))\n\n# O is one of the products advertised during week 3 (index 2)\nsolver.add(Or(week_pairs[2][0] == O_idx, week_pairs[2][1] == O_idx))\n\n# OPTION CHECKING\n# Options:\n# (A) H and K\n# (B) H and M\n# (C) J and O\n# (D) K and L\n# (E) L and M\n\noption_pairs = {\n    'A': ('H', 'K'),\n    'B': ('H', 'M'),\n    'C': ('J', 'O'),\n    'D': ('K', 'L'),\n    'E': ('L', 'M')\n}\n\nfor opt_letter, (pA, pB) in option_pairs.items():\n    solver.push()\n    pA_idx = products.index(pA)\n    pB_idx = products.index(pB)\n    # Add constraint that pA and pB appear together in some week\n    # If it is possible for them to appear together, then option is possible\n    pair_found = []\n    for w in weeks:\n        p1 = week_pairs[w][0]\n        p2 = week_pairs[w][1]\n        # Check if (pA,pB) or (pB,pA) in week w\n        cond1 = And(p1 == pA_idx, p2 == pB_idx)\n        cond2 = And(p1 == pB_idx, p2 == pA_idx)\n        pair_found.append(Or(cond1, cond2))\n    solver.add(Or(pair_found))\n    if solver.check() == unsat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "During a four-week period, each of seven previously unadvertised products—G, H, J, K, L, M, and O—will be advertised. A different pair of these products will be advertised each week. Exactly one of the products will be a member of two of these four pairs. The following constraints must be observed: J is not advertised during a given week unless H is advertised during the immediately preceding week. The product that is advertised during two of the weeks is advertised during week 4 but is not advertised during week 3. G is not advertised during a given week unless either J or else O is also advertised that week. K is advertised during one of the first two weeks. O is one of the products advertised during week 3.\n\nWhich one of the following CANNOT be the product that is advertised during two of the weeks?\n\nOptions:\n(A) G\n(B) H\n(C) K\n(D) L\n(E) M",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nproducts = ['G', 'H', 'J', 'K', 'L', 'M', 'O']\nweeks = [0, 1, 2, 3]  # 4 weeks indexed 0 to 3\n\n# Each week advertises a pair of distinct products\n# week_pairs[w] = (product1, product2) as indices into products\nweek_pairs = []\nfor w in weeks:\n    p1 = Int(f'p1_{w}')\n    p2 = Int(f'p2_{w}')\n    week_pairs.append((p1, p2))\n\n# The product advertised twice\nadvertised_twice = Int('advertised_twice')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each product index is within range\nfor w in weeks:\n    p1, p2 = week_pairs[w]\n    solver.add(And(p1 >= 0, p1 < len(products)))\n    solver.add(And(p2 >= 0, p2 < len(products)))\n\n# 2) Products in a pair are distinct\nfor w in weeks:\n    p1, p2 = week_pairs[w]\n    solver.add(p1 != p2)\n\n# 3) Exactly one product is advertised twice in the four pairs\n# Count occurrences of each product in all pairs\noccurrences = []\nfor i in range(len(products)):\n    count = Sum([If(Or([week_pairs[w][0] == i, week_pairs[w][1] == i]), 1, 0) for w in weeks])\n    occurrences.append(count)\n\n# Exactly one product occurs twice, others once\n# The problem states: \"Exactly one of the products will be a member of two of these four pairs.\"\n# That means exactly one product appears twice, all others appear once.\nfor i in range(len(products)):\n    # advertised_twice == i <=> occurrences[i] == 2 and all others == 1\n    cond = And(occurrences[i] == 2,\n               And([occurrences[j] == 1 for j in range(len(products)) if j != i]))\n    solver.add(advertised_twice == i == True if False else True)  # placeholder, will add later\n\n# We'll add this constraint properly below using Or\n\n# 4) The product advertised twice is advertised during week 4 (index 3) but not during week 3 (index 2)\n# week 3 = index 2, week 4 = index 3\np3 = week_pairs[2]\np4 = week_pairs[3]\n\n# advertised_twice in week 4\noccurs_in_week4 = Or(p4[0] == advertised_twice, p4[1] == advertised_twice)\nsolver.add(occurs_in_week4)\n\n# advertised_twice NOT in week 3\nnot_in_week3 = And(p3[0] != advertised_twice, p3[1] != advertised_twice)\nsolver.add(not_in_week3)\n\n# 5) J is not advertised during a given week unless H is advertised during the immediately preceding week.\n# For weeks 1,2,3 (index 1,2,3), if J is in week w, then H must be in week w-1\nfor w in range(1, 4):\n    p_curr = week_pairs[w]\n    p_prev = week_pairs[w-1]\n    j_in_curr = Or(p_curr[0] == products.index('J'), p_curr[1] == products.index('J'))\n    h_in_prev = Or(p_prev[0] == products.index('H'), p_prev[1] == products.index('H'))\n    solver.add(Implies(j_in_curr, h_in_prev))\n\n# 6) G is not advertised during a given week unless either J or O is also advertised that week.\n# For each week, if G in week, then J or O in week\nfor w in weeks:\n    p1, p2 = week_pairs[w]\n    g_in_week = Or(p1 == products.index('G'), p2 == products.index('G'))\n    j_in_week = Or(p1 == products.index('J'), p2 == products.index('J'))\n    o_in_week = Or(p1 == products.index('O'), p2 == products.index('O'))\n    solver.add(Implies(g_in_week, Or(j_in_week, o_in_week)))\n\n# 7) K is advertised during one of the first two weeks (week 0 or week 1)\np0 = week_pairs[0]\np1 = week_pairs[1]\nk_index = products.index('K')\nk_in_week0 = Or(p0[0] == k_index, p0[1] == k_index)\nk_in_week1 = Or(p1[0] == k_index, p1[1] == k_index)\nsolver.add(Or(k_in_week0, k_in_week1))\n\n# 8) O is one of the products advertised during week 3 (index 2)\np_week3 = week_pairs[2]\no_index = products.index('O')\nsolver.add(Or(p_week3[0] == o_index, p_week3[1] == o_index))\n\n# 9) Exactly one product appears twice, others once\n# Add constraint for advertised_twice index and occurrences counts\n# advertised_twice must be one of the products\nsolver.add(And(advertised_twice >= 0, advertised_twice < len(products)))\n\n# For each product i: if i == advertised_twice then occurrences[i] == 2 else occurrences[i] == 1\nfor i in range(len(products)):\n    solver.add(If(advertised_twice == i, occurrences[i] == 2, occurrences[i] == 1))\n\n# OPTION CHECKING\n\noptions = ['G', 'H', 'K', 'L', 'M']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that advertised_twice == index of opt\n    solver.add(advertised_twice == products.index(opt))\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "An upholsterer will do seven jobs—N, O, P, S, T, U, and X—during a given week on Monday through Friday. Each job is done on exactly one of the days, and no two jobs are done concurrently. Each job takes either one half day or an entire day. The following conditions apply: N is done on the same day as S. X is done on Wednesday, and T is done on Friday. S is done earlier than the day on which P is done. U and X are the only jobs that must take an entire day each.\n\nIf O is done on Monday, which one of the following must be true?\n\nOptions:\n(A) N is done on Tuesday.\n(B) P is done on Thursday.\n(C) P is done on Friday.\n(D) S is done on Thursday.\n(E) U is done on Friday.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Days: Monday=0, Tuesday=1, Wednesday=2, Thursday=3, Friday=4\ndays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri']\nnum_days = len(days)\n\n# Jobs\njobs = ['N', 'O', 'P', 'S', 'T', 'U', 'X']\n\n# Create variables for each job's day (0..4)\njob_day = {j: Int(j) for j in jobs}\n\n# Create variables for each job's duration: 0=half day, 1=full day\njob_duration = {j: Int(f\"{j}_dur\") for j in jobs}\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each job is done on exactly one day: day in [0..4]\nfor j in jobs:\n    solver.add(And(job_day[j] >= 0, job_day[j] < num_days))\n\n# Each job takes either half day (0) or full day (1)\nfor j in jobs:\n    solver.add(Or(job_duration[j] == 0, job_duration[j] == 1))\n\n# X is done on Wednesday (day 2)\nsolver.add(job_day['X'] == 2)\n\n# T is done on Friday (day 4)\nsolver.add(job_day['T'] == 4)\n\n# N is done on the same day as S\nsolver.add(job_day['N'] == job_day['S'])\n\n# S is done earlier than P (S_day < P_day)\nsolver.add(job_day['S'] < job_day['P'])\n\n# U and X are the only jobs that must take an entire day each\n# So U and X have duration 1, all others duration 0\nsolver.add(job_duration['U'] == 1)\nsolver.add(job_duration['X'] == 1)\nfor j in jobs:\n    if j not in ['U', 'X']:\n        solver.add(job_duration[j] == 0)\n\n# No two jobs are done concurrently.\n# Each day can hold either one full-day job or two half-day jobs.\n# Since U and X are full-day jobs, they occupy their days fully.\n# N and S share a day, both are half-day jobs, so they together fill one day.\n# So on any day:\n# - If a full-day job is scheduled, no other job on that day.\n# - If only half-day jobs, max two per day.\n\n# We will ensure that no two jobs overlap in time.\n\n# For each day, collect jobs scheduled on that day\n# Then enforce no overlaps\n\n# For each day, get jobs scheduled on that day\nfor d in range(num_days):\n    jobs_on_day = [j for j in jobs]\n    # Create a Bool variable for each job indicating if scheduled on day d\n    is_on_day = [job_day[j] == d for j in jobs]\n    # Sum of durations of jobs on day d must be <= 2 half-days (i.e. 1 full day)\n    # Since durations are 0 or 1 (half or full day), duration*2 is half-days count\n    # But duration is 0 or 1 full day, so half-days count is duration*2\n    # However, duration is 0 (half day) or 1 (full day)\n    # We can sum durations * 2 for half-days count per day\n    # But half-day jobs have duration 0, full-day 1, so half-day jobs need to be counted as 1 half-day (0.5 day)\n    # So redefine duration: 0=half day=0.5 day, 1=full day=1 day\n    # We will create a new variable for half-day count: half_day_count = If(duration==0,1,2)\n    # So half_day_count = 1 for half-day, 2 for full-day\n    half_day_counts = [If(job_duration[j] == 0, 1, 2) for j in jobs]\n    # Sum half_day_counts for jobs on day d must be <= 2 (2 half-days = 1 full day)\n    half_day_sum = Sum([If(is_on_day[i], half_day_counts[i], 0) for i in range(len(jobs))])\n    solver.add(half_day_sum <= 2)\n\n# N and S are on the same day and both half-day jobs, so together fill one day fully (2 half-days)\n# So job_duration for N and S are 0 (half-day) as per earlier constraints\n\n# O is done on Monday (day 0)\nsolver.add(job_day['O'] == 0)\n\n# OPTION CHECKING\n\n# We will check each option by adding the option as a constraint and see if the model is satisfiable.\n\noptions = {\n    'A': job_day['N'] == 1,  # N is done on Tuesday\n    'B': job_day['P'] == 3,  # P is done on Thursday\n    'C': job_day['P'] == 4,  # P is done on Friday\n    'D': job_day['S'] == 3,  # S is done on Thursday\n    'E': job_day['U'] == 4   # U is done on Friday\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        # Check if the negation is unsat (meaning must be true)\n        solver.pop()\n        solver.push()\n        solver.add(Not(cond))\n        if solver.check() == unsat:\n            print(f\"'{letter}'\")\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven persons—G, H, I, K, L, M, and P—are going rock-climbing together. One person will be the organizer and not a member of any team. The remaining six will form three climbing teams, each consisting of two persons. No person can be on more than one team. The following conditions also apply: M and P cannot be on the same team as each other. If K is on a team, M must also be on that team. If G is on a team, either H or I must also be on that team. If H is on a team, K must be the organizer.\n\nWhich one of the following can be a list of the members of the three teams?\n\nOptions:\n(A) Team 1: G, H; Team 2: I, L; Team 3: M, P\n(B) Team 1: G, H; Team 2: L, P; Team 3: K, M\n(C) Team 1: G, I; Team 2: H, M; Team 3: L, P\n(D) Team 1: G, P; Team 2: I, L; Team 3: K, M\n(E) Team 1: H, M; Team 2: I, L; Team 3: K, P",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['G', 'H', 'I', 'K', 'L', 'M', 'P']\nperson_indices = {p: i for i, p in enumerate(persons)}\n\n# Organizer: one person index\nOrganizer = Int('Organizer')\n# Teams: three teams, each with two persons (indices)\nTeam1_0 = Int('Team1_0')\nTeam1_1 = Int('Team1_1')\nTeam2_0 = Int('Team2_0')\nTeam2_1 = Int('Team2_1')\nTeam3_0 = Int('Team3_0')\nTeam3_1 = Int('Team3_1')\n\nteams_vars = [Team1_0, Team1_1, Team2_0, Team2_1, Team3_0, Team3_1]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Organizer is one of the persons\nsolver.add(And(Organizer >= 0, Organizer < len(persons)))\n\n# Each team member must be a valid person index\nfor var in teams_vars:\n    solver.add(And(var >= 0, var < len(persons)))\n\n# Organizer is not in any team\nfor var in teams_vars:\n    solver.add(var != Organizer)\n\n# All team members are distinct (no person on more than one team)\nsolver.add(Distinct(teams_vars))\n\n# M and P cannot be on the same team\n# For each team, check that M and P are not both present\nM_idx = person_indices['M']\nP_idx = person_indices['P']\n\ndef not_both_on_team(a, b):\n    # returns constraint: not (a==M and b==P or a==P and b==M)\n    return Or(a != M_idx, b != P_idx), Or(a != P_idx, b != M_idx)\n\nc1a, c1b = not_both_on_team(Team1_0, Team1_1)\nc2a, c2b = not_both_on_team(Team2_0, Team2_1)\nc3a, c3b = not_both_on_team(Team3_0, Team3_1)\nsolver.add(And(c1a, c1b))\nsolver.add(And(c2a, c2b))\nsolver.add(And(c3a, c3b))\n\n# If K is on a team, M must also be on that team\nK_idx = person_indices['K']\n\ndef k_implies_m(team_a, team_b):\n    # If K is on team (team_a or team_b), then M must be on that team\n    k_on_team = Or(team_a == K_idx, team_b == K_idx)\n    m_on_team = Or(team_a == M_idx, team_b == M_idx)\n    return Implies(k_on_team, m_on_team)\n\nsolver.add(k_implies_m(Team1_0, Team1_1))\nsolver.add(k_implies_m(Team2_0, Team2_1))\nsolver.add(k_implies_m(Team3_0, Team3_1))\n\n# If G is on a team, either H or I must also be on that team\nG_idx = person_indices['G']\nH_idx = person_indices['H']\nI_idx = person_indices['I']\n\ndef g_implies_h_or_i(team_a, team_b):\n    g_on_team = Or(team_a == G_idx, team_b == G_idx)\n    h_or_i_on_team = Or(team_a == H_idx, team_b == H_idx, team_a == I_idx, team_b == I_idx)\n    return Implies(g_on_team, h_or_i_on_team)\n\nsolver.add(g_implies_h_or_i(Team1_0, Team1_1))\nsolver.add(g_implies_h_or_i(Team2_0, Team2_1))\nsolver.add(g_implies_h_or_i(Team3_0, Team3_1))\n\n# If H is on a team, K must be the organizer\ndef h_implies_k_organizer(team_a, team_b):\n    h_on_team = Or(team_a == H_idx, team_b == H_idx)\n    k_is_organizer = Organizer == K_idx\n    return Implies(h_on_team, k_is_organizer)\n\nsolver.add(h_implies_k_organizer(Team1_0, Team1_1))\nsolver.add(h_implies_k_organizer(Team2_0, Team2_1))\nsolver.add(h_implies_k_organizer(Team3_0, Team3_1))\n\n# OPTION CHECKING\noptions = [\n    # (Team1, Team2, Team3)\n    (['G', 'H'], ['I', 'L'], ['M', 'P']),  # A\n    (['G', 'H'], ['L', 'P'], ['K', 'M']),  # B\n    (['G', 'I'], ['H', 'M'], ['L', 'P']),  # C\n    (['G', 'P'], ['I', 'L'], ['K', 'M']),  # D\n    (['H', 'M'], ['I', 'L'], ['K', 'P']),  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Set organizer to a variable (unknown)\n    # Add constraints for teams equal to option persons\n    # Convert each person to index\n    t1_0_idx = person_indices[option[0][0]]\n    t1_1_idx = person_indices[option[0][1]]\n    t2_0_idx = person_indices[option[1][0]]\n    t2_1_idx = person_indices[option[1][1]]\n    t3_0_idx = person_indices[option[2][0]]\n    t3_1_idx = person_indices[option[2][1]]\n\n    # Add constraints that teams equal these persons (order may vary, so consider both orders)\n    team1_cond = Or(And(Team1_0 == t1_0_idx, Team1_1 == t1_1_idx),\n                    And(Team1_0 == t1_1_idx, Team1_1 == t1_0_idx))\n    team2_cond = Or(And(Team2_0 == t2_0_idx, Team2_1 == t2_1_idx),\n                    And(Team2_0 == t2_1_idx, Team2_1 == t2_0_idx))\n    team3_cond = Or(And(Team3_0 == t3_0_idx, Team3_1 == t3_1_idx),\n                    And(Team3_0 == t3_1_idx, Team3_1 == t3_0_idx))\n\n    solver.add(team1_cond)\n    solver.add(team2_cond)\n    solver.add(team3_cond)\n\n    # Organizer must be the person not in any team\n    # The set of all persons: 0..6\n    # The six team members are given; organizer is the one not in these six\n    team_members = [t1_0_idx, t1_1_idx, t2_0_idx, t2_1_idx, t3_0_idx, t3_1_idx]\n    # Organizer is not any of these six\n    for member in team_members:\n        solver.add(Organizer != member)\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven persons—G, H, I, K, L, M, and P—are going rock-climbing together. One person will be the organizer and not a member of any team. The remaining six will form three climbing teams, each consisting of two persons. No person can be on more than one team. The following conditions also apply: M and P cannot be on the same team as each other. If K is on a team, M must also be on that team. If G is on a team, either H or I must also be on that team. If H is on a team, K must be the organizer.\n\nEach of the following is a pair of persons who can constitute a team EXCEPT:\n\nOptions:\n(A) H, I\n(B) H, M\n(C) I, M\n(D) I, P\n(E) L, P",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['G', 'H', 'I', 'K', 'L', 'M', 'P']\nn = len(persons)\n\n# Organizer: one person (index)\nOrganizer = Int('Organizer')\n# Teams: three teams of two persons each: team1 = (T1_0, T1_1), etc.\nT1_0 = Int('T1_0')\nT1_1 = Int('T1_1')\nT2_0 = Int('T2_0')\nT2_1 = Int('T2_1')\nT3_0 = Int('T3_0')\nT3_1 = Int('T3_1')\n\nteams_vars = [T1_0, T1_1, T2_0, T2_1, T3_0, T3_1]\n\n# Helper: map person name to index\nidx = {p: i for i, p in enumerate(persons)}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Organizer must be a valid person\nsolver.add(And(Organizer >= 0, Organizer < n))\n\n# Team members must be valid persons\nfor v in teams_vars:\n    solver.add(And(v >= 0, v < n))\n\n# Organizer is not in any team\nfor v in teams_vars:\n    solver.add(v != Organizer)\n\n# All team members are distinct (no overlap)\nsolver.add(Distinct(teams_vars))\n\n# There are three teams of two persons each\n# So teams_vars are 6 distinct persons, excluding organizer\n\n# Constraint: M and P cannot be on the same team\n# For each team, if M in team then P not in team and vice versa\nM_idx = idx['M']\nP_idx = idx['P']\nfor team in [(T1_0, T1_1), (T2_0, T2_1), (T3_0, T3_1)]:\n    # If M in team then P not in team\n    cond_M_in_team = Or([team[0] == M_idx, team[1] == M_idx])\n    cond_P_in_team = Or([team[0] == P_idx, team[1] == P_idx])\n    solver.add(Implies(cond_M_in_team, Not(cond_P_in_team)))\n    solver.add(Implies(cond_P_in_team, Not(cond_M_in_team)))\n\n# If K is on a team, M must also be on that team\nK_idx = idx['K']\nfor team in [(T1_0, T1_1), (T2_0, T2_1), (T3_0, T3_1)]:\n    cond_K_in_team = Or([team[0] == K_idx, team[1] == K_idx])\n    cond_M_in_team = Or([team[0] == M_idx, team[1] == M_idx])\n    solver.add(Implies(cond_K_in_team, cond_M_in_team))\n\n# If G is on a team, either H or I must also be on that team\nG_idx = idx['G']\nH_idx = idx['H']\nI_idx = idx['I']\nfor team in [(T1_0, T1_1), (T2_0, T2_1), (T3_0, T3_1)]:\n    cond_G_in_team = Or([team[0] == G_idx, team[1] == G_idx])\n    cond_H_in_team = Or([team[0] == H_idx, team[1] == H_idx])\n    cond_I_in_team = Or([team[0] == I_idx, team[1] == I_idx])\n    solver.add(Implies(cond_G_in_team, Or(cond_H_in_team, cond_I_in_team)))\n\n# If H is on a team, K must be the organizer\ncond_H_in_any_team = Or([v == H_idx for v in teams_vars])\nsolver.add(Implies(cond_H_in_any_team, Organizer == K_idx))\n\n# OPTION CHECKING\n# Each option is a pair that can or cannot be a team.\n# We test for each option whether there is a solution with that pair as a team.\n# The EXCEPT option is the one that cannot be a team.\n\noptions = [\n    ('A', ('H', 'I')),\n    ('B', ('H', 'M')),\n    ('C', ('I', 'M')),\n    ('D', ('I', 'P')),\n    ('E', ('L', 'P')),\n]\n\nfor letter, (p1, p2) in options:\n    solver.push()\n    # Add constraint that one of the teams is exactly {p1, p2}\n    pair_set = {idx[p1], idx[p2]}\n    # We check all three teams if any equals this pair (order doesn't matter)\n    team1_cond = Or(\n        And(T1_0 == idx[p1], T1_1 == idx[p2]),\n        And(T1_0 == idx[p2], T1_1 == idx[p1])\n    )\n    team2_cond = Or(\n        And(T2_0 == idx[p1], T2_1 == idx[p2]),\n        And(T2_0 == idx[p2], T2_1 == idx[p1])\n    )\n    team3_cond = Or(\n        And(T3_0 == idx[p1], T3_1 == idx[p2]),\n        And(T3_0 == idx[p2], T3_1 == idx[p1])\n    )\n    solver.add(Or([team1_cond, team2_cond, team3_cond]))\n    if solver.check() == sat:\n        # This pair can be a team\n        solver.pop()\n    else:\n        # This pair cannot be a team - this is the EXCEPT answer\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Seven persons—G, H, I, K, L, M, and P—are going rock-climbing together. One person will be the organizer and not a member of any team. The remaining six will form three climbing teams, each consisting of two persons. No person can be on more than one team. The following conditions also apply: M and P cannot be on the same team as each other. If K is on a team, M must also be on that team. If G is on a team, either H or I must also be on that team. If H is on a team, K must be the organizer.\n\nWhich one of the following can be the organizer, who is not on any team?\n\nOptions:\n(A) G\n(B) H\n(C) I\n(D) L\n(E) P",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\npersons = ['G', 'H', 'I', 'K', 'L', 'M', 'P']\nnum_persons = len(persons)\nperson_idx = {p: i for i, p in enumerate(persons)}\n\n# Organizer variable: integer 0..6 representing who is organizer\nOrganizer = Int('Organizer')\n# Constraint: Organizer in range\n# Teams: 3 teams of 2 persons each from remaining 6 persons\n# We'll create a variable TeamOf[p] for each person p, indicating which team they are on (0,1,2) or -1 if organizer\nTeamOf = [Int(f'TeamOf_{p}') for p in persons]\n\nsolver = Solver()\n\n# Organizer in range\nsolver.add(And(Organizer >= 0, Organizer < num_persons))\n\n# TeamOf constraints:\n# Organizer has TeamOf = -1\nfor i in range(num_persons):\n    is_organizer = Organizer == i\n    # If person i is organizer, TeamOf[i] == -1\n    solver.add(If(is_organizer, TeamOf[i] == -1, And(TeamOf[i] >= 0, TeamOf[i] <= 2)))\n\n# Exactly one organizer:\n# Already ensured by Organizer variable's domain\n\n# The persons who are not organizer must be assigned to exactly 3 teams of 2 persons each\n# So TeamOf values for non-organizers must be 0,1,2 and each team has exactly 2 persons\n\nfor t in range(3):\n    count_team_t = Sum([If(TeamOf[i] == t, 1, 0) for i in range(num_persons)])\n    solver.add(count_team_t == 2)\n\n# The organizer is not on any team\n# Already ensured by TeamOf == -1 for organizer\n\n# No person can be on more than one team: TeamOf is single integer per person, so no overlap\n\n# Constraint: M and P cannot be on the same team\nm_i = person_idx['M']\np_i = person_idx['P']\nsolver.add(TeamOf[m_i] != TeamOf[p_i])\n\n# Constraint: If K is on a team, M must also be on that team\nk_i = person_idx['K']\nsolver.add(Or(TeamOf[k_i] == -1, TeamOf[m_i] == TeamOf[k_i]))\n\n# Constraint: If G is on a team, either H or I must also be on that team\ng_i = person_idx['G']\nh_i = person_idx['H']\ni_i = person_idx['I']\n# If G is organizer, no team; else if G is on team t, then H or I is also on team t\ng_on_team = TeamOf[g_i] != -1\nsolver.add(Implies(g_on_team, Or(TeamOf[h_i] == TeamOf[g_i], TeamOf[i_i] == TeamOf[g_i])))\n\n# Constraint: If H is on a team, K must be the organizer\nh_on_team = TeamOf[h_i] != -1\nsolver.add(Implies(h_on_team, Organizer == k_i))\n\n# OPTION CHECKING\n\noptions = ['G', 'H', 'I', 'L', 'P']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that organizer is opt\n    solver.add(Organizer == person_idx[opt])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Seven persons—G, H, I, K, L, M, and P—are going rock-climbing together. One person will be the organizer and not a member of any team. The remaining six will form three climbing teams, each consisting of two persons. No person can be on more than one team. The following conditions also apply: M and P cannot be on the same team as each other. If K is on a team, M must also be on that team. If G is on a team, either H or I must also be on that team. If H is on a team, K must be the organizer.\n\nIf G and I form a team and if H is a member of a team, then H must be on the same team as either\n\nOptions:\n(A) K or L\n(B) K or P\n(C) L or M\n(D) L or P\n(E) M or P",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['G', 'H', 'I', 'K', 'L', 'M', 'P']\nnum_persons = len(persons)\nperson_idx = {p: i for i, p in enumerate(persons)}\n\n# Organizer variable: integer index of organizer person\norganizer = Int('organizer')\n# Teams: three teams of two persons each, represented by pairs of indices\n# team1 = (t1a, t1b), team2 = (t2a, t2b), team3 = (t3a, t3b)\nt1a, t1b = Ints('t1a t1b')\nt2a, t2b = Ints('t2a t2b')\nt3a, t3b = Ints('t3a t3b')\n\n# List of all team member variables\nteam_members = [t1a, t1b, t2a, t2b, t3a, t3b]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Organizer is one of the persons\nsolver.add(And(organizer >= 0, organizer < num_persons))\n\n# Each team member is a valid person index\nfor tm in team_members:\n    solver.add(And(tm >= 0, tm < num_persons))\n\n# Organizer is not on any team\nfor tm in team_members:\n    solver.add(tm != organizer)\n\n# All team members are distinct (no person on more than one team)\nsolver.add(Distinct(team_members))\n\n# Teams are pairs of two persons each (already enforced by distinctness and count)\n\n# M and P cannot be on the same team\n# For each team, if one is M then the other is not P\nM_idx = person_idx['M']\nP_idx = person_idx['P']\nfor a, b in [(t1a, t1b), (t2a, t2b), (t3a, t3b)]:\n    solver.add(Or(a != M_idx, b != P_idx))\n    solver.add(Or(a != P_idx, b != M_idx))\n\n# If K is on a team, M must also be on that team\nK_idx = person_idx['K']\nfor a, b in [(t1a, t1b), (t2a, t2b), (t3a, t3b)]:\n    # (K in team) => (M in team)\n    k_in_team = Or(a == K_idx, b == K_idx)\n    m_in_team = Or(a == M_idx, b == M_idx)\n    solver.add(Implies(k_in_team, m_in_team))\n\n# If G is on a team, either H or I must also be on that team\nG_idx = person_idx['G']\nH_idx = person_idx['H']\nI_idx = person_idx['I']\nfor a, b in [(t1a, t1b), (t2a, t2b), (t3a, t3b)]:\n    g_in_team = Or(a == G_idx, b == G_idx)\n    h_or_i_in_team = Or(a == H_idx, b == H_idx, a == I_idx, b == I_idx)\n    solver.add(Implies(g_in_team, h_or_i_in_team))\n\n# If H is on a team, K must be the organizer\n# That means if H is on any team, organizer == K_idx\nh_on_team = Or([tm == H_idx for tm in team_members])\nsolver.add(Implies(h_on_team, organizer == K_idx))\n\n# OPTION CHECKING\n# The question:\n# If G and I form a team and if H is a member of a team,\n# then H must be on the same team as either\n# (A) K or L\n# (B) K or P\n# (C) L or M\n# (D) L or P\n# (E) M or P\n\n# We first add the condition that G and I form a team\n# and that H is on a team\n# Then for each option, check if the option must hold.\n\n# Define a helper function to check if G and I form a team\ndef g_i_team_constraint():\n    # G and I are on the same team means there exists a team with G and I\n    conds = []\n    for a, b in [(t1a, t1b), (t2a, t2b), (t3a, t3b)]:\n        conds.append(Or(And(a == G_idx, b == I_idx), And(a == I_idx, b == G_idx)))\n    return Or(conds)\n\n# Define a helper function to check if H is on a team\ndef h_on_team_constraint():\n    return Or([tm == H_idx for tm in team_members])\n\n# Define a helper function to check if H is on the same team as either of two persons x,y\ndef h_with_x_or_y_constraint(x_idx, y_idx):\n    # There exists a team with H and (x or y)\n    conds = []\n    for a, b in [(t1a, t1b), (t2a, t2b), (t3a, t3b)]:\n        conds.append(Or(And(a == H_idx, Or(b == x_idx, b == y_idx)),\n                        And(b == H_idx, Or(a == x_idx, a == y_idx))))\n    return Or(conds)\n\noptions = [\n    ('A', [K_idx, person_idx['L']]),\n    ('B', [K_idx, P_idx]),\n    ('C', [person_idx['L'], M_idx]),\n    ('D', [person_idx['L'], P_idx]),\n    ('E', [M_idx, P_idx])\n]\n\n# We want to find which option must be true under the conditions:\n# G and I form a team AND H is on a team\n# => H is on the same team as either option persons\n\n# We check each option by adding the negation of the implication and see if it is unsat\n# That is, check if:\n# G and I form a team AND H is on a team AND NOT (H is on same team as option persons)\n# is unsat. If unsat, then the option must hold.\n\nfor letter, (x_idx, y_idx) in options:\n    solver.push()\n    solver.add(g_i_team_constraint())\n    solver.add(h_on_team_constraint())\n    # Add negation of \"H is on same team as x or y\"\n    solver.add(Not(h_with_x_or_y_constraint(x_idx, y_idx)))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Seven persons—G, H, I, K, L, M, and P—are going rock-climbing together. One person will be the organizer and not a member of any team. The remaining six will form three climbing teams, each consisting of two persons. No person can be on more than one team. The following conditions also apply: M and P cannot be on the same team as each other. If K is on a team, M must also be on that team. If G is on a team, either H or I must also be on that team. If H is on a team, K must be the organizer.\n\nThere are how many different persons any one of whom could be paired with M to form a team?\n\nOptions:\n(A) one\n(B) two\n(C) three\n(D) four\n(E) five",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['G', 'H', 'I', 'K', 'L', 'M', 'P']\nnum_persons = len(persons)\nindices = {p: i for i, p in enumerate(persons)}\n\n# Variables:\n# organizer: one person not on any team\norganizer = Int('organizer')\n# teams: three teams, each with two members (indices of persons)\n# Represent teams as list of pairs (t0_0, t0_1), (t1_0, t1_1), (t2_0, t2_1)\nteams = [(Int(f't{i}_0'), Int(f't{i}_1')) for i in range(3)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Organizer is between 0 and 6\nsolver.add(And(organizer >= 0, organizer < num_persons))\n\n# All team members are between 0 and 6\nfor t in teams:\n    solver.add(And(t[0] >= 0, t[0] < num_persons))\n    solver.add(And(t[1] >= 0, t[1] < num_persons))\n\n# Organizer not on any team\nfor t in teams:\n    solver.add(t[0] != organizer)\n    solver.add(t[1] != organizer)\n\n# All persons except organizer are on exactly one team\n# Collect all team members\nteam_members = []\nfor t in teams:\n    team_members.append(t[0])\n    team_members.append(t[1])\n\n# All team members distinct\nsolver.add(Distinct(team_members))\n\n# The set of team members plus organizer is all persons\n# So team_members + organizer is a permutation of persons indices 0..6\nall_vars = team_members + [organizer]\nsolver.add(Distinct(all_vars))\nsolver.add(And([And(v >= 0, v < num_persons) for v in all_vars]))\n# Since the distinctness and domain are enforced, all persons are used exactly once\n\n# Condition: M and P cannot be on the same team\n# M index and P index\nM_idx = indices['M']\nP_idx = indices['P']\nfor t in teams:\n    # Not both M and P in same team\n    cond = Not(And(Or(t[0] == M_idx, t[1] == M_idx), Or(t[0] == P_idx, t[1] == P_idx)))\n    solver.add(cond)\n\n# Condition: If K is on a team, M must also be on that team\nK_idx = indices['K']\nfor t in teams:\n    # If K in team then M in team\n    cond = Implies(Or(t[0] == K_idx, t[1] == K_idx), Or(t[0] == M_idx, t[1] == M_idx))\n    solver.add(cond)\n\n# Condition: If G is on a team, either H or I must also be on that team\nG_idx = indices['G']\nH_idx = indices['H']\nI_idx = indices['I']\nfor t in teams:\n    cond = Implies(Or(t[0] == G_idx, t[1] == G_idx), Or(t[0] == H_idx, t[1] == H_idx, t[0] == I_idx, t[1] == I_idx))\n    solver.add(cond)\n\n# Condition: If H is on a team, K must be the organizer\n# That means if H is in any team, then organizer == K_idx\nH_in_team = Or([Or(t[0] == H_idx, t[1] == H_idx) for t in teams])\nsolver.add(Implies(H_in_team, organizer == K_idx))\n\n# OPTION CHECKING\n# The question:\n# There are how many different persons any one of whom could be paired with M to form a team?\n\n# So we want to find all possible persons X != M such that there exists a valid arrangement where M and X are on the same team.\n\n# We will check for each person X != M if solver is satisfiable with constraint that M and X are on same team.\n\npossible_partners = []\n\nfor p in persons:\n    if p == 'M':\n        continue\n    p_idx = indices[p]\n\n    solver.push()\n    # Add constraint that M and p are on the same team\n    # So there exists a team t where (t[0], t[1]) == (M_idx, p_idx) or (p_idx, M_idx)\n    cond = Or([Or(And(t[0] == M_idx, t[1] == p_idx), And(t[0] == p_idx, t[1] == M_idx)) for t in teams])\n    solver.add(cond)\n\n    if solver.check() == sat:\n        possible_partners.append(p)\n\n    solver.pop()\n\n# Count how many possible partners\ncount = len(possible_partners)\n\n# Map count to option letter\n# (A) one\n# (B) two\n# (C) three\n# (D) four\n# (E) five\n\noption_map = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E'}\n\nprint(f\"'{option_map[count]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A train makes five trips around a loop through five stations—P, Q, R, S, and T, in that order—stopping at exactly three of the stations on each trip. The train must conform to the following conditions: The train stops at any given station on exactly three trips, but not on three consecutive trips. The train stops at any given station at least once in any two consecutive trips.\n\nWhich one of the following could be the list of stations at which the train stops on the first two trips?\n\nOptions:\n(A) first trip: P, Q, S; second trip: P, Q, R\n(B) first trip: P, Q, T; second trip: Q, R, T\n(C) first trip: Q, R, S; second trip: P, Q, S\n(D) first trip: Q, S, T; second trip: P, R, S\n(E) first trip: R, S, T; second trip: P, R, T",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstations = ['P', 'Q', 'R', 'S', 'T']\nnum_trips = 5\nnum_stations = len(stations)\n\n# Create Bool variables: stops[trip][station] is True if train stops at station on trip\nstops = [[Bool(f'stop_{trip}_{station}') for station in range(num_stations)] for trip in range(num_trips)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each trip stops at exactly 3 stations\nfor trip in range(num_trips):\n    solver.add(Sum([If(stops[trip][station], 1, 0) for station in range(num_stations)]) == 3)\n\n# Each station is stopped at exactly 3 times (over 5 trips)\nfor station in range(num_stations):\n    solver.add(Sum([If(stops[trip][station], 1, 0) for trip in range(num_trips)]) == 3)\n\n# No station is stopped at on 3 consecutive trips\nfor station in range(num_stations):\n    for trip in range(num_trips - 2):\n        # Not all three consecutive trips have stops at this station\n        trip0 = stops[trip][station]\n        trip1 = stops[trip+1][station]\n        trip2 = stops[trip+2][station]\n        solver.add(Not(And(trip0, trip1, trip2)))\n\n# Each station stops at least once in any two consecutive trips\nfor station in range(num_stations):\n    for trip in range(num_trips - 1):\n        trip0 = stops[trip][station]\n        trip1 = stops[trip+1][station]\n        solver.add(Or(trip0, trip1))\n\n# OPTION CHECKING\n# Define options as lists of sets of stations stopped on trips 1 and 2 (0-based indexing)\noptions = [\n    (['P', 'Q', 'S'], ['P', 'Q', 'R']),  # A\n    (['P', 'Q', 'T'], ['Q', 'R', 'T']),  # B\n    (['Q', 'R', 'S'], ['P', 'Q', 'S']),  # C\n    (['Q', 'S', 'T'], ['P', 'R', 'S']),  # D\n    (['R', 'S', 'T'], ['P', 'R', 'T']),  # E\n]\n\nfor i, (first_trip_stops, second_trip_stops) in enumerate(options):\n    solver.push()\n    # Add constraints for first trip stops\n    for station in range(num_stations):\n        station_name = stations[station]\n        if station_name in first_trip_stops:\n            solver.add(stops[0][station] == True)\n        else:\n            solver.add(stops[0][station] == False)\n    # Add constraints for second trip stops\n    for station in range(num_stations):\n        station_name = stations[station]\n        if station_name in second_trip_stops:\n            solver.add(stops[1][station] == True)\n        else:\n            solver.add(stops[1][station] == False)\n\n    # Check if model is satisfiable with these first two trips\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A train makes five trips around a loop through five stations—P, Q, R, S, and T, in that order—stopping at exactly three of the stations on each trip. The train must conform to the following conditions: The train stops at any given station on exactly three trips, but not on three consecutive trips. The train stops at any given station at least once in any two consecutive trips.\n\nIf on the first and third trips the train is to stop at Q, R, and S, and at R, S, and T, respectively, which one of the following is the list of stations at which it must stop on the second trip?\n\nOptions:\n(A) P, Q, R\n(B) P, Q, T\n(C) P, S, T\n(D) Q, R, T\n(E) Q, S, T",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstations = ['P', 'Q', 'R', 'S', 'T']\nnum_trips = 5\nnum_stops_per_trip = 3\nnum_trips_per_station = 3\n\n# Create variables: stops[trip][station] = Bool indicating if train stops at station on trip\nstops = [[Bool(f\"stop_{trip}_{station}\") for station in stations] for trip in range(num_trips)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each trip stops at exactly 3 stations\nfor trip in range(num_trips):\n    solver.add(Sum([If(stops[trip][s], 1, 0) for s in range(len(stations))]) == num_stops_per_trip)\n\n# 2) Each station is stopped at exactly 3 trips\nfor s in range(len(stations)):\n    solver.add(Sum([If(stops[trip][s], 1, 0) for trip in range(num_trips)]) == num_trips_per_station)\n\n# 3) No station is stopped at on 3 consecutive trips\n# For each station, for trips 0-2, 1-3, 2-4, sum stops in those 3 trips <= 2\nfor s in range(len(stations)):\n    for start in range(num_trips - 2):\n        trip_stops = [If(stops[start + i][s], 1, 0) for i in range(3)]\n        solver.add(Sum(trip_stops) <= 2)\n\n# 4) Each station is stopped at at least once in any two consecutive trips\n# For each station and each pair of consecutive trips, sum stops >= 1\nfor s in range(len(stations)):\n    for start in range(num_trips - 1):\n        trip_stops = [If(stops[start + i][s], 1, 0) for i in range(2)]\n        solver.add(Sum(trip_stops) >= 1)\n\n# 5) Given stops on first and third trips:\n# First trip (trip 0) stops at Q, R, S\nfor s in range(len(stations)):\n    if stations[s] in ['Q', 'R', 'S']:\n        solver.add(stops[0][s] == True)\n    else:\n        solver.add(stops[0][s] == False)\n\n# Third trip (trip 2) stops at R, S, T\nfor s in range(len(stations)):\n    if stations[s] in ['R', 'S', 'T']:\n        solver.add(stops[2][s] == True)\n    else:\n        solver.add(stops[2][s] == False)\n\n# OPTION CHECKING\noptions = [\n    ['P', 'Q', 'R'],  # A\n    ['P', 'Q', 'T'],  # B\n    ['P', 'S', 'T'],  # C\n    ['Q', 'R', 'T'],  # D\n    ['Q', 'S', 'T']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for second trip (trip 1) stops exactly at the option stations\n    for s in range(len(stations)):\n        if stations[s] in option:\n            solver.add(stops[1][s] == True)\n        else:\n            solver.add(stops[1][s] == False)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A train makes five trips around a loop through five stations—P, Q, R, S, and T, in that order—stopping at exactly three of the stations on each trip. The train must conform to the following conditions: The train stops at any given station on exactly three trips, but not on three consecutive trips. The train stops at any given station at least once in any two consecutive trips.\n\nThe train CANNOT stop at both P and Q on both the\n\nOptions:\n(A) first and third trips\n(B) first and fourth trips\n(C) second and fourth trips\n(D) second and fifth trips\n(E) fourth and fifth trips",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstations = ['P', 'Q', 'R', 'S', 'T']\nnum_stations = len(stations)\nnum_trips = 5\n\n# Create a 5x5 matrix: stop[trip][station] = Bool indicating if train stops at that station on that trip\nstop = [[Bool(f'stop_{t}_{s}') for s in range(num_stations)] for t in range(num_trips)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. The train stops at exactly 3 stations on each trip\nfor t in range(num_trips):\n    solver.add(Sum([If(stop[t][s], 1, 0) for s in range(num_stations)]) == 3)\n\n# 2. The train stops at any given station on exactly 3 trips\nfor s in range(num_stations):\n    solver.add(Sum([If(stop[t][s], 1, 0) for t in range(num_trips)]) == 3)\n\n# 3. The train does NOT stop at any given station on three consecutive trips\nfor s in range(num_stations):\n    for t in range(num_trips - 2):\n        # Not all three consecutive trips stop at station s\n        c = And(stop[t][s], stop[t+1][s], stop[t+2][s])\n        solver.add(Not(c))\n\n# 4. The train stops at any given station at least once in any two consecutive trips\nfor s in range(num_stations):\n    for t in range(num_trips - 1):\n        solver.add(Or(stop[t][s], stop[t+1][s]))\n\n# OPTION CHECKING\n\n# The train CANNOT stop at both P and Q on both the specified trips in each option\n# We will check for each option if it is possible that the train stops at both P and Q on both those trips\n# If it is not possible, that option is the correct answer\n\n# Map station names to indices\nP_idx = stations.index('P')\nQ_idx = stations.index('Q')\n\noptions = {\n    'A': [0, 2],  # first and third trips (0-based indexing)\n    'B': [0, 3],  # first and fourth trips\n    'C': [1, 3],  # second and fourth trips\n    'D': [1, 4],  # second and fifth trips\n    'E': [3, 4],  # fourth and fifth trips\n}\n\nfor opt_letter, trips in options.items():\n    solver.push()\n    t1, t2 = trips\n    # Add constraint that train stops at both P and Q on both trips\n    solver.add(stop[t1][P_idx])\n    solver.add(stop[t1][Q_idx])\n    solver.add(stop[t2][P_idx])\n    solver.add(stop[t2][Q_idx])\n    if solver.check() == unsat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A train makes five trips around a loop through five stations—P, Q, R, S, and T, in that order—stopping at exactly three of the stations on each trip. The train must conform to the following conditions: The train stops at any given station on exactly three trips, but not on three consecutive trips. The train stops at any given station at least once in any two consecutive trips.\n\nIf the train is to stop at Q, R, and T on the first trip and at Q, R, and S on the fourth trip, then it could be true that the train\n\nOptions:\n(A) stops at Q on the second trip\n(B) stops at R on the fifth trip\n(C) stops at T on the second trip\n(D) does not stop at P on the third trip\n(E) does not stop at T on the fifth trip",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstations = ['P', 'Q', 'R', 'S', 'T']\ntrips = range(5)\n\n# Create a 5x5 matrix of Bool variables: stops[trip][station]\nstops = [[Bool(f\"stop_{t}_{s}\") for s in stations] for t in trips]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each trip stops at exactly 3 stations\nfor t in trips:\n    solver.add(Sum([If(stops[t][s], 1, 0) for s in range(len(stations))]) == 3)\n\n# 2. Each station stops on exactly 3 trips\nfor s in range(len(stations)):\n    solver.add(Sum([If(stops[t][s], 1, 0) for t in trips]) == 3)\n\n# 3. No station stops on three consecutive trips\nfor s in range(len(stations)):\n    for t in range(3):\n        # stops[t][s] and stops[t+1][s] and stops[t+2][s] cannot all be True\n        solver.add(Not(And(stops[t][s], stops[t+1][s], stops[t+2][s])))\n\n# 4. Each station stops at least once in any two consecutive trips\nfor s in range(len(stations)):\n    for t in range(4):\n        # stops[t][s] or stops[t+1][s] must be True\n        solver.add(Or(stops[t][s], stops[t+1][s]))\n\n# 5. Given conditions for trips 1 and 4 (0-based indexing)\n# Trip 1 (index 0) stops at Q, R, T\nsolver.add(stops[0][stations.index('Q')])\nsolver.add(stops[0][stations.index('R')])\nsolver.add(stops[0][stations.index('T')])\nfor s in range(len(stations)):\n    if stations[s] not in ['Q', 'R', 'T']:\n        solver.add(Not(stops[0][s]))\n\n# Trip 4 (index 3) stops at Q, R, S\nsolver.add(stops[3][stations.index('Q')])\nsolver.add(stops[3][stations.index('R')])\nsolver.add(stops[3][stations.index('S')])\nfor s in range(len(stations)):\n    if stations[s] not in ['Q', 'R', 'S']:\n        solver.add(Not(stops[3][s]))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) stops at Q on the second trip (trip 2 index 1)\n    stops[1][stations.index('Q')],\n    # (B) stops at R on the fifth trip (trip 5 index 4)\n    stops[4][stations.index('R')],\n    # (C) stops at T on the second trip (trip 2 index 1)\n    stops[1][stations.index('T')],\n    # (D) does not stop at P on the third trip (trip 3 index 2)\n    Not(stops[2][stations.index('P')]),\n    # (E) does not stop at T on the fifth trip (trip 5 index 4)\n    Not(stops[4][stations.index('T')]),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "On a certain morning, each of six speakers—Feinberg, Guzman, Harrison, Jansen, Kim, and Mackey—will lecture for exactly one hour. Each lecture will take place in either the library or the studio, with exactly one speaker at a time lecturing in each of these two rooms. The lectures must be given in a manner consistent with the following conditions: Exactly three of the lectures are given in each room, the first beginning at precisely 8 A.M. , the second at precisely 9 A.M., and the third at precisely 10 A.M. Feinberg's lecture cannot begin earlier than Guzman's. Neither Jansen's lecture nor Mackey's lecture begins at the same time as Feinberg's. Harrison's lecture begins earlier than Feinberg's. Jansen and Mackey, not necessarily in that order, lecture in the studio.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Either Jansen or else Mackey lectures in the studio beginning at 8 A.M.\n(B) Either Harrison or else Mackey lectures in the studio beginning at 9 A.M.\n(C) Either Guzman or else Harrison lectures in the library beginning at 8 A.M.\n(D) Either Feinberg or else Guzman lectures in the library beginning at 9 A.M.\n(E) Either Feinberg or else Guzman lectures in the library beginning at 10 A.M.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nspeakers = ['Feinberg', 'Guzman', 'Harrison', 'Jansen', 'Kim', 'Mackey']\nrooms = ['Library', 'Studio']\ntimes = [8, 9, 10]  # Represent hours as integers\n\n# Create Z3 variables for each speaker's time and room\ntime_vars = {s: Int(f\"time_{s}\") for s in speakers}\nroom_vars = {s: Int(f\"room_{s}\") for s in speakers}  # 0 for Library, 1 for Studio\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each speaker's time must be one of 8, 9, 10\nfor s in speakers:\n    solver.add(Or([time_vars[s] == t for t in times]))\n\n# Each speaker's room must be either 0 (Library) or 1 (Studio)\nfor s in speakers:\n    solver.add(Or(room_vars[s] == 0, room_vars[s] == 1))\n\n# Exactly three lectures in each room\nlibrary_lectures = [If(room_vars[s] == 0, 1, 0) for s in speakers]\nstudio_lectures = [If(room_vars[s] == 1, 1, 0) for s in speakers]\nsolver.add(Sum(library_lectures) == 3)\nsolver.add(Sum(studio_lectures) == 3)\n\n# Exactly one speaker at a time in each room (no time overlaps in same room)\n# For each pair of distinct speakers, if they share room, times must differ\nfor i in range(len(speakers)):\n    for j in range(i + 1, len(speakers)):\n        s1 = speakers[i]\n        s2 = speakers[j]\n        same_room = room_vars[s1] == room_vars[s2]\n        same_time = time_vars[s1] == time_vars[s2]\n        # If same room, then times differ\n        solver.add(Implies(same_room, time_vars[s1] != time_vars[s2]))\n\n# Feinberg's lecture cannot begin earlier than Guzman's\nsolver.add(time_vars['Feinberg'] >= time_vars['Guzman'])\n\n# Neither Jansen's nor Mackey's lecture begins at the same time as Feinberg's\nsolver.add(time_vars['Jansen'] != time_vars['Feinberg'])\nsolver.add(time_vars['Mackey'] != time_vars['Feinberg'])\n\n# Harrison's lecture begins earlier than Feinberg's\nsolver.add(time_vars['Harrison'] < time_vars['Feinberg'])\n\n# Jansen and Mackey, not necessarily in that order, lecture in the studio\nsolver.add(room_vars['Jansen'] == 1)\nsolver.add(room_vars['Mackey'] == 1)\n\n# OPTION CHECKING\n\noptions = {\n    'A': Or(room_vars['Jansen'] == 1, And(time_vars['Jansen'] == 8, room_vars['Jansen'] == 1),\n            room_vars['Mackey'] == 1, And(time_vars['Mackey'] == 8, room_vars['Mackey'] == 1)),\n    # (A) Either Jansen or else Mackey lectures in the studio beginning at 8 A.M.\n    # More precisely: Jansen or Mackey lectures in studio at 8 AM\n    'A': Or(And(room_vars['Jansen'] == 1, time_vars['Jansen'] == 8),\n            And(room_vars['Mackey'] == 1, time_vars['Mackey'] == 8)),\n\n    # (B) Either Harrison or else Mackey lectures in the studio beginning at 9 A.M.\n    'B': Or(And(room_vars['Harrison'] == 1, time_vars['Harrison'] == 9),\n            And(room_vars['Mackey'] == 1, time_vars['Mackey'] == 9)),\n\n    # (C) Either Guzman or else Harrison lectures in the library beginning at 8 A.M.\n    'C': Or(And(room_vars['Guzman'] == 0, time_vars['Guzman'] == 8),\n            And(room_vars['Harrison'] == 0, time_vars['Harrison'] == 8)),\n\n    # (D) Either Feinberg or else Guzman lectures in the library beginning at 9 A.M.\n    'D': Or(And(room_vars['Feinberg'] == 0, time_vars['Feinberg'] == 9),\n            And(room_vars['Guzman'] == 0, time_vars['Guzman'] == 9)),\n\n    # (E) Either Feinberg or else Guzman lectures in the library beginning at 10 A.M.\n    'E': Or(And(room_vars['Feinberg'] == 0, time_vars['Feinberg'] == 10),\n            And(room_vars['Guzman'] == 0, time_vars['Guzman'] == 10)),\n}\n\n# Check each option: add negation of option and see if problem is still satisfiable\n# If negation is unsat, option must be true\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(Not(options[letter]))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "On a certain morning, each of six speakers—Feinberg, Guzman, Harrison, Jansen, Kim, and Mackey—will lecture for exactly one hour. Each lecture will take place in either the library or the studio, with exactly one speaker at a time lecturing in each of these two rooms. The lectures must be given in a manner consistent with the following conditions: Exactly three of the lectures are given in each room, the first beginning at precisely 8 A.M. , the second at precisely 9 A.M., and the third at precisely 10 A.M. Feinberg's lecture cannot begin earlier than Guzman's. Neither Jansen's lecture nor Mackey's lecture begins at the same time as Feinberg's. Harrison's lecture begins earlier than Feinberg's. Jansen and Mackey, not necessarily in that order, lecture in the studio.\n\nIf both Kim's lecture and Mackey's lecture begin at 9 A.M. , which one of the following could be true?\n\nOptions:\n(A) Guzman's lecture begins at 8 A.M.\n(B) Harrison's lecture begins at 10 A.M.\n(C) Jansen's lecture begins at 10 A.M.\n(D) Guzman lectures in the library.\n(E) Harrison lectures in the studio.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nspeakers = ['Feinberg', 'Guzman', 'Harrison', 'Jansen', 'Kim', 'Mackey']\ntimes = [8, 9, 10]  # Represent times as integers 8,9,10 for 8AM,9AM,10AM\nrooms = ['Library', 'Studio']\n\n# Create Z3 variables for each speaker's time and room\ntime_vars = {s: Int(f\"time_{s}\") for s in speakers}\nroom_vars = {s: Int(f\"room_{s}\") for s in speakers}  # 0 for Library, 1 for Studio\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each speaker lectures exactly once, time in {8,9,10}\nfor s in speakers:\n    solver.add(Or([time_vars[s] == t for t in times]))\n\n# Each speaker lectures exactly once, room in {0,1}\nfor s in speakers:\n    solver.add(Or([room_vars[s] == r for r in [0,1]]))\n\n# Exactly 3 lectures in each room\nlibrary_lectures = [If(room_vars[s] == 0, 1, 0) for s in speakers]\nstudio_lectures = [If(room_vars[s] == 1, 1, 0) for s in speakers]\nsolver.add(Sum(library_lectures) == 3)\nsolver.add(Sum(studio_lectures) == 3)\n\n# Exactly one speaker at each time in each room: no two speakers share same time and room\nfor t in times:\n    # Speakers in Library at time t\n    lib_at_t = [If(And(time_vars[s] == t, room_vars[s] == 0), 1, 0) for s in speakers]\n    solver.add(Sum(lib_at_t) == 1)\n    # Speakers in Studio at time t\n    stu_at_t = [If(And(time_vars[s] == t, room_vars[s] == 1), 1, 0) for s in speakers]\n    solver.add(Sum(stu_at_t) == 1)\n\n# Feinberg's lecture cannot begin earlier than Guzman's\nsolver.add(time_vars['Feinberg'] >= time_vars['Guzman'])\n\n# Neither Jansen's lecture nor Mackey's lecture begins at the same time as Feinberg's\nsolver.add(time_vars['Jansen'] != time_vars['Feinberg'])\nsolver.add(time_vars['Mackey'] != time_vars['Feinberg'])\n\n# Harrison's lecture begins earlier than Feinberg's\nsolver.add(time_vars['Harrison'] < time_vars['Feinberg'])\n\n# Jansen and Mackey, not necessarily in that order, lecture in the studio\nsolver.add(Or(And(room_vars['Jansen'] == 1, room_vars['Mackey'] == 1)))\n\n# Additional given condition for the question:\n# Both Kim's lecture and Mackey's lecture begin at 9 A.M.\nsolver.add(time_vars['Kim'] == 9)\nsolver.add(time_vars['Mackey'] == 9)\n\n# OPTION CHECKING\noptions = {\n    'A': time_vars['Guzman'] == 8,\n    'B': time_vars['Harrison'] == 10,\n    'C': time_vars['Jansen'] == 10,\n    'D': room_vars['Guzman'] == 0,\n    'E': room_vars['Harrison'] == 1\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "On a certain morning, each of six speakers—Feinberg, Guzman, Harrison, Jansen, Kim, and Mackey—will lecture for exactly one hour. Each lecture will take place in either the library or the studio, with exactly one speaker at a time lecturing in each of these two rooms. The lectures must be given in a manner consistent with the following conditions: Exactly three of the lectures are given in each room, the first beginning at precisely 8 A.M. , the second at precisely 9 A.M., and the third at precisely 10 A.M. Feinberg's lecture cannot begin earlier than Guzman's. Neither Jansen's lecture nor Mackey's lecture begins at the same time as Feinberg's. Harrison's lecture begins earlier than Feinberg's. Jansen and Mackey, not necessarily in that order, lecture in the studio.\n\nIf Harrison's lecture begins at 9 A.M. , which one of the following must be true?\n\nOptions:\n(A) Feinberg lectures in the library.\n(B) Guzman lectures in the studio.\n(C) Harrison lectures in the library.\n(D) Kim lectures in the studio.\n(E) Mackey lectures in the library.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Speakers\nspeakers = ['Feinberg', 'Guzman', 'Harrison', 'Jansen', 'Kim', 'Mackey']\n\n# Times: 8 AM = 0, 9 AM = 1, 10 AM = 2\ntimes = [0, 1, 2]\n\n# Rooms: Library = 0, Studio = 1\nrooms = [0, 1]\n\n# Create Z3 variables for each speaker's time and room\ntime_vars = {s: Int(f\"time_{s}\") for s in speakers}\nroom_vars = {s: Int(f\"room_{s}\") for s in speakers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each speaker lectures exactly one hour at a valid time and room\nfor s in speakers:\n    solver.add(And(time_vars[s] >= 0, time_vars[s] <= 2))\n    solver.add(Or(room_vars[s] == 0, room_vars[s] == 1))\n\n# Exactly one speaker at each time in each room (no overlap)\n# For each time and room, exactly one speaker lectures\nfor t in times:\n    for r in rooms:\n        speakers_at_t_r = [And(time_vars[s] == t, room_vars[s] == r) for s in speakers]\n        solver.add(PbEq([(cond,1) for cond in speakers_at_t_r], 1))\n\n# Exactly three lectures in each room\n# Count how many speakers are in each room\nfor r in rooms:\n    speakers_in_r = [If(room_vars[s] == r, 1, 0) for s in speakers]\n    solver.add(Sum(speakers_in_r) == 3)\n\n# Feinberg's lecture cannot begin earlier than Guzman's\nsolver.add(time_vars['Feinberg'] >= time_vars['Guzman'])\n\n# Neither Jansen's lecture nor Mackey's lecture begins at the same time as Feinberg's\nsolver.add(time_vars['Jansen'] != time_vars['Feinberg'])\nsolver.add(time_vars['Mackey'] != time_vars['Feinberg'])\n\n# Harrison's lecture begins earlier than Feinberg's\nsolver.add(time_vars['Harrison'] < time_vars['Feinberg'])\n\n# Jansen and Mackey, not necessarily in that order, lecture in the studio (room 1)\nsolver.add(room_vars['Jansen'] == 1)\nsolver.add(room_vars['Mackey'] == 1)\n\n# Additional given condition for the question: Harrison's lecture begins at 9 AM (time 1)\nsolver.add(time_vars['Harrison'] == 1)\n\n# OPTION CHECKING\n\n# Define options as functions adding the option-specific constraint\ndef option_A():\n    # Feinberg lectures in the library (room 0)\n    solver.push()\n    solver.add(room_vars['Feinberg'] == 0)\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\ndef option_B():\n    # Guzman lectures in the studio (room 1)\n    solver.push()\n    solver.add(room_vars['Guzman'] == 1)\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\ndef option_C():\n    # Harrison lectures in the library (room 0)\n    solver.push()\n    solver.add(room_vars['Harrison'] == 0)\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\ndef option_D():\n    # Kim lectures in the studio (room 1)\n    solver.push()\n    solver.add(room_vars['Kim'] == 1)\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\ndef option_E():\n    # Mackey lectures in the library (room 0)\n    solver.push()\n    solver.add(room_vars['Mackey'] == 0)\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\n# Since only one option must be true, check which options are always true\n# We'll check which options are true in all models consistent with the constraints\n\n# To check if an option must be true, we check if adding the negation of the option is unsat\n\ndef must_be_true(option_func):\n    # If negation of option leads to unsat, option must be true\n    solver.push()\n    # Add negation of option\n    if option_func == option_A:\n        solver.add(room_vars['Feinberg'] != 0)\n    elif option_func == option_B:\n        solver.add(room_vars['Guzman'] != 1)\n    elif option_func == option_C:\n        solver.add(room_vars['Harrison'] != 0)\n    elif option_func == option_D:\n        solver.add(room_vars['Kim'] != 1)\n    elif option_func == option_E:\n        solver.add(room_vars['Mackey'] != 0)\n    else:\n        solver.pop()\n        return False\n    result = solver.check()\n    solver.pop()\n    return result == unsat\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, opt in enumerate(options):\n    if must_be_true(opt):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "On a certain morning, each of six speakers—Feinberg, Guzman, Harrison, Jansen, Kim, and Mackey—will lecture for exactly one hour. Each lecture will take place in either the library or the studio, with exactly one speaker at a time lecturing in each of these two rooms. The lectures must be given in a manner consistent with the following conditions: Exactly three of the lectures are given in each room, the first beginning at precisely 8 A.M. , the second at precisely 9 A.M., and the third at precisely 10 A.M. Feinberg's lecture cannot begin earlier than Guzman's. Neither Jansen's lecture nor Mackey's lecture begins at the same time as Feinberg's. Harrison's lecture begins earlier than Feinberg's. Jansen and Mackey, not necessarily in that order, lecture in the studio.\n\nEach of the following is a pair of speakers whose lectures could begin at the same time as each other EXCEPT:\n\nOptions:\n(A) Feinberg and Guzman\n(B) Feinberg and Kim\n(C) Guzman and Jansen\n(D) Guzman and Kim\n(E) Guzman and Mackey",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nspeakers = ['Feinberg', 'Guzman', 'Harrison', 'Jansen', 'Kim', 'Mackey']\nrooms = ['Library', 'Studio']\ntimes = [8, 9, 10]  # Representing hours 8 AM, 9 AM, 10 AM\n\n# Create Z3 Int variables for each speaker's time and room\n# time: 0,1,2 representing 8,9,10\n# room: 0 for Library, 1 for Studio\ntime_vars = {s: Int(f\"time_{s}\") for s in speakers}\nroom_vars = {s: Int(f\"room_{s}\") for s in speakers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each speaker lectures exactly once at one of the three times and one of the two rooms\nfor s in speakers:\n    solver.add(And(time_vars[s] >= 0, time_vars[s] < 3))\n    solver.add(Or(room_vars[s] == 0, room_vars[s] == 1))\n\n# Exactly three lectures in each room\n# Count number of speakers in library = 3 and in studio = 3\nlibrary_count = Sum([If(room_vars[s] == 0, 1, 0) for s in speakers])\nstudio_count = Sum([If(room_vars[s] == 1, 1, 0) for s in speakers])\nsolver.add(library_count == 3)\nsolver.add(studio_count == 3)\n\n# Exactly one speaker at a time in each room (no overlap)\n# For each pair of distinct speakers:\nfor i in range(len(speakers)):\n    for j in range(i+1, len(speakers)):\n        s1 = speakers[i]\n        s2 = speakers[j]\n        # If same room, then times must be different\n        same_room = room_vars[s1] == room_vars[s2]\n        same_time = time_vars[s1] == time_vars[s2]\n        solver.add(Implies(same_room, Not(same_time)))\n\n# Feinberg's lecture cannot begin earlier than Guzman's (Feinberg time >= Guzman time)\nsolver.add(time_vars['Feinberg'] >= time_vars['Guzman'])\n\n# Neither Jansen's nor Mackey's lecture begins at the same time as Feinberg's\nsolver.add(time_vars['Jansen'] != time_vars['Feinberg'])\nsolver.add(time_vars['Mackey'] != time_vars['Feinberg'])\n\n# Harrison's lecture begins earlier than Feinberg's (Harrison time < Feinberg time)\nsolver.add(time_vars['Harrison'] < time_vars['Feinberg'])\n\n# Jansen and Mackey, not necessarily in that order, lecture in the studio\nsolver.add(room_vars['Jansen'] == 1)\nsolver.add(room_vars['Mackey'] == 1)\n\n# OPTION CHECKING\n# Each option is a pair of speakers who could begin at the same time EXCEPT which one?\n\noptions = [\n    ('Feinberg', 'Guzman'),  # A\n    ('Feinberg', 'Kim'),     # B\n    ('Guzman', 'Jansen'),    # C\n    ('Guzman', 'Kim'),       # D\n    ('Guzman', 'Mackey')     # E\n]\n\n# We test each option by adding a constraint that these two speakers start at the same time\n# If the solver finds a solution, then they could start at the same time.\n# The EXCEPT answer is the one for which no solution exists.\n\nfor i, (s1, s2) in enumerate(options):\n    solver.push()\n    solver.add(time_vars[s1] == time_vars[s2])\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        solver.pop()\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "On a certain morning, each of six speakers—Feinberg, Guzman, Harrison, Jansen, Kim, and Mackey—will lecture for exactly one hour. Each lecture will take place in either the library or the studio, with exactly one speaker at a time lecturing in each of these two rooms. The lectures must be given in a manner consistent with the following conditions: Exactly three of the lectures are given in each room, the first beginning at precisely 8 A.M. , the second at precisely 9 A.M., and the third at precisely 10 A.M. Feinberg's lecture cannot begin earlier than Guzman's. Neither Jansen's lecture nor Mackey's lecture begins at the same time as Feinberg's. Harrison's lecture begins earlier than Feinberg's. Jansen and Mackey, not necessarily in that order, lecture in the studio.\n\nIf Feinberg lectures in the library beginning at 9 A.M., which one of the following could be true?\n\nOptions:\n(A) Guzman lectures in the studio beginning at 10 A.M.\n(B) Harrison lectures in the studio beginning at 8 A.M.\n(C) Jansen lectures in the studio beginning at 10 A.M.\n(D) Kim lectures in the studio beginning at 9 A.M.\n(E) Mackey lectures in the studio beginning at 9 A.M.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Speakers\nspeakers = ['Feinberg', 'Guzman', 'Harrison', 'Jansen', 'Kim', 'Mackey']\n\n# Rooms\nrooms = ['Library', 'Studio']\n\n# Timeslots (0=8AM,1=9AM,2=10AM)\ntimes = [0, 1, 2]\n\n# Create variables for each speaker's time and room\ntime_vars = {s: Int(f\"time_{s}\") for s in speakers}\nroom_vars = {s: Int(f\"room_{s}\") for s in speakers}  # 0=Library, 1=Studio\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each speaker lectures exactly once at one time and one room\nfor s in speakers:\n    solver.add(And(time_vars[s] >= 0, time_vars[s] <= 2))\n    solver.add(Or(room_vars[s] == 0, room_vars[s] == 1))\n\n# 2. Exactly one speaker lectures in each room at each time\nfor t in times:\n    # Speakers in library at time t\n    lib_speakers = [And(time_vars[s] == t, room_vars[s] == 0) for s in speakers]\n    # Exactly one in library at time t\n    solver.add(PbEq([(cond, 1) for cond in lib_speakers], 1))\n    # Speakers in studio at time t\n    stu_speakers = [And(time_vars[s] == t, room_vars[s] == 1) for s in speakers]\n    # Exactly one in studio at time t\n    solver.add(PbEq([(cond, 1) for cond in stu_speakers], 1))\n\n# 3. Exactly three lectures in each room total\nlib_count = [If(room_vars[s] == 0, 1, 0) for s in speakers]\nsolver.add(Sum(lib_count) == 3)\n# Studio count is 3 by complement\n\n# 4. Feinberg's lecture cannot begin earlier than Guzman's\nsolver.add(time_vars['Feinberg'] >= time_vars['Guzman'])\n\n# 5. Neither Jansen's nor Mackey's lecture begins at the same time as Feinberg's\nsolver.add(time_vars['Jansen'] != time_vars['Feinberg'])\nsolver.add(time_vars['Mackey'] != time_vars['Feinberg'])\n\n# 6. Harrison's lecture begins earlier than Feinberg's\nsolver.add(time_vars['Harrison'] < time_vars['Feinberg'])\n\n# 7. Jansen and Mackey, not necessarily in that order, lecture in the studio\nsolver.add(Or(And(room_vars['Jansen'] == 1, room_vars['Mackey'] == 1)))\n\n# GIVEN: Feinberg lectures in the library beginning at 9 A.M.\nsolver.add(time_vars['Feinberg'] == 1)\nsolver.add(room_vars['Feinberg'] == 0)\n\n# OPTION CHECKING\n\noptions = [\n    ('A', And(room_vars['Guzman'] == 1, time_vars['Guzman'] == 2)),  # Guzman in studio at 10AM\n    ('B', And(room_vars['Harrison'] == 1, time_vars['Harrison'] == 0)),  # Harrison in studio at 8AM\n    ('C', And(room_vars['Jansen'] == 1, time_vars['Jansen'] == 2)),  # Jansen in studio at 10AM\n    ('D', And(room_vars['Kim'] == 1, time_vars['Kim'] == 1)),  # Kim in studio at 9AM\n    ('E', And(room_vars['Mackey'] == 1, time_vars['Mackey'] == 1)),  # Mackey in studio at 9AM\n]\n\nfor letter, condition in options:\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "On a certain morning, each of six speakers—Feinberg, Guzman, Harrison, Jansen, Kim, and Mackey—will lecture for exactly one hour. Each lecture will take place in either the library or the studio, with exactly one speaker at a time lecturing in each of these two rooms. The lectures must be given in a manner consistent with the following conditions: Exactly three of the lectures are given in each room, the first beginning at precisely 8 A.M. , the second at precisely 9 A.M., and the third at precisely 10 A.M. Feinberg's lecture cannot begin earlier than Guzman's. Neither Jansen's lecture nor Mackey's lecture begins at the same time as Feinberg's. Harrison's lecture begins earlier than Feinberg's. Jansen and Mackey, not necessarily in that order, lecture in the studio.\n\nWhich one of the following could be a list of the speakers who give their lectures in the studio, in the order in which they give their lectures, from first to third, respectively?\n\nOptions:\n(A) Feinberg, Jansen, Mackey\n(B) Guzman, Kim, Mackey\n(C) Harrison, Jansen, Kim\n(D) Jansen, Mackey, Harrison\n(E) Mackey, Feinberg, Jansen",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nspeakers = ['Feinberg', 'Guzman', 'Harrison', 'Jansen', 'Kim', 'Mackey']\nrooms = ['Library', 'Studio']\ntimes = [8, 9, 10]  # Representing 8 A.M., 9 A.M., 10 A.M.\n\n# Create variables for each speaker:\n# time_vars[speaker] = time slot index (0 for 8 AM, 1 for 9 AM, 2 for 10 AM)\n# room_vars[speaker] = room index (0 for Library, 1 for Studio)\ntime_vars = {s: Int(f\"time_{s}\") for s in speakers}\nroom_vars = {s: Int(f\"room_{s}\") for s in speakers}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each speaker lectures exactly once at one of the three times and one room\nfor s in speakers:\n    solver.add(And(time_vars[s] >= 0, time_vars[s] < 3))\n    solver.add(And(room_vars[s] >= 0, room_vars[s] < 2))\n\n# Exactly one speaker lectures in each room at each time\n# For each time slot, exactly one speaker in Library and one in Studio\nfor t in range(3):\n    # Speakers in Library at time t\n    lib_at_t = [And(time_vars[s] == t, room_vars[s] == 0) for s in speakers]\n    # Speakers in Studio at time t\n    stu_at_t = [And(time_vars[s] == t, room_vars[s] == 1) for s in speakers]\n    solver.add(PbEq([(lib_at_t[i], 1) for i in range(len(lib_at_t))], 1))\n    solver.add(PbEq([(stu_at_t[i], 1) for i in range(len(stu_at_t))], 1))\n\n# Each speaker must have a unique time slot (no two speakers at the same time in the same room)\n# Already ensured by above constraints for each room and time\n\n# Each speaker has a unique time slot (no two speakers at the same time in the same room is allowed,\n# but two speakers can be at the same time if in different rooms)\n# So no need to enforce distinct times overall.\n\n# Condition 1: Feinberg's lecture cannot begin earlier than Guzman's.\nsolver.add(time_vars['Feinberg'] >= time_vars['Guzman'])\n\n# Condition 2: Neither Jansen's lecture nor Mackey's lecture begins at the same time as Feinberg's.\nsolver.add(time_vars['Jansen'] != time_vars['Feinberg'])\nsolver.add(time_vars['Mackey'] != time_vars['Feinberg'])\n\n# Condition 3: Harrison's lecture begins earlier than Feinberg's.\nsolver.add(time_vars['Harrison'] < time_vars['Feinberg'])\n\n# Condition 4: Jansen and Mackey, not necessarily in that order, lecture in the studio.\nsolver.add(room_vars['Jansen'] == 1)\nsolver.add(room_vars['Mackey'] == 1)\n\n# Exactly three lectures are given in each room\n# Count speakers in each room\nstudio_speakers = [If(room_vars[s] == 1, 1, 0) for s in speakers]\nlibrary_speakers = [If(room_vars[s] == 0, 1, 0) for s in speakers]\nsolver.add(Sum(studio_speakers) == 3)\nsolver.add(Sum(library_speakers) == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': ['Feinberg', 'Jansen', 'Mackey'],\n    'B': ['Guzman', 'Kim', 'Mackey'],\n    'C': ['Harrison', 'Jansen', 'Kim'],\n    'D': ['Jansen', 'Mackey', 'Harrison'],\n    'E': ['Mackey', 'Feinberg', 'Jansen']\n}\n\nfor opt_letter, opt_speakers in options.items():\n    solver.push()\n\n    # Add constraints that the studio speakers in order of their lecture times are exactly opt_speakers\n    # Get list of studio speakers and their times\n    studio_speakers_vars = [s for s in speakers if s in opt_speakers or True]  # We will filter below\n\n    # We want to find the three speakers in studio sorted by time, and they must equal opt_speakers in order\n\n    # Create a list of all studio speakers variables and their times\n    # But we don't know which speakers are in studio yet except Jansen and Mackey are fixed\n    # So we enforce that the speakers in opt_speakers are exactly the studio speakers in order\n\n    # First, enforce that the speakers in opt_speakers are in studio\n    for s in opt_speakers:\n        solver.add(room_vars[s] == 1)\n\n    # Enforce that no other speakers except these three are in studio\n    other_speakers = [s for s in speakers if s not in opt_speakers]\n    for s in other_speakers:\n        solver.add(room_vars[s] == 0)\n\n    # Get times of the three studio speakers in opt_speakers\n    times_opt = [time_vars[s] for s in opt_speakers]\n\n    # The times must be all different (since only one speaker per room per time)\n    solver.add(Distinct(times_opt))\n\n    # Sort the times and compare order to opt_speakers order\n    # times_opt sorted ascending: t0 < t1 < t2\n    # We want to ensure that the order of the speakers by time is opt_speakers in order\n\n    # Enforce times_opt in ascending order\n    solver.add(times_opt[0] < times_opt[1])\n    solver.add(times_opt[1] < times_opt[2])\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "At a benefit dinner, a community theater's seven sponsors—K, L, M, P, Q, V, and Z—will be seated at three tables—1, 2, and 3. Of the sponsors, only K, L, and M will receive honors, and only M, P, and Q will give a speech. The sponsors' seating assignments must conform to the following conditions: Each table has at least two sponsors seated at it, and each sponsor is seated at exactly one table. Any sponsor receiving honors is seated at table 1 or table 2. L is seated at the same table as V.\n\nWhich one of the following is an acceptable assignment of sponsors to tables?\n\nOptions:\n(A) Table 1: K, P; Table 2: M, Q; Table 3: L, V, Z\n(B) Table 1: K, Q, Z; Table 2: L, V; Table 3: M, P\n(C) Table 1: L, P; Table 2: K, M; Table 3: Q, V, Z\n(D) Table 1: L, Q, V; Table 2: K, M; Table 3: P, Z\n(E) Table 1: L, V, Z; Table 2: K, M, P; Table 3: Q",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsponsors = ['K', 'L', 'M', 'P', 'Q', 'V', 'Z']\ntables = [1, 2, 3]\n\n# Create Z3 Int variables for each sponsor's table assignment\nseat = {s: Int(s) for s in sponsors}\n\n# Sets for honors and speeches\nhonors = ['K', 'L', 'M']\nspeeches = ['M', 'P', 'Q']\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each sponsor is seated at exactly one table (1, 2, or 3)\nfor s in sponsors:\n    solver.add(And(seat[s] >= 1, seat[s] <= 3))\n\n# Each table has at least two sponsors\nfor t in tables:\n    count_at_t = Sum([If(seat[s] == t, 1, 0) for s in sponsors])\n    solver.add(count_at_t >= 2)\n\n# Any sponsor receiving honors is seated at table 1 or 2\nfor h in honors:\n    solver.add(Or(seat[h] == 1, seat[h] == 2))\n\n# L is seated at the same table as V\nsolver.add(seat['L'] == seat['V'])\n\n# OPTION CHECKING\noptions = [\n    {'1': ['K', 'P'],        '2': ['M', 'Q'],      '3': ['L', 'V', 'Z']},  # A\n    {'1': ['K', 'Q', 'Z'],  '2': ['L', 'V'],      '3': ['M', 'P']},       # B\n    {'1': ['L', 'P'],       '2': ['K', 'M'],      '3': ['Q', 'V', 'Z']},  # C\n    {'1': ['L', 'Q', 'V'],  '2': ['K', 'M'],      '3': ['P', 'Z']},       # D\n    {'1': ['L', 'V', 'Z'],  '2': ['K', 'M', 'P'], '3': ['Q']}              # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n\n    # Add constraints for this option: seat assignments must match the option exactly\n    for t_str, s_list in option.items():\n        t_num = int(t_str)\n        for s in s_list:\n            solver.add(seat[s] == t_num)\n\n    # Also, sponsors not listed in any table of option must not be assigned to any table (should not happen)\n    assigned_sponsors = set()\n    for s_list in option.values():\n        assigned_sponsors.update(s_list)\n    unassigned = set(sponsors) - assigned_sponsors\n    for s in unassigned:\n        # Not assigned to any table (contradiction), so add false constraint\n        solver.add(False)\n\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "At a benefit dinner, a community theater's seven sponsors—K, L, M, P, Q, V, and Z—will be seated at three tables—1, 2, and 3. Of the sponsors, only K, L, and M will receive honors, and only M, P, and Q will give a speech. The sponsors' seating assignments must conform to the following conditions: Each table has at least two sponsors seated at it, and each sponsor is seated at exactly one table. Any sponsor receiving honors is seated at table 1 or table 2. L is seated at the same table as V.\n\nIf K is assigned to a different table than M, which one of the following must be true of the seating assignment?\n\nOptions:\n(A) K is seated at the same table as L.\n(B) L is seated at the same table as Q.\n(C) M is seated at the same table as V.\n(D) Exactly two sponsors are seated at table 1.\n(E) Exactly two sponsors are seated at table 3.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsponsors = ['K', 'L', 'M', 'P', 'Q', 'V', 'Z']\ntables = [1, 2, 3]\n\n# Create Z3 Int variables for each sponsor's table assignment\nseat = {s: Int(s) for s in sponsors}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each sponsor is seated at exactly one table (table numbers 1, 2, or 3)\nfor s in sponsors:\n    solver.add(And(seat[s] >= 1, seat[s] <= 3))\n\n# Each table has at least two sponsors seated at it\nfor t in tables:\n    count_at_t = Sum([If(seat[s] == t, 1, 0) for s in sponsors])\n    solver.add(count_at_t >= 2)\n\n# Only K, L, M receive honors; honors must be seated at table 1 or 2\n# So K, L, M must be seated at table 1 or 2\nfor honored in ['K', 'L', 'M']:\n    solver.add(Or(seat[honored] == 1, seat[honored] == 2))\n\n# L is seated at the same table as V\nsolver.add(seat['L'] == seat['V'])\n\n# Additional given condition for the question:\n# If K is assigned to a different table than M\nsolver.add(seat['K'] != seat['M'])\n\n# OPTION CHECKING\n\n# We will check each option by adding its constraint and testing satisfiability\n\n# Option A: K is seated at the same table as L\nsolver.push()\nsolver.add(seat['K'] == seat['L'])\nif solver.check() == unsat:\n    solver.pop()\n    option_A_valid = False\nelse:\n    solver.pop()\n    option_A_valid = True\n\n# Option B: L is seated at the same table as Q\nsolver.push()\nsolver.add(seat['L'] == seat['Q'])\nif solver.check() == unsat:\n    solver.pop()\n    option_B_valid = False\nelse:\n    solver.pop()\n    option_B_valid = True\n\n# Option C: M is seated at the same table as V\nsolver.push()\nsolver.add(seat['M'] == seat['V'])\nif solver.check() == unsat:\n    solver.pop()\n    option_C_valid = False\nelse:\n    solver.pop()\n    option_C_valid = True\n\n# Option D: Exactly two sponsors are seated at table 1\nsolver.push()\ncount_table_1 = Sum([If(seat[s] == 1, 1, 0) for s in sponsors])\nsolver.add(count_table_1 == 2)\nif solver.check() == unsat:\n    solver.pop()\n    option_D_valid = False\nelse:\n    solver.pop()\n    option_D_valid = True\n\n# Option E: Exactly two sponsors are seated at table 3\nsolver.push()\ncount_table_3 = Sum([If(seat[s] == 3, 1, 0) for s in sponsors])\nsolver.add(count_table_3 == 2)\nif solver.check() == unsat:\n    solver.pop()\n    option_E_valid = False\nelse:\n    solver.pop()\n    option_E_valid = True\n\n# Now check which options must be true: \n# An option must be true if its negation is unsat under the base constraints.\n# So we check negation of each option.\n\n# Check if option A must be true\nsolver.push()\nsolver.add(seat['K'] != seat['L'])\nif solver.check() == unsat:\n    must_be_true_A = True\nelse:\n    must_be_true_A = False\nsolver.pop()\n\n# Check if option B must be true\nsolver.push()\nsolver.add(seat['L'] != seat['Q'])\nif solver.check() == unsat:\n    must_be_true_B = True\nelse:\n    must_be_true_B = False\nsolver.pop()\n\n# Check if option C must be true\nsolver.push()\nsolver.add(seat['M'] != seat['V'])\nif solver.check() == unsat:\n    must_be_true_C = True\nelse:\n    must_be_true_C = False\nsolver.pop()\n\n# Check if option D must be true\nsolver.push()\nsolver.add(count_table_1 != 2)\nif solver.check() == unsat:\n    must_be_true_D = True\nelse:\n    must_be_true_D = False\nsolver.pop()\n\n# Check if option E must be true\nsolver.push()\nsolver.add(count_table_3 != 2)\nif solver.check() == unsat:\n    must_be_true_E = True\nelse:\n    must_be_true_E = False\nsolver.pop()\n\n# Print the letter of the option that must be true\nif must_be_true_A:\n    print(\"'A'\")\nelif must_be_true_B:\n    print(\"'B'\")\nelif must_be_true_C:\n    print(\"'C'\")\nelif must_be_true_D:\n    print(\"'D'\")\nelif must_be_true_E:\n    print(\"'E'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "At a benefit dinner, a community theater's seven sponsors—K, L, M, P, Q, V, and Z—will be seated at three tables—1, 2, and 3. Of the sponsors, only K, L, and M will receive honors, and only M, P, and Q will give a speech. The sponsors' seating assignments must conform to the following conditions: Each table has at least two sponsors seated at it, and each sponsor is seated at exactly one table. Any sponsor receiving honors is seated at table 1 or table 2. L is seated at the same table as V.\n\nIf Q is assigned to table 1 along with two other sponsors, which one of the following could be true of the seating assignment?\n\nOptions:\n(A) K is seated at the same table as L.\n(B) K is seated at the same table as Q.\n(C) M is seated at the same table as V.\n(D) M is seated at the same table as Z.\n(E) P Is seated at the same table as Q.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsponsors = ['K', 'L', 'M', 'P', 'Q', 'V', 'Z']\ntables = [1, 2, 3]\n\n# Create a Z3 Int variable for each sponsor representing their table assignment\nseat = {s: Int(s) for s in sponsors}\n\n# Sets for honors and speeches\nhonors = ['K', 'L', 'M']\nspeeches = ['M', 'P', 'Q']\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each sponsor seated at exactly one table (1, 2, or 3)\nfor s in sponsors:\n    solver.add(And(seat[s] >= 1, seat[s] <= 3))\n\n# Each table has at least two sponsors\nfor t in tables:\n    count_at_table = Sum([If(seat[s] == t, 1, 0) for s in sponsors])\n    solver.add(count_at_table >= 2)\n\n# Honors only at table 1 or 2\nfor h in honors:\n    solver.add(Or(seat[h] == 1, seat[h] == 2))\n\n# L is seated at the same table as V\nsolver.add(seat['L'] == seat['V'])\n\n# Q is assigned to table 1 along with two other sponsors\nsolver.add(seat['Q'] == 1)\ncount_table1 = Sum([If(seat[s] == 1, 1, 0) for s in sponsors])\nsolver.add(count_table1 == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': seat['K'] == seat['L'],\n    'B': seat['K'] == seat['Q'],\n    'C': seat['M'] == seat['V'],\n    'D': seat['M'] == seat['Z'],\n    'E': seat['P'] == seat['Q'],\n}\n\nfor option_letter, option_constraint in options.items():\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "At a benefit dinner, a community theater's seven sponsors—K, L, M, P, Q, V, and Z—will be seated at three tables—1, 2, and 3. Of the sponsors, only K, L, and M will receive honors, and only M, P, and Q will give a speech. The sponsors' seating assignments must conform to the following conditions: Each table has at least two sponsors seated at it, and each sponsor is seated at exactly one table. Any sponsor receiving honors is seated at table 1 or table 2. L is seated at the same table as V.\n\nIf the sponsors assigned to table 3 include exactly one of the sponsors who will give a speech, then the sponsors assigned to table 1 could include any of the following EXCEPT:\n\nOptions:\n(A) K\n(B) M\n(C) P\n(D) Q\n(E) Z",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsponsors = ['K', 'L', 'M', 'P', 'Q', 'V', 'Z']\ntables = [1, 2, 3]\n\n# Map sponsor to a Z3 Int variable representing their table assignment\nseat = {s: Int(s) for s in sponsors}\n\n# Helper sets for honors and speakers\nhonors = ['K', 'L', 'M']\nspeakers = ['M', 'P', 'Q']\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each sponsor seated at exactly one table (1, 2, or 3)\nfor s in sponsors:\n    solver.add(And(seat[s] >= 1, seat[s] <= 3))\n\n# Each table has at least two sponsors seated\nfor t in tables:\n    count_at_t = Sum([If(seat[s] == t, 1, 0) for s in sponsors])\n    solver.add(count_at_t >= 2)\n\n# Any sponsor receiving honors is seated at table 1 or 2\nfor s in honors:\n    solver.add(Or(seat[s] == 1, seat[s] == 2))\n\n# L is seated at the same table as V\nsolver.add(seat['L'] == seat['V'])\n\n# OPTION CHECKING\n# Condition: Table 3 includes exactly one speaker\n# Count speakers at table 3\nspeakers_at_3 = [If(seat[s] == 3, 1, 0) for s in speakers]\ncount_speakers_at_3 = Sum(speakers_at_3)\nsolver.add(count_speakers_at_3 == 1)\n\n# For each option, check if that sponsor can be seated at table 1\noptions = ['K', 'M', 'P', 'Q', 'Z']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that the sponsor in option is NOT at table 1 (to check if they can be at table 1)\n    # Actually, we want to check if the sponsor CAN be at table 1.\n    # So we add the constraint that the sponsor IS at table 1 and check satisfiability.\n    solver.add(seat[opt] == 1)\n    if solver.check() == unsat:\n        # If unsat, sponsor cannot be at table 1 under the conditions\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "At a benefit dinner, a community theater's seven sponsors—K, L, M, P, Q, V, and Z—will be seated at three tables—1, 2, and 3. Of the sponsors, only K, L, and M will receive honors, and only M, P, and Q will give a speech. The sponsors' seating assignments must conform to the following conditions: Each table has at least two sponsors seated at it, and each sponsor is seated at exactly one table. Any sponsor receiving honors is seated at table 1 or table 2. L is seated at the same table as V.\n\nIf three sponsors, exactly two of whom are receiving honors, are assigned to table 2, which one of the following could be the list of sponsors assigned to table 1?\n\nOptions:\n(A) K, M\n(B) K, Z\n(C) P, V\n(D) P, Z\n(E) Q, Z",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsponsors = ['K', 'L', 'M', 'P', 'Q', 'V', 'Z']\ntables = [1, 2, 3]\n\n# Indices for honors and speech\nhonors = ['K', 'L', 'M']\nspeech = ['M', 'P', 'Q']\n\n# Create Z3 Int variables for each sponsor's table assignment\nseat = {s: Int(s) for s in sponsors}\n\n# Helper functions\ndef is_honors(s):\n    return s in honors\n\ndef is_speech(s):\n    return s in speech\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each sponsor is seated at exactly one table (1, 2, or 3)\nfor s in sponsors:\n    solver.add(And(seat[s] >= 1, seat[s] <= 3))\n\n# Each table has at least two sponsors\nfor t in tables:\n    count_t = Sum([If(seat[s] == t, 1, 0) for s in sponsors])\n    solver.add(count_t >= 2)\n\n# Any sponsor receiving honors is seated at table 1 or table 2\nfor s in sponsors:\n    if is_honors(s):\n        solver.add(Or(seat[s] == 1, seat[s] == 2))\n\n# L is seated at the same table as V\nsolver.add(seat['L'] == seat['V'])\n\n# Additional condition given in the question:\n# Table 2 has exactly three sponsors, exactly two of whom are receiving honors\ncount_table2 = Sum([If(seat[s] == 2, 1, 0) for s in sponsors])\nsolver.add(count_table2 == 3)\n\ncount_table2_honors = Sum([If(And(seat[s] == 2, is_honors(s)), 1, 0) for s in sponsors])\nsolver.add(count_table2_honors == 2)\n\n# OPTION CHECKING\noptions = {\n    'A': ['K', 'M'],\n    'B': ['K', 'Z'],\n    'C': ['P', 'V'],\n    'D': ['P', 'Z'],\n    'E': ['Q', 'Z']\n}\n\nfor letter, group in options.items():\n    solver.push()\n    # Assign the specified sponsors to table 1\n    for s in sponsors:\n        if s in group:\n            solver.add(seat[s] == 1)\n        else:\n            # For sponsors not in the group, ensure they are not at table 1\n            solver.add(seat[s] != 1)\n\n    # Check if this seating is possible\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "At a benefit dinner, a community theater's seven sponsors—K, L, M, P, Q, V, and Z—will be seated at three tables—1, 2, and 3. Of the sponsors, only K, L, and M will receive honors, and only M, P, and Q will give a speech. The sponsors' seating assignments must conform to the following conditions: Each table has at least two sponsors seated at it, and each sponsor is seated at exactly one table. Any sponsor receiving honors is seated at table 1 or table 2. L is seated at the same table as V.\n\nWhich one of the following conditions, if added to the existing conditions, results in a set of conditions to which no seating assignment for the sponsors can conform?\n\nOptions:\n(A) At most two sponsors are seated at table 1.\n(B) Any sponsor giving a speech is seated at table 1 or else table 2.\n(C) Any sponsor giving a speech is seated at table 2 or else table 3.\n(D) Exactly three of the sponsors are seated at table 1.\n(E) Any table at which both L and V are seated also has a third sponsor seated at it.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsponsors = ['K', 'L', 'M', 'P', 'Q', 'V', 'Z']\ntables = [1, 2, 3]\n\n# Indices for honors and speeches\nhonors = ['K', 'L', 'M']\nspeeches = ['M', 'P', 'Q']\n\n# Create Z3 Int variables for each sponsor's table assignment\nseat = {s: Int(s) for s in sponsors}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each sponsor is seated at exactly one table (1, 2, or 3)\nfor s in sponsors:\n    solver.add(And(seat[s] >= 1, seat[s] <= 3))\n\n# Each table has at least two sponsors seated at it\nfor t in tables:\n    count_t = Sum([If(seat[s] == t, 1, 0) for s in sponsors])\n    solver.add(count_t >= 2)\n\n# Any sponsor receiving honors is seated at table 1 or table 2\nfor s in honors:\n    solver.add(Or(seat[s] == 1, seat[s] == 2))\n\n# L is seated at the same table as V\nsolver.add(seat['L'] == seat['V'])\n\n# OPTION CHECKING\n\noptions = [\n    # (A) At most two sponsors are seated at table 1.\n    lambda: solver.add(Sum([If(seat[s] == 1, 1, 0) for s in sponsors]) <= 2),\n    # (B) Any sponsor giving a speech is seated at table 1 or else table 2.\n    lambda: [solver.add(Or(seat[s] == 1, seat[s] == 2)) for s in speeches],\n    # (C) Any sponsor giving a speech is seated at table 2 or else table 3.\n    lambda: [solver.add(Or(seat[s] == 2, seat[s] == 3)) for s in speeches],\n    # (D) Exactly three of the sponsors are seated at table 1.\n    lambda: solver.add(Sum([If(seat[s] == 1, 1, 0) for s in sponsors]) == 3),\n    # (E) Any table at which both L and V are seated also has a third sponsor seated at it.\n    # Since L and V are at the same table, that table must have at least 3 sponsors.\n    lambda: solver.add(Sum([If(seat[s] == seat['L'], 1, 0) for s in sponsors]) >= 3)\n]\n\nfor i, add_option in enumerate(options):\n    solver.push()\n    add_option()\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly four medical training sessions—M, O, R, and S—will be scheduled for four consecutive days—day 1 through day 4—one session each day. Six professionals—three nurses and three psychologists—will teach the sessions. The nurses are Fine, Johnson, and Leopold; the psychologists are Tyler, Vitale, and Wong. Each session will be taught by exactly one nurse and exactly one psychologist. The schedule must conform to the following conditions: Each professional teaches at least once. Day 3 is a day on which Leopold teaches. Neither Fine nor Leopold teaches with Tyler. Johnson teaches session S only. Session M is taught on the day after the day on which session S is taught.\n\nWhich one of the following must be false?\n\nOptions:\n(A) Session O is scheduled for day 1.\n(B) Session S is scheduled for day 3.\n(C) Leopold is scheduled for day 1.\n(D) Vitale is scheduled for day 4.\n(E) Wong is scheduled for day 1.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Sessions and days\nsessions = ['M', 'O', 'R', 'S']\ndays = [1, 2, 3, 4]\n\n# Nurses and psychologists\nnurses = ['Fine', 'Johnson', 'Leopold']\npsychologists = ['Tyler', 'Vitale', 'Wong']\n\n# Create Z3 Int variables for sessions scheduled on days: session_day[s] = day of session s\nsession_day = {s: Int(f'session_day_{s}') for s in sessions}\n\n# Create Z3 Int variables for nurse teaching each session: nurse_of_session[s] = nurse index\nnurse_of_session = {s: Int(f'nurse_of_session_{s}') for s in sessions}\n\n# Create Z3 Int variables for psychologist teaching each session: psych_of_session[s] = psychologist index\npsych_of_session = {s: Int(f'psych_of_session_{s}') for s in sessions}\n\n# Map nurse and psychologist names to indices\nnurse_idx = {nurses[i]: i for i in range(len(nurses))}\npsych_idx = {psychologists[i]: i for i in range(len(psychologists))}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each session scheduled on a valid day 1-4\nfor s in sessions:\n    solver.add(And(session_day[s] >= 1, session_day[s] <= 4))\n\n# 2. Sessions are scheduled on distinct days (one session per day)\nsolver.add(Distinct([session_day[s] for s in sessions]))\n\n# 3. Each session taught by exactly one nurse and one psychologist (indices in valid ranges)\nfor s in sessions:\n    solver.add(And(nurse_of_session[s] >= 0, nurse_of_session[s] < len(nurses)))\n    solver.add(And(psych_of_session[s] >= 0, psych_of_session[s] < len(psychologists)))\n\n# 4. Each professional teaches at least once\n\n# Nurses teach at least once\nfor i in range(len(nurses)):\n    teaches = [nurse_of_session[s] == i for s in sessions]\n    solver.add(Or(teaches))\n\n# Psychologists teach at least once\nfor i in range(len(psychologists)):\n    teaches = [psych_of_session[s] == i for s in sessions]\n    solver.add(Or(teaches))\n\n# 5. Day 3 is a day on which Leopold teaches\n\n# Find sessions taught by Leopold (nurse index of Leopold)\nleopold_idx = nurse_idx['Leopold']\nleopold_sessions = [session_day[s] for s in sessions if s in sessions]  # all sessions\n\n# Add constraint that day 3 is day of a session taught by Leopold\nleopold_teach_day3 = []\nfor s in sessions:\n    cond = And(nurse_of_session[s] == leopold_idx, session_day[s] == 3)\n    leopold_teach_day3.append(cond)\nsolver.add(Or(leopold_teach_day3))\n\n# 6. Neither Fine nor Leopold teaches with Tyler\n\nfine_idx = nurse_idx['Fine']\ntyler_idx = psych_idx['Tyler']\n\nfor s in sessions:\n    # If nurse is Fine or Leopold, psychologist is not Tyler\n    cond_fine = Implies(nurse_of_session[s] == fine_idx, psych_of_session[s] != tyler_idx)\n    cond_leopold = Implies(nurse_of_session[s] == leopold_idx, psych_of_session[s] != tyler_idx)\n    solver.add(cond_fine)\n    solver.add(cond_leopold)\n\n# 7. Johnson teaches session S only\n\njohnson_idx = nurse_idx['Johnson']\n\nfor s in sessions:\n    if s == 'S':\n        # Johnson teaches session S\n        solver.add(nurse_of_session[s] == johnson_idx)\n    else:\n        # Johnson does not teach other sessions\n        solver.add(nurse_of_session[s] != johnson_idx)\n\n# 8. Session M is taught on the day after the day on which session S is taught\nsolver.add(session_day['M'] == session_day['S'] + 1)\n\n# OPTION CHECKING\n\noptions = [\n    ('A', session_day['O'] == 1),\n    ('B', session_day['S'] == 3),\n    ('C', Or([And(nurse_of_session[s] == leopold_idx, session_day[s] == 1) for s in sessions])),\n    ('D', Or([psych_of_session[s] == psych_idx['Vitale'], session_day[s] == 4]) == False),  # careful: must check Vitale scheduled day 4\n    ('E', Or([psych_of_session[s] == psych_idx['Wong'], session_day[s] == 1]) == False),  # careful: must check Wong scheduled day 1\n]\n\n# For options D and E, we must check if Vitale is scheduled on day 4 and Wong on day 1 respectively.\n# So we need to check if there exists a session s with psych_of_session[s] == Vitale and session_day[s] == 4\n# Similarly for Wong and day 1.\n\n# We will define helper functions to check these.\n\ndef check_option_A():\n    solver.push()\n    solver.add(session_day['O'] == 1)\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\ndef check_option_B():\n    solver.push()\n    solver.add(session_day['S'] == 3)\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\ndef check_option_C():\n    # Leopold scheduled day 1 means there exists a session s with nurse_of_session[s] == Leopold and session_day[s] == 1\n    solver.push()\n    conds = [And(nurse_of_session[s] == leopold_idx, session_day[s] == 1) for s in sessions]\n    solver.add(Or(conds))\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\ndef check_option_D():\n    # Vitale scheduled day 4 means there exists a session s with psych_of_session[s] == Vitale and session_day[s] == 4\n    solver.push()\n    conds = [And(psych_of_session[s] == psych_idx['Vitale'], session_day[s] == 4) for s in sessions]\n    solver.add(Or(conds))\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\ndef check_option_E():\n    # Wong scheduled day 1 means there exists a session s with psych_of_session[s] == Wong and session_day[s] == 1\n    solver.push()\n    conds = [And(psych_of_session[s] == psych_idx['Wong'], session_day[s] == 1) for s in sessions]\n    solver.add(Or(conds))\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\nchecks = [\n    ('A', check_option_A),\n    ('B', check_option_B),\n    ('C', check_option_C),\n    ('D', check_option_D),\n    ('E', check_option_E),\n]\n\nfor letter, check_func in checks:\n    if check_func():\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly four medical training sessions—M, O, R, and S—will be scheduled for four consecutive days—day 1 through day 4—one session each day. Six professionals—three nurses and three psychologists—will teach the sessions. The nurses are Fine, Johnson, and Leopold; the psychologists are Tyler, Vitale, and Wong. Each session will be taught by exactly one nurse and exactly one psychologist. The schedule must conform to the following conditions: Each professional teaches at least once. Day 3 is a day on which Leopold teaches. Neither Fine nor Leopold teaches with Tyler. Johnson teaches session S only. Session M is taught on the day after the day on which session S is taught.\n\nWhich one of the following could be the session and the professionals scheduled for day 4 ?\n\nOptions:\n(A) session M, Fine, Wong\n(B) session O, Fine, Tyler\n(C) session O, Johnson, Tyler\n(D) session R, Fine, Wong\n(E) session S, Fine, Vitale",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Days\ndays = [1, 2, 3, 4]\n\n# Sessions\nsessions = ['M', 'O', 'R', 'S']\nsession_idx = {s: i for i, s in enumerate(sessions)}\n\n# Nurses and Psychologists\nnurses = ['Fine', 'Johnson', 'Leopold']\npsychologists = ['Tyler', 'Vitale', 'Wong']\n\n# Create Z3 variables for each day:\n# session_day[d] = index of session on day d (0 to 3)\nsession_day = [Int(f'session_day_{d}') for d in days]\n\n# nurse_day[d] = index of nurse teaching on day d (0 to 2)\nnurse_day = [Int(f'nurse_day_{d}') for d in days]\n\n# psych_day[d] = index of psychologist teaching on day d (0 to 2)\npsych_day = [Int(f'psych_day_{d}') for d in days]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each day has a valid session, nurse, and psychologist\nfor d in range(4):\n    solver.add(And(session_day[d] >= 0, session_day[d] < len(sessions)))\n    solver.add(And(nurse_day[d] >= 0, nurse_day[d] < len(nurses)))\n    solver.add(And(psych_day[d] >= 0, psych_day[d] < len(psychologists)))\n\n# Each session is scheduled exactly once (since 4 sessions and 4 days)\nsolver.add(Distinct(session_day))\n\n# Each nurse teaches at least once over the 4 days\nfor n in range(len(nurses)):\n    teaches_nurse = [nurse_day[d] == n for d in range(4)]\n    solver.add(Or(teaches_nurse))\n\n# Each psychologist teaches at least once over the 4 days\nfor p in range(len(psychologists)):\n    teaches_psych = [psych_day[d] == p for d in range(4)]\n    solver.add(Or(teaches_psych))\n\n# Day 3 (index 2) is a day on which Leopold teaches\nsolver.add(nurse_day[2] == nurses.index('Leopold'))\n\n# Neither Fine nor Leopold teaches with Tyler\n# For each day, if nurse is Fine or Leopold, psychologist cannot be Tyler\nfor d in range(4):\n    nurse_is_fine_or_leopold = Or(nurse_day[d] == nurses.index('Fine'), nurse_day[d] == nurses.index('Leopold'))\n    psych_is_tyler = psych_day[d] == psychologists.index('Tyler')\n    solver.add(Implies(nurse_is_fine_or_leopold, Not(psych_is_tyler)))\n\n# Johnson teaches session S only\n# For each day, if nurse is Johnson, then session is S\nfor d in range(4):\n    nurse_is_johnson = nurse_day[d] == nurses.index('Johnson')\n    session_is_S = session_day[d] == session_idx['S']\n    solver.add(Implies(nurse_is_johnson, session_is_S))\n\n# Session M is taught on the day after the day on which session S is taught\n# Find day of S and day of M, M_day = S_day + 1\n# We create variables for S_day and M_day\nS_day = Int('S_day')\nM_day = Int('M_day')\n\nsolver.add(S_day >= 0, S_day < 4)\nsolver.add(M_day >= 0, M_day < 4)\n\n# Link S_day and M_day with session_day array\nfor d in range(4):\n    solver.add(If(session_day[d] == session_idx['S'], S_day == d, True))\n    solver.add(If(session_day[d] == session_idx['M'], M_day == d, True))\n\nsolver.add(M_day == S_day + 1)\n\n# OPTION CHECKING\n\noptions = [\n    ('M', 'Fine', 'Wong'),    # A\n    ('O', 'Fine', 'Tyler'),   # B\n    ('O', 'Johnson', 'Tyler'),# C\n    ('R', 'Fine', 'Wong'),    # D\n    ('S', 'Fine', 'Vitale')   # E\n]\n\nfor i, (sess_opt, nurse_opt, psych_opt) in enumerate(options):\n    solver.push()\n    # Add constraints for day 4 (index 3)\n    solver.add(session_day[3] == session_idx[sess_opt])\n    solver.add(nurse_day[3] == nurses.index(nurse_opt))\n    solver.add(psych_day[3] == psychologists.index(psych_opt))\n\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly four medical training sessions—M, O, R, and S—will be scheduled for four consecutive days—day 1 through day 4—one session each day. Six professionals—three nurses and three psychologists—will teach the sessions. The nurses are Fine, Johnson, and Leopold; the psychologists are Tyler, Vitale, and Wong. Each session will be taught by exactly one nurse and exactly one psychologist. The schedule must conform to the following conditions: Each professional teaches at least once. Day 3 is a day on which Leopold teaches. Neither Fine nor Leopold teaches with Tyler. Johnson teaches session S only. Session M is taught on the day after the day on which session S is taught.\n\nIf session S is scheduled for day 2, which one of the following is a professional who must be scheduled to teach session M ?\n\nOptions:\n(A) Fine\n(B) Leopold\n(C) Tyler\n(D) Vitale\n(E) Wong",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = [1, 2, 3, 4]\nsessions = ['M', 'O', 'R', 'S']\nnurses = ['Fine', 'Johnson', 'Leopold']\npsychologists = ['Tyler', 'Vitale', 'Wong']\n\n# Create Int variables for session day assignments: session -> day\nsession_day = {s: Int(f'day_{s}') for s in sessions}\n\n# Create Bool variables for who teaches each session: nurse_session and psych_session\nnurse_session = {}\nfor n in nurses:\n    for s in sessions:\n        nurse_session[(n, s)] = Bool(f'nurse_{n}_{s}')\npsych_session = {}\nfor p in psychologists:\n    for s in sessions:\n        psych_session[(p, s)] = Bool(f'psych_{p}_{s}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each session is scheduled on exactly one day from 1 to 4\nfor s in sessions:\n    solver.add(And(session_day[s] >= 1, session_day[s] <= 4))\n# All sessions on different days\nsolver.add(Distinct([session_day[s] for s in sessions]))\n\n# Each session is taught by exactly one nurse and exactly one psychologist\nfor s in sessions:\n    solver.add(Sum([If(nurse_session[(n, s)], 1, 0) for n in nurses]) == 1)\n    solver.add(Sum([If(psych_session[(p, s)], 1, 0) for p in psychologists]) == 1)\n\n# Each professional teaches at least once (nurses)\nfor n in nurses:\n    taught_sessions = [nurse_session[(n, s)] for s in sessions]\n    solver.add(Or(taught_sessions))\n\n# Each professional teaches at least once (psychologists)\nfor p in psychologists:\n    taught_sessions = [psych_session[(p, s)] for s in sessions]\n    solver.add(Or(taught_sessions))\n\n# Day 3 is a day on which Leopold teaches\nleopold_teaches_day3 = []\nfor s in sessions:\n    cond = And(session_day[s] == 3, nurse_session[('Leopold', s)])\n    leopold_teaches_day3.append(cond)\nsolver.add(Or(leopold_teaches_day3))\n\n# Neither Fine nor Leopold teaches with Tyler\nfor s in sessions:\n    fine_and_tyler = And(nurse_session[('Fine', s)], psych_session[('Tyler', s)])\n    leopold_and_tyler = And(nurse_session[('Leopold', s)], psych_session[('Tyler', s)])\n    solver.add(Not(fine_and_tyler))\n    solver.add(Not(leopold_and_tyler))\n\n# Johnson teaches session S only\n# Johnson teaches S\nsolver.add(nurse_session[('Johnson', 'S')])\n# Johnson does not teach any other session\nfor s in sessions:\n    if s != 'S':\n        solver.add(Not(nurse_session[('Johnson', s)]))\n\n# Session M is taught on the day after the day on which session S is taught\nsolver.add(session_day['M'] == session_day['S'] + 1)\n\n# Given: Session S is scheduled for day 2\nsolver.add(session_day['S'] == 2)\n\n# OPTION CHECKING\noptions = ['Fine', 'Leopold', 'Tyler', 'Vitale', 'Wong']\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraint: the professional teaches session M\n    if option in nurses:\n        solver.add(nurse_session[(option, 'M')])\n    else:\n        solver.add(psych_session[(option, 'M')])\n    # Check if the constraints are satisfiable\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly four medical training sessions—M, O, R, and S—will be scheduled for four consecutive days—day 1 through day 4—one session each day. Six professionals—three nurses and three psychologists—will teach the sessions. The nurses are Fine, Johnson, and Leopold; the psychologists are Tyler, Vitale, and Wong. Each session will be taught by exactly one nurse and exactly one psychologist. The schedule must conform to the following conditions: Each professional teaches at least once. Day 3 is a day on which Leopold teaches. Neither Fine nor Leopold teaches with Tyler. Johnson teaches session S only. Session M is taught on the day after the day on which session S is taught.\n\nWhich one of the following could be the order in which the nurses teach the sessions, listed from day 1 through day 4?\n\nOptions:\n(A) Fine, Johnson, Leopold, Leopold\n(B) Fine, Leopold, Leopold, Johnson\n(C) Johnson, Johnson, Leopold, Fine\n(D) Johnson, Leopold, Leopold, Johnson\n(E) Leopold, Leopold, Fine, Fine",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = [1, 2, 3, 4]\nsessions = ['M', 'O', 'R', 'S']\nnurses = ['Fine', 'Johnson', 'Leopold']\npsychologists = ['Tyler', 'Vitale', 'Wong']\n\n# Map names to indices for Z3 variables\nsession_idx = {s: i for i, s in enumerate(sessions)}\nnurse_idx = {n: i for i, n in enumerate(nurses)}\npsych_idx = {p: i for i, p in enumerate(psychologists)}\n\n# Variables for each day: which session is scheduled\nsession_day = [Int(f'session_day_{d}') for d in days]\n# Variables for nurses teaching each day\nnurse_day = [Int(f'nurse_day_{d}') for d in days]\n# Variables for psychologists teaching each day\npsych_day = [Int(f'psych_day_{d}') for d in days]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each day has exactly one session, nurse, psychologist\nfor d in range(4):\n    solver.add(And(session_day[d] >= 0, session_day[d] < len(sessions)))\n    solver.add(And(nurse_day[d] >= 0, nurse_day[d] < len(nurses)))\n    solver.add(And(psych_day[d] >= 0, psych_day[d] < len(psychologists)))\n\n# All sessions scheduled exactly once (distinct)\nsolver.add(Distinct(session_day))\n\n# Each professional teaches at least once\n# Nurses teach at least once: Fine, Johnson, Leopold\nfor n in range(len(nurses)):\n    teaches_nurse = [nurse_day[d] == n for d in range(4)]\n    solver.add(Or(teaches_nurse))\n\n# Psychologists teach at least once: Tyler, Vitale, Wong\nfor p in range(len(psychologists)):\n    teaches_psych = [psych_day[d] == p for d in range(4)]\n    solver.add(Or(teaches_psych))\n\n# Day 3 is a day on which Leopold teaches\nsolver.add(nurse_day[2] == nurse_idx['Leopold'])\n\n# Neither Fine nor Leopold teaches with Tyler\nfor d in range(4):\n    fine_or_leopold = Or(nurse_day[d] == nurse_idx['Fine'], nurse_day[d] == nurse_idx['Leopold'])\n    with_tyler = psych_day[d] == psych_idx['Tyler']\n    solver.add(Not(And(fine_or_leopold, with_tyler)))\n\n# Johnson teaches session S only\nfor d in range(4):\n    is_s = session_day[d] == session_idx['S']\n    is_johnson = nurse_day[d] == nurse_idx['Johnson']\n    # If session is S, nurse must be Johnson\n    solver.add(Implies(is_s, is_johnson))\n    # If nurse is Johnson, session must be S\n    solver.add(Implies(is_johnson, is_s))\n\n# Session M is taught on the day after the day on which session S is taught\n# Find day of S and day of M\n# Since sessions are distinct, exactly one day for each\nday_s = Int('day_s')\nday_m = Int('day_m')\nsolver.add(day_s >= 0, day_s < 4)\nsolver.add(day_m >= 0, day_m < 4)\n\nfor d in range(4):\n    solver.add(Implies(session_day[d] == session_idx['S'], day_s == d))\n    solver.add(Implies(session_day[d] == session_idx['M'], day_m == d))\n\nsolver.add(day_m == day_s + 1)\n\n# OPTION CHECKING\n\noptions = [\n    ['Fine', 'Johnson', 'Leopold', 'Leopold'],  # A\n    ['Fine', 'Leopold', 'Leopold', 'Johnson'],  # B\n    ['Johnson', 'Johnson', 'Leopold', 'Fine'],  # C\n    ['Johnson', 'Leopold', 'Leopold', 'Johnson'],  # D\n    ['Leopold', 'Leopold', 'Fine', 'Fine']  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for the nurse order for days 1-4\n    for d in range(4):\n        solver.add(nurse_day[d] == nurse_idx[option[d]])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly four medical training sessions—M, O, R, and S—will be scheduled for four consecutive days—day 1 through day 4—one session each day. Six professionals—three nurses and three psychologists—will teach the sessions. The nurses are Fine, Johnson, and Leopold; the psychologists are Tyler, Vitale, and Wong. Each session will be taught by exactly one nurse and exactly one psychologist. The schedule must conform to the following conditions: Each professional teaches at least once. Day 3 is a day on which Leopold teaches. Neither Fine nor Leopold teaches with Tyler. Johnson teaches session S only. Session M is taught on the day after the day on which session S is taught.\n\nIf session O is scheduled for day 3, which one of the following must be scheduled for day 4?\n\nOptions:\n(A) session R\n(B) session S\n(C) Fine\n(D) Leopold\n(E) Vitale",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = [1, 2, 3, 4]\nsessions = ['M', 'O', 'R', 'S']\nnurses = ['Fine', 'Johnson', 'Leopold']\npsychologists = ['Tyler', 'Vitale', 'Wong']\n\n# Map names to indices for Z3 variables\nsession_idx = {s: i for i, s in enumerate(sessions)}\nnurse_idx = {n: i for i, n in enumerate(nurses)}\npsych_idx = {p: i for i, p in enumerate(psychologists)}\n\n# Variables for each day: session, nurse, psychologist\nsession_day = [Int(f'session_day_{d}') for d in days]\nnurse_day = [Int(f'nurse_day_{d}') for d in days]\npsych_day = [Int(f'psych_day_{d}') for d in days]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each day has a valid session, nurse, psychologist\nfor d in range(4):\n    solver.add(And(session_day[d] >= 0, session_day[d] < 4))\n    solver.add(And(nurse_day[d] >= 0, nurse_day[d] < 3))\n    solver.add(And(psych_day[d] >= 0, psych_day[d] < 3))\n\n# All sessions scheduled exactly once (one per day)\nsolver.add(Distinct(session_day))\n\n# Each nurse teaches at least once\nfor n in range(3):\n    teaches_nurse = [nurse_day[d] == n for d in range(4)]\n    solver.add(Or(teaches_nurse))\n\n# Each psychologist teaches at least once\nfor p in range(3):\n    teaches_psych = [psych_day[d] == p for d in range(4)]\n    solver.add(Or(teaches_psych))\n\n# Each session taught by exactly one nurse and one psychologist per day\n# (Implicit in variables per day)\n\n# Day 3 is a day on which Leopold teaches\nsolver.add(nurse_day[2] == nurse_idx['Leopold'])\n\n# Neither Fine nor Leopold teaches with Tyler\nfor d in range(4):\n    fine_teaches = nurse_day[d] == nurse_idx['Fine']\n    leopold_teaches = nurse_day[d] == nurse_idx['Leopold']\n    tyler_teaches = psych_day[d] == psych_idx['Tyler']\n    solver.add(Not(And(fine_teaches, tyler_teaches)))\n    solver.add(Not(And(leopold_teaches, tyler_teaches)))\n\n# Johnson teaches session S only\nfor d in range(4):\n    johnson_teaches = nurse_day[d] == nurse_idx['Johnson']\n    session_s = session_day[d] == session_idx['S']\n    # Johnson only teaches session S\n    solver.add(johnson_teaches == session_s)\n\n# Session M is taught on the day after the day on which session S is taught\nday_s = Int('day_s')\nday_m = Int('day_m')\nsolver.add(day_s >= 1, day_s <= 4)\nsolver.add(day_m >= 1, day_m <= 4)\n# Find days for S and M\nfor d in range(4):\n    solver.add(If(session_day[d] == session_idx['S'], day_s == d + 1, True))\n    solver.add(If(session_day[d] == session_idx['M'], day_m == d + 1, True))\nsolver.add(day_m == day_s + 1)\n\n# IF session O is scheduled for day 3 (day index 2)\nsolver.add(session_day[2] == session_idx['O'])\n\n# OPTION CHECKING\n\n# We want to find which option must be scheduled for day 4 (index 3)\n# Options:\n# (A) session R\n# (B) session S\n# (C) Fine\n# (D) Leopold\n# (E) Vitale\n\noptions = [\n    ('session', session_idx['R']),\n    ('session', session_idx['S']),\n    ('nurse', nurse_idx['Fine']),\n    ('nurse', nurse_idx['Leopold']),\n    ('psych', psych_idx['Vitale'])\n]\n\nfor i, (typ, val) in enumerate(options):\n    solver.push()\n    # Add constraint that day 4 does NOT have the option value\n    if typ == 'session':\n        solver.add(session_day[3] != val)\n    elif typ == 'nurse':\n        solver.add(nurse_day[3] != val)\n    else:  # psych\n        solver.add(psych_day[3] != val)\n\n    if solver.check() == unsat:\n        # If adding the negation of the option makes it unsat,\n        # then this option must be scheduled on day 4\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Six paintings hang next to each other as shown below: Each of the paintings is an oil or else a watercolor. Each oil is directly beside, directly above, or directly below another oil. Each watercolor is directly beside, directly above, or directly below another watercolor. Each painting is a nineteenth-century painting or else a twentieth-century painting. Each painting is directly beside, directly above, or directly below another painting painted in the same century. Painting 2 is a nineteenth-century painting. Painting 3 is an oil. Painting 5 is a twentieth-century painting.\n\nIf all of the nineteenth-century paintings are watercolors, which one of the following must be true?\n\nOptions:\n(A) Painting 1 is an oil.\n(B) Painting 3 is a nineteenth-century painting.\n(C) Painting 4 is a watercolor.\n(D) Painting 5 is an oil.\n(E) Painting 6 is a twentieth-century painting.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Paintings numbered 1 through 6\npaintings = [1, 2, 3, 4, 5, 6]\n\n# Types: 0 = Oil, 1 = Watercolor\ntypes = [Int(f\"type_{p}\") for p in paintings]\n\n# Centuries: 0 = 19th century, 1 = 20th century\ncenturies = [Int(f\"century_{p}\") for p in paintings]\n\n# Helper: adjacency list based on the \"hang next to each other as shown below\"\n# The problem states \"hang next to each other as shown below\" but no diagram given,\n# so assume they are arranged in a row: 1-2-3-4-5-6\n# So adjacency is between neighbors only: (1-2), (2-3), (3-4), (4-5), (5-6)\nadjacent_pairs = [(1,2), (2,3), (3,4), (4,5), (5,6)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each painting's type is either 0 (oil) or 1 (watercolor)\nfor t in types:\n    solver.add(Or(t == 0, t == 1))\n\n# Each painting's century is either 0 (19th) or 1 (20th)\nfor c in centuries:\n    solver.add(Or(c == 0, c == 1))\n\n# Painting 2 is nineteenth-century\nsolver.add(centuries[1] == 0)  # painting 2 index=1\n\n# Painting 3 is an oil\nsolver.add(types[2] == 0)  # painting 3 index=2\n\n# Painting 5 is twentieth-century\nsolver.add(centuries[4] == 1)  # painting 5 index=4\n\n# Each oil is directly beside, above, or below another oil\n# Since paintings are in a row, \"beside\" means adjacent in the list\n# So for each oil painting, at least one adjacent painting is oil\nfor i, p in enumerate(paintings):\n    oil_cond = types[i] == 0\n    adjacent_indices = []\n    for (a,b) in adjacent_pairs:\n        if a == p:\n            adjacent_indices.append(b-1)\n        if b == p:\n            adjacent_indices.append(a-1)\n    # For painting p, if it is oil, then at least one adjacent painting is oil\n    adj_oils = [types[j] == 0 for j in adjacent_indices]\n    if adj_oils:\n        solver.add(Implies(oil_cond, Or(adj_oils)))\n\n# Each watercolor is directly beside, above, or below another watercolor\nfor i, p in enumerate(paintings):\n    water_cond = types[i] == 1\n    adjacent_indices = []\n    for (a,b) in adjacent_pairs:\n        if a == p:\n            adjacent_indices.append(b-1)\n        if b == p:\n            adjacent_indices.append(a-1)\n    adj_waters = [types[j] == 1 for j in adjacent_indices]\n    if adj_waters:\n        solver.add(Implies(water_cond, Or(adj_waters)))\n\n# Each painting is directly beside, above, or below another painting painted in the same century\nfor i, p in enumerate(paintings):\n    c_cond = centuries[i]\n    adjacent_indices = []\n    for (a,b) in adjacent_pairs:\n        if a == p:\n            adjacent_indices.append(b-1)\n        if b == p:\n            adjacent_indices.append(a-1)\n    adj_same_century = [centuries[j] == c_cond for j in adjacent_indices]\n    if adj_same_century:\n        solver.add(Or(adj_same_century))\n\n# If all nineteenth-century paintings are watercolors\n# So if century is 0, then type is 1 (watercolor)\nfor i in range(len(paintings)):\n    solver.add(Implies(centuries[i] == 0, types[i] == 1))\n\n# OPTION CHECKING\n# Options:\n# (A) Painting 1 is an oil. -> types[0] == 0\n# (B) Painting 3 is a nineteenth-century painting. -> centuries[2] == 0\n# (C) Painting 4 is a watercolor. -> types[3] == 1\n# (D) Painting 5 is an oil. -> types[4] == 0\n# (E) Painting 6 is a twentieth-century painting. -> centuries[5] == 1\n\noptions = [\n    (types[0] == 0),  # A\n    (centuries[2] == 0),  # B\n    (types[3] == 1),  # C\n    (types[4] == 0),  # D\n    (centuries[5] == 1)  # E\n]\n\n# Exactly one correct option, so check which must be true in all models\n# To check which must be true, we check if negation is unsat\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(Not(opt))\n    if solver.check() == unsat:\n        # The negation is unsat, so the option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Six paintings hang next to each other as shown below: Each of the paintings is an oil or else a watercolor. Each oil is directly beside, directly above, or directly below another oil. Each watercolor is directly beside, directly above, or directly below another watercolor. Each painting is a nineteenth-century painting or else a twentieth-century painting. Each painting is directly beside, directly above, or directly below another painting painted in the same century. Painting 2 is a nineteenth-century painting. Painting 3 is an oil. Painting 5 is a twentieth-century painting.\n\nIf there are exactly three oils and three watercolors, which one of the following must be true?\n\nOptions:\n(A) Painting 1 is a watercolor.\n(B) Painting 2 is a watercolor.\n(C) Painting 4 is a watercolor.\n(D) Painting 5 is a watercolor.\n(E) Painting 6 is a watercolor.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Paintings numbered 1 to 6\npaintings = [1, 2, 3, 4, 5, 6]\n\n# Types: 0 = Oil, 1 = Watercolor\ntypes = {p: Int(f\"type_{p}\") for p in paintings}\n\n# Centuries: 0 = 19th, 1 = 20th\ncenturies = {p: Int(f\"century_{p}\") for p in paintings}\n\n# Positions of paintings in a 2x3 grid:\n# Painting 1: (0,0), Painting 2: (0,1), Painting 3: (0,2)\n# Painting 4: (1,0), Painting 5: (1,1), Painting 6: (1,2)\npositions = {\n    1: (0, 0),\n    2: (0, 1),\n    3: (0, 2),\n    4: (1, 0),\n    5: (1, 1),\n    6: (1, 2),\n}\n\n# Helper function to find neighbors of a painting\ndef neighbors(p):\n    x, y = positions[p]\n    neigh = []\n    for q in paintings:\n        if q == p:\n            continue\n        xq, yq = positions[q]\n        # Directly beside (left/right) or directly above/below (up/down)\n        if (abs(x - xq) == 1 and y == yq) or (abs(y - yq) == 1 and x == xq):\n            neigh.append(q)\n    return neigh\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each painting's type is 0 (Oil) or 1 (Watercolor)\nfor p in paintings:\n    solver.add(Or(types[p] == 0, types[p] == 1))\n\n# Each painting's century is 0 (19th) or 1 (20th)\nfor p in paintings:\n    solver.add(Or(centuries[p] == 0, centuries[p] == 1))\n\n# Exactly three oils and three watercolors\nsolver.add(Sum([If(types[p] == 0, 1, 0) for p in paintings]) == 3)\nsolver.add(Sum([If(types[p] == 1, 1, 0) for p in paintings]) == 3)\n\n# Painting 2 is 19th century (0)\nsolver.add(centuries[2] == 0)\n\n# Painting 3 is oil (0)\nsolver.add(types[3] == 0)\n\n# Painting 5 is 20th century (1)\nsolver.add(centuries[5] == 1)\n\n# Each oil is directly beside, above, or below another oil\nfor p in paintings:\n    # If p is oil, then at least one neighbor is oil\n    oil_cond = Implies(\n        types[p] == 0,\n        Or([types[n] == 0 for n in neighbors(p)])\n    )\n    solver.add(oil_cond)\n\n# Each watercolor is directly beside, above, or below another watercolor\nfor p in paintings:\n    # If p is watercolor, then at least one neighbor is watercolor\n    watercolor_cond = Implies(\n        types[p] == 1,\n        Or([types[n] == 1 for n in neighbors(p)])\n    )\n    solver.add(watercolor_cond)\n\n# Each painting is directly beside, above, or below another painting painted in the same century\nfor p in paintings:\n    century_cond = Or([centuries[n] == centuries[p] for n in neighbors(p)])\n    solver.add(century_cond)\n\n# OPTION CHECKING\noptions = {\n    'A': types[1] == 1,  # Painting 1 is watercolor\n    'B': types[2] == 1,  # Painting 2 is watercolor\n    'C': types[4] == 1,  # Painting 4 is watercolor\n    'D': types[5] == 1,  # Painting 5 is watercolor\n    'E': types[6] == 1,  # Painting 6 is watercolor\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    # Add negation of the option condition to test if it can be false\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        # If unsat, the negation is impossible, so option must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Six paintings hang next to each other as shown below: Each of the paintings is an oil or else a watercolor. Each oil is directly beside, directly above, or directly below another oil. Each watercolor is directly beside, directly above, or directly below another watercolor. Each painting is a nineteenth-century painting or else a twentieth-century painting. Each painting is directly beside, directly above, or directly below another painting painted in the same century. Painting 2 is a nineteenth-century painting. Painting 3 is an oil. Painting 5 is a twentieth-century painting.\n\nIf exactly two paintings are oils and exactly two paintings are nineteenth-century paintings, which one of the following must be false?\n\nOptions:\n(A) Painting 1 is a nineteenth-century painting, and painting 6 is an oil.\n(B) Painting 2 is both a nineteenth-century painting and an oil.\n(C) Painting 3 is a nineteenth-century painting.\n(D) Paintings 1 and 2 are both nineteenth-century paintings.\n(E) Painting 2 is an oil, and painting 4 is a nineteenth-century painting.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Paintings indices: 1 to 6 (we will use 0-based internally)\npaintings = list(range(6))\n\n# Each painting is either Oil (1) or Watercolor (0)\nOil = 1\nWatercolor = 0\npainting_types = [Int(f'type_{i+1}') for i in paintings]\n\n# Each painting is either 19th century (1) or 20th century (0)\nCentury_19 = 1\nCentury_20 = 0\npainting_centuries = [Int(f'century_{i+1}') for i in paintings]\n\n# Positions of paintings:\n# The problem states \"Six paintings hang next to each other as shown below\"\n# but no diagram is given.\n# However, the problem states adjacency includes directly beside, directly above, or directly below.\n# Since only 6 paintings, let's assume a 2-row by 3-column grid:\n# Positions indexed as (row, col):\n# Painting 1: (0,0)\n# Painting 2: (0,1)\n# Painting 3: (0,2)\n# Painting 4: (1,0)\n# Painting 5: (1,1)\n# Painting 6: (1,2)\n\npositions = [(0,0),(0,1),(0,2),(1,0),(1,1),(1,2)]\n\ndef adjacent(i, j):\n    # Returns True if paintings i and j are adjacent (beside, above, or below)\n    r1, c1 = positions[i]\n    r2, c2 = positions[j]\n    return Or(\n        And(r1 == r2, Abs(c1 - c2) == 1),  # beside horizontally\n        And(c1 == c2, Abs(r1 - r2) == 1)   # above or below vertically\n    )\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each painting type is either Oil or Watercolor\nfor t in painting_types:\n    solver.add(Or(t == Oil, t == Watercolor))\n\n# Each painting century is either 19th or 20th\nfor c in painting_centuries:\n    solver.add(Or(c == Century_19, c == Century_20))\n\n# Exactly two paintings are oils\nsolver.add(Sum([If(t == Oil, 1, 0) for t in painting_types]) == 2)\n\n# Exactly two paintings are nineteenth-century\nsolver.add(Sum([If(c == Century_19, 1, 0) for c in painting_centuries]) == 2)\n\n# Painting 2 is nineteenth-century (index 1)\nsolver.add(painting_centuries[1] == Century_19)\n\n# Painting 3 is oil (index 2)\nsolver.add(painting_types[2] == Oil)\n\n# Painting 5 is twentieth-century (index 4)\nsolver.add(painting_centuries[4] == Century_20)\n\n# Each oil is directly beside, above, or below another oil.\n# For each oil, there must be at least one adjacent painting that is oil.\nfor i in paintings:\n    oil_i = painting_types[i] == Oil\n    adj_oils = [And(adjacent(i,j), painting_types[j] == Oil) for j in paintings if j != i]\n    # If painting i is oil, then at least one adjacent painting is oil\n    solver.add(Implies(oil_i, Or(adj_oils)))\n\n# Each watercolor is directly beside, above, or below another watercolor.\nfor i in paintings:\n    water_i = painting_types[i] == Watercolor\n    adj_waters = [And(adjacent(i,j), painting_types[j] == Watercolor) for j in paintings if j != i]\n    solver.add(Implies(water_i, Or(adj_waters)))\n\n# Each painting is directly beside, above, or below another painting painted in the same century.\nfor i in paintings:\n    c_i = painting_centuries[i]\n    adj_same_century = [And(adjacent(i,j), painting_centuries[j] == c_i) for j in paintings if j != i]\n    solver.add(Or(adj_same_century))\n\n# OPTION CHECKING\n\n# Options:\n# (A) Painting 1 is 19th century, and painting 6 is oil.\n# (B) Painting 2 is both 19th century and oil.\n# (C) Painting 3 is 19th century.\n# (D) Paintings 1 and 2 are both 19th century.\n# (E) Painting 2 is oil, and painting 4 is 19th century.\n\noptions = [\n    # A\n    And(painting_centuries[0] == Century_19, painting_types[5] == Oil),\n    # B\n    And(painting_centuries[1] == Century_19, painting_types[1] == Oil),\n    # C\n    painting_centuries[2] == Century_19,\n    # D\n    And(painting_centuries[0] == Century_19, painting_centuries[1] == Century_19),\n    # E\n    And(painting_types[1] == Oil, painting_centuries[3] == Century_19)\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == unsat:\n        # This option must be false\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Six paintings hang next to each other as shown below: Each of the paintings is an oil or else a watercolor. Each oil is directly beside, directly above, or directly below another oil. Each watercolor is directly beside, directly above, or directly below another watercolor. Each painting is a nineteenth-century painting or else a twentieth-century painting. Each painting is directly beside, directly above, or directly below another painting painted in the same century. Painting 2 is a nineteenth-century painting. Painting 3 is an oil. Painting 5 is a twentieth-century painting.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Paintings 1 and 4 are two of exactly three twentieth-century paintings.\n(B) Paintings 1 and 6 are two of exactly three twentieth-century paintings.\n(C) Paintings 1 and 6 are two of exactly three nineteenth-century paintings.\n(D) Paintings 3 and 4 are two of exactly three nineteenth-century paintings.\n(E) Paintings 4 and 6 are two of exactly three nineteenth-century paintings.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Paintings numbered 1 to 6\npaintings = [1, 2, 3, 4, 5, 6]\n\n# Types: 0 = oil, 1 = watercolor\ntypes = ['oil', 'watercolor']\ntype_vars = {p: Int(f\"type_{p}\") for p in paintings}\n\n# Centuries: 0 = 19th, 1 = 20th\ncenturies = ['19th', '20th']\ncentury_vars = {p: Int(f\"century_{p}\") for p in paintings}\n\n# Positions of paintings in a 2x3 grid for adjacency:\n# Assume layout:\n# 1 2 3\n# 4 5 6\n# Coordinates (row, col)\npositions = {\n    1: (0, 0),\n    2: (0, 1),\n    3: (0, 2),\n    4: (1, 0),\n    5: (1, 1),\n    6: (1, 2)\n}\n\n# Helper function to find adjacent paintings (beside, above, below)\ndef adjacent(p1, p2):\n    r1, c1 = positions[p1]\n    r2, c2 = positions[p2]\n    return Or(\n        And(r1 == r2, Abs(c1 - c2) == 1),\n        And(c1 == c2, Abs(r1 - r2) == 1)\n    )\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Type vars domain\nfor p in paintings:\n    solver.add(And(type_vars[p] >= 0, type_vars[p] <= 1))  # 0 or 1\n\n# Century vars domain\nfor p in paintings:\n    solver.add(And(century_vars[p] >= 0, century_vars[p] <= 1))  # 0 or 1\n\n# Given facts:\n# Painting 2 is 19th century (0)\nsolver.add(century_vars[2] == 0)\n\n# Painting 3 is oil (0)\nsolver.add(type_vars[3] == 0)\n\n# Painting 5 is 20th century (1)\nsolver.add(century_vars[5] == 1)\n\n# Each oil is directly beside, above, or below another oil\nfor p in paintings:\n    cond = type_vars[p] == 0\n    # For each oil painting p, there exists some adjacent painting q with type oil\n    adj_oils = []\n    for q in paintings:\n        if p != q:\n            adj_oils.append(And(adjacent(p, q), type_vars[q] == 0))\n    # If p is oil, then at least one adjacent painting is oil\n    solver.add(Implies(cond, Or(adj_oils)))\n\n# Each watercolor is directly beside, above, or below another watercolor\nfor p in paintings:\n    cond = type_vars[p] == 1\n    adj_waters = []\n    for q in paintings:\n        if p != q:\n            adj_waters.append(And(adjacent(p, q), type_vars[q] == 1))\n    solver.add(Implies(cond, Or(adj_waters)))\n\n# Each painting is directly beside, above, or below another painting painted in the same century\nfor p in paintings:\n    adj_same_century = []\n    for q in paintings:\n        if p != q:\n            adj_same_century.append(And(adjacent(p, q), century_vars[q] == century_vars[p]))\n    solver.add(Or(adj_same_century))\n\n# OPTION CHECKING\noptions = {\n    'A': [1, 4],  # Paintings 1 and 4 are two of exactly three twentieth-century paintings\n    'B': [1, 6],  # Paintings 1 and 6 are two of exactly three twentieth-century paintings\n    'C': [1, 6],  # Paintings 1 and 6 are two of exactly three nineteenth-century paintings\n    'D': [3, 4],  # Paintings 3 and 4 are two of exactly three nineteenth-century paintings\n    'E': [4, 6],  # Paintings 4 and 6 are two of exactly three nineteenth-century paintings\n}\n\nfor letter, pair in options.items():\n    solver.push()\n    # Count number of twentieth-century paintings\n    twentieth_count = Sum([If(century_vars[p] == 1, 1, 0) for p in paintings])\n    nineteenth_count = Sum([If(century_vars[p] == 0, 1, 0) for p in paintings])\n\n    # For options A and B: exactly three twentieth-century paintings, and pair are twentieth-century\n    if letter in ['A', 'B']:\n        solver.add(twentieth_count == 3)\n        solver.add(century_vars[pair[0]] == 1)\n        solver.add(century_vars[pair[1]] == 1)\n    # For options C, D, E: exactly three nineteenth-century paintings, and pair are nineteenth-century\n    else:\n        solver.add(nineteenth_count == 3)\n        solver.add(century_vars[pair[0]] == 0)\n        solver.add(century_vars[pair[1]] == 0)\n\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly six of seven jugglers—G, H, K, L, N, P, and Q—are each assigned to exactly one of three positions—front, middle, and rear—on one of two teams—team 1 and team 2. For each team, exactly one juggler must be assigned to each position according to the following conditions: If either G or H or both are assigned to teams, they are assigned to front positions. If assigned to a team, K is assigned to a middle position. If assigned to a team, L is assigned to team 1. Neither P nor K is on the same team as N. P is not on the same team as Q. If H is on team 2, then Q is assigned to the middle position on team 1.\n\nWhich one of the following is an acceptable list of assignments of jugglers to team 2?\n\nOptions:\n(A) front: Q; middle: K; rear: N\n(B) front: H; middle: P; rear: K\n(C) front: H; middle: L; near: N\n(D) front: G; middle: Q; rear: P\n(E) front: G; middle: Q; rear: N",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\njugglers = ['G', 'H', 'K', 'L', 'N', 'P', 'Q']\nteams = [1, 2]\npositions = ['front', 'middle', 'rear']\n\n# Map jugglers to indices for Z3 variables\njuggler_idx = {j: i for i, j in enumerate(jugglers)}\nposition_idx = {p: i for i, p in enumerate(positions)}\n\n# Create Z3 variables\n# assigned[j]: Bool - whether juggler j is assigned to a team\nassigned = [Bool(f\"assigned_{j}\") for j in jugglers]\n\n# team[j]: Int - team number (1 or 2) if assigned, else 0\nteam = [Int(f\"team_{j}\") for j in jugglers]\n\n# pos[j]: Int - position index (0=front,1=middle,2=rear) if assigned, else -1\npos = [Int(f\"pos_{j}\") for j in jugglers]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each juggler assigned or not\nfor j in range(len(jugglers)):\n    solver.add(Implies(assigned[j], And(team[j] >= 1, team[j] <= 2)))\n    solver.add(Implies(assigned[j], And(pos[j] >= 0, pos[j] <= 2)))\n    solver.add(Implies(Not(assigned[j]), team[j] == 0))\n    solver.add(Implies(Not(assigned[j]), pos[j] == -1))\n\n# Exactly six jugglers are assigned\nsolver.add(Sum([If(assigned[j], 1, 0) for j in range(len(jugglers))]) == 6)\n\n# For each team, exactly one juggler per position\nfor t in teams:\n    for p in range(len(positions)):\n        assigned_in_pos = []\n        for j in range(len(jugglers)):\n            cond = And(assigned[j], team[j] == t, pos[j] == p)\n            assigned_in_pos.append(cond)\n        # Exactly one juggler assigned to team t at position p\n        solver.add(Sum([If(c, 1, 0) for c in assigned_in_pos]) == 1)\n\n# If G or H or both assigned, they are assigned to front positions\nfor j in [juggler_idx['G'], juggler_idx['H']]:\n    solver.add(Implies(assigned[j], pos[j] == position_idx['front']))\n\n# If assigned, K is assigned to a middle position\nk = juggler_idx['K']\nsolver.add(Implies(assigned[k], pos[k] == position_idx['middle']))\n\n# If assigned, L is assigned to team 1\nl = juggler_idx['L']\nsolver.add(Implies(assigned[l], team[l] == 1))\n\n# Neither P nor K is on the same team as N\np = juggler_idx['P']\nn = juggler_idx['N']\nsolver.add(Implies(And(assigned[p], assigned[n]), team[p] != team[n]))\nsolver.add(Implies(And(assigned[k], assigned[n]), team[k] != team[n]))\n\n# P is not on the same team as Q\nq = juggler_idx['Q']\nsolver.add(Implies(And(assigned[p], assigned[q]), team[p] != team[q]))\n\n# If H is on team 2, then Q is assigned to the middle position on team 1\nh = juggler_idx['H']\ncond_h_team2 = And(assigned[h], team[h] == 2)\ncond_q_team1_middle = And(assigned[q], team[q] == 1, pos[q] == position_idx['middle'])\nsolver.add(Implies(cond_h_team2, cond_q_team1_middle))\n\n# OPTION CHECKING\n\noptions = {\n    'A': [('Q', 'front'), ('K', 'middle'), ('N', 'rear')],\n    'B': [('H', 'front'), ('P', 'middle'), ('K', 'rear')],\n    'C': [('H', 'front'), ('L', 'middle'), ('N', 'rear')],\n    'D': [('G', 'front'), ('Q', 'middle'), ('P', 'rear')],\n    'E': [('G', 'front'), ('Q', 'middle'), ('N', 'rear')]\n}\n\nfor opt_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Assign jugglers to team 2 as per option\n    # First, reset any previous team 2 assignments\n    # Assign the three jugglers in option to team 2 with specified positions\n    # The other assigned jugglers (3 more) must be assigned to team 1 with valid positions\n\n    # Identify jugglers assigned to team 2 in this option\n    team2_jugglers = [juggler_idx[j] for j, _ in options[opt_letter]]\n\n    # Assign team 2 jugglers according to option\n    for j in range(len(jugglers)):\n        if j in team2_jugglers:\n            solver.add(assigned[j])\n            solver.add(team[j] == 2)\n            # Set position from option\n            for (jj, pos_str) in options[opt_letter]:\n                if juggler_idx[jj] == j:\n                    solver.add(pos[j] == position_idx[pos_str])\n        else:\n            # Either assigned to team 1 or not assigned\n            # If assigned, team 1\n            # Remember total assigned is 6, 3 assigned to team 2, so 3 assigned to team 1\n            # We'll enforce assigned jugglers not in team2_jugglers assigned to team 1\n            solver.add(Implies(assigned[j], team[j] == 1))\n\n    # Exactly 3 jugglers assigned to team 2\n    solver.add(Sum([If(And(assigned[j], team[j] == 2), 1, 0) for j in range(len(jugglers))]) == 3)\n    # Exactly 3 jugglers assigned to team 1\n    solver.add(Sum([If(And(assigned[j], team[j] == 1), 1, 0) for j in range(len(jugglers))]) == 3)\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six of seven jugglers—G, H, K, L, N, P, and Q—are each assigned to exactly one of three positions—front, middle, and rear—on one of two teams—team 1 and team 2. For each team, exactly one juggler must be assigned to each position according to the following conditions: If either G or H or both are assigned to teams, they are assigned to front positions. If assigned to a team, K is assigned to a middle position. If assigned to a team, L is assigned to team 1. Neither P nor K is on the same team as N. P is not on the same team as Q. If H is on team 2, then Q is assigned to the middle position on team 1.\n\nIf H is assigned to team 2, which one of the following is an acceptable assignment of jugglers to team 1?\n\nOptions:\n(A) front: G; middle: K; rear: L\n(B) front: G; middle: K; rear: N\n(C) front: L; middle: K; rear: P\n(D) front: L; middle: Q; rear: G\n(E) front: L; middle: Q; rear: N",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\njugglers = ['G', 'H', 'K', 'L', 'N', 'P', 'Q']\npositions = ['front', 'middle', 'rear']\nteams = [1, 2]\n\n# Create variables:\n# assigned[j] = 1 if juggler j is assigned to a team, 0 otherwise\nassigned = {j: Int(f'assigned_{j}') for j in jugglers}\n\n# team[j] = team number (1 or 2) if assigned[j] == 1, else 0\nteam = {j: Int(f'team_{j}') for j in jugglers}\n\n# position[j] = position index (0: front, 1: middle, 2: rear) if assigned[j] == 1, else -1\nposition = {j: Int(f'position_{j}') for j in jugglers}\n\nsolver = Solver()\n\n# Constraints on assigned variables: 0 or 1\nfor j in jugglers:\n    solver.add(Or(assigned[j] == 0, assigned[j] == 1))\n\n# Constraints on team variables: 0 if not assigned, else 1 or 2\nfor j in jugglers:\n    solver.add(Or(team[j] == 0, team[j] == 1, team[j] == 2))\n    # If not assigned, team must be 0\n    solver.add(If(assigned[j] == 0, team[j] == 0, And(team[j] >= 1, team[j] <= 2)))\n\n# Constraints on position variables: -1 if not assigned, else 0..2\nfor j in jugglers:\n    solver.add(Or(position[j] == -1, And(position[j] >= 0, position[j] < 3)))\n    # If not assigned, position == -1\n    solver.add(If(assigned[j] == 0, position[j] == -1, And(position[j] >= 0, position[j] < 3)))\n\n# Exactly six jugglers are assigned\nsolver.add(Sum([assigned[j] for j in jugglers]) == 6)\n\n# For each team, exactly one juggler assigned to each position (front=0, middle=1, rear=2)\n# So for each team and each position, exactly one juggler assigned there\nfor t in teams:\n    for pos_idx in range(3):\n        assigned_here = []\n        for j in jugglers:\n            cond = And(assigned[j] == 1, team[j] == t, position[j] == pos_idx)\n            assigned_here.append(If(cond, 1, 0))\n        solver.add(Sum(assigned_here) == 1)\n\n# Conditions:\n\n# If either G or H or both are assigned to teams, they are assigned to front positions.\n# This means if assigned[G]==1 then position[G]==0 (front)\nsolver.add(If(assigned['G'] == 1, position['G'] == 0, True))\nsolver.add(If(assigned['H'] == 1, position['H'] == 0, True))\n\n# If assigned to a team, K is assigned to a middle position.\nsolver.add(If(assigned['K'] == 1, position['K'] == 1, True))\n\n# If assigned to a team, L is assigned to team 1.\nsolver.add(If(assigned['L'] == 1, team['L'] == 1, True))\n\n# Neither P nor K is on the same team as N.\n# For each pair (P,N) and (K,N) if both assigned, their teams differ\nsolver.add(If(And(assigned['P'] == 1, assigned['N'] == 1), team['P'] != team['N'], True))\nsolver.add(If(And(assigned['K'] == 1, assigned['N'] == 1), team['K'] != team['N'], True))\n\n# P is not on the same team as Q.\nsolver.add(If(And(assigned['P'] == 1, assigned['Q'] == 1), team['P'] != team['Q'], True))\n\n# If H is on team 2, then Q is assigned to the middle position on team 1.\nh_on_team2 = And(assigned['H'] == 1, team['H'] == 2)\nq_middle_team1 = And(assigned['Q'] == 1, team['Q'] == 1, position['Q'] == 1)\nsolver.add(Implies(h_on_team2, q_middle_team1))\n\n# We are told: If H is assigned to team 2\nsolver.add(h_on_team2)\n\n# Exactly six jugglers assigned, so one juggler is not assigned.\n# We will check each option for team 1 assignments and see which is consistent.\n\n# OPTION CHECKING\n# Options:\n# (A) front: G; middle: K; rear: L\n# (B) front: G; middle: K; rear: N\n# (C) front: L; middle: K; rear: P\n# (D) front: L; middle: Q; rear: G\n# (E) front: L; middle: Q; rear: N\n\noptions = {\n    'A': {'front': 'G', 'middle': 'K', 'rear': 'L'},\n    'B': {'front': 'G', 'middle': 'K', 'rear': 'N'},\n    'C': {'front': 'L', 'middle': 'K', 'rear': 'P'},\n    'D': {'front': 'L', 'middle': 'Q', 'rear': 'G'},\n    'E': {'front': 'L', 'middle': 'Q', 'rear': 'N'},\n}\n\n# Position indices\npos_idx_map = {'front': 0, 'middle': 1, 'rear': 2}\n\nfor opt_letter, assignment in options.items():\n    solver.push()\n    # For team 1, fix the assignments as per option\n    # For each position, the assigned juggler must be assigned, on team 1, at that position\n    for pos_name, juggler in assignment.items():\n        solver.add(assigned[juggler] == 1)\n        solver.add(team[juggler] == 1)\n        solver.add(position[juggler] == pos_idx_map[pos_name])\n    # Also, no other juggler assigned to team 1 at these positions (already ensured by unique position constraint)\n    # Check if solution is satisfiable\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six of seven jugglers—G, H, K, L, N, P, and Q—are each assigned to exactly one of three positions—front, middle, and rear—on one of two teams—team 1 and team 2. For each team, exactly one juggler must be assigned to each position according to the following conditions: If either G or H or both are assigned to teams, they are assigned to front positions. If assigned to a team, K is assigned to a middle position. If assigned to a team, L is assigned to team 1. Neither P nor K is on the same team as N. P is not on the same team as Q. If H is on team 2, then Q is assigned to the middle position on team 1.\n\nWhich one of the following is an acceptable list of assignments of jugglers to team 1?\n\nOptions:\n(A) front: G; middle: K; rear: L\n(B) front: G; middle: K; rear: P\n(C) front: L; middle: K; rear: Q\n(D) front: Q; middle: K; rear: P\n(E) front: Q; middle: L; rear: N",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\njugglers = ['G', 'H', 'K', 'L', 'N', 'P', 'Q']\nteams = [1, 2]\npositions = ['front', 'middle', 'rear']\n\n# Map positions and teams to indices\npos_idx = {p: i for i, p in enumerate(positions)}\nteam_idx = {t: t for t in teams}  # team 1->1, team 2->2\n\n# Create variables:\n# assigned[j] = Bool indicating if juggler j is assigned\nassigned = {j: Bool(j+'_assigned') for j in jugglers}\n# team[j] = Int variable for team assignment if assigned (1 or 2)\nteam = {j: Int(j+'_team') for j in jugglers}\n# position[j] = Int variable for position assignment if assigned (0=front,1=middle,2=rear)\nposition = {j: Int(j+'_position') for j in jugglers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly 6 jugglers assigned\nsolver.add(Sum([If(assigned[j], 1, 0) for j in jugglers]) == 6)\n\n# For each juggler, if assigned, team in {1,2} and position in {0,1,2}\nfor j in jugglers:\n    solver.add(Implies(assigned[j], And(team[j] >= 1, team[j] <= 2)))\n    solver.add(Implies(assigned[j], And(position[j] >= 0, position[j] <= 2)))\n\n# For each team, exactly one juggler assigned to each position\nfor t in teams:\n    for p in range(3):\n        # Count jugglers assigned to team t and position p\n        count = Sum([If(And(assigned[j], team[j] == t, position[j] == p), 1, 0) for j in jugglers])\n        solver.add(count == 1)\n\n# If G or H or both are assigned, they are assigned to front positions\nfor j in ['G', 'H']:\n    solver.add(Implies(assigned[j], position[j] == pos_idx['front']))\n\n# If K assigned, position is middle\nsolver.add(Implies(assigned['K'], position['K'] == pos_idx['middle']))\n\n# If L assigned, team is 1\nsolver.add(Implies(assigned['L'], team['L'] == 1))\n\n# Neither P nor K is on the same team as N (if assigned)\n# If P and N assigned, team[P] != team[N]\nsolver.add(Implies(And(assigned['P'], assigned['N']), team['P'] != team['N']))\n# If K and N assigned, team[K] != team[N]\nsolver.add(Implies(And(assigned['K'], assigned['N']), team['K'] != team['N']))\n\n# P is not on the same team as Q (if both assigned)\nsolver.add(Implies(And(assigned['P'], assigned['Q']), team['P'] != team['Q']))\n\n# If H is on team 2, then Q is assigned to middle position on team 1\nh_team_2 = And(assigned['H'], team['H'] == 2)\nq_middle_team1 = And(assigned['Q'], team['Q'] == 1, position['Q'] == pos_idx['middle'])\nsolver.add(Implies(h_team_2, q_middle_team1))\n\n# Exactly six assigned means exactly one juggler not assigned\n# Create a list of jugglers not assigned\nnot_assigned = [Not(assigned[j]) for j in jugglers]\nsolver.add(Sum([If(Not(assigned[j]), 1, 0) for j in jugglers]) == 1)\n\n# OPTION CHECKING\n\noptions = {\n    'A': {'front': 'G', 'middle': 'K', 'rear': 'L'},\n    'B': {'front': 'G', 'middle': 'K', 'rear': 'P'},\n    'C': {'front': 'L', 'middle': 'K', 'rear': 'Q'},\n    'D': {'front': 'Q', 'middle': 'K', 'rear': 'P'},\n    'E': {'front': 'Q', 'middle': 'L', 'rear': 'N'},\n}\n\nfor opt_letter, assignment in options.items():\n    solver.push()\n    # The option specifies the assignments for team 1 positions front, middle, rear\n    # Add constraints that these jugglers are assigned to team 1 at the specified positions\n    # Also, these jugglers must be assigned\n    for pos_name, juggler in assignment.items():\n        solver.add(assigned[juggler] == True)\n        solver.add(team[juggler] == 1)\n        solver.add(position[juggler] == pos_idx[pos_name])\n    # Additionally, all other jugglers assigned to team 1 must be these three (since only one per position)\n    # So no other juggler assigned to team 1 at these positions\n    # The constraints above ensure exactly one per position per team, so no duplicates\n    # But we must ensure that no other juggler assigned to team 1 occupies these positions\n    # Already guaranteed by global constraints, so no need to add here\n\n    # Now check if a model exists with these constraints\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six of seven jugglers—G, H, K, L, N, P, and Q—are each assigned to exactly one of three positions—front, middle, and rear—on one of two teams—team 1 and team 2. For each team, exactly one juggler must be assigned to each position according to the following conditions: If either G or H or both are assigned to teams, they are assigned to front positions. If assigned to a team, K is assigned to a middle position. If assigned to a team, L is assigned to team 1. Neither P nor K is on the same team as N. P is not on the same team as Q. If H is on team 2, then Q is assigned to the middle position on team 1.\n\nIf G is assigned to team 1 and K is assigned to team 2, which one of the following must be assigned the rear position on team 2?\n\nOptions:\n(A) H\n(B) L\n(C) N\n(D) P\n(E) Q",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\njugglers = ['G', 'H', 'K', 'L', 'N', 'P', 'Q']\nteams = [1, 2]\npositions = ['front', 'middle', 'rear']\n\n# Create enums for teams and positions\nteam_map = {1: 0, 2: 1}\nposition_map = {'front': 0, 'middle': 1, 'rear': 2}\n\n# Variables:\n# assigned[j]: Bool indicating if juggler j is assigned\n# team[j]: Int in {0,1} indicating team index (0 for team 1, 1 for team 2)\n# pos[j]: Int in {0,1,2} indicating position index (0 for front, 1 for middle, 2 for rear)\n\nassigned = {j: Bool(f'assigned_{j}') for j in jugglers}\nteam = {j: Int(f'team_{j}') for j in jugglers}\npos = {j: Int(f'pos_{j}') for j in jugglers}\n\nsolver = Solver()\n\n# Constraints:\n\n# Each assigned juggler's team must be 0 or 1 (team 1 or 2)\nfor j in jugglers:\n    solver.add(Implies(assigned[j], And(team[j] >= 0, team[j] <= 1)))\n    solver.add(Implies(assigned[j], And(pos[j] >= 0, pos[j] <= 2)))\n\n# Exactly six jugglers assigned\nsolver.add(Sum([If(assigned[j], 1, 0) for j in jugglers]) == 6)\n\n# For each team, exactly one juggler per position\nfor t in [0,1]:\n    for p in [0,1,2]:\n        count = Sum([If(And(assigned[j], team[j] == t, pos[j] == p), 1, 0) for j in jugglers])\n        solver.add(count == 1)\n\n# If either G or H or both are assigned, they are assigned to front positions\n# That means if assigned G then pos[G]==front, if assigned H then pos[H]==front\nsolver.add(Implies(assigned['G'], pos['G'] == position_map['front']))\nsolver.add(Implies(assigned['H'], pos['H'] == position_map['front']))\n\n# If assigned, K is assigned to a middle position\nsolver.add(Implies(assigned['K'], pos['K'] == position_map['middle']))\n\n# If assigned, L is assigned to team 1 (team index 0)\nsolver.add(Implies(assigned['L'], team['L'] == team_map[1]))\n\n# Neither P nor K is on the same team as N\n# If assigned P and N, team[P] != team[N]\nsolver.add(Implies(And(assigned['P'], assigned['N']), team['P'] != team['N']))\n# If assigned K and N, team[K] != team[N]\nsolver.add(Implies(And(assigned['K'], assigned['N']), team['K'] != team['N']))\n\n# P is not on the same team as Q\nsolver.add(Implies(And(assigned['P'], assigned['Q']), team['P'] != team['Q']))\n\n# If H is on team 2 (team index 1), then Q is assigned to the middle position on team 1 (team index 0)\nsolver.add(Implies(And(assigned['H'], team['H'] == team_map[2]),\n                   And(assigned['Q'], team['Q'] == team_map[1], pos['Q'] == position_map['middle'])))\n\n# Exactly one juggler is not assigned (6 assigned out of 7)\n# Already constrained above\n\n# Given: G is assigned to team 1 (team index 0)\nsolver.add(assigned['G'])\nsolver.add(team['G'] == team_map[1])\n\n# Given: K is assigned to team 2 (team index 1)\nsolver.add(assigned['K'])\nsolver.add(team['K'] == team_map[2])\n\n# OPTION CHECKING\noptions = ['H', 'L', 'N', 'P', 'Q']\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, candidate in enumerate(options):\n    solver.push()\n    # Add constraint that candidate is assigned to rear position on team 2 (team index 1)\n    solver.add(assigned[candidate])\n    solver.add(team[candidate] == team_map[2])\n    solver.add(pos[candidate] == position_map['rear'])\n    # Check if there is a solution with this candidate in rear position on team 2\n    # Also check if any other candidate can be in that position by negating this candidate's rear assignment\n    # We will check if the candidate must be the rear on team 2 by:\n    # 1) Check if solution exists with candidate rear on team 2\n    # 2) Check if solution exists with candidate NOT rear on team 2\n    # If 2) is unsat, then candidate must be rear on team 2\n    if solver.check() == sat:\n        # Now check if candidate can NOT be rear on team 2\n        solver.pop()\n        solver.push()\n        # Candidate assigned and on team 2 but NOT rear position\n        solver.add(assigned[candidate])\n        solver.add(team[candidate] == team_map[2])\n        solver.add(pos[candidate] != position_map['rear'])\n        if solver.check() == unsat:\n            # Candidate must be rear on team 2\n            print(f\"'{option_letters[i]}'\")\n            solver.pop()\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A producer is positioning exactly seven music pieces—F, G, H, J, K, L, and M—one after another on a music recording, not necessarily in that order. Each piece will fill exactly one of the seven sequential tracks on the recording, according to the following conditions: F must be second. J cannot be seventh. G can come neither immediately before nor immediately after H. H must be in some track before that of L. L must be in some track before that of M.\n\nWhich one of the following could be the order, from first to seventh, of the pieces on the recording?\n\nOptions:\n(A) F, K, G, J, H, L, M\n(B) G, F, H, K, L, J, M\n(C) G, F, H, K, L, M, J\n(D) K, F, G, H, J, L, M\n(E) K, F, L, J, H, M, G",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npieces = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\npositions = range(7)  # 0 to 6 for tracks 1 to 7\n\n# Create a variable for the position of each piece\npos = {p: Int(p) for p in pieces}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each piece is assigned to a unique position from 0 to 6\nfor p in pieces:\n    solver.add(And(pos[p] >= 0, pos[p] <= 6))\nsolver.add(Distinct([pos[p] for p in pieces]))\n\n# F must be second (position 1)\nsolver.add(pos['F'] == 1)\n\n# J cannot be seventh (position 6)\nsolver.add(pos['J'] != 6)\n\n# G can come neither immediately before nor immediately after H\ndiff_GH = Abs(pos['G'] - pos['H'])\nsolver.add(diff_GH != 1)\n\n# H must be in some track before that of L\nsolver.add(pos['H'] < pos['L'])\n\n# L must be in some track before that of M\nsolver.add(pos['L'] < pos['M'])\n\n# OPTION CHECKING\noptions = [\n    ['F', 'K', 'G', 'J', 'H', 'L', 'M'],  # A\n    ['G', 'F', 'H', 'K', 'L', 'J', 'M'],  # B\n    ['G', 'F', 'H', 'K', 'L', 'M', 'J'],  # C\n    ['K', 'F', 'G', 'H', 'J', 'L', 'M'],  # D\n    ['K', 'F', 'L', 'J', 'H', 'M', 'G']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that the pieces are in the given order\n    for track, piece in enumerate(option):\n        solver.add(pos[piece] == track)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A producer is positioning exactly seven music pieces—F, G, H, J, K, L, and M—one after another on a music recording, not necessarily in that order. Each piece will fill exactly one of the seven sequential tracks on the recording, according to the following conditions: F must be second. J cannot be seventh. G can come neither immediately before nor immediately after H. H must be in some track before that of L. L must be in some track before that of M.\n\nIf M fills some track before that of J and also before that of K on the recording, which one of the following must be true?\n\nOptions:\n(A) G is first.\n(B) K is seventh.\n(C) L is third.\n(D) H comes either immediately before or immediately after F.\n(E) L comes either immediately before or immediately after G.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npieces = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\npositions = {p: Int(p) for p in pieces}  # position of each piece on the recording (1 to 7)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Positions are between 1 and 7\nfor p in pieces:\n    solver.add(And(positions[p] >= 1, positions[p] <= 7))\n\n# All positions are distinct\nsolver.add(Distinct([positions[p] for p in pieces]))\n\n# F must be second\nsolver.add(positions['F'] == 2)\n\n# J cannot be seventh\nsolver.add(positions['J'] != 7)\n\n# G can come neither immediately before nor immediately after H\nsolver.add(positions['G'] != positions['H'] + 1)\nsolver.add(positions['G'] != positions['H'] - 1)\n\n# H must be before L\nsolver.add(positions['H'] < positions['L'])\n\n# L must be before M\nsolver.add(positions['L'] < positions['M'])\n\n# M fills some track before J and before K\nsolver.add(positions['M'] < positions['J'])\nsolver.add(positions['M'] < positions['K'])\n\n# OPTION CHECKING\noptions = [\n    # (A) G is first\n    positions['G'] == 1,\n    # (B) K is seventh\n    positions['K'] == 7,\n    # (C) L is third\n    positions['L'] == 3,\n    # (D) H comes immediately before or immediately after F\n    Or(positions['H'] == positions['F'] + 1, positions['H'] == positions['F'] - 1),\n    # (E) L comes immediately before or immediately after G\n    Or(positions['L'] == positions['G'] + 1, positions['L'] == positions['G'] - 1)\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))  # check if option can be false\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A producer is positioning exactly seven music pieces—F, G, H, J, K, L, and M—one after another on a music recording, not necessarily in that order. Each piece will fill exactly one of the seven sequential tracks on the recording, according to the following conditions: F must be second. J cannot be seventh. G can come neither immediately before nor immediately after H. H must be in some track before that of L. L must be in some track before that of M.\n\nThe earliest track that M can fill is the\n\nOptions:\n(A) first\n(B) third\n(C) fourth\n(D) fifth\n(E) sixth",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npieces = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\ntracks = list(range(1, 8))  # Tracks numbered 1 to 7\n\n# Create Int variables for each piece representing their track positions\npositions = {}\nfor p in pieces:\n    positions[p] = Int(p)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each piece occupies a track between 1 and 7\nfor p in pieces:\n    solver.add(And(positions[p] >= 1, positions[p] <= 7))\n\n# All pieces occupy distinct tracks\nsolver.add(Distinct([positions[p] for p in pieces]))\n\n# F must be second\nsolver.add(positions['F'] == 2)\n\n# J cannot be seventh\nsolver.add(positions['J'] != 7)\n\n# G cannot be immediately before or after H\nsolver.add(positions['G'] != positions['H'] + 1)\nsolver.add(positions['G'] != positions['H'] - 1)\n\n# H must be in some track before L\nsolver.add(positions['H'] < positions['L'])\n\n# L must be in some track before M\nsolver.add(positions['L'] < positions['M'])\n\n# OPTION CHECKING\n# We want to find the earliest track M can fill.\n# We test each option by adding constraint M == option track and check if satisfiable.\n\noption_tracks = [1, 3, 4, 5, 6]\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor track, letter in zip(option_tracks, option_letters):\n    solver.push()\n    solver.add(positions['M'] == track)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A producer is positioning exactly seven music pieces—F, G, H, J, K, L, and M—one after another on a music recording, not necessarily in that order. Each piece will fill exactly one of the seven sequential tracks on the recording, according to the following conditions: F must be second. J cannot be seventh. G can come neither immediately before nor immediately after H. H must be in some track before that of L. L must be in some track before that of M.\n\nIf G is to come immediately before H but all the other conditions remain in effect, any of the following could be true EXCEPT:\n\nOptions:\n(A) J comes immediately before F.\n(B) K comes immediately before G.\n(C) J comes immediately after L.\n(D) J comes immediately after K.\n(E) K comes immediately after M.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npieces = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\nindices = {p: Int(p) for p in pieces}  # position of each piece (1-based track number)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each piece is assigned to a unique track from 1 to 7\nfor p in pieces:\n    solver.add(indices[p] >= 1, indices[p] <= 7)\nsolver.add(Distinct([indices[p] for p in pieces]))\n\n# F must be second\nsolver.add(indices['F'] == 2)\n\n# J cannot be seventh\nsolver.add(indices['J'] != 7)\n\n# G can come neither immediately before nor immediately after H\n# But the problem states: \"If G is to come immediately before H but all other conditions remain in effect\"\n# So this constraint is overridden by the \"if\" condition for this scenario.\n# So we do NOT add this constraint here.\n\n# H must be before L\nsolver.add(indices['H'] < indices['L'])\n\n# L must be before M\nsolver.add(indices['L'] < indices['M'])\n\n# Additional condition for this scenario: G immediately before H\nsolver.add(indices['G'] + 1 == indices['H'])\n\n# OPTION CHECKING\n\n# We will check each option by adding the option's condition and checking satisfiability.\n\n# Define helper function for \"X comes immediately before Y\" and \"X comes immediately after Y\"\ndef immediately_before(x, y):\n    return indices[x] + 1 == indices[y]\n\ndef immediately_after(x, y):\n    return indices[x] == indices[y] + 1\n\noptions = [\n    immediately_before('J', 'F'),  # (A) J comes immediately before F\n    immediately_before('K', 'G'),  # (B) K comes immediately before G\n    immediately_after('J', 'L'),   # (C) J comes immediately after L\n    immediately_after('J', 'K'),   # (D) J comes immediately after K\n    immediately_after('K', 'M'),   # (E) K comes immediately after M\n]\n\n# Check each option by adding its condition and checking if the model is satisfiable\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == unsat:\n        # This option cannot be true under the conditions\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, and Ordoveza are the only applicants being considered for some positions at a nonprofit organization. Only applicants who are interviewed will be hired. The hiring process must meet the following constraints: If Gunsel is interviewed, Jackson is interviewed. If Jackson is interviewed, Lee is interviewed. Fu is interviewed. Fu is not hired, unless Kowalski is interviewed. Kowalski is not hired, unless Mayer is interviewed. If Mayer is hired, and Lee is interviewed, Ordoveza is hired.\n\nWhich one of the following could be a complete and accurate list of the applicants that are interviewed?\n\nOptions:\n(A) Fu, Gunsel\n(B) Fu, Jackson\n(C) Fu, Lee\n(D) Fu, Gunsel, Lee\n(E) Fu, Gunsel, Jackson",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Fu', 'Gunsel', 'Jackson', 'Kowalski', 'Lee', 'Mayer', 'Ordoveza']\n\n# Create Bool variables for interviewed and hired for each applicant\ninterviewed = {a: Bool(f\"interviewed_{a}\") for a in applicants}\nhired = {a: Bool(f\"hired_{a}\") for a in applicants}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Only applicants who are interviewed will be hired\nfor a in applicants:\n    solver.add(Implies(hired[a], interviewed[a]))\n\n# If Gunsel is interviewed, Jackson is interviewed\nsolver.add(Implies(interviewed['Gunsel'], interviewed['Jackson']))\n\n# If Jackson is interviewed, Lee is interviewed\nsolver.add(Implies(interviewed['Jackson'], interviewed['Lee']))\n\n# Fu is interviewed\nsolver.add(interviewed['Fu'])\n\n# Fu is not hired unless Kowalski is interviewed\nsolver.add(Implies(hired['Fu'], interviewed['Kowalski']))\n\n# Kowalski is not hired unless Mayer is interviewed\nsolver.add(Implies(hired['Kowalski'], interviewed['Mayer']))\n\n# If Mayer is hired and Lee is interviewed, Ordoveza is hired\nsolver.add(Implies(And(hired['Mayer'], interviewed['Lee']), hired['Ordoveza']))\n\n# OPTION CHECKING\noptions = [\n    ['Fu', 'Gunsel'],                # A\n    ['Fu', 'Jackson'],               # B\n    ['Fu', 'Lee'],                   # C\n    ['Fu', 'Gunsel', 'Lee'],         # D\n    ['Fu', 'Gunsel', 'Jackson']      # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Set interviewed for option applicants to True\n    for a in applicants:\n        if a in option:\n            solver.add(interviewed[a])\n        else:\n            solver.add(Not(interviewed[a]))\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, and Ordoveza are the only applicants being considered for some positions at a nonprofit organization. Only applicants who are interviewed will be hired. The hiring process must meet the following constraints: If Gunsel is interviewed, Jackson is interviewed. If Jackson is interviewed, Lee is interviewed. Fu is interviewed. Fu is not hired, unless Kowalski is interviewed. Kowalski is not hired, unless Mayer is interviewed. If Mayer is hired, and Lee is interviewed, Ordoveza is hired.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Lee and Mayer are the only applicants interviewed.\n(B) Fu, Jackson, and Kowalski are the only applicants interviewed.\n(C) Gunsel and one other applicant are the only applicants interviewed.\n(D) Gunsel and two other applicants are the only applicants interviewed.\n(E) Gunsel and three other applicants are the only applicants interviewed.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Fu', 'Gunsel', 'Jackson', 'Kowalski', 'Lee', 'Mayer', 'Ordoveza']\n\n# Create Z3 Bool variables for interviewed and hired status of each applicant\ninterviewed = {a: Bool(f\"interviewed_{a}\") for a in applicants}\nhired = {a: Bool(f\"hired_{a}\") for a in applicants}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Only interviewed applicants can be hired\nfor a in applicants:\n    solver.add(Implies(hired[a], interviewed[a]))\n\n# If Gunsel is interviewed, Jackson is interviewed\nsolver.add(Implies(interviewed['Gunsel'], interviewed['Jackson']))\n\n# If Jackson is interviewed, Lee is interviewed\nsolver.add(Implies(interviewed['Jackson'], interviewed['Lee']))\n\n# Fu is interviewed\nsolver.add(interviewed['Fu'])\n\n# Fu is not hired unless Kowalski is interviewed\nsolver.add(Implies(hired['Fu'], interviewed['Kowalski']))\n\n# Kowalski is not hired unless Mayer is interviewed\nsolver.add(Implies(hired['Kowalski'], interviewed['Mayer']))\n\n# If Mayer is hired and Lee is interviewed, then Ordoveza is hired\nsolver.add(Implies(And(hired['Mayer'], interviewed['Lee']), hired['Ordoveza']))\n\n# OPTION CHECKING\noptions = {\n    'A': ['Lee', 'Mayer'],\n    'B': ['Fu', 'Jackson', 'Kowalski'],\n    'C': ['Gunsel', 'Fu'],  # \"and one other applicant\" means Gunsel + 1 = 2 total\n    'D': ['Gunsel', 'Fu', 'Jackson'],  # Gunsel + 2 others = 3 total\n    'E': ['Gunsel', 'Fu', 'Jackson', 'Lee'],  # Gunsel + 3 others = 4 total\n}\n\nfor letter, interviewed_list in options.items():\n    solver.push()\n    # Exactly these applicants are interviewed\n    for a in applicants:\n        if a in interviewed_list:\n            solver.add(interviewed[a])\n        else:\n            solver.add(Not(interviewed[a]))\n    # Check if the constraints can be satisfied\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, and Ordoveza are the only applicants being considered for some positions at a nonprofit organization. Only applicants who are interviewed will be hired. The hiring process must meet the following constraints: If Gunsel is interviewed, Jackson is interviewed. If Jackson is interviewed, Lee is interviewed. Fu is interviewed. Fu is not hired, unless Kowalski is interviewed. Kowalski is not hired, unless Mayer is interviewed. If Mayer is hired, and Lee is interviewed, Ordoveza is hired.\n\nIf Mayer is not interviewed, which one of the following must be true?\n\nOptions:\n(A) Kowalski is not interviewed.\n(B) Kowalski is interviewed but not hired.\n(C) Fu is not hired.\n(D) Fu is hired but Kowalski is not hired.\n(E) Fu is interviewed but Kowalski is not hired.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Fu', 'Gunsel', 'Jackson', 'Kowalski', 'Lee', 'Mayer', 'Ordoveza']\n\n# Create Z3 Bool variables for interviewed and hired status for each applicant\ninterviewed = {a: Bool(f\"interviewed_{a}\") for a in applicants}\nhired = {a: Bool(f\"hired_{a}\") for a in applicants}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Only interviewed applicants can be hired\nfor a in applicants:\n    solver.add(Implies(hired[a], interviewed[a]))\n\n# If Gunsel is interviewed, Jackson is interviewed\nsolver.add(Implies(interviewed['Gunsel'], interviewed['Jackson']))\n\n# If Jackson is interviewed, Lee is interviewed\nsolver.add(Implies(interviewed['Jackson'], interviewed['Lee']))\n\n# Fu is interviewed\nsolver.add(interviewed['Fu'])\n\n# Fu is not hired unless Kowalski is interviewed\nsolver.add(Implies(hired['Fu'], interviewed['Kowalski']))\n\n# Kowalski is not hired unless Mayer is interviewed\nsolver.add(Implies(hired['Kowalski'], interviewed['Mayer']))\n\n# If Mayer is hired and Lee is interviewed, Ordoveza is hired\nsolver.add(Implies(And(hired['Mayer'], interviewed['Lee']), hired['Ordoveza']))\n\n# Condition: Mayer is not interviewed\nsolver.add(Not(interviewed['Mayer']))\n\n# OPTION CHECKING\noptions = [\n    # (A) Kowalski is not interviewed.\n    Not(interviewed['Kowalski']),\n    # (B) Kowalski is interviewed but not hired.\n    And(interviewed['Kowalski'], Not(hired['Kowalski'])),\n    # (C) Fu is not hired.\n    Not(hired['Fu']),\n    # (D) Fu is hired but Kowalski is not hired.\n    And(hired['Fu'], Not(hired['Kowalski'])),\n    # (E) Fu is interviewed but Kowalski is not hired.\n    And(interviewed['Fu'], Not(hired['Kowalski']))\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add negation of option to check if option must be true\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, and Ordoveza are the only applicants being considered for some positions at a nonprofit organization. Only applicants who are interviewed will be hired. The hiring process must meet the following constraints: If Gunsel is interviewed, Jackson is interviewed. If Jackson is interviewed, Lee is interviewed. Fu is interviewed. Fu is not hired, unless Kowalski is interviewed. Kowalski is not hired, unless Mayer is interviewed. If Mayer is hired, and Lee is interviewed, Ordoveza is hired.\n\nIf Gunsel and five other applicants are the only applicants interviewed, and if exactly three applicants are hired, then which one of the following could be an accurate list of the applicants hired?\n\nOptions:\n(A) Fu, Lee, Mayer\n(B) Fu, Kowalski, Mayer\n(C) Kowalski, Lee, Ordoveza\n(D) Gunsel, Jackson, Mayer\n(E) Gunsel, Jackson, Lee",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Fu', 'Gunsel', 'Jackson', 'Kowalski', 'Lee', 'Mayer', 'Ordoveza']\n\n# Create Z3 Boolean variables for interviewed and hired status of each applicant\ninterviewed = {a: Bool(f\"interviewed_{a}\") for a in applicants}\nhired = {a: Bool(f\"hired_{a}\") for a in applicants}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Constraint: Only applicants who are interviewed will be hired\nfor a in applicants:\n    solver.add(Implies(hired[a], interviewed[a]))\n\n# Constraint: If Gunsel is interviewed, Jackson is interviewed\nsolver.add(Implies(interviewed['Gunsel'], interviewed['Jackson']))\n\n# Constraint: If Jackson is interviewed, Lee is interviewed\nsolver.add(Implies(interviewed['Jackson'], interviewed['Lee']))\n\n# Constraint: Fu is interviewed\nsolver.add(interviewed['Fu'])\n\n# Constraint: Fu is not hired unless Kowalski is interviewed\nsolver.add(Implies(hired['Fu'], interviewed['Kowalski']))\n\n# Constraint: Kowalski is not hired unless Mayer is interviewed\nsolver.add(Implies(hired['Kowalski'], interviewed['Mayer']))\n\n# Constraint: If Mayer is hired and Lee is interviewed, Ordoveza is hired\nsolver.add(Implies(And(hired['Mayer'], interviewed['Lee']), hired['Ordoveza']))\n\n# Additional problem conditions:\n# Gunsel and five other applicants are the only applicants interviewed\n# So total interviewed = 6, and Gunsel is interviewed\nsolver.add(interviewed['Gunsel'])\n\n# Count interviewed\ninterviewed_list = [interviewed[a] for a in applicants]\n# Sum of interviewed == 6\nsolver.add(Sum([If(interviewed[a], 1, 0) for a in applicants]) == 6)\n\n# Exactly three applicants are hired\nsolver.add(Sum([If(hired[a], 1, 0) for a in applicants]) == 3)\n\n# OPTION CHECKING\noptions = [\n    ['Fu', 'Lee', 'Mayer'],         # A\n    ['Fu', 'Kowalski', 'Mayer'],    # B\n    ['Kowalski', 'Lee', 'Ordoveza'],# C\n    ['Gunsel', 'Jackson', 'Mayer'], # D\n    ['Gunsel', 'Jackson', 'Lee']    # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that these applicants are hired\n    for a in applicants:\n        if a in option:\n            solver.add(hired[a])\n        else:\n            solver.add(Not(hired[a]))\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, and Ordoveza are the only applicants being considered for some positions at a nonprofit organization. Only applicants who are interviewed will be hired. The hiring process must meet the following constraints: If Gunsel is interviewed, Jackson is interviewed. If Jackson is interviewed, Lee is interviewed. Fu is interviewed. Fu is not hired, unless Kowalski is interviewed. Kowalski is not hired, unless Mayer is interviewed. If Mayer is hired, and Lee is interviewed, Ordoveza is hired.\n\nIf every applicant that is interviewed is hired, and if Lee is hired, then each of the following applicants must be interviewed EXCEPT:\n\nOptions:\n(A) Fu\n(B) Jackson\n(C) Kowalski\n(D) Mayer\n(E) Ordoveza",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Fu', 'Gunsel', 'Jackson', 'Kowalski', 'Lee', 'Mayer', 'Ordoveza']\n\n# Create variables for interviewed and hired status for each applicant\ninterviewed = {a: Bool(f\"interviewed_{a}\") for a in applicants}\nhired = {a: Bool(f\"hired_{a}\") for a in applicants}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. If Gunsel is interviewed, Jackson is interviewed\nsolver.add(Implies(interviewed['Gunsel'], interviewed['Jackson']))\n\n# 2. If Jackson is interviewed, Lee is interviewed\nsolver.add(Implies(interviewed['Jackson'], interviewed['Lee']))\n\n# 3. Fu is interviewed\nsolver.add(interviewed['Fu'])\n\n# 4. Fu is not hired, unless Kowalski is interviewed\n# Fu hired => Kowalski interviewed\nsolver.add(Implies(hired['Fu'], interviewed['Kowalski']))\n\n# 5. Kowalski is not hired, unless Mayer is interviewed\n# Kowalski hired => Mayer interviewed\nsolver.add(Implies(hired['Kowalski'], interviewed['Mayer']))\n\n# 6. If Mayer is hired, and Lee is interviewed, Ordoveza is hired\nsolver.add(Implies(And(hired['Mayer'], interviewed['Lee']), hired['Ordoveza']))\n\n# 7. Only applicants who are interviewed will be hired\nfor a in applicants:\n    solver.add(Implies(hired[a], interviewed[a]))\n\n# 8. Every applicant that is interviewed is hired\nfor a in applicants:\n    solver.add(interviewed[a] == hired[a])\n\n# 9. Lee is hired (given in the question: \"if Lee is hired\")\nsolver.add(hired['Lee'])\n\n# OPTION CHECKING\n\noptions = ['Fu', 'Jackson', 'Kowalski', 'Mayer', 'Ordoveza']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Check if it is possible that Lee is hired and the applicant in option is NOT interviewed\n    solver.add(Not(interviewed[opt]))\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Fu, Gunsel, Jackson, Kowalski, Lee, Mayer, and Ordoveza are the only applicants being considered for some positions at a nonprofit organization. Only applicants who are interviewed will be hired. The hiring process must meet the following constraints: If Gunsel is interviewed, Jackson is interviewed. If Jackson is interviewed, Lee is interviewed. Fu is interviewed. Fu is not hired, unless Kowalski is interviewed. Kowalski is not hired, unless Mayer is interviewed. If Mayer is hired, and Lee is interviewed, Ordoveza is hired.\n\nIf Ordoveza is not interviewed, and if exactly four applicants are hired, then which one of the following must be false?\n\nOptions:\n(A) Lee is hired.\n(B) Mayer is hired.\n(C) Jackson is interviewed.\n(D) Kowalski is interviewed.\n(E) Gunsel is interviewed.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Fu', 'Gunsel', 'Jackson', 'Kowalski', 'Lee', 'Mayer', 'Ordoveza']\n\n# Create interview and hired variables for each applicant\ninterview = {a: Bool(f'interview_{a}') for a in applicants}\nhired = {a: Bool(f'hired_{a}') for a in applicants}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. If Gunsel is interviewed, Jackson is interviewed: Gunsel_interviewed => Jackson_interviewed\nsolver.add(Implies(interview['Gunsel'], interview['Jackson']))\n\n# 2. If Jackson is interviewed, Lee is interviewed: Jackson_interviewed => Lee_interviewed\nsolver.add(Implies(interview['Jackson'], interview['Lee']))\n\n# 3. Fu is interviewed\nsolver.add(interview['Fu'])\n\n# 4. Only interviewed applicants can be hired: hired => interviewed for all\nfor a in applicants:\n    solver.add(Implies(hired[a], interview[a]))\n\n# 5. Fu is not hired unless Kowalski is interviewed: hired_Fu => interview_Kowalski\nsolver.add(Implies(hired['Fu'], interview['Kowalski']))\n\n# 6. Kowalski is not hired unless Mayer is interviewed: hired_Kowalski => interview_Mayer\nsolver.add(Implies(hired['Kowalski'], interview['Mayer']))\n\n# 7. If Mayer is hired and Lee is interviewed, then Ordoveza is hired:\n# (hired_Mayer AND interview_Lee) => hired_Ordoveza\nsolver.add(Implies(And(hired['Mayer'], interview['Lee']), hired['Ordoveza']))\n\n# Additional given condition: Ordoveza is NOT interviewed\nsolver.add(Not(interview['Ordoveza']))\n\n# Additional given condition: Exactly four applicants are hired\nhired_list = [If(hired[a], 1, 0) for a in applicants]\nsolver.add(Sum(hired_list) == 4)\n\n# OPTION CHECKING\n# We want to find which option must be FALSE.\n# So for each option, add the assumption that the option is TRUE,\n# and check if the model is satisfiable.\n# If satisfiable, then the option can be true, so it is NOT necessarily false.\n# If unsat, then the option must be false.\n\noptions = {\n    'A': hired['Lee'],         # Lee is hired\n    'B': hired['Mayer'],       # Mayer is hired\n    'C': interview['Jackson'], # Jackson is interviewed\n    'D': interview['Kowalski'],# Kowalski is interviewed\n    'E': interview['Gunsel']   # Gunsel is interviewed\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)  # assume option is true\n    if solver.check() == sat:\n        # option can be true, so it is NOT necessarily false\n        solver.pop()\n    else:\n        # option must be false\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.\n\nWhich one of the following could be the list of the researchers on the two teams?\n\nOptions:\n(A) team 1: Franklin, Marquez, Osborne team 2: Jones, Neil, Rice\n(B) team 1: Franklin, Neil, Samuels team 2: Jones, Osborne, Rice\n(C) team 1: Franklin, Osborne, Rice team 2: Jones, Neil, Samuels\n(D) team 1: Jones, Marquez, Neil team 2: Osborne, Rice, Samuels\n(E) team 1: Jones, Osborne, Rice team 2: Franklin, Marquez, Neil",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Researchers\nanthropologists = ['Franklin', 'Jones', 'Marquez']\nlinguists = ['Neil', 'Osborne', 'Rice', 'Samuels']\nall_researchers = anthropologists + linguists\n\n# Teams and indices\nteams = [1, 2]\n\n# Create variables: team_assignment[r] = 0 if not on any team, 1 if on team 1, 2 if on team 2\nteam_assignment = {r: Int(r) for r in all_researchers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each researcher assigned to 0 (not on team), 1 (team 1), or 2 (team 2)\nfor r in all_researchers:\n    solver.add(Or([team_assignment[r] == 0, team_assignment[r] == 1, team_assignment[r] == 2]))\n\n# Exactly six researchers included (assigned to team 1 or team 2)\nincluded = [If(team_assignment[r] != 0, 1, 0) for r in all_researchers]\nsolver.add(Sum(included) == 6)\n\n# Each team has exactly 3 researchers\nfor t in teams:\n    team_members = [If(team_assignment[r] == t, 1, 0) for r in all_researchers]\n    solver.add(Sum(team_members) == 3)\n\n# No researcher in more than one team (enforced by domain of team_assignment)\n\n# Each team must include at least one anthropologist and at least one linguist\nfor t in teams:\n    anthro_in_team = [If(And(team_assignment[r] == t, r in anthropologists), 1, 0) for r in all_researchers]\n    ling_in_team = [If(And(team_assignment[r] == t, r in linguists), 1, 0) for r in all_researchers]\n    solver.add(Sum(anthro_in_team) >= 1)\n    solver.add(Sum(ling_in_team) >= 1)\n\n# Conditions:\n# 1. Neither team includes both Franklin and Samuels.\nfor t in teams:\n    franklin_in = team_assignment['Franklin'] == t\n    samuels_in = team_assignment['Samuels'] == t\n    solver.add(Not(And(franklin_in, samuels_in)))\n\n# 2. Neither team includes both Neil and Rice.\nfor t in teams:\n    neil_in = team_assignment['Neil'] == t\n    rice_in = team_assignment['Rice'] == t\n    solver.add(Not(And(neil_in, rice_in)))\n\n# 3. If a team includes Marquez, it includes neither Rice nor Samuels.\nfor t in teams:\n    marquez_in = team_assignment['Marquez'] == t\n    rice_in = team_assignment['Rice'] == t\n    samuels_in = team_assignment['Samuels'] == t\n    solver.add(Implies(marquez_in, And(Not(rice_in), Not(samuels_in))))\n\n# 4. If team 1 includes Jones, team 2 includes Rice.\nsolver.add(Implies(team_assignment['Jones'] == 1, team_assignment['Rice'] == 2))\n\n# OPTION CHECKING\n\noptions = {\n    'A': {'team1': ['Franklin', 'Marquez', 'Osborne'], 'team2': ['Jones', 'Neil', 'Rice']},\n    'B': {'team1': ['Franklin', 'Neil', 'Samuels'], 'team2': ['Jones', 'Osborne', 'Rice']},\n    'C': {'team1': ['Franklin', 'Osborne', 'Rice'], 'team2': ['Jones', 'Neil', 'Samuels']},\n    'D': {'team1': ['Jones', 'Marquez', 'Neil'], 'team2': ['Osborne', 'Rice', 'Samuels']},\n    'E': {'team1': ['Jones', 'Osborne', 'Rice'], 'team2': ['Franklin', 'Marquez', 'Neil']}\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Assign teams according to option\n    for r in all_researchers:\n        if r in options[letter]['team1']:\n            solver.add(team_assignment[r] == 1)\n        elif r in options[letter]['team2']:\n            solver.add(team_assignment[r] == 2)\n        else:\n            solver.add(team_assignment[r] == 0)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.\n\nIf Jones is on team 1, which one of the following is a pair of researchers that must be on team 2 together?\n\nOptions:\n(A) Franklin and Rice\n(B) Marquez and Osborne\n(C) Neil and Osborne\n(D) Osborne and Samuels\n(E) Rice and Samuels",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Researchers\nanthropologists = ['Franklin', 'Jones', 'Marquez']\nlinguists = ['Neil', 'Osborne', 'Rice', 'Samuels']\nall_researchers = anthropologists + linguists\n\n# Indices for researchers\nresearcher_idx = {name: i for i, name in enumerate(all_researchers)}\n\n# Variables: for each researcher, which team they are on (0 = no team, 1 = team1, 2 = team2)\n# 0 means not included\nteam = [Int(f\"team_{r}\") for r in all_researchers]\n\n# Helper sets for anthropologists and linguists indices\nanthro_indices = [researcher_idx[a] for a in anthropologists]\nlinguist_indices = [researcher_idx[l] for l in linguists]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each researcher is either not on a team (0), or on team 1 or team 2\nfor t in team:\n    solver.add(Or(t == 0, t == 1, t == 2))\n\n# Exactly six researchers are included (team != 0)\nincluded = [If(t != 0, 1, 0) for t in team]\nsolver.add(Sum(included) == 6)\n\n# No researcher on more than one team (already ensured by single variable per researcher)\n\n# Each team has exactly 3 members\nteam1_members = [If(t == 1, 1, 0) for t in team]\nteam2_members = [If(t == 2, 1, 0) for t in team]\nsolver.add(Sum(team1_members) == 3)\nsolver.add(Sum(team2_members) == 3)\n\n# Each team has at least one anthropologist and at least one linguist\n\n# Team 1 anthropologists count\nteam1_anthro = [If(And(team[i] == 1, i in anthro_indices), 1, 0) for i in range(len(team))]\nsolver.add(Sum(team1_anthro) >= 1)\n\n# Team 1 linguists count\nteam1_linguist = [If(And(team[i] == 1, i in linguist_indices), 1, 0) for i in range(len(team))]\nsolver.add(Sum(team1_linguist) >= 1)\n\n# Team 2 anthropologists count\nteam2_anthro = [If(And(team[i] == 2, i in anthro_indices), 1, 0) for i in range(len(team))]\nsolver.add(Sum(team2_anthro) >= 1)\n\n# Team 2 linguists count\nteam2_linguist = [If(And(team[i] == 2, i in linguist_indices), 1, 0) for i in range(len(team))]\nsolver.add(Sum(team2_linguist) >= 1)\n\n# Conditions:\n\n# Neither team includes both Franklin and Samuels.\n# Franklin index\nf_idx = researcher_idx['Franklin']\ns_idx = researcher_idx['Samuels']\nfor team_number in [1, 2]:\n    solver.add(Not(And(team[f_idx] == team_number, team[s_idx] == team_number)))\n\n# Neither team includes both Neil and Rice.\nn_idx = researcher_idx['Neil']\nr_idx = researcher_idx['Rice']\nfor team_number in [1, 2]:\n    solver.add(Not(And(team[n_idx] == team_number, team[r_idx] == team_number)))\n\n# If a team includes Marquez, it includes neither Rice nor Samuels.\nm_idx = researcher_idx['Marquez']\nfor team_number in [1, 2]:\n    # If Marquez on team_number then Rice and Samuels not on team_number\n    solver.add(Implies(team[m_idx] == team_number,\n                       And(team[r_idx] != team_number, team[s_idx] != team_number)))\n\n# If team 1 includes Jones, team 2 includes Rice.\nj_idx = researcher_idx['Jones']\nsolver.add(Implies(team[j_idx] == 1, team[r_idx] == 2))\n\n# OPTION CHECKING\n\n# Jones is on team 1 (given)\nsolver.add(team[j_idx] == 1)\n\n# Options to check: which pair must be on team 2 together?\n\n# Define a helper function to check if both researchers are on team 2\ndef pair_on_team2(pair):\n    i1 = researcher_idx[pair[0]]\n    i2 = researcher_idx[pair[1]]\n    return And(team[i1] == 2, team[i2] == 2)\n\noptions = {\n    'A': ('Franklin', 'Rice'),\n    'B': ('Marquez', 'Osborne'),\n    'C': ('Neil', 'Osborne'),\n    'D': ('Osborne', 'Samuels'),\n    'E': ('Rice', 'Samuels')\n}\n\nfor letter, pair in options.items():\n    solver.push()\n    # Add constraint that pair is NOT both on team 2\n    solver.add(Not(pair_on_team2(pair)))\n    # If unsat, then pair must be on team 2\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.\n\nIf Neil is on team 1, which one of the following is a pair of researchers that could be on team 1 together with Neil?\n\nOptions:\n(A) Franklin and Jones\n(B) Jones and Osborne\n(C) Jones and Rice\n(D) Jones and Samuels\n(E) Osborne and Samuels",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nanthropologists = ['Franklin', 'Jones', 'Marquez']\nlinguists = ['Neil', 'Osborne', 'Rice', 'Samuels']\nresearchers = anthropologists + linguists\n\n# Create variables for team assignments: 0 = not included, 1 = team1, 2 = team2\nteam = {}\nfor r in researchers:\n    team[r] = Int(r)\n    \n# Values: 0 (not included), 1 (team1), 2 (team2)\nvalid_teams = [0, 1, 2]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each researcher assigned to 0, 1, or 2\nfor r in researchers:\n    solver.add(Or([team[r] == v for v in valid_teams]))\n\n# Exactly six researchers included (team != 0)\nincluded = [If(team[r] != 0, 1, 0) for r in researchers]\nsolver.add(Sum(included) == 6)\n\n# Each team has exactly 3 members\nteam1_members = [If(team[r] == 1, 1, 0) for r in researchers]\nteam2_members = [If(team[r] == 2, 1, 0) for r in researchers]\nsolver.add(Sum(team1_members) == 3)\nsolver.add(Sum(team2_members) == 3)\n\n# No researcher on more than one team (already ensured by domain 0,1,2)\n\n# Each team has at least one anthropologist and at least one linguist\ndef has_anthropologist(team_num):\n    return Or([team[r] == team_num for r in anthropologists])\ndef has_linguist(team_num):\n    return Or([team[r] == team_num for r in linguists])\n\nsolver.add(has_anthropologist(1))\nsolver.add(has_linguist(1))\nsolver.add(has_anthropologist(2))\nsolver.add(has_linguist(2))\n\n# Constraints:\n# 1) Neither team includes both Franklin and Samuels\nsolver.add(Or(team['Franklin'] != team['Samuels'], team['Franklin'] == 0, team['Samuels'] == 0))\n\n# 2) Neither team includes both Neil and Rice\nsolver.add(Or(team['Neil'] != team['Rice'], team['Neil'] == 0, team['Rice'] == 0))\n\n# 3) If a team includes Marquez, it includes neither Rice nor Samuels\n# For team 1:\nsolver.add(Implies(team['Marquez'] == 1, And(team['Rice'] != 1, team['Samuels'] != 1)))\n# For team 2:\nsolver.add(Implies(team['Marquez'] == 2, And(team['Rice'] != 2, team['Samuels'] != 2)))\n\n# 4) If team 1 includes Jones, team 2 includes Rice\nsolver.add(Implies(team['Jones'] == 1, team['Rice'] == 2))\n\n# Neil is on team 1\nsolver.add(team['Neil'] == 1)\n\n# OPTION CHECKING\noptions = {\n    'A': ['Franklin', 'Jones'],\n    'B': ['Jones', 'Osborne'],\n    'C': ['Jones', 'Rice'],\n    'D': ['Jones', 'Samuels'],\n    'E': ['Osborne', 'Samuels']\n}\n\nfor letter, pair in options.items():\n    solver.push()\n    # Both in team 1 with Neil\n    solver.add(team[pair[0]] == 1)\n    solver.add(team[pair[1]] == 1)\n    # Check if satisfiable\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.\n\nIf Franklin is on the same team as Marquez, which one of the following could be true?\n\nOptions:\n(A) Jones is on team 1.\n(B) Rice is on team 1.\n(C) Samuels is on team 2.\n(D) Both Neil and Osborne are on team 1.\n(E) Both Neil and Osborne are on team 2.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Researchers\nanthropologists = ['Franklin', 'Jones', 'Marquez']\nlinguists = ['Neil', 'Osborne', 'Rice', 'Samuels']\nresearchers = anthropologists + linguists\n\n# Teams: 0 = not selected, 1 = team1, 2 = team2\n# We will assign each researcher an Int variable indicating their team assignment:\n# 0 = not selected, 1 = team1, 2 = team2\n\nteam = {r: Int(r) for r in researchers}\n\n# Helper sets for quick membership tests\nanthro_set = set(anthropologists)\nlinguist_set = set(linguists)\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each researcher assigned to 0, 1, or 2\nfor r in researchers:\n    solver.add(Or(team[r] == 0, team[r] == 1, team[r] == 2))\n\n# Exactly six researchers are included (team 1 or 2)\nincluded = [If(Or(team[r] == 1, team[r] == 2), 1, 0) for r in researchers]\nsolver.add(Sum(included) == 6)\n\n# Each team has exactly 3 members\nteam1_members = [If(team[r] == 1, 1, 0) for r in researchers]\nteam2_members = [If(team[r] == 2, 1, 0) for r in researchers]\nsolver.add(Sum(team1_members) == 3)\nsolver.add(Sum(team2_members) == 3)\n\n# No researcher in more than one team (already ensured by domain constraints)\n\n# Each team includes at least one anthropologist and at least one linguist\ndef has_anthro(team_num):\n    return Or([team[r] == team_num for r in anthropologists])\n\ndef has_ling(team_num):\n    return Or([team[r] == team_num for r in linguists])\n\nsolver.add(has_anthro(1))\nsolver.add(has_ling(1))\nsolver.add(has_anthro(2))\nsolver.add(has_ling(2))\n\n# Conditions:\n\n# 1) Neither team includes both Franklin and Samuels.\n# For team 1:\nsolver.add(Not(And(team['Franklin'] == 1, team['Samuels'] == 1)))\n# For team 2:\nsolver.add(Not(And(team['Franklin'] == 2, team['Samuels'] == 2)))\n\n# 2) Neither team includes both Neil and Rice.\nsolver.add(Not(And(team['Neil'] == 1, team['Rice'] == 1)))\nsolver.add(Not(And(team['Neil'] == 2, team['Rice'] == 2)))\n\n# 3) If a team includes Marquez, it includes neither Rice nor Samuels.\n# For team 1:\nsolver.add(Implies(team['Marquez'] == 1, And(team['Rice'] != 1, team['Samuels'] != 1)))\n# For team 2:\nsolver.add(Implies(team['Marquez'] == 2, And(team['Rice'] != 2, team['Samuels'] != 2)))\n\n# 4) If team 1 includes Jones, team 2 includes Rice.\nsolver.add(Implies(team['Jones'] == 1, team['Rice'] == 2))\n\n# Additional condition for the question:\n# Franklin is on the same team as Marquez.\n# So team[Franklin] == team[Marquez] and both != 0.\nsolver.add(team['Franklin'] != 0)\nsolver.add(team['Marquez'] != 0)\nsolver.add(team['Franklin'] == team['Marquez'])\n\n# OPTION CHECKING\n\n# Options:\n# (A) Jones is on team 1.\n# (B) Rice is on team 1.\n# (C) Samuels is on team 2.\n# (D) Both Neil and Osborne are on team 1.\n# (E) Both Neil and Osborne are on team 2.\n\noptions = [\n    team['Jones'] == 1,\n    team['Rice'] == 1,\n    team['Samuels'] == 2,\n    And(team['Neil'] == 1, team['Osborne'] == 1),\n    And(team['Neil'] == 2, team['Osborne'] == 2)\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.\n\nEach of the following is a pair of researchers that could be on team 2 together EXCEPT:\n\nOptions:\n(A) Franklin and Jones\n(B) Franklin and Marquez\n(C) Franklin and Rice\n(D) Jones and Marquez\n(E) Jones and Rice",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Researchers\nanthropologists = ['Franklin', 'Jones', 'Marquez']\nlinguists = ['Neil', 'Osborne', 'Rice', 'Samuels']\nresearchers = anthropologists + linguists\n\n# Create variables for team assignments: 0 = not included, 1 = team 1, 2 = team 2\nteam = {r: Int(r) for r in researchers}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each researcher assigned to 0, 1, or 2\nfor r in researchers:\n    solver.add(Or(team[r] == 0, team[r] == 1, team[r] == 2))\n\n# Exactly six researchers included (team 1 or team 2)\nincluded = [If(Or(team[r] == 1, team[r] == 2), 1, 0) for r in researchers]\nsolver.add(Sum(included) == 6)\n\n# Each team has exactly 3 members\nteam1_members = [If(team[r] == 1, 1, 0) for r in researchers]\nteam2_members = [If(team[r] == 2, 1, 0) for r in researchers]\nsolver.add(Sum(team1_members) == 3)\nsolver.add(Sum(team2_members) == 3)\n\n# No researcher in more than one team (enforced by domain 0,1,2)\n\n# Each team must have at least one anthropologist and at least one linguist\nteam1_anth = [If(team[r] == 1, 1, 0) for r in anthropologists]\nteam1_ling = [If(team[r] == 1, 1, 0) for r in linguists]\nteam2_anth = [If(team[r] == 2, 1, 0) for r in anthropologists]\nteam2_ling = [If(team[r] == 2, 1, 0) for r in linguists]\nsolver.add(Sum(team1_anth) >= 1)\nsolver.add(Sum(team1_ling) >= 1)\nsolver.add(Sum(team2_anth) >= 1)\nsolver.add(Sum(team2_ling) >= 1)\n\n# Conditions:\n# Neither team includes both Franklin and Samuels\nfor t in [1, 2]:\n    solver.add(Or(team['Franklin'] != t, team['Samuels'] != t))\n\n# Neither team includes both Neil and Rice\nfor t in [1, 2]:\n    solver.add(Or(team['Neil'] != t, team['Rice'] != t))\n\n# If a team includes Marquez, it includes neither Rice nor Samuels\nfor t in [1, 2]:\n    solver.add(Implies(team['Marquez'] == t, And(team['Rice'] != t, team['Samuels'] != t)))\n\n# If team 1 includes Jones, team 2 includes Rice\nsolver.add(Implies(team['Jones'] == 1, team['Rice'] == 2))\n\n# OPTION CHECKING\n# Each option is a pair of researchers that could be on team 2 together EXCEPT one\noptions = [\n    ('Franklin', 'Jones'),\n    ('Franklin', 'Marquez'),\n    ('Franklin', 'Rice'),\n    ('Jones', 'Marquez'),\n    ('Jones', 'Rice')\n]\n\nfor i, (r1, r2) in enumerate(options):\n    solver.push()\n    # Add constraint that r1 and r2 are both on team 2\n    solver.add(team[r1] == 2)\n    solver.add(team[r2] == 2)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Franklin is on team 1 and Neil is on team 2.\n(B) Franklin is on team 2 and Jones is not on any team.\n(C) Franklin is on team 2 and Marquez is on team 2.\n(D) Franklin is not on any team and Jones is on team 1.\n(E) Jones is on team 1 and Neil is on team 2.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nresearchers = ['Franklin', 'Jones', 'Marquez', 'Neil', 'Osborne', 'Rice', 'Samuels']\nanthropologists = ['Franklin', 'Jones', 'Marquez']\nlinguists = ['Neil', 'Osborne', 'Rice', 'Samuels']\n\n# Create variables: team assignment for each researcher\n# Values: 0 = not on any team, 1 = team 1, 2 = team 2\nteam = {r: Int(r) for r in researchers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each researcher assigned to 0, 1, or 2\nfor r in researchers:\n    solver.add(Or(team[r] == 0, team[r] == 1, team[r] == 2))\n\n# Exactly six researchers assigned to teams (value 1 or 2)\nassigned = [If(Or(team[r] == 1, team[r] == 2), 1, 0) for r in researchers]\nsolver.add(Sum(assigned) == 6)\n\n# Each team has exactly 3 members\nteam1_members = [If(team[r] == 1, 1, 0) for r in researchers]\nteam2_members = [If(team[r] == 2, 1, 0) for r in researchers]\nsolver.add(Sum(team1_members) == 3)\nsolver.add(Sum(team2_members) == 3)\n\n# No researcher on more than one team (already ensured by variable domain)\n\n# Each team must have at least one anthropologist and at least one linguist\n\n# Team 1 anthropologists count\nteam1_anthro = [If(And(team[r] == 1, r in anthropologists), 1, 0) for r in researchers]\nsolver.add(Sum(team1_anthro) >= 1)\n\n# Team 1 linguists count\nteam1_ling = [If(And(team[r] == 1, r in linguists), 1, 0) for r in researchers]\nsolver.add(Sum(team1_ling) >= 1)\n\n# Team 2 anthropologists count\nteam2_anthro = [If(And(team[r] == 2, r in anthropologists), 1, 0) for r in researchers]\nsolver.add(Sum(team2_anthro) >= 1)\n\n# Team 2 linguists count\nteam2_ling = [If(And(team[r] == 2, r in linguists), 1, 0) for r in researchers]\nsolver.add(Sum(team2_ling) >= 1)\n\n# Constraints:\n# Neither team includes both Franklin and Samuels\nfor t in [1, 2]:\n    solver.add(Or(team['Franklin'] != t, team['Samuels'] != t))\n\n# Neither team includes both Neil and Rice\nfor t in [1, 2]:\n    solver.add(Or(team['Neil'] != t, team['Rice'] != t))\n\n# If a team includes Marquez, it includes neither Rice nor Samuels\nfor t in [1, 2]:\n    # If Marquez in team t then Rice not in t and Samuels not in t\n    solver.add(Implies(team['Marquez'] == t, And(team['Rice'] != t, team['Samuels'] != t)))\n\n# If team 1 includes Jones, team 2 includes Rice\nsolver.add(Implies(team['Jones'] == 1, team['Rice'] == 2))\n\n# OPTION CHECKING\n# Options:\n# (A) Franklin is on team 1 and Neil is on team 2.\n# (B) Franklin is on team 2 and Jones is not on any team.\n# (C) Franklin is on team 2 and Marquez is on team 2.\n# (D) Franklin is not on any team and Jones is on team 1.\n# (E) Jones is on team 1 and Neil is on team 2.\n\noptions = [\n    [team['Franklin'] == 1, team['Neil'] == 2],\n    [team['Franklin'] == 2, team['Jones'] == 0],\n    [team['Franklin'] == 2, team['Marquez'] == 2],\n    [team['Franklin'] == 0, team['Jones'] == 1],\n    [team['Jones'] == 1, team['Neil'] == 2]\n]\n\nfor i, option_constraints in enumerate(options):\n    solver.push()\n    solver.add(option_constraints)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly six of seven researchers—three anthropologists: Franklin, Jones, and Marquez; and four linguists: Neil, Osborne, Rice, and Samuels—will be included in two three-person teams—team 1 and team 2. No researcher will be included in more than one team. Each team must include at least one anthropologist and at least one linguist. The teams' composition must conform to the following conditions: Neither team includes both Franklin and Samuels. Neither team includes both Neil and Rice. If a team includes Marquez, it includes neither Rice nor Samuels. If team 1 includes Jones, team 2 includes Rice.\n\nIf Marquez is on team 2, which one of the following must also be on team 2?\n\nOptions:\n(A) Franklin\n(B) Jones\n(C) Osborne\n(D) Rice\n(E) Samuels",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Researchers\nanthropologists = ['Franklin', 'Jones', 'Marquez']\nlinguists = ['Neil', 'Osborne', 'Rice', 'Samuels']\nall_researchers = anthropologists + linguists\n\n# Index mapping for researchers\nindex = {name: i for i, name in enumerate(all_researchers)}\n\n# Variables: team assignments\n# team1[i] = 1 if researcher i in team 1, else 0\n# team2[i] = 1 if researcher i in team 2, else 0\n# Note: exactly six researchers included in two teams total, no overlap\n\nteam1 = [Int(f\"t1_{r}\") for r in all_researchers]\nteam2 = [Int(f\"t2_{r}\") for r in all_researchers]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each variable is 0 or 1\nfor i in range(len(all_researchers)):\n    solver.add(Or(team1[i] == 0, team1[i] == 1))\n    solver.add(Or(team2[i] == 0, team2[i] == 1))\n\n# No researcher in more than one team\nfor i in range(len(all_researchers)):\n    solver.add(team1[i] + team2[i] <= 1)\n\n# Exactly six researchers included total (sum over all researchers in both teams)\ntotal_included = Sum([team1[i] + team2[i] for i in range(len(all_researchers))])\nsolver.add(total_included == 6)\n\n# Each team has exactly 3 members\nsolver.add(Sum(team1) == 3)\nsolver.add(Sum(team2) == 3)\n\n# Each team must have at least one anthropologist and at least one linguist\n# Anthropologist indices\nanthro_indices = [index[a] for a in anthropologists]\nlinguist_indices = [index[l] for l in linguists]\n\n# Team 1 anthro count >= 1\nsolver.add(Sum([team1[i] for i in anthro_indices]) >= 1)\n# Team 1 linguist count >= 1\nsolver.add(Sum([team1[i] for i in linguist_indices]) >= 1)\n\n# Team 2 anthro count >= 1\nsolver.add(Sum([team2[i] for i in anthro_indices]) >= 1)\n# Team 2 linguist count >= 1\nsolver.add(Sum([team2[i] for i in linguist_indices]) >= 1)\n\n# Condition: Neither team includes both Franklin and Samuels\nf = index['Franklin']\ns = index['Samuels']\nsolver.add(Or(team1[f] + team1[s] <= 1))\nsolver.add(Or(team2[f] + team2[s] <= 1))\n\n# Condition: Neither team includes both Neil and Rice\nn = index['Neil']\nr = index['Rice']\nsolver.add(Or(team1[n] + team1[r] <= 1))\nsolver.add(Or(team2[n] + team2[r] <= 1))\n\n# Condition: If a team includes Marquez, it includes neither Rice nor Samuels\nm = index['Marquez']\n# For team 1:\nsolver.add(Implies(team1[m] == 1, And(team1[r] == 0, team1[s] == 0)))\n# For team 2:\nsolver.add(Implies(team2[m] == 1, And(team2[r] == 0, team2[s] == 0)))\n\n# Condition: If team 1 includes Jones, team 2 includes Rice\nj = index['Jones']\nsolver.add(Implies(team1[j] == 1, team2[r] == 1))\n\n# OPTION CHECKING\n\n# Marquez is on team 2\nsolver.add(team2[m] == 1)\n\noptions = ['Franklin', 'Jones', 'Osborne', 'Rice', 'Samuels']\n\n# For each option, check if it must be on team 2 if Marquez is on team 2\n# To check if option X must be on team 2, check if solver is UNSAT when option X is NOT on team 2\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint: option researcher NOT on team 2\n    solver.add(team2[index[opt]] == 0)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Five candidates for mayor—Q, R, S, T, and U—will each speak exactly once at each of three town meetings—meetings 1, 2, and 3. At each meeting, each candidate will speak in one of five consecutive time slots. No two candidates will speak in the same time slot as each other at any meeting. The order in which the candidates will speak will meet the following conditions: Each candidate must speak either first or second at at least one of the meetings. Any candidate who speaks fifth at any of the meetings must speak first at at least one of the other meetings. No candidate can speak fourth at more than one of the meetings.\n\nWhich one of the following could be the order, from first to fifth, in which the candidates speak at the meetings?\n\nOptions:\n(A) meeting 1: Q, U, R, T, S meeting 2: S, T, R, U, Q meeting 3: T, U, Q, R, S\n(B) meeting 1: R, S, Q, T, U meeting 2: U, T, S, R, Q meeting 3: Q, R, T, U, S\n(C) meeting 1: S, Q, U, T, R meeting 2: U, T, Q, R, S meeting 3: R, Q, S, T, U\n(D) meeting 1: T, R, S, U, Q meeting 2: Q, R, S, T, U meeting 3: U, S, R, Q, T\n(E) meeting 1: U, T, R, S, Q meeting 2: Q, R, S, T, U meeting 3: S, T, U, Q, R",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\ncandidates = ['Q', 'R', 'S', 'T', 'U']\nmeetings = [1, 2, 3]\nslots = [1, 2, 3, 4, 5]\n\n# Create a dictionary: position[candidate][meeting] = slot number (1 to 5)\nposition = {c: {m: Int(f'{c}_{m}') for m in meetings} for c in candidates}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each candidate speaks exactly once at each meeting, in one of the five slots (1 to 5)\nfor c in candidates:\n    for m in meetings:\n        solver.add(And(position[c][m] >= 1, position[c][m] <= 5))\n\n# 2) At each meeting, no two candidates speak in the same slot (slots distinct per meeting)\nfor m in meetings:\n    solver.add(Distinct([position[c][m] for c in candidates]))\n\n# 3) Each candidate must speak either first or second at at least one meeting\nfor c in candidates:\n    cond_first_or_second = Or([Or(position[c][m] == 1, position[c][m] == 2) for m in meetings])\n    solver.add(cond_first_or_second)\n\n# 4) Any candidate who speaks fifth at any meeting must speak first at at least one other meeting\nfor c in candidates:\n    for m in meetings:\n        # If candidate c speaks 5th at meeting m\n        fifth_at_m = position[c][m] == 5\n        # then there exists another meeting m2 != m where c speaks first\n        others = [m2 for m2 in meetings if m2 != m]\n        first_at_other = Or([position[c][m2] == 1 for m2 in others])\n        solver.add(Implies(fifth_at_m, first_at_other))\n\n# 5) No candidate can speak fourth at more than one meeting\nfor c in candidates:\n    fourth_count = Sum([If(position[c][m] == 4, 1, 0) for m in meetings])\n    solver.add(fourth_count <= 1)\n\n# OPTION CHECKING\n\noptions = [\n    # (A)\n    {\n        1: ['Q', 'U', 'R', 'T', 'S'],\n        2: ['S', 'T', 'R', 'U', 'Q'],\n        3: ['T', 'U', 'Q', 'R', 'S'],\n    },\n    # (B)\n    {\n        1: ['R', 'S', 'Q', 'T', 'U'],\n        2: ['U', 'T', 'S', 'R', 'Q'],\n        3: ['Q', 'R', 'T', 'U', 'S'],\n    },\n    # (C)\n    {\n        1: ['S', 'Q', 'U', 'T', 'R'],\n        2: ['U', 'T', 'Q', 'R', 'S'],\n        3: ['R', 'Q', 'S', 'T', 'U'],\n    },\n    # (D)\n    {\n        1: ['T', 'R', 'S', 'U', 'Q'],\n        2: ['Q', 'R', 'S', 'T', 'U'],\n        3: ['U', 'S', 'R', 'Q', 'T'],\n    },\n    # (E)\n    {\n        1: ['U', 'T', 'R', 'S', 'Q'],\n        2: ['Q', 'R', 'S', 'T', 'U'],\n        3: ['S', 'T', 'U', 'Q', 'R'],\n    }\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints to fix positions according to the option\n    # For each meeting and slot, the candidate speaking at that slot must match the option\n    # So for each meeting m and slot s, position[candidate][m] == s\n    # We add constraints for all candidates and meetings\n    for m in meetings:\n        for slot_idx, c in enumerate(option[m], start=1):\n            solver.add(position[c][m] == slot_idx)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Five candidates for mayor—Q, R, S, T, and U—will each speak exactly once at each of three town meetings—meetings 1, 2, and 3. At each meeting, each candidate will speak in one of five consecutive time slots. No two candidates will speak in the same time slot as each other at any meeting. The order in which the candidates will speak will meet the following conditions: Each candidate must speak either first or second at at least one of the meetings. Any candidate who speaks fifth at any of the meetings must speak first at at least one of the other meetings. No candidate can speak fourth at more than one of the meetings.\n\nIf the order in which the candidates speak at meeting 1 is R, U, S, T, Q, and the order in which they speak at meeting 2 is Q, R, U, S, T, which one of the following could be true of meeting 3?\n\nOptions:\n(A) Q speaks first.\n(B) R speaks third.\n(C) S speaks first.\n(D) T speaks second.\n(E) U speaks fifth.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\ncandidates = ['Q', 'R', 'S', 'T', 'U']\nmeetings = [1, 2, 3]\nslots = range(1, 6)  # Slots 1 to 5\n\n# Create a dict of Int variables: position[candidate][meeting] = slot number (1 to 5)\nposition = {}\nfor c in candidates:\n    position[c] = {}\n    for m in meetings:\n        position[c][m] = Int(f'pos_{c}_{m}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each candidate speaks exactly once at each meeting (position is between 1 and 5)\nfor c in candidates:\n    for m in meetings:\n        solver.add(And(position[c][m] >= 1, position[c][m] <= 5))\n\n# 2) At each meeting, no two candidates speak in the same slot (all positions distinct)\nfor m in meetings:\n    solver.add(Distinct([position[c][m] for c in candidates]))\n\n# 3) Given orders for meeting 1 and meeting 2:\n# Meeting 1: R, U, S, T, Q  => positions: R=1, U=2, S=3, T=4, Q=5\nsolver.add(position['R'][1] == 1)\nsolver.add(position['U'][1] == 2)\nsolver.add(position['S'][1] == 3)\nsolver.add(position['T'][1] == 4)\nsolver.add(position['Q'][1] == 5)\n\n# Meeting 2: Q, R, U, S, T => positions: Q=1, R=2, U=3, S=4, T=5\nsolver.add(position['Q'][2] == 1)\nsolver.add(position['R'][2] == 2)\nsolver.add(position['U'][2] == 3)\nsolver.add(position['S'][2] == 4)\nsolver.add(position['T'][2] == 5)\n\n# 4) Each candidate must speak first or second at at least one meeting\nfor c in candidates:\n    cond_first_or_second = Or([Or(position[c][m] == 1, position[c][m] == 2) for m in meetings])\n    solver.add(cond_first_or_second)\n\n# 5) Any candidate who speaks fifth at any meeting must speak first at at least one other meeting\nfor c in candidates:\n    # For each meeting m1 where candidate c speaks fifth,\n    # there exists another meeting m2 != m1 where c speaks first\n    fifth_meetings = [m for m in meetings]\n    fifth_conditions = []\n    for m1 in meetings:\n        # If candidate speaks fifth at m1:\n        cond_fifth_at_m1 = position[c][m1] == 5\n        # candidate speaks first at some other meeting m2 != m1\n        others = [m2 for m2 in meetings if m2 != m1]\n        cond_first_other = Or([position[c][m2] == 1 for m2 in others])\n        # implication: if speaks fifth at m1 then speaks first at other meeting\n        fifth_conditions.append(Implies(cond_fifth_at_m1, cond_first_other))\n    solver.add(And(fifth_conditions))\n\n# 6) No candidate can speak fourth at more than one meeting\nfor c in candidates:\n    # Count how many meetings candidate speaks fourth\n    fourth_count = Sum([If(position[c][m] == 4, 1, 0) for m in meetings])\n    solver.add(fourth_count <= 1)\n\n# OPTION CHECKING\n\noptions = {\n    'A': ('Q', 1),\n    'B': ('R', 3),\n    'C': ('S', 1),\n    'D': ('T', 2),\n    'E': ('U', 5)\n}\n\nfor letter, (cand, slot) in options.items():\n    solver.push()\n    # Add the option-specific constraint for meeting 3\n    solver.add(position[cand][3] == slot)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Five candidates for mayor—Q, R, S, T, and U—will each speak exactly once at each of three town meetings—meetings 1, 2, and 3. At each meeting, each candidate will speak in one of five consecutive time slots. No two candidates will speak in the same time slot as each other at any meeting. The order in which the candidates will speak will meet the following conditions: Each candidate must speak either first or second at at least one of the meetings. Any candidate who speaks fifth at any of the meetings must speak first at at least one of the other meetings. No candidate can speak fourth at more than one of the meetings.\n\nIt could be true that at all three meetings T speaks\n\nOptions:\n(A) first\n(B) second\n(C) in some time slot after the time slot in which R speaks\n(D) in some time slot after the time slots in which S and U speak\n(E) in some time slot before the time slots in which R and U speak",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncandidates = ['Q', 'R', 'S', 'T', 'U']\nmeetings = [1, 2, 3]\nslots = [1, 2, 3, 4, 5]  # time slots\n\n# Create Z3 Int variables: speaking slot for each candidate at each meeting\n# slot_vars[candidate][meeting] = slot number (1 to 5)\nslot_vars = {}\nfor c in candidates:\n    slot_vars[c] = {}\n    for m in meetings:\n        slot_vars[c][m] = Int(f\"{c}_{m}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each candidate speaks exactly once at each meeting in one of five slots\nfor c in candidates:\n    for m in meetings:\n        solver.add(And(slot_vars[c][m] >= 1, slot_vars[c][m] <= 5))\n\n# 2) No two candidates speak in the same time slot at the same meeting\nfor m in meetings:\n    for i in range(len(candidates)):\n        for j in range(i+1, len(candidates)):\n            c1 = candidates[i]\n            c2 = candidates[j]\n            solver.add(slot_vars[c1][m] != slot_vars[c2][m])\n\n# 3) Each candidate must speak either first or second at at least one meeting\nfor c in candidates:\n    first_or_second_slots = [slot_vars[c][m] <= 2 for m in meetings]\n    solver.add(Or(first_or_second_slots))\n\n# 4) Any candidate who speaks fifth at any meeting must speak first at at least one other meeting\nfor c in candidates:\n    # If candidate speaks 5 at meeting m, then there exists another meeting m2 != m where candidate speaks 1\n    for m in meetings:\n        other_meetings = [m2 for m2 in meetings if m2 != m]\n        speak_5 = slot_vars[c][m] == 5\n        speak_1_elsewhere = Or([slot_vars[c][m2] == 1 for m2 in other_meetings])\n        solver.add(Implies(speak_5, speak_1_elsewhere))\n\n# 5) No candidate can speak fourth at more than one meeting\nfor c in candidates:\n    speak_4_count = Sum([If(slot_vars[c][m] == 4, 1, 0) for m in meetings])\n    solver.add(speak_4_count <= 1)\n\n# OPTION CHECKING\n# Define helper function to check if an option is possible\ndef check_option(option_constraints):\n    solver.push()\n    for constr in option_constraints:\n        solver.add(constr)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# (A) T speaks first at all three meetings\noption_A = [slot_vars['T'][m] == 1 for m in meetings]\n\n# (B) T speaks second at all three meetings\noption_B = [slot_vars['T'][m] == 2 for m in meetings]\n\n# (C) T speaks in some time slot after the time slot in which R speaks (at some meeting)\n# Means: There exists a meeting m where slot(T,m) > slot(R,m)\noption_C = [Or([slot_vars['T'][m] > slot_vars['R'][m] for m in meetings])]\n\n# (D) T speaks in some time slot after the time slots in which S and U speak\n# Means: There exists a meeting m where slot(T,m) > slot(S,m) and slot(T,m) > slot(U,m)\noption_D = [Or([And(slot_vars['T'][m] > slot_vars['S'][m], slot_vars['T'][m] > slot_vars['U'][m]) for m in meetings])]\n\n# (E) T speaks in some time slot before the time slots in which R and U speak\n# Means: There exists a meeting m where slot(T,m) < slot(R,m) and slot(T,m) < slot(U,m)\noption_E = [Or([And(slot_vars['T'][m] < slot_vars['R'][m], slot_vars['T'][m] < slot_vars['U'][m]) for m in meetings])]\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, option in enumerate(options):\n    if check_option(option):\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Five candidates for mayor—Q, R, S, T, and U—will each speak exactly once at each of three town meetings—meetings 1, 2, and 3. At each meeting, each candidate will speak in one of five consecutive time slots. No two candidates will speak in the same time slot as each other at any meeting. The order in which the candidates will speak will meet the following conditions: Each candidate must speak either first or second at at least one of the meetings. Any candidate who speaks fifth at any of the meetings must speak first at at least one of the other meetings. No candidate can speak fourth at more than one of the meetings.\n\nIf S, T, and U speak second at meetings 1, 2, and 3, respectively, which one of the following must be true?\n\nOptions:\n(A) The fifth speaker at at least one of the meetings is either Q or R.\n(B) Either Q speaks first at exactly two of the meetings or else R does so.\n(C) Neither S nor T speaks fifth at any of the meetings.\n(D) Q speaks third at one of the meetings, and R speaks third at another of the meetings.\n(E) Q speaks fourth at one of the meetings, and R speaks fourth at another of the meetings.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\ncandidates = ['Q', 'R', 'S', 'T', 'U']\nmeetings = [1, 2, 3]\nslots = [1, 2, 3, 4, 5]\n\n# Create a dictionary of Z3 Int variables: position[candidate][meeting] = slot number (1-5)\nposition = {}\nfor c in candidates:\n    position[c] = {}\n    for m in meetings:\n        position[c][m] = Int(f'pos_{c}_{m}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each candidate speaks exactly once at each meeting in one of five consecutive time slots (1 to 5)\nfor c in candidates:\n    for m in meetings:\n        solver.add(And(position[c][m] >= 1, position[c][m] <= 5))\n\n# 2) No two candidates speak in the same slot at the same meeting\nfor m in meetings:\n    solver.add(Distinct([position[c][m] for c in candidates]))\n\n# 3) Each candidate must speak either first or second at at least one meeting\nfor c in candidates:\n    first_or_second_slots = [position[c][m] == 1 for m in meetings] + [position[c][m] == 2 for m in meetings]\n    solver.add(Or(first_or_second_slots))\n\n# 4) Any candidate who speaks fifth at any meeting must speak first at least one of the other meetings\nfor c in candidates:\n    for m in meetings:\n        # If candidate c speaks fifth at meeting m,\n        # then there exists another meeting m2 != m where c speaks first\n        other_meetings = [m2 for m2 in meetings if m2 != m]\n        speaks_fifth = position[c][m] == 5\n        speaks_first_other = Or([position[c][m2] == 1 for m2 in other_meetings])\n        solver.add(Implies(speaks_fifth, speaks_first_other))\n\n# 5) No candidate can speak fourth at more than one meeting\nfor c in candidates:\n    # Count number of meetings where c speaks fourth <= 1\n    # Use boolean variables for each meeting whether c speaks fourth\n    fourth_bools = [position[c][m] == 4 for m in meetings]\n    # Sum of these boolean expressions <= 1\n    # Z3 doesn't directly sum Booleans, so convert to If(cond,1,0)\n    count_fourth = Sum([If(cond, 1, 0) for cond in fourth_bools])\n    solver.add(count_fourth <= 1)\n\n# 6) Given conditions about S, T, U speaking second at meetings 1, 2, 3 respectively\nsolver.add(position['S'][1] == 2)\nsolver.add(position['T'][2] == 2)\nsolver.add(position['U'][3] == 2)\n\n# OPTION CHECKING\n\noptions = {\n    'A': Or([position[c][m] == 5 for c in ['Q', 'R'] for m in meetings]),\n    'B': Or([\n        Sum([If(position['Q'][m] == 1, 1, 0) for m in meetings]) == 2,\n        Sum([If(position['R'][m] == 1, 1, 0) for m in meetings]) == 2,\n    ]),\n    'C': And(\n        And([position['S'][m] != 5 for m in meetings]),\n        And([position['T'][m] != 5 for m in meetings])\n    ),\n    'D': And(\n        Or([position['Q'][m] == 3 for m in meetings]),\n        Or([position['R'][m] == 3 for m in meetings])\n    ),\n    'E': And(\n        Or([position['Q'][m] == 4 for m in meetings]),\n        Or([position['R'][m] == 4 for m in meetings])\n    )\n}\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(Not(options[opt]))\n    if solver.check() == unsat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "In a certain recipe contest, each contestant submits two recipes, one for an appetizer and one for a main dish. Together the two recipes must include exactly seven flavorings—fenugreek, ginger, lemongrass, nutmeg, paprika, saffron, and turmeric—with no flavoring included in more than one of the two recipes. Each contestant's recipes must satisfy the following conditions: The appetizer recipe includes at most three of the flavorings. Fenugreek is not included in the same recipe as nutmeg. Saffron is not included in the same recipe as turmeric. Ginger is included in the same recipe as nutmeg.\n\nWhich one of the following could be a complete and accurate list of the flavorings included in one contestant's main-dish recipe?\n\nOptions:\n(A) fenugreek, lemongrass, saffron\n(B) fenugreek, ginger, nutmeg, turmeric\n(C) ginger, lemongrass, nutmeg, paprika\n(D) ginger, nutmeg, paprika, turmeric\n(E) lemongrass, nutmeg, saffron, turmeric",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflavorings = ['fenugreek', 'ginger', 'lemongrass', 'nutmeg', 'paprika', 'saffron', 'turmeric']\nn = len(flavorings)\n\n# Create Bool variables for each flavoring in appetizer and main dish\nappetizer = {f: Bool(f'app_{f}') for f in flavorings}\nmain = {f: Bool(f'main_{f}') for f in flavorings}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each flavoring is in exactly one recipe (no overlap and together all 7)\nfor f in flavorings:\n    solver.add(Xor(appetizer[f], main[f]))\n# 2. Exactly 7 flavorings total (all are used)\n# Since each flavoring is in exactly one recipe, this is guaranteed by above\n\n# 3. Appetizer includes at most 3 flavorings\nappetizer_count = Sum([If(appetizer[f], 1, 0) for f in flavorings])\nsolver.add(appetizer_count <= 3)\n\n# 4. Fenugreek is not in the same recipe as nutmeg\nsolver.add(Not(And(appetizer['fenugreek'], appetizer['nutmeg'])))\nsolver.add(Not(And(main['fenugreek'], main['nutmeg'])))\n\n# 5. Saffron is not in the same recipe as turmeric\nsolver.add(Not(And(appetizer['saffron'], appetizer['turmeric'])))\nsolver.add(Not(And(main['saffron'], main['turmeric'])))\n\n# 6. Ginger is included in the same recipe as nutmeg\nsolver.add(appetizer['ginger'] == appetizer['nutmeg'])\nsolver.add(main['ginger'] == main['nutmeg'])\n\n# OPTION CHECKING\noptions = [\n    ['fenugreek', 'lemongrass', 'saffron'],              # A\n    ['fenugreek', 'ginger', 'nutmeg', 'turmeric'],       # B\n    ['ginger', 'lemongrass', 'nutmeg', 'paprika'],       # C\n    ['ginger', 'nutmeg', 'paprika', 'turmeric'],         # D\n    ['lemongrass', 'nutmeg', 'saffron', 'turmeric']      # E\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Set main dish flavorings to exactly the option list\n    for f in flavorings:\n        if f in opt:\n            solver.add(main[f] == True)\n        else:\n            solver.add(main[f] == False)\n    # Check if solvable\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "In a certain recipe contest, each contestant submits two recipes, one for an appetizer and one for a main dish. Together the two recipes must include exactly seven flavorings—fenugreek, ginger, lemongrass, nutmeg, paprika, saffron, and turmeric—with no flavoring included in more than one of the two recipes. Each contestant's recipes must satisfy the following conditions: The appetizer recipe includes at most three of the flavorings. Fenugreek is not included in the same recipe as nutmeg. Saffron is not included in the same recipe as turmeric. Ginger is included in the same recipe as nutmeg.\n\nIf a contestant's appetizer recipe does not include fenugreek, then the contestant's appetizer recipe must include\n\nOptions:\n(A) ginger\n(B) lemongrass\n(C) paprika\n(D) saffron\n(E) turmeric",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflavorings = ['fenugreek', 'ginger', 'lemongrass', 'nutmeg', 'paprika', 'saffron', 'turmeric']\nF = range(len(flavorings))  # indices 0 to 6\n\n# Create boolean variables for each flavoring in appetizer and main dish\n# appetizer[i] == True means flavoring i is in appetizer\nappetizer = [Bool(f\"appetizer_{f}\") for f in F]\nmain = [Bool(f\"main_{f}\") for f in F]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly 7 flavorings total in appetizer + main\n# Since total flavorings are 7, and no flavoring can appear in both recipes,\n# each flavoring must be in exactly one of the two recipes\nfor i in F:\n    solver.add(Xor(appetizer[i], main[i]))\n\n# The appetizer includes at most three flavorings\nsolver.add(Sum([If(appetizer[i], 1, 0) for i in F]) <= 3)\n\n# Fenugreek (index 0) is not included in the same recipe as nutmeg (index 3)\n# So fenugreek and nutmeg cannot both be in appetizer, and cannot both be in main\nsolver.add(Not(And(appetizer[0], appetizer[3])))\nsolver.add(Not(And(main[0], main[3])))\n\n# Saffron (index 5) is not included in the same recipe as turmeric (index 6)\nsolver.add(Not(And(appetizer[5], appetizer[6])))\nsolver.add(Not(And(main[5], main[6])))\n\n# Ginger (index 1) is included in the same recipe as nutmeg (index 3)\n# So appetizer[1] == appetizer[3], main[1] == main[3]\nsolver.add(appetizer[1] == appetizer[3])\nsolver.add(main[1] == main[3])\n\n# The condition: If appetizer does not include fenugreek (appetizer[0] == False),\n# then appetizer must include one of the options (A) ginger(1), (B) lemongrass(2),\n# (C) paprika(4), (D) saffron(5), (E) turmeric(6)\n# We will check each option by adding the constraint:\n# If not appetizer[0], then appetizer must include the option flavoring\n\noptions = {\n    'A': 1,\n    'B': 2,\n    'C': 4,\n    'D': 5,\n    'E': 6\n}\n\n# OPTION CHECKING\nfor letter, idx in options.items():\n    solver.push()\n    # Add the condition: If appetizer does not include fenugreek, then appetizer includes flavor idx\n    # This means: (Not appetizer[0]) => appetizer[idx]\n    solver.add(Implies(Not(appetizer[0]), appetizer[idx]))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "In a certain recipe contest, each contestant submits two recipes, one for an appetizer and one for a main dish. Together the two recipes must include exactly seven flavorings—fenugreek, ginger, lemongrass, nutmeg, paprika, saffron, and turmeric—with no flavoring included in more than one of the two recipes. Each contestant's recipes must satisfy the following conditions: The appetizer recipe includes at most three of the flavorings. Fenugreek is not included in the same recipe as nutmeg. Saffron is not included in the same recipe as turmeric. Ginger is included in the same recipe as nutmeg.\n\nWhich one of the following could be a list of all of the flavorings included in one contestant's appetizer recipe?\n\nOptions:\n(A) fenugreek, saffron\n(B) ginger, nutmeg\n(C) fenugreek, nutmeg, turmeric\n(D) lemongrass, nutmeg, saffron\n(E) fenugreek, lemongrass, paprika, turmeric",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflavors = ['fenugreek', 'ginger', 'lemongrass', 'nutmeg', 'paprika', 'saffron', 'turmeric']\nflavor_indices = {f: i for i, f in enumerate(flavors)}\n\n# Variables: For each flavor, 0 if in appetizer, 1 if in main dish\n# Since each flavor must be in exactly one recipe and no flavor is in both\n# We'll represent assignment as Int variables with domain {0,1}\n# 0: appetizer, 1: main dish\nassign = [Int(f) for f in flavors]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each flavor assigned to either appetizer (0) or main dish (1)\nfor a in assign:\n    solver.add(Or(a == 0, a == 1))\n\n# Exactly 7 flavors total, all assigned (given)\n# No flavor in both recipes (enforced by assign variables)\n\n# The appetizer includes at most 3 flavorings\nappetizer_count = Sum([If(a == 0, 1, 0) for a in assign])\nsolver.add(appetizer_count <= 3)\n\n# Fenugreek is not included in the same recipe as nutmeg\nfenugreek_idx = flavor_indices['fenugreek']\nnutmeg_idx = flavor_indices['nutmeg']\nsolver.add(assign[fenugreek_idx] != assign[nutmeg_idx])\n\n# Saffron is not included in the same recipe as turmeric\nsaffron_idx = flavor_indices['saffron']\nturmeric_idx = flavor_indices['turmeric']\nsolver.add(assign[saffron_idx] != assign[turmeric_idx])\n\n# Ginger is included in the same recipe as nutmeg\nginger_idx = flavor_indices['ginger']\nsolver.add(assign[ginger_idx] == assign[nutmeg_idx])\n\n# OPTION CHECKING\noptions = {\n    'A': ['fenugreek', 'saffron'],\n    'B': ['ginger', 'nutmeg'],\n    'C': ['fenugreek', 'nutmeg', 'turmeric'],\n    'D': ['lemongrass', 'nutmeg', 'saffron'],\n    'E': ['fenugreek', 'lemongrass', 'paprika', 'turmeric'],\n}\n\nfor letter, appetizer_flavors in options.items():\n    solver.push()\n    # Add constraints that the appetizer recipe contains exactly the flavors in appetizer_flavors\n    # For each flavor, assign 0 if in appetizer_flavors, else 1\n    for f in flavors:\n        if f in appetizer_flavors:\n            solver.add(assign[flavor_indices[f]] == 0)\n        else:\n            solver.add(assign[flavor_indices[f]] == 1)\n    # Check if the constraints are satisfiable\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "In a certain recipe contest, each contestant submits two recipes, one for an appetizer and one for a main dish. Together the two recipes must include exactly seven flavorings—fenugreek, ginger, lemongrass, nutmeg, paprika, saffron, and turmeric—with no flavoring included in more than one of the two recipes. Each contestant's recipes must satisfy the following conditions: The appetizer recipe includes at most three of the flavorings. Fenugreek is not included in the same recipe as nutmeg. Saffron is not included in the same recipe as turmeric. Ginger is included in the same recipe as nutmeg.\n\nIf a contestant includes lemongrass in the same recipe as paprika, which one of the following is a flavoring that must be included in the contestant's main-dish recipe?\n\nOptions:\n(A) ginger\n(B) lemongrass\n(C) nutmeg\n(D) saffron\n(E) turmeric",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflavorings = ['fenugreek', 'ginger', 'lemongrass', 'nutmeg', 'paprika', 'saffron', 'turmeric']\n# Map flavorings to indices\nf_idx = {f: i for i, f in enumerate(flavorings)}\n\n# Variables: For each flavoring, 0 if in appetizer, 1 if in main dish\n# Since no flavoring can be in both, and must be in exactly one, we can model as a boolean or integer 0/1\n# 0 = appetizer, 1 = main dish\nrecipe = [Int(f) for f in flavorings]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each flavoring must be in exactly one recipe: 0 or 1\nfor r in recipe:\n    solver.add(Or(r == 0, r == 1))\n\n# Together the two recipes must include exactly all 7 flavorings (all included, no flavoring missing)\n# Already modeled by all flavorings assigned 0 or 1\n\n# The appetizer recipe includes at most three flavorings\n# So sum of flavorings assigned 0 <= 3\nappetizer_count = Sum([If(r == 0, 1, 0) for r in recipe])\nsolver.add(appetizer_count <= 3)\n\n# Fenugreek is not included in the same recipe as nutmeg\nsolver.add(recipe[f_idx['fenugreek']] != recipe[f_idx['nutmeg']])\n\n# Saffron is not included in the same recipe as turmeric\nsolver.add(recipe[f_idx['saffron']] != recipe[f_idx['turmeric']])\n\n# Ginger is included in the same recipe as nutmeg\nsolver.add(recipe[f_idx['ginger']] == recipe[f_idx['nutmeg']])\n\n# Additional given condition for the question:\n# If lemongrass is in the same recipe as paprika\n# That means recipe[lemongrass] == recipe[paprika]\n# We add this condition to the solver to test options under this assumption\nsolver.add(recipe[f_idx['lemongrass']] == recipe[f_idx['paprika']])\n\n# OPTION CHECKING\n# For each option, check if the flavoring must be included in the main dish\n# That means check if the flavoring is always assigned 1 (main dish) in all models satisfying constraints\n\noptions = ['ginger', 'lemongrass', 'nutmeg', 'saffron', 'turmeric']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Check if the flavoring can be NOT in main dish (i.e., assigned 0)\n    solver.add(recipe[f_idx[opt]] == 0)\n    if solver.check() == unsat:\n        # If unsat, then flavoring must be in main dish (1)\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "In a certain recipe contest, each contestant submits two recipes, one for an appetizer and one for a main dish. Together the two recipes must include exactly seven flavorings—fenugreek, ginger, lemongrass, nutmeg, paprika, saffron, and turmeric—with no flavoring included in more than one of the two recipes. Each contestant's recipes must satisfy the following conditions: The appetizer recipe includes at most three of the flavorings. Fenugreek is not included in the same recipe as nutmeg. Saffron is not included in the same recipe as turmeric. Ginger is included in the same recipe as nutmeg.\n\nIf the condition that requires ginger to be included in the same recipe as nutmeg is suspended but all of the other original conditions remain in effect, then which one of the following could be a list of all of the flavorings included in one contestant's main-dish recipe?\n\nOptions:\n(A) ginger, lemongrass, nutmeg, paprika\n(B) ginger, lemongrass, paprika, turmeric\n(C) fenugreek, ginger, lemongrass, paprika, saffron\n(D) fenugreek, ginger, lemongrass, saffron, turmeric\n(E) fenugreek, lemongrass, nutmeg, paprika, saffron",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflavorings = ['fenugreek', 'ginger', 'lemongrass', 'nutmeg', 'paprika', 'saffron', 'turmeric']\nflavor_index = {f: i for i, f in enumerate(flavorings)}\n\n# Variables representing whether a flavoring is in the appetizer (True) or main dish (False)\n# We use Bool variables: True means flavoring in appetizer, False means in main dish\nappetizer = {f: Bool(f + '_app') for f in flavorings}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1. Exactly seven flavorings total (given, so all flavorings are used)\n# This is implicit since all flavorings are assigned to either appetizer or main dish\n\n# 2. No flavoring in more than one recipe\n# Modeled by assigning each flavoring to exactly one recipe (appetizer or main dish)\n# Since appetizer[f] is Bool, True means in appetizer, False means in main dish\n\n# 3. Appetizer includes at most three flavorings\nnum_appetizer = Sum([If(appetizer[f], 1, 0) for f in flavorings])\nsolver.add(num_appetizer <= 3)\n\n# 4. Fenugreek is not included in the same recipe as nutmeg\n# They cannot both be in appetizer, and cannot both be in main dish\n# So appetizer(fenugreek) != appetizer(nutmeg)\nsolver.add(appetizer['fenugreek'] != appetizer['nutmeg'])\n\n# 5. Saffron is not included in the same recipe as turmeric\n# So appetizer(saffron) != appetizer(turmeric)\nsolver.add(appetizer['saffron'] != appetizer['turmeric'])\n\n# 6. Ginger and nutmeg must be in the same recipe is suspended (so no constraint on ginger and nutmeg)\n\n# OPTION CHECKING\noptions = [\n    ['ginger', 'lemongrass', 'nutmeg', 'paprika'],            # A\n    ['ginger', 'lemongrass', 'paprika', 'turmeric'],          # B\n    ['fenugreek', 'ginger', 'lemongrass', 'paprika', 'saffron'],  # C\n    ['fenugreek', 'ginger', 'lemongrass', 'saffron', 'turmeric'], # D\n    ['fenugreek', 'lemongrass', 'nutmeg', 'paprika', 'saffron']   # E\n]\n\nfor i, main_flavors in enumerate(options):\n    solver.push()\n    # Add constraints that the main dish flavors are exactly main_flavors\n    # So for each flavoring:\n    # if in main_flavors => appetizer[f] == False\n    # else => appetizer[f] == True\n    for f in flavorings:\n        if f in main_flavors:\n            solver.add(appetizer[f] == False)\n        else:\n            solver.add(appetizer[f] == True)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.\n\nWhich one of the following is an acceptable schedule for the evening's performers, from first through seventh?\n\nOptions:\n(A) Ken, Jamie, Maya, Lalitha, Patrick, Norton, Olive\n(B) Lalitha, Patrick, Norton, Olive, Maya, Ken, Jamie\n(C) Norton, Olive, Ken, Jamie, Maya, Patrick, Lalitha\n(D) Olive, Maya, Ken, Lalitha, Patrick, Norton, Jamie\n(E) Olive, Maya, Lalitha, Norton, Patrick, Ken, Jamie",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsingers = ['Jamie', 'Ken', 'Lalitha', 'Maya', 'Norton', 'Olive', 'Patrick']\npositions = {s: Int(s) for s in singers}\n\nsolver = Solver()\n\n# Each singer performs exactly once, positions from 1 to 7\nfor s in singers:\n    solver.add(And(positions[s] >= 1, positions[s] <= 7))\n\n# All positions are distinct\nsolver.add(Distinct([positions[s] for s in singers]))\n\n# CONSTRAINTS\n\n# 1. Jamie performs immediately after Ken.\nsolver.add(positions['Jamie'] == positions['Ken'] + 1)\n\n# 2. Patrick performs at some time after Maya.\nsolver.add(positions['Patrick'] > positions['Maya'])\n\n# 3. Lalitha performs third only if Norton performs fifth.\n# This is: If Lalitha is third then Norton is fifth.\nsolver.add(Implies(positions['Lalitha'] == 3, positions['Norton'] == 5))\n\n# 4. If Patrick does not perform second, he performs fifth.\nsolver.add(Or(positions['Patrick'] == 2, positions['Patrick'] == 5))\n\n# OPTION CHECKING\noptions = [\n    ['Ken', 'Jamie', 'Maya', 'Lalitha', 'Patrick', 'Norton', 'Olive'],  # A\n    ['Lalitha', 'Patrick', 'Norton', 'Olive', 'Maya', 'Ken', 'Jamie'],  # B\n    ['Norton', 'Olive', 'Ken', 'Jamie', 'Maya', 'Patrick', 'Lalitha'],  # C\n    ['Olive', 'Maya', 'Ken', 'Lalitha', 'Patrick', 'Norton', 'Jamie'],  # D\n    ['Olive', 'Maya', 'Lalitha', 'Norton', 'Patrick', 'Ken', 'Jamie']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this option: positions according to the list\n    for pos, singer in enumerate(option, start=1):\n        solver.add(positions[singer] == pos)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.\n\nIf Lalitha is scheduled for the third performance, which one of the following must be scheduled for the sixth performance?\n\nOptions:\n(A) Jamie\n(B) Ken\n(C) Norton\n(D) Olive\n(E) Patrick",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsingers = ['Jamie', 'Ken', 'Lalitha', 'Maya', 'Norton', 'Olive', 'Patrick']\npositions = list(range(1, 8))  # Positions 1 through 7\n\n# Create a Z3 Int variable for each singer representing their performance position\npos = {s: Int(s) for s in singers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each singer performs exactly once in a unique position between 1 and 7\nfor s in singers:\n    solver.add(And(pos[s] >= 1, pos[s] <= 7))\nsolver.add(Distinct([pos[s] for s in singers]))\n\n# Jamie performs immediately after Ken: Jamie's position = Ken's position + 1\nsolver.add(pos['Jamie'] == pos['Ken'] + 1)\n\n# Patrick performs at some time after Maya: Patrick's position > Maya's position\nsolver.add(pos['Patrick'] > pos['Maya'])\n\n# Lalitha performs third only if Norton performs fifth\n# This means: if Lalitha's position == 3 then Norton's position == 5\nsolver.add(Implies(pos['Lalitha'] == 3, pos['Norton'] == 5))\n\n# If Patrick does not perform second, he performs fifth\n# This means: (Patrick's position != 2) => (Patrick's position == 5)\nsolver.add(Implies(pos['Patrick'] != 2, pos['Patrick'] == 5))\n\n# OPTION CHECKING\n# We are told: Lalitha is scheduled for the third performance\nsolver.add(pos['Lalitha'] == 3)\n\n# We want to find who must be scheduled for the sixth performance\n# For each option, add constraint that that singer performs sixth and check satisfiability\n\noptions = ['Jamie', 'Ken', 'Norton', 'Olive', 'Patrick']\nfor i, s in enumerate(options):\n    solver.push()\n    solver.add(pos[s] == 6)\n    if solver.check() == sat:\n        # Check if for all models with Lalitha=3, that singer is at 6\n        # To confirm that this singer must be at 6, check if any model exists where Lalitha=3 and that singer != 6\n        solver.pop()\n        solver.push()\n        solver.add(pos['Lalitha'] == 3)\n        solver.add(pos[s] != 6)\n        if solver.check() == unsat:\n            # No model exists where Lalitha=3 and that singer !=6, so this singer must be at 6\n            print(f\"'{chr(65+i)}'\")\n            break\n        else:\n            solver.pop()\n    else:\n        solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.\n\nIf Norton is scheduled for the fifth performance, which one of the following could be true?\n\nOptions:\n(A) Jamie is scheduled for the sixth performance.\n(B) Ken is scheduled for the second performance.\n(C) Lalitha is scheduled for the fourth performance.\n(D) Maya is scheduled for the third performance.\n(E) Olive is scheduled for the first performance.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsingers = ['Jamie', 'Ken', 'Lalitha', 'Maya', 'Norton', 'Olive', 'Patrick']\nnum_singers = len(singers)\n\n# Create a dictionary mapping singer name to a Z3 Int variable representing their performance position (1 to 7)\npositions = {s: Int(s) for s in singers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each singer's position is between 1 and 7\nfor s in singers:\n    solver.add(And(positions[s] >= 1, positions[s] <= 7))\n\n# All positions are distinct\nsolver.add(Distinct([positions[s] for s in singers]))\n\n# Jamie performs immediately after Ken: Jamie = Ken + 1\nsolver.add(positions['Jamie'] == positions['Ken'] + 1)\n\n# Patrick performs at some time after Maya: Patrick > Maya\nsolver.add(positions['Patrick'] > positions['Maya'])\n\n# Lalitha performs third only if Norton performs fifth:\n# (Lalitha == 3) => (Norton == 5)\nsolver.add(Implies(positions['Lalitha'] == 3, positions['Norton'] == 5))\n\n# If Patrick does not perform second, he performs fifth:\n# (Patrick != 2) => (Patrick == 5)\nsolver.add(Implies(positions['Patrick'] != 2, positions['Patrick'] == 5))\n\n# Given: Norton is scheduled for the fifth performance\nsolver.add(positions['Norton'] == 5)\n\n# OPTION CHECKING\n\noptions = {\n    'A': positions['Jamie'] == 6,\n    'B': positions['Ken'] == 2,\n    'C': positions['Lalitha'] == 4,\n    'D': positions['Maya'] == 3,\n    'E': positions['Olive'] == 1,\n}\n\nfor option_letter, option_constraint in options.items():\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.\n\nIf Maya is scheduled for the second performance, which one of the following could be true?\n\nOptions:\n(A) Jamie is scheduled for the sixth performance.\n(B) Ken is scheduled for the fourth performance.\n(C) Lalitha is scheduled for the third performance.\n(D) Norton is scheduled for the fifth performance.\n(E) Olive is scheduled for the fourth performance.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsingers = ['Jamie', 'Ken', 'Lalitha', 'Maya', 'Norton', 'Olive', 'Patrick']\npositions = range(1, 8)  # Performance positions 1 through 7\n\n# Create a dictionary mapping each singer to a Z3 Int variable representing their performance position\npos = {s: Int(s) for s in singers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each singer must have a position from 1 to 7\nfor s in singers:\n    solver.add(And(pos[s] >= 1, pos[s] <= 7))\n\n# All positions must be distinct (no two singers perform at the same time)\nsolver.add(Distinct([pos[s] for s in singers]))\n\n# Jamie performs immediately after Ken: Jamie's position = Ken's position + 1\nsolver.add(pos['Jamie'] == pos['Ken'] + 1)\n\n# Patrick performs at some time after Maya: Patrick's position > Maya's position\nsolver.add(pos['Patrick'] > pos['Maya'])\n\n# Lalitha performs third only if Norton performs fifth:\n# If Lalitha is 3rd then Norton is 5th\nsolver.add(Implies(pos['Lalitha'] == 3, pos['Norton'] == 5))\n\n# If Patrick does not perform second, he performs fifth:\n# (Patrick != 2) => (Patrick == 5)\nsolver.add(Implies(pos['Patrick'] != 2, pos['Patrick'] == 5))\n\n# Additional given condition: Maya is scheduled for the second performance\nsolver.add(pos['Maya'] == 2)\n\n# OPTION CHECKING\noptions = {\n    'A': pos['Jamie'] == 6,\n    'B': pos['Ken'] == 4,\n    'C': pos['Lalitha'] == 3,\n    'D': pos['Norton'] == 5,\n    'E': pos['Olive'] == 4,\n}\n\nfor opt_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[opt_letter])\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Seven singers—Jamie, Ken, Lalitha, Maya, Norton, Olive, and Patrick—will be scheduled to perform in the finals of a singing competition. During the evening of the competition, each singer, performing alone, will give exactly one performance. The schedule for the evening must conform to the following requirements: Jamie performs immediately after Ken. Patrick performs at some time after Maya. Lalitha performs third only if Norton performs fifth. If Patrick does not perform second, he performs fifth.\n\nIf Jamie's performance is scheduled to be immediately before Lalitha's performance, Jamie's performance CANNOT be scheduled to be\n\nOptions:\n(A) second\n(B) third\n(C) fourth\n(D) fifth\n(E) sixth",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsingers = ['Jamie', 'Ken', 'Lalitha', 'Maya', 'Norton', 'Olive', 'Patrick']\npositions = range(1, 8)  # Positions 1 through 7\n\n# Create position variables for each singer\npos = {s: Int(s) for s in singers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each position is between 1 and 7\nfor s in singers:\n    solver.add(And(pos[s] >= 1, pos[s] <= 7))\n\n# All positions are distinct\nsolver.add(Distinct([pos[s] for s in singers]))\n\n# Jamie performs immediately after Ken: Jamie's position = Ken's position + 1\nsolver.add(pos['Jamie'] == pos['Ken'] + 1)\n\n# Patrick performs at some time after Maya: Patrick's position > Maya's position\nsolver.add(pos['Patrick'] > pos['Maya'])\n\n# Lalitha performs third only if Norton performs fifth\n# (pos[Lalitha] == 3) => (pos[Norton] == 5)\nsolver.add(Implies(pos['Lalitha'] == 3, pos['Norton'] == 5))\n\n# If Patrick does not perform second, he performs fifth\n# (pos[Patrick] != 2) => (pos[Patrick] == 5)\nsolver.add(Implies(pos['Patrick'] != 2, pos['Patrick'] == 5))\n\n# OPTION CHECKING\n\noptions_letters = ['A', 'B', 'C', 'D', 'E']\noptions_positions = [2, 3, 4, 5, 6]\n\nfor i, candidate_pos in enumerate(options_positions):\n    solver.push()\n    # Add constraint that Jamie's performance is immediately before Lalitha's\n    # So pos['Jamie'] + 1 == pos['Lalitha']\n    solver.add(pos['Jamie'] + 1 == pos['Lalitha'])\n    # Add constraint that Jamie's position is candidate_pos\n    solver.add(pos['Jamie'] == candidate_pos)\n    # Check if the constraints are satisfiable\n    if solver.check() == unsat:\n        print(f\"'{options_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "At a small press, six textbooks, three introductory—F, G, and H—and three advanced—X, Y, and Z—will each be evaluated once by the editor, Juarez, and once by the publisher, Rosenberg, during six consecutive weeks—week 1 through week 6. Each evaluator evaluates exactly one textbook per week. No textbook will be evaluated by Juarez and Rosenberg during the same week. The following additional constraints apply: Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook. Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook. Rosenberg cannot evaluate any two introductory textbooks consecutively. Juarez must evaluate X during week 4.\n\nWhich one of the following is an acceptable evaluation schedule, with the textbooks listed in order of evaluation from week 1 through week 6?\n\nOptions:\n(A) Juarez: F, G, X, Z, H, Y Rosenberg: X, F, Z, G, Y, H\n(B) Juarez: F, Y, G, X, H, Z Rosenberg Y, F, X, G, Z, H\n(C) Juarez: G, H, F, X, Y, Z Rosenberg: X, G, H, Y, Z, F\n(D) Juarez: G, Z, F, X, H, Y Rosenberg: Z, F, X, G, Y, H\n(E) Juarez: H, Y, F, X, G, Z Rosenberg: X, H, Z, F, Y, G",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Textbooks\nintro_books = ['F', 'G', 'H']\nadv_books = ['X', 'Y', 'Z']\nall_books = intro_books + adv_books\nbook_indices = {b: i for i, b in enumerate(all_books)}\n\n# Weeks\nweeks = range(6)  # 0-based for convenience, corresponds to weeks 1-6\n\n# Evaluators\nevaluators = ['Juarez', 'Rosenberg']\n\n# For each evaluator and week, we create an Int variable representing the textbook evaluated\nJuarez = [Int(f'J_{w}') for w in weeks]\nRosenberg = [Int(f'R_{w}') for w in weeks]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each evaluator evaluates exactly one textbook per week (value in valid range)\nfor w in weeks:\n    solver.add(And(Juarez[w] >= 0, Juarez[w] < 6))\n    solver.add(And(Rosenberg[w] >= 0, Rosenberg[w] < 6))\n\n# 2. Each textbook is evaluated exactly once by Juarez and once by Rosenberg (no repeats)\n# So Juarez's evaluations are all distinct\nsolver.add(Distinct(Juarez))\n# Rosenberg's evaluations are all distinct\nsolver.add(Distinct(Rosenberg))\n\n# 3. No textbook is evaluated by Juarez and Rosenberg during the same week\nfor w in weeks:\n    solver.add(Juarez[w] != Rosenberg[w])\n\n# 4. Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook\n# For each intro book, Rosenberg's evaluation week must be strictly after Juarez's evaluation week\n# So we need to find the week where Juarez evaluates the book and the week where Rosenberg evaluates the book\n# We create helper functions to get these weeks\n\ndef eval_week(evals, book_idx):\n    # returns an Int variable representing the week when book_idx is evaluated in evals\n    # We'll create an Int variable and add constraints that it is equal to the index where evals[w] == book_idx\n    w_var = Int(f'week_{id(evals)}_{book_idx}')\n    # w_var in 0..5\n    solver.add(And(w_var >= 0, w_var < 6))\n    # Exactly one week w where evals[w] == book_idx\n    solver.add(Or([evals[w] == book_idx for w in weeks]))\n    # For all weeks w, if evals[w] == book_idx then w_var == w\n    for w in weeks:\n        solver.add(Implies(evals[w] == book_idx, w_var == w))\n    return w_var\n\n# For each book, get Juarez and Rosenberg evaluation weeks\nJuarez_weeks = {}\nRosenberg_weeks = {}\nfor b in all_books:\n    idx = book_indices[b]\n    Juarez_weeks[b] = eval_week(Juarez, idx)\n    Rosenberg_weeks[b] = eval_week(Rosenberg, idx)\n\n# Rosenberg cannot evaluate any intro book until Juarez has evaluated that book\nfor b in intro_books:\n    solver.add(Rosenberg_weeks[b] > Juarez_weeks[b])\n\n# Juarez cannot evaluate any advanced book until Rosenberg has evaluated that book\nfor b in adv_books:\n    solver.add(Juarez_weeks[b] > Rosenberg_weeks[b])\n\n# Rosenberg cannot evaluate two introductory textbooks consecutively\nfor w in range(5):  # weeks 0-4 check with next week\n    # If Rosenberg[w] and Rosenberg[w+1] are both intro books, forbidden\n    # Create Bool for each\n    is_intro_w = Or([Rosenberg[w] == book_indices[b] for b in intro_books])\n    is_intro_w1 = Or([Rosenberg[w+1] == book_indices[b] for b in intro_books])\n    solver.add(Not(And(is_intro_w, is_intro_w1)))\n\n# Juarez must evaluate X during week 4 (week index 3)\nsolver.add(Juarez[3] == book_indices['X'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': {\n        'Juarez': ['F', 'G', 'X', 'Z', 'H', 'Y'],\n        'Rosenberg': ['X', 'F', 'Z', 'G', 'Y', 'H']\n    },\n    'B': {\n        'Juarez': ['F', 'Y', 'G', 'X', 'H', 'Z'],\n        'Rosenberg': ['Y', 'F', 'X', 'G', 'Z', 'H']\n    },\n    'C': {\n        'Juarez': ['G', 'H', 'F', 'X', 'Y', 'Z'],\n        'Rosenberg': ['X', 'G', 'H', 'Y', 'Z', 'F']\n    },\n    'D': {\n        'Juarez': ['G', 'Z', 'F', 'X', 'H', 'Y'],\n        'Rosenberg': ['Z', 'F', 'X', 'G', 'Y', 'H']\n    },\n    'E': {\n        'Juarez': ['H', 'Y', 'F', 'X', 'G', 'Z'],\n        'Rosenberg': ['X', 'H', 'Z', 'F', 'Y', 'G']\n    }\n}\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add constraints for the option schedule\n    # Juarez assignments\n    for w in weeks:\n        solver.add(Juarez[w] == book_indices[options[opt]['Juarez'][w]])\n    # Rosenberg assignments\n    for w in weeks:\n        solver.add(Rosenberg[w] == book_indices[options[opt]['Rosenberg'][w]])\n    if solver.check() == sat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "At a small press, six textbooks, three introductory—F, G, and H—and three advanced—X, Y, and Z—will each be evaluated once by the editor, Juarez, and once by the publisher, Rosenberg, during six consecutive weeks—week 1 through week 6. Each evaluator evaluates exactly one textbook per week. No textbook will be evaluated by Juarez and Rosenberg during the same week. The following additional constraints apply: Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook. Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook. Rosenberg cannot evaluate any two introductory textbooks consecutively. Juarez must evaluate X during week 4.\n\nIf Juarez evaluates H during week 3 and Rosenberg evaluates G during week 6, which one of the following must be true?\n\nOptions:\n(A) Juarez evaluates F during week 1.\n(B) Juarez evaluates G during week 2.\n(C) Juarez evaluates Z during week 6.\n(D) Rosenberg evaluates X during week 1.\n(E) Rosenberg evaluates Y during week 5.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Textbooks\nintro = ['F', 'G', 'H']\nadv = ['X', 'Y', 'Z']\nall_books = intro + adv\n\n# Evaluators\nevaluators = ['Juarez', 'Rosenberg']\n\n# Weeks 1 to 6\nweeks = list(range(1, 7))\n\n# Create variables: For each evaluator and week, which book is evaluated\n# Variables will hold integers representing indices in all_books\nJ = {w: Int(f'J_{w}') for w in weeks}\nR = {w: Int(f'R_{w}') for w in weeks}\n\n# Map book name to index\nbook_idx = {b: i for i, b in enumerate(all_books)}\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each evaluation variable must be a valid book index\nfor w in weeks:\n    solver.add(And(J[w] >= 0, J[w] < len(all_books)))\n    solver.add(And(R[w] >= 0, R[w] < len(all_books)))\n\n# Each book is evaluated exactly once by Juarez and once by Rosenberg across the 6 weeks\n# So J's evaluations are distinct (one each week, no repeats)\nsolver.add(Distinct([J[w] for w in weeks]))\nsolver.add(Distinct([R[w] for w in weeks]))\n\n# No textbook will be evaluated by Juarez and Rosenberg during the same week\nfor w in weeks:\n    solver.add(J[w] != R[w])\n\n# Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook\n# For each intro book b, Rosenberg's week of evaluation must be after Juarez's week of evaluation\nfor b in intro:\n    b_i = book_idx[b]\n    # Find weeks where Juarez evaluates b and Rosenberg evaluates b\n    J_week = Int(f'Jw_{b}')\n    R_week = Int(f'Rw_{b}')\n    # J_week is the week where J evaluates b\n    solver.add(Or([J[w] == b_i for w in weeks]))\n    solver.add(Or([R[w] == b_i for w in weeks]))\n    # Define J_week and R_week as the weeks where they evaluate b\n    solver.add(Sum([If(J[w] == b_i, 1, 0) for w in weeks]) == 1)\n    solver.add(Sum([If(R[w] == b_i, 1, 0) for w in weeks]) == 1)\n    solver.add(Sum([If(J[w] == b_i, w, 0) for w in weeks]) == J_week)\n    solver.add(Sum([If(R[w] == b_i, w, 0) for w in weeks]) == R_week)\n    # Rosenberg's week > Juarez's week for intro books\n    solver.add(R_week > J_week)\n\n# Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook\nfor b in adv:\n    b_i = book_idx[b]\n    J_week = Int(f'Jw_{b}')\n    R_week = Int(f'Rw_{b}')\n    solver.add(Or([J[w] == b_i for w in weeks]))\n    solver.add(Or([R[w] == b_i for w in weeks]))\n    solver.add(Sum([If(J[w] == b_i, 1, 0) for w in weeks]) == 1)\n    solver.add(Sum([If(R[w] == b_i, 1, 0) for w in weeks]) == 1)\n    solver.add(Sum([If(J[w] == b_i, w, 0) for w in weeks]) == J_week)\n    solver.add(Sum([If(R[w] == b_i, w, 0) for w in weeks]) == R_week)\n    # Juarez's week > Rosenberg's week for advanced books\n    solver.add(J_week > R_week)\n\n# Rosenberg cannot evaluate any two introductory textbooks consecutively\n# For each pair of consecutive weeks, at most one intro book evaluated by Rosenberg\nfor w in weeks[:-1]:\n    is_intro_w = Or([R[w] == book_idx[b] for b in intro])\n    is_intro_w1 = Or([R[w+1] == book_idx[b] for b in intro])\n    # Not both consecutive weeks intro\n    solver.add(Not(And(is_intro_w, is_intro_w1)))\n\n# Juarez must evaluate X during week 4\nsolver.add(J[4] == book_idx['X'])\n\n# Additional given conditions:\n# Juarez evaluates H during week 3\nsolver.add(J[3] == book_idx['H'])\n\n# Rosenberg evaluates G during week 6\nsolver.add(R[6] == book_idx['G'])\n\n# OPTION CHECKING\n\n# Define a function to check if the model satisfies an option constraint\ndef check_option(option_constraints):\n    solver.push()\n    for c in option_constraints:\n        solver.add(c)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# Options:\n\n# (A) Juarez evaluates F during week 1.\noptA = [J[1] == book_idx['F']]\n\n# (B) Juarez evaluates G during week 2.\noptB = [J[2] == book_idx['G']]\n\n# (C) Juarez evaluates Z during week 6.\noptC = [J[6] == book_idx['Z']]\n\n# (D) Rosenberg evaluates X during week 1.\noptD = [R[1] == book_idx['X']]\n\n# (E) Rosenberg evaluates Y during week 5.\noptE = [R[5] == book_idx['Y']]\n\noptions = [optA, optB, optC, optD, optE]\n\n# Since only one option is correct, we check which one must be true.\n# For each option, check if the negation is possible.\n# If negation is impossible, then option must be true.\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add negation of the option constraint(s)\n    neg_opt = [Not(c) for c in opt]\n    solver.add(neg_opt)\n    if solver.check() == unsat:\n        # Negation impossible => option must be true\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "At a small press, six textbooks, three introductory—F, G, and H—and three advanced—X, Y, and Z—will each be evaluated once by the editor, Juarez, and once by the publisher, Rosenberg, during six consecutive weeks—week 1 through week 6. Each evaluator evaluates exactly one textbook per week. No textbook will be evaluated by Juarez and Rosenberg during the same week. The following additional constraints apply: Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook. Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook. Rosenberg cannot evaluate any two introductory textbooks consecutively. Juarez must evaluate X during week 4.\n\nIf Juarez evaluates Z during week 2, then Rosenberg must evaluate which one of the following textbooks during week 5?\n\nOptions:\n(A) F\n(B) H\n(C) X\n(D) Y\n(E) Z",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nintro_textbooks = ['F', 'G', 'H']\nadv_textbooks = ['X', 'Y', 'Z']\nall_textbooks = intro_textbooks + adv_textbooks\n\nweeks = range(1, 7)\n\n# Create integer variables for each evaluator and week representing the textbook index\n# Juarez_eval[w] = textbook index evaluated by Juarez in week w\n# Rosenberg_eval[w] = textbook index evaluated by Rosenberg in week w\n\nJuarez_eval = {}\nRosenberg_eval = {}\nfor w in weeks:\n    Juarez_eval[w] = Int(f'Juarez_{w}')\n    Rosenberg_eval[w] = Int(f'Rosenberg_{w}')\n\n# Helper dictionaries for quick lookup\nintro_indices = [all_textbooks.index(t) for t in intro_textbooks]\nadv_indices = [all_textbooks.index(t) for t in adv_textbooks]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each evaluation variable must be a valid textbook index\nfor w in weeks:\n    solver.add(And(Juarez_eval[w] >= 0, Juarez_eval[w] < 6))\n    solver.add(And(Rosenberg_eval[w] >= 0, Rosenberg_eval[w] < 6))\n\n# Each evaluator evaluates each textbook exactly once over 6 weeks\nsolver.add(Distinct([Juarez_eval[w] for w in weeks]))\nsolver.add(Distinct([Rosenberg_eval[w] for w in weeks]))\n\n# No textbook is evaluated by both Juarez and Rosenberg in the same week\nfor w in weeks:\n    solver.add(Juarez_eval[w] != Rosenberg_eval[w])\n\n# Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook\n# For each introductory textbook t:\n# If Rosenberg evaluates t at week r_w, then Juarez must have evaluated t at some week j_w < r_w\nfor t in intro_indices:\n    for r_w in weeks:\n        ros_eval_t = Rosenberg_eval[r_w] == t\n        # Juarez evaluated t before r_w: Or over j_w in weeks where j_w < r_w\n        juarez_before = Or([Juarez_eval[j_w] == t for j_w in weeks if j_w < r_w])\n        # Constraint: ros_eval_t -> juarez_before\n        solver.add(Implies(ros_eval_t, juarez_before))\n\n# Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook\n# For each advanced textbook t:\n# If Juarez evaluates t at week j_w, then Rosenberg must have evaluated t at some week r_w < j_w\nfor t in adv_indices:\n    for j_w in weeks:\n        juarez_eval_t = Juarez_eval[j_w] == t\n        ros_before = Or([Rosenberg_eval[r_w] == t for r_w in weeks if r_w < j_w])\n        solver.add(Implies(juarez_eval_t, ros_before))\n\n# Rosenberg cannot evaluate any two introductory textbooks consecutively\nfor w in range(1, 6):\n    ros_curr_intro = Or([Rosenberg_eval[w] == t for t in intro_indices])\n    ros_next_intro = Or([Rosenberg_eval[w+1] == t for t in intro_indices])\n    # Not both consecutive weeks are intro textbooks\n    solver.add(Not(And(ros_curr_intro, ros_next_intro)))\n\n# Juarez must evaluate X during week 4\nsolver.add(Juarez_eval[4] == all_textbooks.index('X'))\n\n# Condition: Juarez evaluates Z during week 2\nsolver.add(Juarez_eval[2] == all_textbooks.index('Z'))\n\n# OPTION CHECKING\noptions = ['F', 'H', 'X', 'Y', 'Z']\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Rosenberg evaluates option textbook during week 5\n    solver.add(Rosenberg_eval[5] == all_textbooks.index(option))\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "At a small press, six textbooks, three introductory—F, G, and H—and three advanced—X, Y, and Z—will each be evaluated once by the editor, Juarez, and once by the publisher, Rosenberg, during six consecutive weeks—week 1 through week 6. Each evaluator evaluates exactly one textbook per week. No textbook will be evaluated by Juarez and Rosenberg during the same week. The following additional constraints apply: Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook. Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook. Rosenberg cannot evaluate any two introductory textbooks consecutively. Juarez must evaluate X during week 4.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Rosenberg evaluates H during week 6.\n(B) Rosenberg evaluates an advanced textbook during week 3.\n(C) Juarez evaluates an advanced textbook during week 2.\n(D) Juarez evaluates Y before evaluating G.\n(E) Juarez does not evaluate any two introductory textbooks consecutively.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Textbooks\nintro_books = ['F', 'G', 'H']\nadv_books = ['X', 'Y', 'Z']\nall_books = intro_books + adv_books\n\n# Evaluators\nevaluators = ['Juarez', 'Rosenberg']\n\n# Weeks\nweeks = list(range(1, 7))\n\n# Create Z3 Int variables for each evaluator and week representing the index of the textbook evaluated\n# Values: 0 to 5 corresponding to all_books indices\nJuarez = [Int(f'J_{w}') for w in weeks]\nRosenberg = [Int(f'R_{w}') for w in weeks]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each evaluator evaluates exactly one textbook per week (variable domains)\nfor w in range(6):\n    solver.add(And(Juarez[w] >= 0, Juarez[w] < 6))\n    solver.add(And(Rosenberg[w] >= 0, Rosenberg[w] < 6))\n\n# 2. Each textbook evaluated exactly once by Juarez and once by Rosenberg during the 6 weeks\n# So each book appears exactly once in Juarez's schedule and once in Rosenberg's schedule\nsolver.add(Distinct(Juarez))\nsolver.add(Distinct(Rosenberg))\n\n# 3. No textbook evaluated by Juarez and Rosenberg in the same week\nfor w in range(6):\n    solver.add(Juarez[w] != Rosenberg[w])\n\n# 4. Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook\n# For each intro book, the week Rosenberg evaluates it must be after the week Juarez evaluates it\nfor book in intro_books:\n    b_idx = all_books.index(book)\n    # Find weeks for Juarez and Rosenberg evaluating the book\n    Juarez_week = Int(f'Jw_{book}')\n    Rosenberg_week = Int(f'Rw_{book}')\n    # Define Juarez_week and Rosenberg_week as the week indices where the book is evaluated\n    solver.add(Or([Juarez[w] == b_idx for w in range(6)]))\n    solver.add(Or([Rosenberg[w] == b_idx for w in range(6)]))\n    # Link Juarez_week and Rosenberg_week to actual weeks\n    solver.add(Sum([If(Juarez[w] == b_idx, w+1, 0) for w in range(6)]) == Juarez_week)\n    solver.add(Sum([If(Rosenberg[w] == b_idx, w+1, 0) for w in range(6)]) == Rosenberg_week)\n    # Rosenberg evaluates after Juarez\n    solver.add(Rosenberg_week > Juarez_week)\n\n# 5. Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook\n# For each advanced book, the week Juarez evaluates it must be after the week Rosenberg evaluates it\nfor book in adv_books:\n    b_idx = all_books.index(book)\n    Juarez_week = Int(f'Jw_{book}')\n    Rosenberg_week = Int(f'Rw_{book}')\n    solver.add(Or([Juarez[w] == b_idx for w in range(6)]))\n    solver.add(Or([Rosenberg[w] == b_idx for w in range(6)]))\n    solver.add(Sum([If(Juarez[w] == b_idx, w+1, 0) for w in range(6)]) == Juarez_week)\n    solver.add(Sum([If(Rosenberg[w] == b_idx, w+1, 0) for w in range(6)]) == Rosenberg_week)\n    solver.add(Juarez_week > Rosenberg_week)\n\n# 6. Rosenberg cannot evaluate any two introductory textbooks consecutively\n# For weeks 1 to 5, if Rosenberg evaluates an intro book in week w, then week w+1 cannot be an intro book\nfor w in range(5):\n    cond1 = Or([Rosenberg[w] == all_books.index(b) for b in intro_books])\n    cond2 = Or([Rosenberg[w+1] == all_books.index(b) for b in intro_books])\n    solver.add(Not(And(cond1, cond2)))\n\n# 7. Juarez must evaluate X during week 4\nsolver.add(Juarez[3] == all_books.index('X'))\n\n# OPTION CHECKING\n\noptions = {\n    'A': Rosenberg[5] == all_books.index('H'),\n    'B': Or([Or([Rosenberg[2] == all_books.index(b) for b in adv_books])]),\n    'C': Or([Or([Juarez[1] == all_books.index(b) for b in adv_books])]),\n    'D': None,  # Juarez evaluates Y before G\n    'E': None   # Juarez does not evaluate any two intro textbooks consecutively\n}\n\n# For option D: Juarez evaluates Y before G\n# Define weeks Juarez evaluates Y and G\nJw_Y = Int('Jw_Y')\nJw_G = Int('Jw_G')\nsolver.add(Or([Juarez[w] == all_books.index('Y') for w in range(6)]))\nsolver.add(Or([Juarez[w] == all_books.index('G') for w in range(6)]))\nsolver.add(Sum([If(Juarez[w] == all_books.index('Y'), w+1, 0) for w in range(6)]) == Jw_Y)\nsolver.add(Sum([If(Juarez[w] == all_books.index('G'), w+1, 0) for w in range(6)]) == Jw_G)\noptions['D'] = Jw_Y < Jw_G\n\n# For option E: Juarez does not evaluate any two introductory textbooks consecutively\n# For weeks 1 to 5, if Juarez evaluates an intro book in week w, then week w+1 cannot be an intro book\nintro_indices = [all_books.index(b) for b in intro_books]\nno_two_intro_consec = []\nfor w in range(5):\n    cond1 = Or([Juarez[w] == idx for idx in intro_indices])\n    cond2 = Or([Juarez[w+1] == idx for idx in intro_indices])\n    no_two_intro_consec.append(Not(And(cond1, cond2)))\noptions['E'] = And(no_two_intro_consec)\n\n# Check each option by adding it to the base constraints and checking satisfiability\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        # Check if the negation is unsat (must be true)\n        solver.pop()\n        solver.push()\n        solver.add(Not(options[letter]))\n        if solver.check() == unsat:\n            print(f\"'{letter}'\")\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "At a small press, six textbooks, three introductory—F, G, and H—and three advanced—X, Y, and Z—will each be evaluated once by the editor, Juarez, and once by the publisher, Rosenberg, during six consecutive weeks—week 1 through week 6. Each evaluator evaluates exactly one textbook per week. No textbook will be evaluated by Juarez and Rosenberg during the same week. The following additional constraints apply: Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook. Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook. Rosenberg cannot evaluate any two introductory textbooks consecutively. Juarez must evaluate X during week 4.\n\nIf Rosenberg evaluates X during week 1 and F during week 2, which one of the following could be true?\n\nOptions:\n(A) X is the third of the advanced textbooks to be evaluated by Juarez.\n(B) Y is the first of the advanced textbooks to be evaluated by Juarez.\n(C) Juarez does not evaluate any two introductory textbooks in a row.\n(D) Juarez evaluates G during week 5.\n(E) Juarez evaluates Z during week 6.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Textbooks\nintro_books = ['F', 'G', 'H']\nadv_books = ['X', 'Y', 'Z']\nall_books = intro_books + adv_books\n\n# Evaluators\nevaluators = ['Juarez', 'Rosenberg']\n\n# Weeks\nweeks = list(range(1, 7))\n\n# Map books to indices for Z3\nbook_idx = {b: i for i, b in enumerate(all_books)}\n\n# Create variables: For each evaluator and week, which book is evaluated (Int in [0..5])\nJ = [Int(f'J_{w}') for w in weeks]  # Juarez's book at week w\nR = [Int(f'R_{w}') for w in weeks]  # Rosenberg's book at week w\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each evaluator evaluates exactly one textbook per week (domain constraints)\nfor w in range(6):\n    solver.add(And(J[w] >= 0, J[w] < 6))\n    solver.add(And(R[w] >= 0, R[w] < 6))\n\n# 2) Each textbook is evaluated exactly twice: once by Juarez and once by Rosenberg\n# So each book appears once in J and once in R\nfor b in range(6):\n    # book b appears exactly once in J\n    solver.add(Sum([If(J[w] == b, 1, 0) for w in range(6)]) == 1)\n    # book b appears exactly once in R\n    solver.add(Sum([If(R[w] == b, 1, 0) for w in range(6)]) == 1)\n\n# 3) No textbook evaluated by Juarez and Rosenberg in the same week\nfor w in range(6):\n    solver.add(J[w] != R[w])\n\n# 4) Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook\n# For each intro book b, if Rosenberg evaluates b at week w_r, then Juarez evaluates b at some week w_j < w_r\nfor b in [book_idx[bk] for bk in intro_books]:\n    for w_r in range(6):\n        # If Rosenberg evaluates book b at week w_r\n        # Then Juarez must have evaluated it before w_r\n        cond = Implies(\n            R[w_r] == b,\n            Or([J[w_j] == b for w_j in range(w_r)])\n        )\n        solver.add(cond)\n\n# 5) Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook\n# For each adv book b, if Juarez evaluates b at week w_j, then Rosenberg evaluates b at some week w_r < w_j\nfor b in [book_idx[bk] for bk in adv_books]:\n    for w_j in range(6):\n        cond = Implies(\n            J[w_j] == b,\n            Or([R[w_r] == b for w_r in range(w_j)])\n        )\n        solver.add(cond)\n\n# 6) Rosenberg cannot evaluate any two introductory textbooks consecutively\nfor w in range(5):\n    cond = Implies(\n        And([R[w] >= 0, R[w] < 6, R[w+1] >= 0, R[w+1] < 6]),\n        Not(And(\n            Or([R[w] == book_idx[bk] for bk in intro_books]),\n            Or([R[w+1] == book_idx[bk] for bk in intro_books])\n        ))\n    )\n    solver.add(cond)\n\n# 7) Juarez must evaluate X during week 4 (week index 3)\nsolver.add(J[3] == book_idx['X'])\n\n# 8) Given: Rosenberg evaluates X during week 1 (index 0) and F during week 2 (index 1)\nsolver.add(R[0] == book_idx['X'])\nsolver.add(R[1] == book_idx['F'])\n\n# OPTION CHECKING\n\n# Define helper functions for options\n\ndef is_option_A():\n    # (A) X is the third of the advanced textbooks to be evaluated by Juarez.\n    # Find the weeks where Juarez evaluates advanced books\n    adv_positions = []\n    for w in range(6):\n        adv_positions.append(If(Or([J[w] == book_idx[bk] for bk in adv_books]), w+1, 0))\n    # Filter out zeros and get sorted weeks\n    adv_weeks = [If(Or([J[w] == book_idx[bk] for bk in adv_books]), w+1, 0) for w in range(6)]\n    # We want to find the order of X among the advanced books evaluated by Juarez\n    # So find weeks when Juarez evaluates advanced books and sort them\n    # Because Z3 does not support sorting directly, we will encode:\n    # X's week is the 3rd smallest among Juarez's advanced books weeks\n    # Let's collect weeks of advanced books by Juarez\n    adv_weeks_vars = [If(Or([J[w] == book_idx[bk] for bk in adv_books]), w+1, 0) for w in range(6)]\n    # Extract weeks for advanced books (non-zero)\n    adv_weeks_filtered = [adv_weeks_vars[w] for w in range(6)]\n    # Count how many advanced books evaluated by Juarez before X's week\n    x_week = Int('x_week')\n    solver.add(x_week == Sum([If(J[w] == book_idx['X'], w+1, 0) for w in range(6)]))\n    count_before = Sum([If(And(Or([J[w] == book_idx[bk] for bk in adv_books]), w+1 < x_week), 1, 0) for w in range(6)])\n    # X is the 3rd advanced book means count_before == 2\n    solver.push()\n    solver.add(count_before == 2)\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\ndef is_option_B():\n    # (B) Y is the first of the advanced textbooks to be evaluated by Juarez.\n    # Y's evaluation week is the earliest among Juarez's advanced textbooks\n    y_week = Int('y_week')\n    solver.add(y_week == Sum([If(J[w] == book_idx['Y'], w+1, 0) for w in range(6)]))\n    # For all advanced books b, Juarez evaluates Y earlier or equal\n    conds = []\n    for b in adv_books:\n        if b == 'Y':\n            continue\n        b_week = Sum([If(J[w] == book_idx[b], w+1, 0) for w in range(6)])\n        conds.append(y_week <= b_week)\n    solver.push()\n    solver.add(And(conds))\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\ndef is_option_C():\n    # (C) Juarez does not evaluate any two introductory textbooks in a row.\n    # For all weeks w in 1..5, not both J[w-1] and J[w] are intro books\n    no_two_intro = []\n    for w in range(1,6):\n        cond = Not(And(\n            Or([J[w-1] == book_idx[bk] for bk in intro_books]),\n            Or([J[w] == book_idx[bk] for bk in intro_books])\n        ))\n        no_two_intro.append(cond)\n    solver.push()\n    solver.add(And(no_two_intro))\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\ndef is_option_D():\n    # (D) Juarez evaluates G during week 5 (index 4)\n    solver.push()\n    solver.add(J[4] == book_idx['G'])\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\ndef is_option_E():\n    # (E) Juarez evaluates Z during week 6 (index 5)\n    solver.push()\n    solver.add(J[5] == book_idx['Z'])\n    res = solver.check()\n    solver.pop()\n    return res == sat\n\noptions = [is_option_A, is_option_B, is_option_C, is_option_D, is_option_E]\n\nfor i, option_func in enumerate(options):\n    if option_func():\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "At a small press, six textbooks, three introductory—F, G, and H—and three advanced—X, Y, and Z—will each be evaluated once by the editor, Juarez, and once by the publisher, Rosenberg, during six consecutive weeks—week 1 through week 6. Each evaluator evaluates exactly one textbook per week. No textbook will be evaluated by Juarez and Rosenberg during the same week. The following additional constraints apply: Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook. Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook. Rosenberg cannot evaluate any two introductory textbooks consecutively. Juarez must evaluate X during week 4.\n\nWhich one of the following is a complete and accurate list of those weeks during which Juarez must evaluate an introductory textbook?\n\nOptions:\n(A) week 1\n(B) week 6\n(C) week 1, week 5\n(D) week 1, week 2, week 3\n(E) week 1, week 3, week 5",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Textbooks\nintro_books = ['F', 'G', 'H']\nadv_books = ['X', 'Y', 'Z']\nall_books = intro_books + adv_books\n\n# Evaluators\nevaluators = ['Juarez', 'Rosenberg']\n\n# Weeks\nweeks = range(1, 7)\n\n# Create variables: for each evaluator and each week, which book is evaluated\n# Variables are integers representing indices in all_books list\nJuarez = [Int(f'J_{w}') for w in weeks]\nRosenberg = [Int(f'R_{w}') for w in weeks]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each evaluation variable must be valid book index\nfor w in weeks:\n    solver.add(And(Juarez[w-1] >= 0, Juarez[w-1] < len(all_books)))\n    solver.add(And(Rosenberg[w-1] >= 0, Rosenberg[w-1] < len(all_books)))\n\n# No textbook is evaluated by both evaluators in the same week\nfor w in weeks:\n    solver.add(Juarez[w-1] != Rosenberg[w-1])\n\n# Each textbook is evaluated exactly once by each evaluator over the 6 weeks\n# So the lists Juarez and Rosenberg are permutations of all_books\nsolver.add(Distinct(Juarez))\nsolver.add(Distinct(Rosenberg))\n\n# Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook\n# For each intro book, if Rosenberg evaluates it in week r_week,\n# then Juarez must have evaluated it in some week j_week < r_week\nfor book in intro_books:\n    book_idx = all_books.index(book)\n    # For Rosenberg weeks where Rosenberg evaluates book, Juarez must have evaluated it earlier\n    # We create a condition for each week wR for Rosenberg evaluating book\n    # If Rosenberg[wR] == book_idx then Exists wJ < wR with Juarez[wJ] == book_idx\n    for r_week in weeks:\n        cond_ros = Rosenberg[r_week-1] == book_idx\n        # Juarez weeks less than r_week\n        juarez_earlier = [Juarez[w-1] == book_idx for w in range(1, r_week)]\n        # If Rosenberg evaluates book at r_week, Juarez must have evaluated it earlier\n        # If r_week == 1, no earlier week, so Rosenberg cannot evaluate book at week 1\n        if r_week == 1:\n            # Rosenberg cannot evaluate intro books at week 1\n            solver.add(Not(cond_ros))\n        else:\n            solver.add(Implies(cond_ros, Or(juarez_earlier)))\n\n# Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook\n# For each advanced book, if Juarez evaluates it in week j_week,\n# then Rosenberg must have evaluated it in some week r_week < j_week\nfor book in adv_books:\n    book_idx = all_books.index(book)\n    for j_week in weeks:\n        cond_jua = Juarez[j_week-1] == book_idx\n        rosenberg_earlier = [Rosenberg[w-1] == book_idx for w in range(1, j_week)]\n        if j_week == 1:\n            # Juarez cannot evaluate advanced books at week 1\n            solver.add(Not(cond_jua))\n        else:\n            solver.add(Implies(cond_jua, Or(rosenberg_earlier)))\n\n# Rosenberg cannot evaluate any two introductory textbooks consecutively\nfor w in range(1, 6):\n    r_curr = Rosenberg[w-1]\n    r_next = Rosenberg[w]\n    # Conditions for these being intro books\n    cond_curr_intro = Or([r_curr == all_books.index(b) for b in intro_books])\n    cond_next_intro = Or([r_next == all_books.index(b) for b in intro_books])\n    # Not both intro consecutively\n    solver.add(Not(And(cond_curr_intro, cond_next_intro)))\n\n# Juarez must evaluate X during week 4\nsolver.add(Juarez[3] == all_books.index('X'))\n\n# OPTION CHECKING\n\n# We want to find the weeks during which Juarez must evaluate an introductory textbook\n# For each week, check if Juarez must evaluate intro book in that week\n\n# For each week, check if Juarez can evaluate an advanced book in that week (i.e. not forced intro)\n# If Juarez can evaluate an advanced book in that week, then intro is not forced in that week\n# Otherwise, intro is forced in that week\n\nforced_intro_weeks = []\n\nfor w in weeks:\n    solver.push()\n    # Add constraint: Juarez evaluates advanced book in week w\n    adv_book_indices = [all_books.index(b) for b in adv_books]\n    solver.add(Or([Juarez[w-1] == idx for idx in adv_book_indices]))\n    if solver.check() == sat:\n        # Juarez can evaluate advanced book in week w, so intro not forced\n        pass\n    else:\n        # Juarez must evaluate intro book in week w\n        forced_intro_weeks.append(w)\n    solver.pop()\n\n# Now check which option matches forced_intro_weeks\n\noptions = {\n    'A': [1],\n    'B': [6],\n    'C': [1, 5],\n    'D': [1, 2, 3],\n    'E': [1, 3, 5]\n}\n\nfor letter, weeks_list in options.items():\n    if forced_intro_weeks == weeks_list:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "At a small press, six textbooks, three introductory—F, G, and H—and three advanced—X, Y, and Z—will each be evaluated once by the editor, Juarez, and once by the publisher, Rosenberg, during six consecutive weeks—week 1 through week 6. Each evaluator evaluates exactly one textbook per week. No textbook will be evaluated by Juarez and Rosenberg during the same week. The following additional constraints apply: Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook. Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook. Rosenberg cannot evaluate any two introductory textbooks consecutively. Juarez must evaluate X during week 4.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Juarez evaluates F during week 6.\n(B) Juarez evaluates Z during week 1.\n(C) Rosenberg evaluates F during week 3.\n(D) Rosenberg evaluates H during week 2.\n(E) Rosenberg evaluates X during week 5.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nintro_textbooks = ['F', 'G', 'H']\nadv_textbooks = ['X', 'Y', 'Z']\nall_textbooks = intro_textbooks + adv_textbooks\nevaluators = ['Juarez', 'Rosenberg']\nweeks = range(1, 7)\n\n# Create variables:\n# For each evaluator and each week, which textbook is evaluated (index)\nJuarez_eval = [Int(f'J_week_{w}') for w in weeks]\nRosenberg_eval = [Int(f'R_week_{w}') for w in weeks]\n\n# Map textbooks to indices\ntextbook_indices = {tb: i for i, tb in enumerate(all_textbooks)}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each evaluation is a valid textbook index\nfor w in range(6):\n    solver.add(And(Juarez_eval[w] >= 0, Juarez_eval[w] < 6))\n    solver.add(And(Rosenberg_eval[w] >= 0, Rosenberg_eval[w] < 6))\n\n# Each textbook is evaluated exactly once by Juarez and once by Rosenberg\n# So Juarez_eval is a permutation of all textbooks\nsolver.add(Distinct(Juarez_eval))\nsolver.add(Distinct(Rosenberg_eval))\n\n# No textbook evaluated by Juarez and Rosenberg in the same week\nfor w in range(6):\n    solver.add(Juarez_eval[w] != Rosenberg_eval[w])\n\n# Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook.\n# For each intro textbook t, Rosenberg's week of evaluation > Juarez's week of evaluation\nfor t in intro_textbooks:\n    t_idx = textbook_indices[t]\n    # Find weeks Rosenberg evaluates t\n    # Find weeks Juarez evaluates t\n    # We can express as:\n    # week_R = the week where Rosenberg_eval[w] == t_idx\n    # week_J = the week where Juarez_eval[w] == t_idx\n    # week_R > week_J\n    # We use integer variables to represent weeks for each evaluator for each textbook\n    pass\n\n# Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook.\n# For each advanced textbook t, Juarez's week of evaluation > Rosenberg's week of evaluation\n# Similar to above\n\n# We introduce helper variables for evaluation weeks per textbook and evaluator\nJ_week_of = [Int(f'J_week_of_{tb}') for tb in all_textbooks]\nR_week_of = [Int(f'R_week_of_{tb}') for tb in all_textbooks]\n\nfor i in range(6):\n    # J_week_of[i] is the week Juarez evaluates textbook i, 1-based\n    solver.add(And(J_week_of[i] >= 1, J_week_of[i] <= 6))\n    solver.add(And(R_week_of[i] >= 1, R_week_of[i] <= 6))\n\n# Link J_week_of and Juarez_eval\nfor w in range(6):\n    # Juarez_eval[w] == i <=> J_week_of[i] == w+1\n    for i in range(6):\n        # If Juarez_eval[w] == i then J_week_of[i] == w+1\n        solver.add(Implies(Juarez_eval[w] == i, J_week_of[i] == w+1))\n        # If J_week_of[i] == w+1 then Juarez_eval[w] == i\n        solver.add(Implies(J_week_of[i] == w+1, Juarez_eval[w] == i))\n\n# Link R_week_of and Rosenberg_eval\nfor w in range(6):\n    for i in range(6):\n        solver.add(Implies(Rosenberg_eval[w] == i, R_week_of[i] == w+1))\n        solver.add(Implies(R_week_of[i] == w+1, Rosenberg_eval[w] == i))\n\n# Rosenberg cannot evaluate any introductory textbook until Juarez has evaluated that textbook.\nfor t in intro_textbooks:\n    idx = textbook_indices[t]\n    solver.add(R_week_of[idx] > J_week_of[idx])\n\n# Juarez cannot evaluate any advanced textbook until Rosenberg has evaluated that textbook.\nfor t in adv_textbooks:\n    idx = textbook_indices[t]\n    solver.add(J_week_of[idx] > R_week_of[idx])\n\n# Rosenberg cannot evaluate any two introductory textbooks consecutively.\n# For weeks 1 to 5, if Rosenberg evaluates an intro textbook in week w, then week w+1 cannot be intro\nfor w in range(5):\n    cond_w_intro = Or([Rosenberg_eval[w] == textbook_indices[t] for t in intro_textbooks])\n    cond_w1_intro = Or([Rosenberg_eval[w+1] == textbook_indices[t] for t in intro_textbooks])\n    solver.add(Implies(cond_w_intro, Not(cond_w1_intro)))\n\n# Juarez must evaluate X during week 4.\nsolver.add(Juarez_eval[3] == textbook_indices['X'])  # week 4 is index 3\n\n# OPTION CHECKING\noptions = [\n    ('A', Juarez_eval[5] == textbook_indices['F']),  # Juarez evaluates F during week 6 (index 5)\n    ('B', Juarez_eval[0] == textbook_indices['Z']),  # Juarez evaluates Z during week 1 (index 0)\n    ('C', Rosenberg_eval[2] == textbook_indices['F']),  # Rosenberg evaluates F during week 3 (index 2)\n    ('D', Rosenberg_eval[1] == textbook_indices['H']),  # Rosenberg evaluates H during week 2 (index 1)\n    ('E', Rosenberg_eval[4] == textbook_indices['X']),  # Rosenberg evaluates X during week 5 (index 4)\n]\n\nfor letter, option_constraint in options:\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Nine different treatments are available for a certain illness: three antibiotics—F, G, and H—three dietary regimens—M, N, and O—and three physical therapies—U, V, and W. For each case of the illness, a doctor will prescribe exactly five of the treatments, in accordance with the following conditions: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed. There must be exactly one dietary regimen prescribed. If O is not prescribed, F cannot be prescribed. If W is prescribed, F cannot be prescribed. G cannot be prescribed if both N and U are prescribed. V cannot be prescribed unless both H and M are prescribed.\n\nWhich one of the following could be the five treatments prescribed for a given case?\n\nOptions:\n(A) F, G, H, M, V\n(B) F, G, M, O, V\n(C) F, H, M, O, W\n(D) G, H, N, U, W\n(E) G, H, O, U, W",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntreatments = ['F', 'G', 'H', 'M', 'N', 'O', 'U', 'V', 'W']\nindices = {t: i for i, t in enumerate(treatments)}\n\n# Create a Bool variable for each treatment indicating if it is prescribed\nprescribed = {t: Bool(t) for t in treatments}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly five treatments prescribed\nsolver.add(Sum([If(prescribed[t], 1, 0) for t in treatments]) == 5)\n\n# Antibiotics: F, G, H\nantibiotics = ['F', 'G', 'H']\n# Condition: If two antibiotics prescribed, the remaining antibiotic cannot be prescribed\n# This means you cannot have all three antibiotics prescribed at once\n# So number of antibiotics prescribed <= 2\nsolver.add(Sum([If(prescribed[a], 1, 0) for a in antibiotics]) <= 2)\n\n# Exactly one dietary regimen prescribed: M, N, O\ndietary = ['M', 'N', 'O']\nsolver.add(Sum([If(prescribed[d], 1, 0) for d in dietary]) == 1)\n\n# If O is not prescribed, F cannot be prescribed\nsolver.add(Implies(Not(prescribed['O']), Not(prescribed['F'])))\n\n# If W is prescribed, F cannot be prescribed\nsolver.add(Implies(prescribed['W'], Not(prescribed['F'])))\n\n# G cannot be prescribed if both N and U are prescribed\nsolver.add(Implies(And(prescribed['N'], prescribed['U']), Not(prescribed['G'])))\n\n# V cannot be prescribed unless both H and M are prescribed\nsolver.add(Implies(prescribed['V'], And(prescribed['H'], prescribed['M'])))\n\n# OPTION CHECKING\noptions = [\n    ['F', 'G', 'H', 'M', 'V'],  # A\n    ['F', 'G', 'M', 'O', 'V'],  # B\n    ['F', 'H', 'M', 'O', 'W'],  # C\n    ['G', 'H', 'N', 'U', 'W'],  # D\n    ['G', 'H', 'O', 'U', 'W'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that the prescribed treatments are exactly those in the option\n    # So treatments in option are True, others False\n    for t in treatments:\n        if t in option:\n            solver.add(prescribed[t] == True)\n        else:\n            solver.add(prescribed[t] == False)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Nine different treatments are available for a certain illness: three antibiotics—F, G, and H—three dietary regimens—M, N, and O—and three physical therapies—U, V, and W. For each case of the illness, a doctor will prescribe exactly five of the treatments, in accordance with the following conditions: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed. There must be exactly one dietary regimen prescribed. If O is not prescribed, F cannot be prescribed. If W is prescribed, F cannot be prescribed. G cannot be prescribed if both N and U are prescribed. V cannot be prescribed unless both H and M are prescribed.\n\nWhich one of the following could be the antibiotics and physical therapies prescribed for a given case?\n\nOptions:\n(A) F, G, H, W\n(B) F, G, U, V\n(C) F, U, V, W\n(D) G, U, V, W\n(E) H, U, V, W",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Treatments categories\nantibiotics = ['F', 'G', 'H']\ndietary = ['M', 'N', 'O']\nphysical = ['U', 'V', 'W']\n\nall_treatments = antibiotics + dietary + physical\n\n# Create a dictionary of Bool variables for each treatment: True if prescribed, False otherwise\nprescribed = {t: Bool(t) for t in all_treatments}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly five treatments are prescribed\ntotal_prescribed = Sum([If(prescribed[t], 1, 0) for t in all_treatments])\nsolver.add(total_prescribed == 5)\n\n# If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed\n# In other words, the number of antibiotics prescribed cannot be 2 or 3\n# The condition states: If two antibiotics are prescribed, the remaining antibiotic cannot be prescribed\n# So total antibiotics prescribed can be 0,1 or 2 but not 3\n# But since \"If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed\"\n# That means at most two antibiotics can be prescribed.\n# But must be consistent with the condition \"If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed\"\n# This means the number of antibiotics prescribed can be 0,1 or 2 but not 3\n# So total antibiotics prescribed <= 2\nnum_antibiotics = Sum([If(prescribed[a], 1, 0) for a in antibiotics])\nsolver.add(num_antibiotics <= 2)\n\n# There must be exactly one dietary regimen prescribed\nnum_dietary = Sum([If(prescribed[d], 1, 0) for d in dietary])\nsolver.add(num_dietary == 1)\n\n# If O is not prescribed, F cannot be prescribed\nsolver.add(Implies(Not(prescribed['O']), Not(prescribed['F'])))\n\n# If W is prescribed, F cannot be prescribed\nsolver.add(Implies(prescribed['W'], Not(prescribed['F'])))\n\n# G cannot be prescribed if both N and U are prescribed\nsolver.add(Implies(And(prescribed['N'], prescribed['U']), Not(prescribed['G'])))\n\n# V cannot be prescribed unless both H and M are prescribed\nsolver.add(Implies(prescribed['V'], And(prescribed['H'], prescribed['M'])))\n\n# OPTION CHECKING\noptions = {\n    'A': ['F', 'G', 'H', 'W'],\n    'B': ['F', 'G', 'U', 'V'],\n    'C': ['F', 'U', 'V', 'W'],\n    'D': ['G', 'U', 'V', 'W'],\n    'E': ['H', 'U', 'V', 'W']\n}\n\nfor letter, treatments_list in options.items():\n    solver.push()\n    # Add constraints that antibiotics and physical therapies prescribed are exactly those in treatments_list\n    # So for antibiotics and physical therapies:\n    # All treatments in treatments_list that are antibiotics or physical must be prescribed\n    for t in antibiotics + physical:\n        if t in treatments_list:\n            solver.add(prescribed[t] == True)\n        else:\n            solver.add(prescribed[t] == False)\n    # Dietary regimen is not specified in the option, so no additional constraint here\n\n    # Check if model is satisfiable\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Nine different treatments are available for a certain illness: three antibiotics—F, G, and H—three dietary regimens—M, N, and O—and three physical therapies—U, V, and W. For each case of the illness, a doctor will prescribe exactly five of the treatments, in accordance with the following conditions: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed. There must be exactly one dietary regimen prescribed. If O is not prescribed, F cannot be prescribed. If W is prescribed, F cannot be prescribed. G cannot be prescribed if both N and U are prescribed. V cannot be prescribed unless both H and M are prescribed.\n\nIf O is prescribed for a given case, which one of the following is a pair of treatments both of which must also be prescribed for that case?\n\nOptions:\n(A) F, M\n(B) G, V\n(C) N, U\n(D) U, V\n(E) U, W",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Treatments categorized\nantibiotics = ['F', 'G', 'H']\ndietary = ['M', 'N', 'O']\nphysical = ['U', 'V', 'W']\nall_treatments = antibiotics + dietary + physical\n\n# Create Bool variables for each treatment indicating if prescribed\ntreatment_vars = {t: Bool(t) for t in all_treatments}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly five treatments prescribed\nsolver.add(Sum([If(treatment_vars[t], 1, 0) for t in all_treatments]) == 5)\n\n# If two antibiotics prescribed, the remaining antibiotic cannot be prescribed\n# So number of antibiotics prescribed is either 1 or 3 or 0? \n# But since exactly 5 total treatments, let's add the exact constraint:\n# The problem states: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed.\n# So the number of antibiotics prescribed cannot be 3 (all three), because if two are prescribed, the third cannot be prescribed.\n# So number of antibiotics prescribed can be 0, 1 or 2 but not 3.\n# But the statement says: if two antibiotics are prescribed, the third cannot be prescribed.\n# So all three antibiotics cannot be prescribed simultaneously.\n# So number of antibiotics prescribed ≤ 2\nsolver.add(Sum([If(treatment_vars[t], 1, 0) for t in antibiotics]) <= 2)\n\n# There must be exactly one dietary regimen prescribed\nsolver.add(Sum([If(treatment_vars[t], 1, 0) for t in dietary]) == 1)\n\n# If O is not prescribed, F cannot be prescribed\nsolver.add(Implies(Not(treatment_vars['O']), Not(treatment_vars['F'])))\n\n# If W is prescribed, F cannot be prescribed\nsolver.add(Implies(treatment_vars['W'], Not(treatment_vars['F'])))\n\n# G cannot be prescribed if both N and U are prescribed\nsolver.add(Implies(And(treatment_vars['N'], treatment_vars['U']), Not(treatment_vars['G'])))\n\n# V cannot be prescribed unless both H and M are prescribed\nsolver.add(Implies(treatment_vars['V'], And(treatment_vars['H'], treatment_vars['M'])))\n\n# OPTION CHECKING\n# The question: If O is prescribed, which pair of treatments both must be prescribed?\n# So we fix O prescribed and check each option's pair: if both treatments in the pair must be prescribed.\n\noptions = {\n    'A': ('F', 'M'),\n    'B': ('G', 'V'),\n    'C': ('N', 'U'),\n    'D': ('U', 'V'),\n    'E': ('U', 'W')\n}\n\n# Fix O prescribed\nsolver.add(treatment_vars['O'])\n\nfor letter, (t1, t2) in options.items():\n    solver.push()\n    # Add constraint that at least one of t1 or t2 is NOT prescribed (to test if both must be prescribed)\n    solver.add(Or(Not(treatment_vars[t1]), Not(treatment_vars[t2])))\n    # Check if model is still satisfiable\n    if solver.check() == unsat:\n        # If unsat, then both t1 and t2 must be prescribed\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Nine different treatments are available for a certain illness: three antibiotics—F, G, and H—three dietary regimens—M, N, and O—and three physical therapies—U, V, and W. For each case of the illness, a doctor will prescribe exactly five of the treatments, in accordance with the following conditions: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed. There must be exactly one dietary regimen prescribed. If O is not prescribed, F cannot be prescribed. If W is prescribed, F cannot be prescribed. G cannot be prescribed if both N and U are prescribed. V cannot be prescribed unless both H and M are prescribed.\n\nIf G is prescribed for a given case, which one of the following is a pair of treatments both of which could also be prescribed for that case?\n\nOptions:\n(A) F, M\n(B) F, N\n(C) N, V\n(D) O, V\n(E) V, W",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Treatments by category\nantibiotics = ['F', 'G', 'H']\ndietary = ['M', 'N', 'O']\nphysical = ['U', 'V', 'W']\nall_treatments = antibiotics + dietary + physical\n\n# Create a Bool variable for each treatment indicating whether it is prescribed\ntreatments = {t: Bool(t) for t in all_treatments}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly five treatments prescribed\nsolver.add(Sum([If(treatments[t], 1, 0) for t in all_treatments]) == 5)\n\n# If two antibiotics are prescribed, the remaining one cannot be prescribed\n# This means: cannot prescribe all three antibiotics at once\nsolver.add(Not(And(treatments['F'], treatments['G'], treatments['H'])))\n\n# There must be exactly one dietary regimen prescribed\nsolver.add(Sum([If(treatments[d], 1, 0) for d in dietary]) == 1)\n\n# If O is not prescribed, F cannot be prescribed\nsolver.add(Implies(Not(treatments['O']), Not(treatments['F'])))\n\n# If W is prescribed, F cannot be prescribed\nsolver.add(Implies(treatments['W'], Not(treatments['F'])))\n\n# G cannot be prescribed if both N and U are prescribed\nsolver.add(Implies(And(treatments['N'], treatments['U']), Not(treatments['G'])))\n\n# V cannot be prescribed unless both H and M are prescribed\nsolver.add(Implies(treatments['V'], And(treatments['H'], treatments['M'])))\n\n# G is prescribed (given condition)\nsolver.add(treatments['G'])\n\n# OPTION CHECKING\noptions = {\n    'A': ['F', 'M'],\n    'B': ['F', 'N'],\n    'C': ['N', 'V'],\n    'D': ['O', 'V'],\n    'E': ['V', 'W']\n}\n\nfor option_letter, pair in options.items():\n    solver.push()\n    # Both treatments in the pair are prescribed\n    solver.add(treatments[pair[0]])\n    solver.add(treatments[pair[1]])\n    if solver.check() == sat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Nine different treatments are available for a certain illness: three antibiotics—F, G, and H—three dietary regimens—M, N, and O—and three physical therapies—U, V, and W. For each case of the illness, a doctor will prescribe exactly five of the treatments, in accordance with the following conditions: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed. There must be exactly one dietary regimen prescribed. If O is not prescribed, F cannot be prescribed. If W is prescribed, F cannot be prescribed. G cannot be prescribed if both N and U are prescribed. V cannot be prescribed unless both H and M are prescribed.\n\nWhich one of the following is a list of three treatments that could be prescribed together for a given case?\n\nOptions:\n(A) F, M, U\n(B) F, O, W\n(C) G, N, V\n(D) G, V, W\n(E) H, N, V",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Treatments categories\nantibiotics = ['F', 'G', 'H']\ndietary = ['M', 'N', 'O']\nphysical = ['U', 'V', 'W']\nall_treatments = antibiotics + dietary + physical\n\n# Create a Bool variable for each treatment indicating if it is prescribed\ntreatment_vars = {t: Bool(t) for t in all_treatments}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly five treatments prescribed\nsolver.add(Sum([If(treatment_vars[t], 1, 0) for t in all_treatments]) == 5)\n\n# If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed\n# This means antibiotics prescribed count cannot be 3\nantibiotics_prescribed = [treatment_vars[t] for t in antibiotics]\nsolver.add(Sum([If(t, 1, 0) for t in antibiotics_prescribed]) != 3)\n\n# Exactly one dietary regimen prescribed\ndietary_prescribed = [treatment_vars[t] for t in dietary]\nsolver.add(Sum([If(t, 1, 0) for t in dietary_prescribed]) == 1)\n\n# If O is not prescribed, F cannot be prescribed\nsolver.add(Implies(Not(treatment_vars['O']), Not(treatment_vars['F'])))\n\n# If W is prescribed, F cannot be prescribed\nsolver.add(Implies(treatment_vars['W'], Not(treatment_vars['F'])))\n\n# G cannot be prescribed if both N and U are prescribed\nsolver.add(Implies(And(treatment_vars['N'], treatment_vars['U']), Not(treatment_vars['G'])))\n\n# V cannot be prescribed unless both H and M are prescribed\nsolver.add(Implies(treatment_vars['V'], And(treatment_vars['H'], treatment_vars['M'])))\n\n# OPTION CHECKING\noptions = [\n    ['F', 'M', 'U'],  # A\n    ['F', 'O', 'W'],  # B\n    ['G', 'N', 'V'],  # C\n    ['G', 'V', 'W'],  # D\n    ['H', 'N', 'V']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that the three treatments in option must be prescribed\n    for t in option:\n        solver.add(treatment_vars[t] == True)\n    # Check if there is a valid prescription including these three treatments\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Nine different treatments are available for a certain illness: three antibiotics—F, G, and H—three dietary regimens—M, N, and O—and three physical therapies—U, V, and W. For each case of the illness, a doctor will prescribe exactly five of the treatments, in accordance with the following conditions: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed. There must be exactly one dietary regimen prescribed. If O is not prescribed, F cannot be prescribed. If W is prescribed, F cannot be prescribed. G cannot be prescribed if both N and U are prescribed. V cannot be prescribed unless both H and M are prescribed.\n\nWhich one of the following treatments CANNOT be prescribed for any case?\n\nOptions:\n(A) G\n(B) M\n(C) N\n(D) U\n(E) W",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntreatments = ['F', 'G', 'H', 'M', 'N', 'O', 'U', 'V', 'W']\nindices = {t: i for i, t in enumerate(treatments)}\n\n# Create Bool variables for each treatment: True if prescribed, False otherwise\nprescribed = {t: Bool(t) for t in treatments}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly 5 treatments prescribed\nsolver.add(Sum([If(prescribed[t], 1, 0) for t in treatments]) == 5)\n\n# Condition 1: If two of the antibiotics are prescribed, the remaining antibiotic cannot be prescribed.\n# Antibiotics: F, G, H\n# This means at most 2 antibiotics can be prescribed\nantibiotics = ['F', 'G', 'H']\nsolver.add(Sum([If(prescribed[a], 1, 0) for a in antibiotics]) <= 2)\n\n# Condition 2: Exactly one dietary regimen prescribed\n# Dietary regimens: M, N, O\ndietary = ['M', 'N', 'O']\nsolver.add(Sum([If(prescribed[d], 1, 0) for d in dietary]) == 1)\n\n# Condition 3: If O is not prescribed, F cannot be prescribed.\nsolver.add(Implies(Not(prescribed['O']), Not(prescribed['F'])))\n\n# Condition 4: If W is prescribed, F cannot be prescribed.\nsolver.add(Implies(prescribed['W'], Not(prescribed['F'])))\n\n# Condition 5: G cannot be prescribed if both N and U are prescribed.\nsolver.add(Implies(And(prescribed['N'], prescribed['U']), Not(prescribed['G'])))\n\n# Condition 6: V cannot be prescribed unless both H and M are prescribed.\nsolver.add(Implies(prescribed['V'], And(prescribed['H'], prescribed['M'])))\n\n# OPTION CHECKING\noptions = ['G', 'M', 'N', 'U', 'W']\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraint that the option treatment is prescribed\n    solver.add(prescribed[option] == True)\n    check_result = solver.check()\n    if check_result == unsat:\n        # This treatment cannot be prescribed in any case\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "The members of two committees, a planting committee and a trails committee, are to be selected from among seven volunteers—F, G, H, J, K, L, and M. The following conditions govern the composition of the committees: Each committee must have at least three members. F cannot be on the same committee as K. If K is on a committee, J must also be on that committee. M must be on at least one of the committees. The two committees must have at least one member in common.\n\nWhich one of the following represents an acceptable selection of volunteers for the committees?\n\nOptions:\n(A) planting: F, G, H; trails: G, J, K, L\n(B) planting: F, H, J; trails: G, H, L, M\n(C) planting: F, H, M; trails: G, K, L, M\n(D) planting: F, G, L, M; trails: F, H\n(E) planting: F, H, J, K; trails: H, L, M",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nvolunteers = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\nvol_index = {v: i for i, v in enumerate(volunteers)}\n\n# Variables: For each volunteer, two Booleans indicating membership in planting and trails\nplanting = {v: Bool(f'planting_{v}') for v in volunteers}\ntrails = {v: Bool(f'trails_{v}') for v in volunteers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each committee must have at least three members\nsolver.add(Sum([If(planting[v], 1, 0) for v in volunteers]) >= 3)\nsolver.add(Sum([If(trails[v], 1, 0) for v in volunteers]) >= 3)\n\n# F cannot be on the same committee as K\nsolver.add(Or(Not(planting['F']), Not(planting['K'])))\nsolver.add(Or(Not(trails['F']), Not(trails['K'])))\n\n# If K is on a committee, J must also be on that committee\nsolver.add(Implies(planting['K'], planting['J']))\nsolver.add(Implies(trails['K'], trails['J']))\n\n# M must be on at least one of the committees\nsolver.add(Or(planting['M'], trails['M']))\n\n# The two committees must have at least one member in common\ncommon_members = [And(planting[v], trails[v]) for v in volunteers]\nsolver.add(Or(common_members))\n\n# OPTION CHECKING\n\n# Define options as sets of volunteers for planting and trails\noptions = [\n    (['F', 'G', 'H'], ['G', 'J', 'K', 'L']),        # A\n    (['F', 'H', 'J'], ['G', 'H', 'L', 'M']),        # B\n    (['F', 'H', 'M'], ['G', 'K', 'L', 'M']),        # C\n    (['F', 'G', 'L', 'M'], ['F', 'H']),              # D\n    (['F', 'H', 'J', 'K'], ['H', 'L', 'M']),        # E\n]\n\nfor i, (planting_list, trails_list) in enumerate(options):\n    solver.push()\n    # Add constraints that planting members are exactly planting_list\n    for v in volunteers:\n        if v in planting_list:\n            solver.add(planting[v])\n        else:\n            solver.add(Not(planting[v]))\n    # Add constraints that trails members are exactly trails_list\n    for v in volunteers:\n        if v in trails_list:\n            solver.add(trails[v])\n        else:\n            solver.add(Not(trails[v]))\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "The members of two committees, a planting committee and a trails committee, are to be selected from among seven volunteers—F, G, H, J, K, L, and M. The following conditions govern the composition of the committees: Each committee must have at least three members. F cannot be on the same committee as K. If K is on a committee, J must also be on that committee. M must be on at least one of the committees. The two committees must have at least one member in common.\n\nIf the only members of the planting committee are G, H, and L and if the two committees are to have as many members in common as the conditions allow, then which one of the following must be true?\n\nOptions:\n(A) The trails committee and the planting committee have exactly one member in common.\n(B) The trails committee and the planting committee have exactly two members in common.\n(C) The trails committee and the planting committee have an equal number of members.\n(D) The trails committee has at least one more member than the planting committee.\n(E) The planting committee has exactly two more members than the trails committee.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nvolunteers = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\nn = len(volunteers)\n\n# Create Int variables for membership in planting and trails committees\n# 1 means member is on the committee, 0 means not\nplanting = {v: Int('planting_' + v) for v in volunteers}\ntrails = {v: Int('trails_' + v) for v in volunteers}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each variable is 0 or 1\nfor v in volunteers:\n    solver.add(Or(planting[v] == 0, planting[v] == 1))\n    solver.add(Or(trails[v] == 0, trails[v] == 1))\n\n# Each committee must have at least 3 members\nsolver.add(Sum([planting[v] for v in volunteers]) >= 3)\nsolver.add(Sum([trails[v] for v in volunteers]) >= 3)\n\n# F cannot be on the same committee as K\nsolver.add(planting['F'] + planting['K'] <= 1)\nsolver.add(trails['F'] + trails['K'] <= 1)\n\n# If K is on a committee, J must also be on that committee\nsolver.add(Implies(planting['K'] == 1, planting['J'] == 1))\nsolver.add(Implies(trails['K'] == 1, trails['J'] == 1))\n\n# M must be on at least one of the committees\nsolver.add(Or(planting['M'] == 1, trails['M'] == 1))\n\n# The two committees must have at least one member in common\ncommon_members = [If(And(planting[v] == 1, trails[v] == 1), 1, 0) for v in volunteers]\nsolver.add(Sum(common_members) >= 1)\n\n# The only members of the planting committee are G, H, and L\nfor v in volunteers:\n    if v in ['G', 'H', 'L']:\n        solver.add(planting[v] == 1)\n    else:\n        solver.add(planting[v] == 0)\n\n# We want to maximize the number of members in common between the two committees\n# under the above constraints\n# So we will try all possible numbers of common members from max down to 1\nmax_common = 3  # max possible common is 3 because planting committee has exactly 3 members\n\ncorrect_option = None\n\nfor common_count in range(max_common, 0, -1):\n    solver.push()\n    solver.add(Sum(common_members) == common_count)\n    if solver.check() == sat:\n        model = solver.model()\n        planting_size = 3  # fixed by problem\n        trails_size = sum([model.evaluate(trails[v]).as_long() for v in volunteers])\n\n        # Check each option\n        # (A) Exactly one member in common\n        if common_count == 1:\n            correct_option = 'A'\n        # (B) Exactly two members in common\n        elif common_count == 2:\n            correct_option = 'B'\n        # (C) The two committees have equal number of members\n        elif planting_size == trails_size:\n            correct_option = 'C'\n        # (D) Trails has at least one more member than planting\n        elif trails_size >= planting_size + 1:\n            correct_option = 'D'\n        # (E) Planting has exactly two more members than trails\n        elif planting_size == trails_size + 2:\n            correct_option = 'E'\n        else:\n            correct_option = None\n\n        solver.pop()\n        if correct_option is not None:\n            print(f\"'{correct_option}'\")\n            break\n    else:\n        solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "The members of two committees, a planting committee and a trails committee, are to be selected from among seven volunteers—F, G, H, J, K, L, and M. The following conditions govern the composition of the committees: Each committee must have at least three members. F cannot be on the same committee as K. If K is on a committee, J must also be on that committee. M must be on at least one of the committees. The two committees must have at least one member in common.\n\nIf K is on both committees and L is also on both committees and if the planting committee has exactly three members, then which one of the following must be true?\n\nOptions:\n(A) F is on the planting committee.\n(B) F is on the trails committee.\n(C) G is on the planting committee.\n(D) M is on the planting committee.\n(E) M is on the trails committee.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nvolunteers = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\nnum_volunteers = len(volunteers)\nvol_index = {v: i for i, v in enumerate(volunteers)}\n\n# Create Bool variables: for each volunteer, whether they are in planting committee and trails committee\nplanting = [Bool(f\"planting_{v}\") for v in volunteers]\ntrails = [Bool(f\"trails_{v}\") for v in volunteers]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each committee must have at least three members\nsolver.add(Sum([If(planting[i], 1, 0) for i in range(num_volunteers)]) >= 3)\nsolver.add(Sum([If(trails[i], 1, 0) for i in range(num_volunteers)]) >= 3)\n\n# F cannot be on the same committee as K\n# For planting:\nsolver.add(Or(Not(planting[vol_index['F']]), Not(planting[vol_index['K']])))\n# For trails:\nsolver.add(Or(Not(trails[vol_index['F']]), Not(trails[vol_index['K']])))\n\n# If K is on a committee, J must also be on that committee\n# For planting:\nsolver.add(Implies(planting[vol_index['K']], planting[vol_index['J']]))\n# For trails:\nsolver.add(Implies(trails[vol_index['K']], trails[vol_index['J']]))\n\n# M must be on at least one of the committees\nsolver.add(Or(planting[vol_index['M']], trails[vol_index['M']]))\n\n# The two committees must have at least one member in common\ncommon_members = [And(planting[i], trails[i]) for i in range(num_volunteers)]\nsolver.add(Or(common_members))\n\n# Additional conditions from the question:\n# K is on both committees\nsolver.add(planting[vol_index['K']])\nsolver.add(trails[vol_index['K']])\n\n# L is on both committees\nsolver.add(planting[vol_index['L']])\nsolver.add(trails[vol_index['L']])\n\n# Planting committee has exactly three members\nsolver.add(Sum([If(planting[i], 1, 0) for i in range(num_volunteers)]) == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': planting[vol_index['F']],       # F is on the planting committee\n    'B': trails[vol_index['F']],         # F is on the trails committee\n    'C': planting[vol_index['G']],       # G is on the planting committee\n    'D': planting[vol_index['M']],       # M is on the planting committee\n    'E': trails[vol_index['M']],         # M is on the trails committee\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    # Check if condition can be false\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        # If Not(cond) is unsat, cond must be true in all models\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "The members of two committees, a planting committee and a trails committee, are to be selected from among seven volunteers—F, G, H, J, K, L, and M. The following conditions govern the composition of the committees: Each committee must have at least three members. F cannot be on the same committee as K. If K is on a committee, J must also be on that committee. M must be on at least one of the committees. The two committees must have at least one member in common.\n\nThe largest number of members that the planting committee and the trails committee could have in common is\n\nOptions:\n(A) three\n(B) four\n(C) five\n(D) six\n(E) seven",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nvolunteers = ['F', 'G', 'H', 'J', 'K', 'L', 'M']\nn = len(volunteers)\n\n# Create boolean variables indicating membership in planting and trails committees\nplanting = {v: Bool(f'planting_{v}') for v in volunteers}\ntrails = {v: Bool(f'trails_{v}') for v in volunteers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each committee must have at least three members\nplanting_count = Sum([If(planting[v], 1, 0) for v in volunteers])\ntrails_count = Sum([If(trails[v], 1, 0) for v in volunteers])\nsolver.add(planting_count >= 3)\nsolver.add(trails_count >= 3)\n\n# F cannot be on the same committee as K\n# So not (F and K) in planting, and not (F and K) in trails\nsolver.add(Or(Not(planting['F']), Not(planting['K'])))\nsolver.add(Or(Not(trails['F']), Not(trails['K'])))\n\n# If K is on a committee, J must also be on that committee\nsolver.add(Implies(planting['K'], planting['J']))\nsolver.add(Implies(trails['K'], trails['J']))\n\n# M must be on at least one of the committees\nsolver.add(Or(planting['M'], trails['M']))\n\n# The two committees must have at least one member in common\ncommon_members = [And(planting[v], trails[v]) for v in volunteers]\nsolver.add(Or(common_members))\n\n# OPTION CHECKING\n# The largest number of members that the committees could have in common is what we want to find.\n# So we check from largest to smallest possible common members (max 7)\n# and see which is satisfiable.\n\nfor common_size in range(7, 0, -1):\n    solver.push()\n    # Add constraint that number of common members is at least common_size\n    common_count = Sum([If(And(planting[v], trails[v]), 1, 0) for v in volunteers])\n    solver.add(common_count >= common_size)\n    if solver.check() == sat:\n        # Map common_size to option letter\n        # Options: (A)3, (B)4, (C)5, (D)6, (E)7\n        # So if common_size >= 3, print corresponding letter\n        # If common_size <3, no option matches, but problem says at least one member in common, so min 1.\n        # The question is largest number possible, so answer must be >=3 per options.\n        # So print corresponding letter for common_size\n        option_map = {3:'A',4:'B',5:'C',6:'D',7:'E'}\n        # Find largest common_size in option_map <= common_size\n        for size in range(common_size, 2, -1):\n            if size in option_map:\n                print(f\"'{option_map[size]}'\")\n                break\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.\n\nEach of the following could be true EXCEPT:\n\nOptions:\n(A) Both Klaus and Harry speak Turkish.\n(B) Both Klaus and Michael speak French.\n(C) Both Klaus and Michael speak Russian.\n(D) Both Klaus and Norma speak French.\n(E) Both Klaus and Norma speak Spanish.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntourists = ['Harry', 'Irene', 'Klaus', 'Laura', 'Michael', 'Norma']\nguides = ['Valois', 'Xerxes', 'Yossarian', 'Zalamea']\nlanguages = ['French', 'Turkish', 'Spanish', 'Russian']\n\n# Map guides to their spoken languages as sets of language indices\nguide_languages = {\n    'Valois': [languages.index('French')],\n    'Xerxes': [languages.index('Turkish'), languages.index('Spanish')],\n    'Yossarian': [languages.index('French'), languages.index('Turkish')],\n    'Zalamea': [languages.index('Spanish'), languages.index('Russian')]\n}\n\n# Create Z3 variables for each tourist's guide and language\ntourist_guide = {t: Int(t + '_guide') for t in tourists}\ntourist_lang = {t: Int(t + '_lang') for t in tourists}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each tourist assigned to exactly one guide (0..3)\nfor t in tourists:\n    solver.add(And(tourist_guide[t] >= 0, tourist_guide[t] < len(guides)))\n\n# Each tourist assigned exactly one language (0..3)\nfor t in tourists:\n    solver.add(And(tourist_lang[t] >= 0, tourist_lang[t] < len(languages)))\n\n# Each tourist speaks exactly one of the languages spoken by his/her guide\nfor t in tourists:\n    # Allowed languages for the assigned guide\n    allowed_langs = []\n    for g_idx, g in enumerate(guides):\n        langs = guide_languages[g]\n        # If tourist assigned to g_idx, then language must be in langs\n        cond = Implies(tourist_guide[t] == g_idx, Or([tourist_lang[t] == l for l in langs]))\n        allowed_langs.append(cond)\n    solver.add(And(allowed_langs))\n\n# Each guide has at least one tourist assigned\nfor g_idx in range(len(guides)):\n    assigned_to_g = [tourist_guide[t] == g_idx for t in tourists]\n    solver.add(Or(assigned_to_g))\n\n# At least Harry and Irene assigned to Yossarian (Yossarian index)\nyossarian_idx = guides.index('Yossarian')\nsolver.add(tourist_guide['Harry'] == yossarian_idx)\nsolver.add(tourist_guide['Irene'] == yossarian_idx)\n\n# At least Laura assigned to Zalamea\nzalamea_idx = guides.index('Zalamea')\nsolver.add(tourist_guide['Laura'] == zalamea_idx)\n\n# If Klaus assigned to Xerxes, then Michael speaks French\nxerxes_idx = guides.index('Xerxes')\nfrench_idx = languages.index('French')\nsolver.add(Implies(tourist_guide['Klaus'] == xerxes_idx, tourist_lang['Michael'] == french_idx))\n\n# OPTION CHECKING\n\n# Options (A) to (E) as constraints to test\n# We want to find which option cannot be true (no solution)\n\n# Helper: get language index for a given language string\ndef lang_idx(lang):\n    return languages.index(lang)\n\noptions = [\n    # (A) Both Klaus and Harry speak Turkish.\n    And(tourist_lang['Klaus'] == lang_idx('Turkish'), tourist_lang['Harry'] == lang_idx('Turkish')),\n    # (B) Both Klaus and Michael speak French.\n    And(tourist_lang['Klaus'] == lang_idx('French'), tourist_lang['Michael'] == lang_idx('French')),\n    # (C) Both Klaus and Michael speak Russian.\n    And(tourist_lang['Klaus'] == lang_idx('Russian'), tourist_lang['Michael'] == lang_idx('Russian')),\n    # (D) Both Klaus and Norma speak French.\n    And(tourist_lang['Klaus'] == lang_idx('French'), tourist_lang['Norma'] == lang_idx('French')),\n    # (E) Both Klaus and Norma speak Spanish.\n    And(tourist_lang['Klaus'] == lang_idx('Spanish'), tourist_lang['Norma'] == lang_idx('Spanish')),\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        solver.pop()\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Zalamea is assigned fewer than three of the tourists.\n(B) Xerxes is assigned fewer than two of the tourists.\n(C) Yossarian is assigned exactly two of the tourists.\n(D) Valois is assigned exactly one of the tourists.\n(E) Zalamea is assigned exactly one of the tourists.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Tourists and Guides\ntourists = ['Harry', 'Irene', 'Klaus', 'Laura', 'Michael', 'Norma']\nguides = ['Valois', 'Xerxes', 'Yossarian', 'Zalamea']\n\n# Languages spoken by guides (indices)\nlanguages = ['French', 'Turkish', 'Spanish', 'Russian']\n\n# Guide language sets\nguide_langs = {\n    'Valois': ['French'],\n    'Xerxes': ['Turkish', 'Spanish'],\n    'Yossarian': ['French', 'Turkish'],\n    'Zalamea': ['Spanish', 'Russian']\n}\n\n# Map languages to indices for easy comparison\nlang_idx = {lang: i for i, lang in enumerate(languages)}\n\n# Each tourist speaks exactly one language spoken by his/her guide\n# For each tourist, create two variables:\n#   guide assignment: Int variable in [0..3]\n#   language spoken: Int variable in [0..3]\n\nguide_idx = {g: i for i, g in enumerate(guides)}\n\n# Create Z3 variables for guide assignments and languages spoken\ntourist_guide = {t: Int(f'guide_{t}') for t in tourists}\ntourist_lang = {t: Int(f'lang_{t}') for t in tourists}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each tourist assigned to exactly one guide (index 0 to 3)\nfor t in tourists:\n    solver.add(And(tourist_guide[t] >= 0, tourist_guide[t] < len(guides)))\n\n# 2. Each tourist speaks exactly one language spoken by his/her guide\nfor t in tourists:\n    # language index must be one of the languages of the assigned guide\n    # We create a condition for each guide and its languages\n    guide_conditions = []\n    for g in guides:\n        g_i = guide_idx[g]\n        langs_for_g = guide_langs[g]\n        lang_indices = [lang_idx[lang] for lang in langs_for_g]\n        # For this guide, language must be one of lang_indices\n        lang_cond = Or([tourist_lang[t] == li for li in lang_indices])\n        # If assigned to this guide, then language condition holds\n        guide_cond = Implies(tourist_guide[t] == g_i, lang_cond)\n        guide_conditions.append(guide_cond)\n    solver.add(And(guide_conditions))\n\n# 3. Each tourist speaks exactly one language (lang index 0..3)\nfor t in tourists:\n    solver.add(And(tourist_lang[t] >= 0, tourist_lang[t] < len(languages)))\n\n# 4. Each guide assigned at least one tourist\nfor g in guides:\n    g_i = guide_idx[g]\n    assigned_to_g = [tourist_guide[t] == g_i for t in tourists]\n    solver.add(Or(assigned_to_g))\n\n# 5. At least Harry and Irene assigned to Yossarian\nyossarian_i = guide_idx['Yossarian']\nsolver.add(tourist_guide['Harry'] == yossarian_i)\nsolver.add(tourist_guide['Irene'] == yossarian_i)\n\n# 6. At least Laura assigned to Zalamea\nzalamea_i = guide_idx['Zalamea']\nsolver.add(tourist_guide['Laura'] == zalamea_i)\n\n# 7. If Klaus assigned to Xerxes, then Michael speaks French\nxerxes_i = guide_idx['Xerxes']\nfrench_i = lang_idx['French']\nsolver.add(Implies(tourist_guide['Klaus'] == xerxes_i, tourist_lang['Michael'] == french_i))\n\n# OPTION CHECKING\n\noptions = {\n    'A': \"Zalamea is assigned fewer than three of the tourists.\",\n    'B': \"Xerxes is assigned fewer than two of the tourists.\",\n    'C': \"Yossarian is assigned exactly two of the tourists.\",\n    'D': \"Valois is assigned exactly one of the tourists.\",\n    'E': \"Zalamea is assigned exactly one of the tourists.\"\n}\n\n# Helper function to count number of tourists assigned to a guide\ndef count_assigned(guide_i):\n    return Sum([If(tourist_guide[t] == guide_i, 1, 0) for t in tourists])\n\n# For each option, add its negation and check satisfiability\n# The correct option must hold in all models, so negation must be unsat\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    if letter == 'A':\n        # Zalamea assigned fewer than three tourists\n        # Negation: Zalamea assigned >= 3 tourists\n        count_zalamea = count_assigned(zalamea_i)\n        solver.add(count_zalamea >= 3)\n    elif letter == 'B':\n        # Xerxes assigned fewer than two tourists\n        # Negation: Xerxes assigned >= 2 tourists\n        count_xerxes = count_assigned(xerxes_i)\n        solver.add(count_xerxes >= 2)\n    elif letter == 'C':\n        # Yossarian assigned exactly two tourists\n        # Negation: Yossarian assigned != 2 tourists\n        count_yossarian = count_assigned(yossarian_i)\n        solver.add(Or(count_yossarian < 2, count_yossarian > 2))\n    elif letter == 'D':\n        # Valois assigned exactly one tourist\n        # Negation: Valois assigned != 1 tourist\n        valois_i = guide_idx['Valois']\n        count_valois = count_assigned(valois_i)\n        solver.add(Or(count_valois < 1, count_valois > 1))\n    elif letter == 'E':\n        # Zalamea assigned exactly one tourist\n        # Negation: Zalamea assigned != 1 tourist\n        count_zalamea = count_assigned(zalamea_i)\n        solver.add(Or(count_zalamea < 1, count_zalamea > 1))\n\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.\n\nEach of the following could be true of the assignment of tourists to guides EXCEPT:\n\nOptions:\n(A) It assigns Klaus to Valois and Michael to Xerxes.\n(B) It assigns Klaus to Yossarian and Norma to Zalamea.\n(C) It assigns Laura to Zalamea and Michael to Zalamea.\n(D) It assigns Michael to Valois and Klaus to Zalamea.\n(E) It assigns Michael to Xerxes and Klaus to Zalamea.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntourists = ['Harry', 'Irene', 'Klaus', 'Laura', 'Michael', 'Norma']\nguides = ['Valois', 'Xerxes', 'Yossarian', 'Zalamea']\n\n# Map guides to indices\nguide_idx = {g: i for i, g in enumerate(guides)}\n\n# Languages spoken by each guide (indices for convenience)\n# Languages: French=0, Turkish=1, Spanish=2, Russian=3\nlanguages = ['French', 'Turkish', 'Spanish', 'Russian']\nlang_idx = {l: i for i, l in enumerate(languages)}\n\n# Guide languages sets\nguide_languages = {\n    'Valois': [lang_idx['French']],\n    'Xerxes': [lang_idx['Turkish'], lang_idx['Spanish']],\n    'Yossarian': [lang_idx['French'], lang_idx['Turkish']],\n    'Zalamea': [lang_idx['Spanish'], lang_idx['Russian']],\n}\n\n# Tourist language variables: each tourist speaks exactly one language spoken by their guide\n# We'll create an Int variable for each tourist: the index of the guide they are assigned to\ntourist_to_guide = {t: Int(t) for t in tourists}\n# For each tourist, a language variable (index)\ntourist_language = {t: Int(f'{t}_lang') for t in tourists}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each tourist assigned to exactly one guide (index in 0..3)\nfor t in tourists:\n    solver.add(And(tourist_to_guide[t] >= 0, tourist_to_guide[t] < len(guides)))\n\n# Each tourist's language must be one of the languages spoken by their assigned guide\nfor t in tourists:\n    # For each guide, if assigned, then language in that guide's languages\n    guide_conditions = []\n    for g in guides:\n        cond = tourist_to_guide[t] == guide_idx[g]\n        lang_in_guide = Or([tourist_language[t] == l for l in guide_languages[g]])\n        guide_conditions.append(And(cond, lang_in_guide))\n    solver.add(Or(guide_conditions))\n\n# Each tourist speaks exactly one language (already ensured by language variable being single valued)\n\n# Each guide has at least one tourist assigned\nfor g in guides:\n    assigned = [tourist_to_guide[t] == guide_idx[g] for t in tourists]\n    solver.add(Or(assigned))  # At least one tourist assigned to guide g\n\n# At least Harry and Irene are assigned to Yossarian\nsolver.add(tourist_to_guide['Harry'] == guide_idx['Yossarian'])\nsolver.add(tourist_to_guide['Irene'] == guide_idx['Yossarian'])\n\n# At least Laura is assigned to Zalamea\nsolver.add(tourist_to_guide['Laura'] == guide_idx['Zalamea'])\n\n# If Klaus is assigned to Xerxes, then Michael speaks French\nklaus_xerxes = tourist_to_guide['Klaus'] == guide_idx['Xerxes']\nmichael_french = tourist_language['Michael'] == lang_idx['French']\nsolver.add(Implies(klaus_xerxes, michael_french))\n\n# OPTION CHECKING\n# Each option is a list of assignments (tourist, guide)\noptions = [\n    [('Klaus', 'Valois'), ('Michael', 'Xerxes')],\n    [('Klaus', 'Yossarian'), ('Norma', 'Zalamea')],\n    [('Laura', 'Zalamea'), ('Michael', 'Zalamea')],\n    [('Michael', 'Valois'), ('Klaus', 'Zalamea')],\n    [('Michael', 'Xerxes'), ('Klaus', 'Zalamea')],\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this option\n    for (t, g) in option:\n        solver.add(tourist_to_guide[t] == guide_idx[g])\n    # Check satisfiability\n    if solver.check() == sat:\n        # Option could be true, so continue\n        solver.pop()\n    else:\n        # Option cannot be true, print its letter and break\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.\n\nIf Klaus and Laura speak the same language as each other, then which one of the following must be true?\n\nOptions:\n(A) At least one of Michael and Norma speaks Spanish.\n(B) At least two tourists speak Russian.\n(C) Klaus and Laura speak Russian.\n(D) At least two tourists speak French.\n(E) At least one of Michael and Norma speaks French.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntourists = ['Harry', 'Irene', 'Klaus', 'Laura', 'Michael', 'Norma']\nguides = ['Valois', 'Xerxes', 'Yossarian', 'Zalamea']\n\n# Languages indices\nlanguages = ['French', 'Turkish', 'Spanish', 'Russian']\nF, T, S, R = 0, 1, 2, 3\n\n# Guide languages mapping (each guide speaks one or two languages)\nguide_langs = {\n    'Valois': [F],           # only French\n    'Xerxes': [T, S],       # Turkish and Spanish\n    'Yossarian': [F, T],    # French and Turkish\n    'Zalamea': [S, R],      # Spanish and Russian\n}\n\n# Create Z3 variables for each tourist: assigned guide and spoken language\n# guide assignment: integer 0..3 (index in guides)\n# language assignment: integer 0..3 (index in languages)\ntourist_guide = {t: Int(t + '_guide') for t in tourists}\ntourist_lang = {t: Int(t + '_lang') for t in tourists}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each tourist assigned to exactly one guide (0..3)\nfor t in tourists:\n    solver.add(And(tourist_guide[t] >= 0, tourist_guide[t] < len(guides)))\n\n# 2) Each tourist speaks exactly one language (0..3)\nfor t in tourists:\n    solver.add(And(tourist_lang[t] >= 0, tourist_lang[t] < len(languages)))\n\n# 3) Each guide must have at least one tourist assigned\nfor g_idx in range(len(guides)):\n    assigned_to_g = [tourist_guide[t] == g_idx for t in tourists]\n    solver.add(Or(assigned_to_g))  # at least one tourist assigned to guide g_idx\n\n# 4) Each tourist's language must be one of the languages spoken by his/her guide\nfor t in tourists:\n    # Get guide index variable\n    g = tourist_guide[t]\n    l = tourist_lang[t]\n    # For each guide, if assigned, then language in guide_langs\n    # We encode as a disjunction over guides\n    lang_cond = []\n    for g_idx, g_name in enumerate(guides):\n        allowed_langs = guide_langs[g_name]\n        lang_cond.append(And(g == g_idx, Or([l == lang for lang in allowed_langs])))\n    solver.add(Or(lang_cond))\n\n# 5) At least Harry and Irene assigned to Yossarian (guide index 2)\nsolver.add(tourist_guide['Harry'] == guides.index('Yossarian'))\nsolver.add(tourist_guide['Irene'] == guides.index('Yossarian'))\n\n# 6) At least Laura assigned to Zalamea (guide index 3)\nsolver.add(tourist_guide['Laura'] == guides.index('Zalamea'))\n\n# 7) If Klaus assigned to Xerxes (guide index 1), then Michael speaks French (language index 0)\nklaus_xerxes = tourist_guide['Klaus'] == guides.index('Xerxes')\nmichael_french = tourist_lang['Michael'] == F\nsolver.add(Implies(klaus_xerxes, michael_french))\n\n# 8) Klaus and Laura speak the same language (given condition for the question)\nsolver.add(tourist_lang['Klaus'] == tourist_lang['Laura'])\n\n# OPTION CHECKING\n\noptions = [\n    # (A) At least one of Michael and Norma speaks Spanish.\n    Or(tourist_lang['Michael'] == S, tourist_lang['Norma'] == S),\n\n    # (B) At least two tourists speak Russian.\n    Sum([If(tourist_lang[t] == R, 1, 0) for t in tourists]) >= 2,\n\n    # (C) Klaus and Laura speak Russian.\n    And(tourist_lang['Klaus'] == R, tourist_lang['Laura'] == R),\n\n    # (D) At least two tourists speak French.\n    Sum([If(tourist_lang[t] == F, 1, 0) for t in tourists]) >= 2,\n\n    # (E) At least one of Michael and Norma speaks French.\n    Or(tourist_lang['Michael'] == F, tourist_lang['Norma'] == F),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.\n\nIf Laura and Norma speak the same language as each other, then the maximum number of the tourists who could speak Turkish is\n\nOptions:\n(A) two\n(B) three\n(C) four\n(D) five\n(E) six",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Tourists and Guides\ntourists = ['Harry', 'Irene', 'Klaus', 'Laura', 'Michael', 'Norma']\nguides = ['Valois', 'Xerxes', 'Yossarian', 'Zalamea']\n\n# Languages\nlanguages = ['French', 'Turkish', 'Spanish', 'Russian']\n\n# Guide to languages mapping (indices)\nguide_langs = {\n    'Valois': [languages.index('French')],\n    'Xerxes': [languages.index('Turkish'), languages.index('Spanish')],\n    'Yossarian': [languages.index('French'), languages.index('Turkish')],\n    'Zalamea': [languages.index('Spanish'), languages.index('Russian')],\n}\n\n# Variables\n# For each tourist: assigned guide (int index)\ntourist_guide = {t: Int(t) for t in tourists}\n# For each tourist: spoken language (int index)\ntourist_lang = {t: Int(t + '_lang') for t in tourists}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each tourist assigned to exactly one guide (valid index)\nfor t in tourists:\n    solver.add(And(tourist_guide[t] >= 0, tourist_guide[t] < len(guides)))\n\n# Each tourist speaks exactly one language (valid index)\nfor t in tourists:\n    solver.add(And(tourist_lang[t] >= 0, tourist_lang[t] < len(languages)))\n\n# Each guide has at least one tourist assigned\nfor g_idx in range(len(guides)):\n    assigned_to_g = [tourist_guide[t] == g_idx for t in tourists]\n    solver.add(Or(assigned_to_g))\n\n# Each tourist's language is one of the languages spoken by his/her guide\nfor t in tourists:\n    g = tourist_guide[t]\n    l = tourist_lang[t]\n    # Build allowed languages for each guide index\n    allowed_langs = []\n    for g_idx, g_name in enumerate(guides):\n        allowed = guide_langs[g_name]\n        allowed_langs.append(And(g == g_idx, Or([l == lang for lang in allowed])))\n    solver.add(Or(allowed_langs))\n\n# At least Harry and Irene assigned to Yossarian (index of Yossarian)\nyossarian_idx = guides.index('Yossarian')\nsolver.add(tourist_guide['Harry'] == yossarian_idx)\nsolver.add(tourist_guide['Irene'] == yossarian_idx)\n\n# At least Laura assigned to Zalamea (index of Zalamea)\nzalamea_idx = guides.index('Zalamea')\nsolver.add(tourist_guide['Laura'] == zalamea_idx)\n\n# If Klaus assigned to Xerxes, then Michael speaks French\nxerxes_idx = guides.index('Xerxes')\nfrench_idx = languages.index('French')\nsolver.add(Implies(tourist_guide['Klaus'] == xerxes_idx, tourist_lang['Michael'] == french_idx))\n\n# Condition: Laura and Norma speak the same language\nsolver.add(tourist_lang['Laura'] == tourist_lang['Norma'])\n\n# We want to find the maximum number of tourists who could speak Turkish\nturkish_idx = languages.index('Turkish')\n\n# OPTION CHECKING\n# Options and their corresponding max Turkish speakers\noptions = {\n    'A': 2,\n    'B': 3,\n    'C': 4,\n    'D': 5,\n    'E': 6,\n}\n\n# We'll check from highest to lowest to find the maximum feasible\nfor letter, max_turkish in reversed(list(options.items())):\n    solver.push()\n    # Count how many tourists speak Turkish\n    turkish_counts = [If(tourist_lang[t] == turkish_idx, 1, 0) for t in tourists]\n    total_turkish = Sum(turkish_counts)\n    # Add constraint that total_turkish >= max_turkish\n    solver.add(total_turkish >= max_turkish)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.\n\nIf exactly two tourists are assigned to Xerxes, then which one of the following could be true?\n\nOptions:\n(A) Norma speaks Russian and Laura speaks Russian.\n(B) Norma speaks French and Michael speaks French.\n(C) Norma speaks French and Klaus speaks Turkish.\n(D) Michael speaks Spanish and Klaus speaks Spanish.\n(E) Michael speaks French and Klaus speaks Spanish.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Tourists\ntourists = ['Harry', 'Irene', 'Klaus', 'Laura', 'Michael', 'Norma']\n\n# Guides\nguides = ['Valois', 'Xerxes', 'Yossarian', 'Zalamea']\n\n# Languages spoken by each guide (indices for languages)\nlanguages = ['French', 'Turkish', 'Spanish', 'Russian']\n\n# Map guides to languages indices they speak\n# Valois: French only\n# Xerxes: Turkish and Spanish\n# Yossarian: French and Turkish\n# Zalamea: Spanish and Russian\nguide_langs = {\n    'Valois': [languages.index('French')],\n    'Xerxes': [languages.index('Turkish'), languages.index('Spanish')],\n    'Yossarian': [languages.index('French'), languages.index('Turkish')],\n    'Zalamea': [languages.index('Spanish'), languages.index('Russian')]\n}\n\n# Create Z3 Int variables for each tourist's guide assignment (index of guide)\ntourist_guide = {}\nfor t in tourists:\n    tourist_guide[t] = Int(t + '_guide')\n\n# Create Z3 Int variables for each tourist's language (index of language)\ntourist_lang = {}\nfor t in tourists:\n    tourist_lang[t] = Int(t + '_lang')\n\n# Map guide names to indices\nguide_indices = {g: i for i, g in enumerate(guides)}\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each tourist assigned to exactly one guide (valid index)\nfor t in tourists:\n    solver.add(And(tourist_guide[t] >= 0, tourist_guide[t] < len(guides)))\n\n# Each tourist speaks exactly one language (valid index)\nfor t in tourists:\n    solver.add(And(tourist_lang[t] >= 0, tourist_lang[t] < len(languages)))\n\n# At least one tourist assigned to each guide\nfor g in guides:\n    g_idx = guide_indices[g]\n    assigned_to_g = [tourist_guide[t] == g_idx for t in tourists]\n    solver.add(Or(assigned_to_g))  # at least one tourist assigned to guide g\n\n# Each tourist's language must be one of the languages spoken by their guide\nfor t in tourists:\n    # Get guide index variable\n    g_var = tourist_guide[t]\n    l_var = tourist_lang[t]\n    # For each guide, if assigned, language must be in guide_langs[guide]\n    lang_conditions = []\n    for g in guides:\n        g_idx = guide_indices[g]\n        allowed_langs = guide_langs[g]\n        lang_conditions.append(And(g_var == g_idx, Or([l_var == lang for lang in allowed_langs])))\n    solver.add(Or(lang_conditions))\n\n# At least Harry and Irene assigned to Yossarian\nsolver.add(tourist_guide['Harry'] == guide_indices['Yossarian'])\nsolver.add(tourist_guide['Irene'] == guide_indices['Yossarian'])\n\n# At least Laura assigned to Zalamea\nsolver.add(tourist_guide['Laura'] == guide_indices['Zalamea'])\n\n# If Klaus assigned to Xerxes, then Michael speaks French\n# Klaus assigned to Xerxes means tourist_guide['Klaus'] == guide_indices['Xerxes']\n# Michael speaks French means tourist_lang['Michael'] == languages.index('French')\nsolver.add(Implies(tourist_guide['Klaus'] == guide_indices['Xerxes'], tourist_lang['Michael'] == languages.index('French')))\n\n# Exactly two tourists assigned to Xerxes\nassigned_to_xerxes = [tourist_guide[t] == guide_indices['Xerxes'] for t in tourists]\nsolver.add(Sum([If(cond, 1, 0) for cond in assigned_to_xerxes]) == 2)\n\n# OPTION CHECKING\n\n# Options:\n# (A) Norma speaks Russian and Laura speaks Russian.\n# (B) Norma speaks French and Michael speaks French.\n# (C) Norma speaks French and Klaus speaks Turkish.\n# (D) Michael speaks Spanish and Klaus speaks Spanish.\n# (E) Michael speaks French and Klaus speaks Spanish.\n\noptions = [\n    And(tourist_lang['Norma'] == languages.index('Russian'), tourist_lang['Laura'] == languages.index('Russian')),\n    And(tourist_lang['Norma'] == languages.index('French'), tourist_lang['Michael'] == languages.index('French')),\n    And(tourist_lang['Norma'] == languages.index('French'), tourist_lang['Klaus'] == languages.index('Turkish')),\n    And(tourist_lang['Michael'] == languages.index('Spanish'), tourist_lang['Klaus'] == languages.index('Spanish')),\n    And(tourist_lang['Michael'] == languages.index('French'), tourist_lang['Klaus'] == languages.index('Spanish'))\n]\n\nfor i, option_constraint in enumerate(options):\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six tourists—Harry, Irene, Klaus, Laura, Michael, Norma—are to be assigned to four guides: Valois, Xerxes, Yossarian, Zalamea. Each tourist is assigned to exactly one guide, with at least one tourist assigned to each guide. Valois speaks only French. Xerxes speaks only Turkish and Spanish. Yossarian speaks only French and Turkish. Zalamea speaks only Spanish and Russian. Each tourist speaks exactly one of the languages spoken by his or her guide and speaks no other language. The following rules govern the assignment of the tourists to the guides: At least Harry and Irene are assigned to Yossarian. At least Laura is assigned to Zalamea. If Klaus is assigned to Xerxes, then Michael speaks French.\n\nIf Harry, Irene, Michael, and Norma all speak the same language as each other, then which one of the following could be true?\n\nOptions:\n(A) Klaus speaks Russian.\n(B) Exactly two of the tourists speak Russian.\n(C) Exactly three of the tourists speak Spanish.\n(D) Exactly two of the tourists speak Turkish.\n(E) Klaus speaks French.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntourists = ['Harry', 'Irene', 'Klaus', 'Laura', 'Michael', 'Norma']\nguides = ['Valois', 'Xerxes', 'Yossarian', 'Zalamea']\nlanguages = ['French', 'Turkish', 'Spanish', 'Russian']\n\n# Map indices for easy reference\nguide_idx = {g: i for i, g in enumerate(guides)}\nlang_idx = {l: i for i, l in enumerate(languages)}\ntourist_idx = {t: i for i, t in enumerate(tourists)}\n\n# Guide languages (sets)\n# Valois: French only\n# Xerxes: Turkish, Spanish\n# Yossarian: French, Turkish\n# Zalamea: Spanish, Russian\nguide_languages = {\n    'Valois': [lang_idx['French']],\n    'Xerxes': [lang_idx['Turkish'], lang_idx['Spanish']],\n    'Yossarian': [lang_idx['French'], lang_idx['Turkish']],\n    'Zalamea': [lang_idx['Spanish'], lang_idx['Russian']],\n}\n\n# Variables\n# For each tourist, assign a guide (0..3)\ntourist_guide = {t: Int(f'guide_{t}') for t in tourists}\n# For each tourist, assign a language (0..3)\ntourist_lang = {t: Int(f'lang_{t}') for t in tourists}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each tourist assigned to exactly one guide (index 0..3)\nfor t in tourists:\n    solver.add(And(tourist_guide[t] >= 0, tourist_guide[t] < len(guides)))\n\n# Each tourist assigned exactly one language (index 0..3)\nfor t in tourists:\n    solver.add(And(tourist_lang[t] >= 0, tourist_lang[t] < len(languages)))\n\n# Each guide has at least one tourist assigned\nfor g in guides:\n    assigned = [tourist_guide[t] == guide_idx[g] for t in tourists]\n    solver.add(Or(assigned))\n\n# Each tourist speaks exactly one of the languages spoken by his/her guide\nfor t in tourists:\n    # The language spoken by the tourist must be one of the guide's languages\n    # We encode: (tourist_guide[t] == guide_idx[g]) => (tourist_lang[t] in guide_languages[g])\n    # For each guide, build implication and then Or over guides\n    lang_cond = []\n    for g in guides:\n        g_idx = guide_idx[g]\n        allowed_langs = guide_languages[g]\n        lang_in_allowed = Or([tourist_lang[t] == l for l in allowed_langs])\n        lang_cond.append(Implies(tourist_guide[t] == g_idx, lang_in_allowed))\n    solver.add(lang_cond)\n\n# At least Harry and Irene assigned to Yossarian\nsolver.add(tourist_guide['Harry'] == guide_idx['Yossarian'])\nsolver.add(tourist_guide['Irene'] == guide_idx['Yossarian'])\n\n# At least Laura assigned to Zalamea\nsolver.add(tourist_guide['Laura'] == guide_idx['Zalamea'])\n\n# If Klaus assigned to Xerxes, then Michael speaks French\nklaus_xerxes = (tourist_guide['Klaus'] == guide_idx['Xerxes'])\nmichael_french = (tourist_lang['Michael'] == lang_idx['French'])\nsolver.add(Implies(klaus_xerxes, michael_french))\n\n# Additional constraint: Harry, Irene, Michael, and Norma all speak the same language as each other\nsame_lang = And([\n    tourist_lang['Harry'] == tourist_lang['Irene'],\n    tourist_lang['Harry'] == tourist_lang['Michael'],\n    tourist_lang['Harry'] == tourist_lang['Norma'],\n])\n\nsolver.add(same_lang)\n\n# Helper: count how many tourists speak a given language\ndef count_language(lang_i):\n    return Sum([If(tourist_lang[t] == lang_i, 1, 0) for t in tourists])\n\n# OPTION CHECKING\n\n# We check each option by adding its condition and checking satisfiability\n\noptions = []\n\n# (A) Klaus speaks Russian.\ncond_A = (tourist_lang['Klaus'] == lang_idx['Russian'])\noptions.append(cond_A)\n\n# (B) Exactly two of the tourists speak Russian.\ncount_russian = count_language(lang_idx['Russian'])\ncond_B = (count_russian == 2)\noptions.append(cond_B)\n\n# (C) Exactly three of the tourists speak Spanish.\ncount_spanish = count_language(lang_idx['Spanish'])\ncond_C = (count_spanish == 3)\noptions.append(cond_C)\n\n# (D) Exactly two of the tourists speak Turkish.\ncount_turkish = count_language(lang_idx['Turkish'])\ncond_D = (count_turkish == 2)\noptions.append(cond_D)\n\n# (E) Klaus speaks French.\ncond_E = (tourist_lang['Klaus'] == lang_idx['French'])\noptions.append(cond_E)\n\nfor i, cond in enumerate(options):\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Maricella plays tennis and Shigeru plays golf.\n(B) Paulo plays tennis and Kim plays golf.\n(C) Kim plays tennis and Paulo plays golf.\n(D) Paulo and Oliver play tennis, Paulo ranking higher than Oliver.\n(E) Maricella and Shigeru play tennis, Maricella ranking higher than Shigeru.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Kim', 'Lina', 'Maricella', 'Oliver', 'Paulo', 'Shigeru']\nsports = ['golf', 'tennis']\n\n# Map people to indices\nidx = {p: i for i, p in enumerate(people)}\n\n# Variables for sports: 0 for golf, 1 for tennis\nsport = {p: Int(p + '_sport') for p in people}\n\n# Variables for ranks within golf and tennis\n# Rank is Int, 1 is highest, larger number is lower rank\n# If only one player in sport, rank = 1\nrank_golf = {p: Int(p + '_rank_golf') for p in people}\nrank_tennis = {p: Int(p + '_rank_tennis') for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each sport variable is 0 (golf) or 1 (tennis)\nfor p in people:\n    solver.add(Or(sport[p] == 0, sport[p] == 1))\n\n# Oliver plays tennis\nsolver.add(sport['Oliver'] == 1)\n\n# Lina plays golf\nsolver.add(sport['Lina'] == 0)\n\n# Collect golf players and tennis players lists dynamically for constraints\n# We cannot use Python lists for Z3, so we create indicator variables for each person for golf and tennis\ngolf_players = [Bool(p + '_golf') for p in people]\ntennis_players = [Bool(p + '_tennis') for p in people]\n\nfor i, p in enumerate(people):\n    solver.add(golf_players[i] == (sport[p] == 0))\n    solver.add(tennis_players[i] == (sport[p] == 1))\n\n# Define golf count and tennis count as Int variables\ngolf_count = Int('golf_count')\ntennis_count = Int('tennis_count')\nsolver.add(golf_count == Sum([If(golf_players[i], 1, 0) for i in range(len(people))]))\nsolver.add(tennis_count == Sum([If(tennis_players[i], 1, 0) for i in range(len(people))]))\n\n# Rank variables constraints:\n# For each person:\n# If person plays golf, rank_golf[p] in [1, golf_count]\n# else rank_golf[p] == 0 (not ranked)\n# Similarly for tennis\nfor p in people:\n    # golf rank\n    solver.add(If(sport[p] == 0,\n                  And(rank_golf[p] >= 1, rank_golf[p] <= golf_count),\n                  rank_golf[p] == 0))\n    # tennis rank\n    solver.add(If(sport[p] == 1,\n                  And(rank_tennis[p] >= 1, rank_tennis[p] <= tennis_count),\n                  rank_tennis[p] == 0))\n\n# No ties in ranking for each sport if more than one player\n\n# For golf players, ranks are distinct and > 0\ngolf_rank_vars = [rank_golf[p] for p in people]\ngolf_ranked_players = [p for p in people if True]  # we will filter later using constraints\n# But we can't filter in Z3, so we enforce Distinct on ranks of golf players only if golf_count > 1\n\n# Similarly for tennis\n\n# To enforce distinct ranks among golf players:\n# For all pairs of people both playing golf, ranks must be distinct\nfor i in range(len(people)):\n    for j in range(i + 1, len(people)):\n        p1 = people[i]\n        p2 = people[j]\n        cond = And(sport[p1] == 0, sport[p2] == 0)\n        solver.add(Implies(cond, rank_golf[p1] != rank_golf[p2]))\n\n# For tennis:\nfor i in range(len(people)):\n    for j in range(i + 1, len(people)):\n        p1 = people[i]\n        p2 = people[j]\n        cond = And(sport[p1] == 1, sport[p2] == 1)\n        solver.add(Implies(cond, rank_tennis[p1] != rank_tennis[p2]))\n\n# There is no golf player ranked higher than Lina.\n# Lina plays golf and has rank rank_golf['Lina']\n# So for every golf player p: rank_golf[p] >= rank_golf['Lina']\n# because higher rank means smaller number, so \"no golf player ranked higher than Lina\" means\n# no golf player has rank less than Lina's rank\nfor p in people:\n    cond = (sport[p] == 0)\n    solver.add(Implies(cond, rank_golf[p] >= rank_golf['Lina']))\n\n# If Maricella plays golf, then Paulo and Shigeru play golf,\n# Paulo ranking lower than Maricella but higher than Shigeru.\n# Note: \"ranking lower\" means larger rank number (because 1 is highest)\nm_golf = (sport['Maricella'] == 0)\np_golf = (sport['Paulo'] == 0)\ns_golf = (sport['Shigeru'] == 0)\nsolver.add(Implies(m_golf, And(p_golf, s_golf)))\nsolver.add(Implies(m_golf, rank_golf['Maricella'] < rank_golf['Paulo']))\nsolver.add(Implies(m_golf, rank_golf['Paulo'] < rank_golf['Shigeru']))\n\n# If Maricella plays tennis, then Shigeru plays tennis,\n# Shigeru ranking lower than Oliver but higher than Maricella.\nm_tennis = (sport['Maricella'] == 1)\ns_tennis = (sport['Shigeru'] == 1)\no_tennis = (sport['Oliver'] == 1)\nsolver.add(Implies(m_tennis, s_tennis))\nsolver.add(Implies(m_tennis, rank_tennis['Oliver'] < rank_tennis['Shigeru']))\nsolver.add(Implies(m_tennis, rank_tennis['Shigeru'] < rank_tennis['Maricella']))\n\n# If Paulo plays tennis, then Kim plays tennis,\n# Oliver ranking lower than Kim but higher than Paulo.\np_tennis = (sport['Paulo'] == 1)\nk_tennis = (sport['Kim'] == 1)\nsolver.add(Implies(p_tennis, k_tennis))\nsolver.add(Implies(p_tennis, rank_tennis['Kim'] < rank_tennis['Oliver']))\nsolver.add(Implies(p_tennis, rank_tennis['Oliver'] < rank_tennis['Paulo']))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Maricella plays tennis and Shigeru plays golf.\n    And(sport['Maricella'] == 1, sport['Shigeru'] == 0),\n\n    # (B) Paulo plays tennis and Kim plays golf.\n    And(sport['Paulo'] == 1, sport['Kim'] == 0),\n\n    # (C) Kim plays tennis and Paulo plays golf.\n    And(sport['Kim'] == 1, sport['Paulo'] == 0),\n\n    # (D) Paulo and Oliver play tennis, Paulo ranking higher than Oliver.\n    And(sport['Paulo'] == 1, sport['Oliver'] == 1, rank_tennis['Paulo'] < rank_tennis['Oliver']),\n\n    # (E) Maricella and Shigeru play tennis, Maricella ranking higher than Shigeru.\n    And(sport['Maricella'] == 1, sport['Shigeru'] == 1, rank_tennis['Maricella'] < rank_tennis['Shigeru'])\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.\n\nEach of the following could be the lowest-ranking tennis player EXCEPT:\n\nOptions:\n(A) Shigeru\n(B) Kim\n(C) Oliver\n(D) Paulo\n(E) Maricella",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nplayers = ['Kim', 'Lina', 'Maricella', 'Oliver', 'Paulo', 'Shigeru']\nsports = ['golf', 'tennis']\n\n# Variables: sport[player] = 0 for golf, 1 for tennis\nsport = {p: Int(p + '_sport') for p in players}\n\n# Ranking variables for golf and tennis players separately\n# We'll assign ranks starting from 1 (highest) to n (lowest) for each sport\n# If a player doesn't play a sport, rank is 0\ngolf_rank = {p: Int(p + '_golf_rank') for p in players}\ntennis_rank = {p: Int(p + '_tennis_rank') for p in players}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each player plays exactly one sport: 0 for golf, 1 for tennis\nfor p in players:\n    solver.add(Or(sport[p] == 0, sport[p] == 1))\n\n# Rankings: If player plays golf, golf_rank[p] >= 1, else 0\n# Similarly for tennis_rank\nfor p in players:\n    solver.add(If(sport[p] == 0, And(golf_rank[p] >= 1, golf_rank[p] <= 6), golf_rank[p] == 0))\n    solver.add(If(sport[p] == 1, And(tennis_rank[p] >= 1, tennis_rank[p] <= 6), tennis_rank[p] == 0))\n\n# For each sport, ranks are distinct among players who play that sport\ngolf_players = [p for p in players]\ntennis_players = [p for p in players]\n\n# Collect golf ranks of golf players (exclude zeros)\ngolf_ranks_list = [golf_rank[p] for p in players]\ntennis_ranks_list = [tennis_rank[p] for p in players]\n\n# Distinctness constraints for ranks within each sport (only for ranks > 0)\n# So we must add that ranks > 0 are distinct\n# Extract golf ranks for players who play golf\ngolf_ranks_nonzero = [golf_rank[p] for p in players]\ntennis_ranks_nonzero = [tennis_rank[p] for p in players]\n\n# Add distinctness of ranks for golf players who play golf\ngolf_players_playing = [p for p in players]\ngolf_playing_vars = [If(sport[p] == 0, golf_rank[p], 0) for p in players]\ntennis_playing_vars = [If(sport[p] == 1, tennis_rank[p], 0) for p in players]\n\n# We'll create lists of ranks > 0 for golf and tennis players\n# Collect golf ranks > 0\ngolf_ranks_gt0 = [golf_rank[p] for p in players if True]\ntennis_ranks_gt0 = [tennis_rank[p] for p in players if True]\n\n# But we want only ranks of players who play that sport\ngolf_ranks_filtered = [golf_rank[p] for p in players]\ntennis_ranks_filtered = [tennis_rank[p] for p in players]\n\n# We'll add the distinctness constraints with conditional filtering\n\n# For golf:\n# Create list of golf ranks for players who play golf\ngolf_ranks_for_distinct = []\nfor p in players:\n    golf_ranks_for_distinct.append(If(sport[p] == 0, golf_rank[p], 0))\n# For tennis:\ntennis_ranks_for_distinct = []\nfor p in players:\n    tennis_ranks_for_distinct.append(If(sport[p] == 1, tennis_rank[p], 0))\n\n# To enforce distinctness only on ranks > 0, we do:\n# For golf: For all i != j, if both ranks > 0, then ranks are distinct\nfor i in range(len(players)):\n    for j in range(i + 1, len(players)):\n        pi = players[i]\n        pj = players[j]\n        cond = And(sport[pi] == 0, sport[pj] == 0)\n        solver.add(Implies(cond, golf_rank[pi] != golf_rank[pj]))\n\n# For tennis:\nfor i in range(len(players)):\n    for j in range(i + 1, len(players)):\n        pi = players[i]\n        pj = players[j]\n        cond = And(sport[pi] == 1, sport[pj] == 1)\n        solver.add(Implies(cond, tennis_rank[pi] != tennis_rank[pj]))\n\n# Now encode the given conditions:\n\n# Oliver plays tennis.\nsolver.add(sport['Oliver'] == 1)\n\n# Lina plays golf.\nsolver.add(sport['Lina'] == 0)\n\n# There is no golf player ranked higher than Lina.\n# Lina has golf_rank >= 1 if she plays golf (she does), so golf_rank[Lina] is minimal among golf players.\n# So for all golf players p, golf_rank[p] >= golf_rank[Lina]\nfor p in players:\n    cond = sport[p] == 0\n    solver.add(Implies(cond, golf_rank[p] >= golf_rank['Lina']))\n\n# If Maricella plays golf, then Paulo and Shigeru play golf,\n# Paulo ranking lower than Maricella but higher than Shigeru.\nsolver.add(Implies(sport['Maricella'] == 0,\n                   And(\n                       sport['Paulo'] == 0,\n                       sport['Shigeru'] == 0,\n                       golf_rank['Maricella'] < golf_rank['Paulo'],\n                       golf_rank['Paulo'] < golf_rank['Shigeru']\n                   )))\n\n# If Maricella plays tennis, then Shigeru plays tennis,\n# Shigeru ranking lower than Oliver but higher than Maricella.\nsolver.add(Implies(sport['Maricella'] == 1,\n                   And(\n                       sport['Shigeru'] == 1,\n                       tennis_rank['Oliver'] < tennis_rank['Shigeru'],\n                       tennis_rank['Shigeru'] < tennis_rank['Maricella']\n                   )))\n\n# If Paulo plays tennis, then Kim plays tennis,\n# Oliver ranking lower than Kim but higher than Paulo.\nsolver.add(Implies(sport['Paulo'] == 1,\n                   And(\n                       sport['Kim'] == 1,\n                       tennis_rank['Oliver'] > tennis_rank['Kim'],\n                       tennis_rank['Oliver'] < tennis_rank['Paulo']\n                   )))\n\n# Additional constraints: ranks start at 1 and go up to number of players playing that sport\n# Count number of golf players and tennis players\nnum_golf_players = Int('num_golf_players')\nnum_tennis_players = Int('num_tennis_players')\n\nsolver.add(num_golf_players == Sum([If(sport[p] == 0, 1, 0) for p in players]))\nsolver.add(num_tennis_players == Sum([If(sport[p] == 1, 1, 0) for p in players]))\n\nfor p in players:\n    # golf_rank[p] <= num_golf_players if plays golf\n    solver.add(Implies(sport[p] == 0, golf_rank[p] <= num_golf_players))\n    # tennis_rank[p] <= num_tennis_players if plays tennis\n    solver.add(Implies(sport[p] == 1, tennis_rank[p] <= num_tennis_players))\n\n# OPTION CHECKING\n\noptions = ['Shigeru', 'Kim', 'Oliver', 'Paulo', 'Maricella']\n\n# We want to find which option CANNOT be the lowest-ranking tennis player\n# So for each option, we check if it's possible that this player has the highest tennis rank among tennis players\n\nfor i, candidate in enumerate(options):\n    solver.push()\n    # Add constraint: candidate plays tennis\n    solver.add(sport[candidate] == 1)\n    # candidate has the lowest tennis rank (highest number)\n    # For all other tennis players p != candidate: tennis_rank[p] < tennis_rank[candidate]\n    others = [p for p in players if p != candidate]\n    conds = []\n    for p in others:\n        cond = Implies(sport[p] == 1, tennis_rank[p] < tennis_rank[candidate])\n        conds.append(cond)\n    solver.add(And(conds))\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        # This candidate cannot be lowest-ranking tennis player\n        print(\"'\" + chr(65 + i) + \"'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.\n\nIf Oliver is the highest-ranking tennis player, which one of the following must be true?\n\nOptions:\n(A) Oliver and Maricella play the same sport as each other.\n(B) Paulo and Lina play the same sport as each other.\n(C) Paulo and Oliver play the same sport as each other.\n(D) Kim and Lina do not play the same sport as each other.\n(E) Kim and Paulo do not play the same sport as each other.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Kim', 'Lina', 'Maricella', 'Oliver', 'Paulo', 'Shigeru']\nsports = ['golf', 'tennis']\n\n# Map people to Int variables representing their sport: 0 for golf, 1 for tennis\nsport = {p: Int(p) for p in people}\n\n# Ranking variables for golf and tennis players:\n# Since ranking only applies if sport has more than one player,\n# we create ranking Int variables for each person, with domain 1..6\n# If person does not play the sport, rank is 0\ngolf_rank = {p: Int(f'golf_rank_{p}') for p in people}\ntennis_rank = {p: Int(f'tennis_rank_{p}') for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person plays exactly one sport: 0 (golf) or 1 (tennis)\nfor p in people:\n    solver.add(Or(sport[p] == 0, sport[p] == 1))\n\n# Oliver plays tennis\nsolver.add(sport['Oliver'] == 1)\n\n# Lina plays golf\nsolver.add(sport['Lina'] == 0)\n\n# Ranking constraints: rank in 1..number_of_players_in_that_sport; 0 if not playing that sport\n# For golf_rank:\nfor p in people:\n    # golf_rank[p] = 0 if not golf player\n    solver.add(If(sport[p] == 0, And(golf_rank[p] >= 1, golf_rank[p] <= 6), golf_rank[p] == 0))\n# For tennis_rank:\nfor p in people:\n    # tennis_rank[p] = 0 if not tennis player\n    solver.add(If(sport[p] == 1, And(tennis_rank[p] >= 1, tennis_rank[p] <= 6), tennis_rank[p] == 0))\n\n# If a sport is played by more than one person, those players are ranked with no ties\n# So golf players have distinct golf_rank > 0\ngolf_players = [p for p in people]\ngolf_ranks_vars = [golf_rank[p] for p in golf_players]\ngolf_playing = [sport[p] == 0 for p in golf_players]\n# Number of golf players:\ngolf_count = Int('golf_count')\nsolver.add(golf_count == Sum([If(cond, 1, 0) for cond in golf_playing]))\n# If golf_count > 1 then golf_rank of golf players are distinct and all > 0\nsolver.add(If(golf_count > 1,\n              Distinct([golf_rank[p] for p in golf_players if True]),  # we will filter below\n              True))\n# But Distinct must be on golf players only\n# So we add Distinct on golf_rank[p] for p with sport[p]==0\ngolf_ranks_for_distinct = [golf_rank[p] for p in people]\ngolf_players_bool = [sport[p] == 0 for p in people]\n# We add a constraint that ranks of non-golf players are 0, so Distinct only applies to golf players\n# So Distinct on golf_rank[p] for p in people with sport[p]==0\n# We do this by adding a Distinct on all golf_rank[p], but since non-golf ranks are 0, they don't conflict\nsolver.add(If(golf_count > 1,\n              Distinct([golf_rank[p] for p in people if True]), True))\n# But this is not enough because 0 repeated many times is not distinct\n# So we add that golf_rank[p] > 0 only if sport[p]==0, else 0\n# Already done above\n\n# Similarly for tennis:\ntennis_players = [p for p in people]\ntennis_playing = [sport[p] == 1 for p in tennis_players]\ntennis_count = Int('tennis_count')\nsolver.add(tennis_count == Sum([If(cond, 1, 0) for cond in tennis_playing]))\nsolver.add(If(tennis_count > 1,\n              Distinct([tennis_rank[p] for p in people if True]), True))\n\n# There is no golf player ranked higher than Lina\n# Lina plays golf, so Lina's golf_rank is defined and > 0\n# No golf player has golf_rank less than Lina's golf_rank (since 1 is highest)\nfor p in people:\n    if p != 'Lina':\n        # If p plays golf, golf_rank[p] >= golf_rank['Lina']\n        solver.add(Implies(sport[p] == 0, golf_rank[p] >= golf_rank['Lina']))\n\n# If Maricella plays golf:\n# then Paulo and Shigeru play golf,\n# Paulo ranking lower than Maricella but higher than Shigeru.\nM_golf = sport['Maricella'] == 0\nsolver.add(Implies(M_golf, sport['Paulo'] == 0))\nsolver.add(Implies(M_golf, sport['Shigeru'] == 0))\n# Ranking: Paulo lower than Maricella but higher than Shigeru means:\n# Maricella rank < Paulo rank < Shigeru rank (numerically)\n# Because 1 is highest rank, higher number means lower rank\nsolver.add(Implies(M_golf, golf_rank['Maricella'] < golf_rank['Paulo']))\nsolver.add(Implies(M_golf, golf_rank['Paulo'] < golf_rank['Shigeru']))\n\n# If Maricella plays tennis:\n# then Shigeru plays tennis,\n# Shigeru ranking lower than Oliver but higher than Maricella.\nM_tennis = sport['Maricella'] == 1\nsolver.add(Implies(M_tennis, sport['Shigeru'] == 1))\n# Ranking: Oliver rank < Shigeru rank < Maricella rank (numerically)\nsolver.add(Implies(M_tennis, tennis_rank['Oliver'] < tennis_rank['Shigeru']))\nsolver.add(Implies(M_tennis, tennis_rank['Shigeru'] < tennis_rank['Maricella']))\n\n# If Paulo plays tennis:\n# then Kim plays tennis,\n# Oliver ranking lower than Kim but higher than Paulo.\nP_tennis = sport['Paulo'] == 1\nsolver.add(Implies(P_tennis, sport['Kim'] == 1))\nsolver.add(Implies(P_tennis, tennis_rank['Oliver'] > tennis_rank['Kim']))  # Oliver ranking lower than Kim means Oliver rank number > Kim rank number\nsolver.add(Implies(P_tennis, tennis_rank['Oliver'] < tennis_rank['Paulo']))\n\n# If a sport is played by more than one person, rankings are distinct and from 1..number_of_players_in_that_sport\n# We added Distinct for golf and tennis ranks above\n\n# Additional constraint: If sport count is 1, ranking is 1 for that player\n# For golf:\nfor p in people:\n    solver.add(Implies(golf_count == 1, If(sport[p] == 0, golf_rank[p] == 1, golf_rank[p] == 0)))\n# For tennis:\nfor p in people:\n    solver.add(Implies(tennis_count == 1, If(sport[p] == 1, tennis_rank[p] == 1, tennis_rank[p] == 0)))\n\n# Constraint: Oliver is the highest-ranking tennis player\n# Highest ranking means tennis_rank[Oliver] == 1 (lowest number)\nsolver.add(tennis_rank['Oliver'] == 1)\n\n# OPTION CHECKING\n\noptions = {\n    'A': sport['Oliver'] == sport['Maricella'],\n    'B': sport['Paulo'] == sport['Lina'],\n    'C': sport['Paulo'] == sport['Oliver'],\n    'D': sport['Kim'] != sport['Lina'],\n    'E': sport['Kim'] != sport['Paulo'],\n}\n\nfor opt_letter, opt_condition in options.items():\n    solver.push()\n    solver.add(Not(opt_condition))  # Check if option can be false\n    if solver.check() == unsat:\n        # option must be true\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each of six people—Kim, Lina, Maricella, Oliver, Paulo, and Shigeru—plays exactly one of two sports—golf, and tennis. If a sport is played by more than one of the six people, then the people who play that sport are ranked in order of ability from highest to lowest, with no ties. The following conditions must apply: Oliver plays tennis. Lina plays golf. There is no golf player ranked higher than Lina. If Maricella plays golf, then Paulo and Shigeru play golf, Paulo ranking lower than Maricella but higher than Shigeru. If Maricella plays tennis, then Shigeru plays tennis, Shigeru ranking lower than Oliver but higher than Maricella. If Paulo plays tennis, then Kim plays tennis, Oliver ranking lower than Kim but higher than Paulo.\n\nSuppose that the condition is added that Shigeru and Paulo do not play the same sport as each other. If all the other conditions remain in effect, then each of the following could be true EXCEPT:\n\nOptions:\n(A) Maricella and Kim play the same sport as each other.\n(B) Paulo and Kim play the same sport as each other.\n(C) Paulo and Maricella play the same sport as each other.\n(D) Kim and Paulo do not play the same sport as each other.\n(E) Maricella and Kim do not play the same sport as each other.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Kim', 'Lina', 'Maricella', 'Oliver', 'Paulo', 'Shigeru']\nsports = ['Golf', 'Tennis']\n\n# Map people to sport variables: 0 for Golf, 1 for Tennis\nsport = {p: Int(p) for p in people}\n\n# Ranking variables for Golf and Tennis players\n# Rankings start from 1 (highest) to number of players in that sport\n# We don't know how many players per sport, so max rank is 6\nrank_golf = {p: Int(f\"rank_golf_{p}\") for p in people}\nrank_tennis = {p: Int(f\"rank_tennis_{p}\") for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person plays exactly one sport (0 or 1)\nfor p in people:\n    solver.add(Or(sport[p] == 0, sport[p] == 1))\n\n# Oliver plays tennis\nsolver.add(sport['Oliver'] == 1)\n\n# Lina plays golf\nsolver.add(sport['Lina'] == 0)\n\n# If a sport has more than one player, the players are ranked from highest (1) to lowest (n), no ties\n# For each sport, collect players and add ranking constraints\n\n# Define helper functions to model ranking constraints\ndef ranking_constraints(sport_id):\n    # List of players who play this sport\n    players = [p for p in people]\n    # rank variables for players who play this sport: rank_sport[p]\n    if sport_id == 0:\n        rank = rank_golf\n    else:\n        rank = rank_tennis\n\n    # Players who play the sport have rank >=1 and <= number of players in that sport\n    # To model number of players, we count number of players playing sport_id\n    # sum of (sport[p] == sport_id)\n    # Since Z3 does not allow counting easily, we approximate by:\n    # For each player playing sport_id: rank in [1..6]\n    for p in people:\n        solver.add(Implies(sport[p] == sport_id, And(rank[p] >= 1, rank[p] <= 6)))\n        solver.add(Implies(sport[p] != sport_id, rank[p] == 0))  # rank 0 means not playing this sport\n\n    # For players playing this sport, ranks are distinct\n    players_in_sport = [rank[p] for p in people if True]  # We will filter below\n    # But we can't filter at solver.add time, so we add pairwise constraints:\n    for p1 in people:\n        for p2 in people:\n            if p1 < p2:\n                solver.add(Implies(And(sport[p1] == sport_id, sport[p2] == sport_id), rank[p1] != rank[p2]))\n\nranking_constraints(0)\nranking_constraints(1)\n\n# There is no golf player ranked higher than Lina.\n# Lina plays golf, so Lina's golf rank is minimal (1)\nsolver.add(rank_golf['Lina'] == 1)\n\n# If Maricella plays golf, then Paulo and Shigeru play golf,\n# Paulo ranking lower than Maricella but higher than Shigeru.\nsolver.add(Implies(sport['Maricella'] == 0,\n                   And(sport['Paulo'] == 0,\n                       sport['Shigeru'] == 0,\n                       rank_golf['Paulo'] > rank_golf['Maricella'],\n                       rank_golf['Paulo'] < rank_golf['Shigeru'])))\n\n# If Maricella plays tennis, then Shigeru plays tennis,\n# Shigeru ranking lower than Oliver but higher than Maricella.\nsolver.add(Implies(sport['Maricella'] == 1,\n                   And(sport['Shigeru'] == 1,\n                       rank_tennis['Shigeru'] > rank_tennis['Oliver'],\n                       rank_tennis['Shigeru'] < rank_tennis['Maricella'])))\n\n# If Paulo plays tennis, then Kim plays tennis,\n# Oliver ranking lower than Kim but higher than Paulo.\nsolver.add(Implies(sport['Paulo'] == 1,\n                   And(sport['Kim'] == 1,\n                       rank_tennis['Oliver'] > rank_tennis['Kim'],\n                       rank_tennis['Oliver'] < rank_tennis['Paulo'])))\n\n# Additional condition: Shigeru and Paulo do not play the same sport\nsolver.add(sport['Shigeru'] != sport['Paulo'])\n\n# OPTION CHECKING\n# Options:\n# (A) Maricella and Kim play the same sport as each other.\n# (B) Paulo and Kim play the same sport as each other.\n# (C) Paulo and Maricella play the same sport as each other.\n# (D) Kim and Paulo do not play the same sport as each other.\n# (E) Maricella and Kim do not play the same sport as each other.\n\noptions = {\n    'A': sport['Maricella'] == sport['Kim'],\n    'B': sport['Paulo'] == sport['Kim'],\n    'C': sport['Paulo'] == sport['Maricella'],\n    'D': sport['Kim'] != sport['Paulo'],\n    'E': sport['Maricella'] != sport['Kim'],\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A disc jockey will play a sequence consisting of exactly seven different songs: three ballads—F, G, and H—and four dance tunes—R, S, V, and X. The following conditions must be met: No dance tune can be played immediately after another dance tune. H must be played earlier in the sequence than V. V and S must be separated from each other by exactly one song. S must be played immediately before or immediately after F. F must be played immediately after R, unless G is played earlier than R.\n\nWhich one of the following could be the order of the songs in the sequence?\n\nOptions:\n(A) G, H, S, X, V, F, R\n(B) R, H, X, G, S, F, V\n(C) S, F, X, G, R, H, V\n(D) V, F, S, H, X, G, R\n(E) X, G, R, H, S, F, V",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsongs = ['F', 'G', 'H', 'R', 'S', 'V', 'X']\nindices = {s: Int(s) for s in songs}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each song position is between 0 and 6 (7 songs total)\nfor s in songs:\n    solver.add(indices[s] >= 0, indices[s] < 7)\n\n# All songs have distinct positions\nsolver.add(Distinct([indices[s] for s in songs]))\n\n# No dance tune can be played immediately after another dance tune\n# Dance tunes: R, S, V, X\ndance = ['R', 'S', 'V', 'X']\n# For every pair of dance tunes, they cannot be adjacent\nfor i in range(len(dance)):\n    for j in range(i + 1, len(dance)):\n        diff = Abs(indices[dance[i]] - indices[dance[j]])\n        solver.add(diff != 1)\n\n# H must be played earlier than V\nsolver.add(indices['H'] < indices['V'])\n\n# V and S must be separated from each other by exactly one song\ndiff_vs = Abs(indices['V'] - indices['S'])\nsolver.add(diff_vs == 2)\n\n# S must be played immediately before or immediately after F\ndiff_sf = Abs(indices['S'] - indices['F'])\nsolver.add(diff_sf == 1)\n\n# F must be played immediately after R, unless G is played earlier than R\n# That is, if G is NOT earlier than R, then F is immediately after R\n# So: If not (G < R) then F = R + 1\n# Equivalent: Or(G < R, F == R + 1)\nsolver.add(Or(indices['G'] < indices['R'], indices['F'] == indices['R'] + 1))\n\n# OPTION CHECKING\noptions = [\n    ['G', 'H', 'S', 'X', 'V', 'F', 'R'],  # A\n    ['R', 'H', 'X', 'G', 'S', 'F', 'V'],  # B\n    ['S', 'F', 'X', 'G', 'R', 'H', 'V'],  # C\n    ['V', 'F', 'S', 'H', 'X', 'G', 'R'],  # D\n    ['X', 'G', 'R', 'H', 'S', 'F', 'V']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that the order matches the option\n    # For each song, its index must be the position in the option list\n    for pos, song in enumerate(option):\n        solver.add(indices[song] == pos)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A disc jockey will play a sequence consisting of exactly seven different songs: three ballads—F, G, and H—and four dance tunes—R, S, V, and X. The following conditions must be met: No dance tune can be played immediately after another dance tune. H must be played earlier in the sequence than V. V and S must be separated from each other by exactly one song. S must be played immediately before or immediately after F. F must be played immediately after R, unless G is played earlier than R.\n\nWhich one of the following must be true about the sequence?\n\nOptions:\n(A) The first song is X.\n(B) The fifth song is S.\n(C) No ballad is played immediately after a dance tune.\n(D) No ballad is played immediately after another ballad.\n(E) No dance tune is played immediately after a ballad.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsongs = ['F', 'G', 'H', 'R', 'S', 'V', 'X']\nballads = ['F', 'G', 'H']\ndance_tunes = ['R', 'S', 'V', 'X']\n\n# Create Int variables for positions of each song (1-based indexing)\npositions = {s: Int(s) for s in songs}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are between 1 and 7\nfor s in songs:\n    solver.add(And(positions[s] >= 1, positions[s] <= 7))\n\n# All positions are distinct\nsolver.add(Distinct([positions[s] for s in songs]))\n\n# No dance tune can be played immediately after another dance tune\n# For all pairs of dance tunes (d1,d2), if position[d2] == position[d1] + 1 then false\nfor d1 in dance_tunes:\n    for d2 in dance_tunes:\n        if d1 != d2:\n            solver.add(positions[d2] != positions[d1] + 1)\n\n# H must be played earlier than V\nsolver.add(positions['H'] < positions['V'])\n\n# V and S must be separated by exactly one song\n# |positions[V] - positions[S]| == 2\ndiff_VS = If(positions['V'] > positions['S'], positions['V'] - positions['S'], positions['S'] - positions['V'])\nsolver.add(diff_VS == 2)\n\n# S must be played immediately before or immediately after F\nsolver.add(Or(positions['S'] == positions['F'] + 1, positions['S'] == positions['F'] - 1))\n\n# F must be played immediately after R, unless G is played earlier than R\n# This means:\n# If positions[G] < positions[R] then no constraint on F and R\n# Else positions[F] == positions[R] + 1\ncond_G_before_R = positions['G'] < positions['R']\nsolver.add(Implies(Not(cond_G_before_R), positions['F'] == positions['R'] + 1))\n\n# OPTION CHECKING\noptions = [\n    # (A) The first song is X\n    positions['X'] == 1,\n    # (B) The fifth song is S\n    positions['S'] == 5,\n    # (C) No ballad is played immediately after a dance tune\n    # For all pairs (d,b) with d in dance_tunes, b in ballads,\n    # positions[b] != positions[d] + 1\n    And([positions[b] != positions[d] + 1 for d in dance_tunes for b in ballads]),\n    # (D) No ballad is played immediately after another ballad\n    # For all pairs (b1,b2) with b1 != b2 in ballads,\n    # positions[b2] != positions[b1] + 1\n    And([positions[b2] != positions[b1] + 1 for b1 in ballads for b2 in ballads if b1 != b2]),\n    # (E) No dance tune is played immediately after a ballad\n    # For all pairs (b,d) with b in ballads, d in dance_tunes,\n    # positions[d] != positions[b] + 1\n    And([positions[d] != positions[b] + 1 for b in ballads for d in dance_tunes])\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A disc jockey will play a sequence consisting of exactly seven different songs: three ballads—F, G, and H—and four dance tunes—R, S, V, and X. The following conditions must be met: No dance tune can be played immediately after another dance tune. H must be played earlier in the sequence than V. V and S must be separated from each other by exactly one song. S must be played immediately before or immediately after F. F must be played immediately after R, unless G is played earlier than R.\n\nWhich one of the following could be the fourth song in the sequence?\n\nOptions:\n(A) G\n(B) R\n(C) S\n(D) V\n(E) X",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsongs = ['F', 'G', 'H', 'R', 'S', 'V', 'X']\nballads = ['F', 'G', 'H']\ndance = ['R', 'S', 'V', 'X']\n\npositions = list(range(7))\n\n# Create a Z3 Int variable for each song representing its position (0-based)\npos = {s: Int(s) for s in songs}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each song position is between 0 and 6\nfor s in songs:\n    solver.add(And(pos[s] >= 0, pos[s] < 7))\n\n# 2) All songs have distinct positions\nsolver.add(Distinct([pos[s] for s in songs]))\n\n# 3) No dance tune can be played immediately after another dance tune.\n# For every pair of dance songs s1 and s2, if pos[s2] == pos[s1] + 1, then s1 and s2 cannot both be dance tunes.\n# So no two dance tunes are adjacent.\n# This means for every pair of dance songs s1 != s2: abs(pos[s1] - pos[s2]) != 1\n\nfor i in range(len(dance)):\n    for j in range(i+1, len(dance)):\n        s1 = dance[i]\n        s2 = dance[j]\n        diff = Abs(pos[s1] - pos[s2])\n        solver.add(diff != 1)\n\n# 4) H must be played earlier than V\nsolver.add(pos['H'] < pos['V'])\n\n# 5) V and S must be separated by exactly one song\n# i.e. abs(pos[V] - pos[S]) == 2\nsolver.add(Abs(pos['V'] - pos['S']) == 2)\n\n# 6) S must be played immediately before or immediately after F\n# i.e. abs(pos[S] - pos[F]) == 1\nsolver.add(Abs(pos['S'] - pos['F']) == 1)\n\n# 7) F must be played immediately after R, unless G is played earlier than R.\n# i.e. If G is not earlier than R, then pos[F] == pos[R] + 1\n# So: (pos[G] < pos[R]) OR (pos[F] == pos[R] + 1)\n\nsolver.add(Or(pos['G'] < pos['R'], pos['F'] == pos['R'] + 1))\n\n# OPTION CHECKING\n# Check which option can be the 4th song (position 3)\noptions = ['G', 'R', 'S', 'V', 'X']\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(pos[option] == 3)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A disc jockey will play a sequence consisting of exactly seven different songs: three ballads—F, G, and H—and four dance tunes—R, S, V, and X. The following conditions must be met: No dance tune can be played immediately after another dance tune. H must be played earlier in the sequence than V. V and S must be separated from each other by exactly one song. S must be played immediately before or immediately after F. F must be played immediately after R, unless G is played earlier than R.\n\nIf the third song in the sequence is S, which one of the following must be the sixth song?\n\nOptions:\n(A) G\n(B) H\n(C) R\n(D) V\n(E) X",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsongs = ['F', 'G', 'H', 'R', 'S', 'V', 'X']\nindices = {song: i for i, song in enumerate(songs)}\n\n# Create Int variables representing the position (0 to 6) of each song in the sequence\npos = {song: Int(song) for song in songs}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each song position is between 0 and 6\nfor song in songs:\n    solver.add(And(pos[song] >= 0, pos[song] <= 6))\n\n# All positions are distinct (each song appears exactly once)\nsolver.add(Distinct([pos[song] for song in songs]))\n\n# No dance tune can be played immediately after another dance tune\ndance_tunes = ['R', 'S', 'V', 'X']\n# For all pairs of dance tunes, their positions cannot be consecutive with the first immediately before the second\nfor d1 in dance_tunes:\n    for d2 in dance_tunes:\n        if d1 != d2:\n            solver.add(pos[d2] - pos[d1] != 1)\n\n# H must be played earlier than V\nsolver.add(pos['H'] < pos['V'])\n\n# V and S must be separated by exactly one song\ndiff_VS = Abs(pos['V'] - pos['S'])\nsolver.add(diff_VS == 2)\n\n# S must be played immediately before or immediately after F\ndiff_SF = Abs(pos['S'] - pos['F'])\nsolver.add(Or(diff_SF == 1))\n\n# F must be played immediately after R, unless G is played earlier than R\n# This means:\n# If G is not earlier than R (i.e. pos['G'] >= pos['R']), then pos['F'] == pos['R'] + 1\n# Otherwise, no restriction on F and R\ng_earlier_than_r = pos['G'] < pos['R']\nf_immediately_after_r = pos['F'] == pos['R'] + 1\nsolver.add(Or(g_earlier_than_r, f_immediately_after_r))\n\n# The third song in the sequence is S\nsolver.add(pos['S'] == 2)\n\n# OPTION CHECKING\noptions = ['G', 'H', 'R', 'V', 'X']\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(pos[option] == 5)  # sixth song means position 5 (0-based indexing)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A disc jockey will play a sequence consisting of exactly seven different songs: three ballads—F, G, and H—and four dance tunes—R, S, V, and X. The following conditions must be met: No dance tune can be played immediately after another dance tune. H must be played earlier in the sequence than V. V and S must be separated from each other by exactly one song. S must be played immediately before or immediately after F. F must be played immediately after R, unless G is played earlier than R.\n\nIf the seventh song in the sequence is R, which one of the following could be the fifth song?\n\nOptions:\n(A) F\n(B) G\n(C) H\n(D) V\n(E) X",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nsongs = ['F', 'G', 'H', 'R', 'S', 'V', 'X']\nsong_indices = {song: i for i, song in enumerate(songs)}\n\n# Positions 0 to 6 represent the sequence order\npositions = list(range(7))\n\n# Create Int variables for each position representing the song played there\nseq = [Int(f'seq_{i}') for i in positions]\n\n# Helper: dance tunes and ballads sets\ndance_tunes = {song_indices[s] for s in ['R', 'S', 'V', 'X']}\nballads = {song_indices[s] for s in ['F', 'G', 'H']}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each position must be assigned a valid song index\nfor pos in positions:\n    solver.add(And(seq[pos] >= 0, seq[pos] < len(songs)))\n\n# All songs are different (exactly seven different songs)\nsolver.add(Distinct(seq))\n\n# No dance tune can be played immediately after another dance tune\nfor pos in range(6):\n    curr = seq[pos]\n    nxt = seq[pos + 1]\n    curr_is_dance = Or([curr == dt for dt in dance_tunes])\n    nxt_is_dance = Or([nxt == dt for dt in dance_tunes])\n    # If current is dance, next is not dance\n    solver.add(Implies(curr_is_dance, Not(nxt_is_dance)))\n\n# H must be played earlier than V\n# Find positions of H and V\n# We can create Int variables for positions of each song to make constraints easier\npos_of = {}\nfor song in songs:\n    pos_of[song] = Int(f'pos_{song}')\n    solver.add(And(pos_of[song] >= 0, pos_of[song] < 7))\n\n# Link pos_of variables with seq variables\nfor song in songs:\n    # pos_of[song] is the index i where seq[i] == song_indices[song]\n    # For each position i, seq[i] == song_indices[song] iff pos_of[song] == i\n    # So for each song, pos_of[song] == i iff seq[i] == song_indices[song]\n    # We encode this using the following constraints:\n    # For all i: (pos_of[song] == i) <-> (seq[i] == song_indices[song])\n    # This can be done by:\n    # pos_of[song] == i => seq[i] == song_indices[song]\n    # and\n    # seq[i] == song_indices[song] => pos_of[song] == i\n    for i in positions:\n        solver.add(Implies(pos_of[song] == i, seq[i] == song_indices[song]))\n        solver.add(Implies(seq[i] == song_indices[song], pos_of[song] == i))\n\n# H must be earlier than V\nsolver.add(pos_of['H'] < pos_of['V'])\n\n# V and S must be separated from each other by exactly one song\n# So |pos(V) - pos(S)| == 2\nsolver.add(Or(pos_of['V'] - pos_of['S'] == 2, pos_of['S'] - pos_of['V'] == 2))\n\n# S must be played immediately before or immediately after F\n# |pos(S) - pos(F)| == 1\nsolver.add(Or(pos_of['S'] - pos_of['F'] == 1, pos_of['F'] - pos_of['S'] == 1))\n\n# F must be played immediately after R, unless G is played earlier than R\n# This means:\n# If G is played earlier than R: no constraint on F and R\n# Else: F immediately after R (pos(F) == pos(R) + 1)\nG_before_R = pos_of['G'] < pos_of['R']\nF_immediately_after_R = pos_of['F'] == pos_of['R'] + 1\nsolver.add(Implies(Not(G_before_R), F_immediately_after_R))\n\n# The seventh song (position 6) is R\nsolver.add(seq[6] == song_indices['R'])\n\n# OPTION CHECKING\noptions = ['F', 'G', 'H', 'V', 'X']\n\nfor i, option_song in enumerate(options):\n    solver.push()\n    # The fifth song is at position 4 (0-based)\n    solver.add(seq[4] == song_indices[option_song])\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.\n\nWhich one of the following could be the assignment of students to benches?\n\nOptions:\n(A) 1: Frank, Victor; 2: Joan, Gwen; 3: Henry, Wanda; 4: Xavier, Yvette\n(B) 1: Gwen, Yvette; 2: Frank, Xavier; 3: Joan, Wanda; 4: Henry, Victor\n(C) 1: Henry, Wanda; 2: Gwen, Xavier; 3: Frank, Victor; 4: Joan, Yvette\n(D) 1: Henry, Xavier; 2: Joan, Wanda; 3: Frank, Victor; 4: Gwen, Yvette\n(E) 1: Henry, Yvette; 2: Gwen, Wanda; 3: Frank, Victor, 4: Joan, Xavier",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Frank', 'Gwen', 'Henry', 'Joan', 'Victor', 'Wanda', 'Xavier', 'Yvette']\nmajors = ['Frank', 'Gwen', 'Henry', 'Joan']\nnonmajors = ['Victor', 'Wanda', 'Xavier', 'Yvette']\nbenches = [1, 2, 3, 4]\n\n# Create a Z3 Int variable for each student representing their bench assignment\nbench_assignment = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student is assigned to exactly one bench (1 to 4)\nfor s in students:\n    solver.add(And(bench_assignment[s] >= 1, bench_assignment[s] <= 4))\n\n# Exactly two students per bench\n# Count number of students assigned to each bench\nfor b in benches:\n    count_bench = Sum([If(bench_assignment[s] == b, 1, 0) for s in students])\n    solver.add(count_bench == 2)\n\n# Exactly one major per bench\nfor b in benches:\n    count_major = Sum([If(bench_assignment[m] == b, 1, 0) for m in majors])\n    solver.add(count_major == 1)\n\n# Frank and Joan assigned to consecutive benches, Frank's bench number is lower\nsolver.add(bench_assignment['Joan'] == bench_assignment['Frank'] + 1)\n\n# Frank assigned to the same bench as Victor\nsolver.add(bench_assignment['Frank'] == bench_assignment['Victor'])\n\n# Gwen is not assigned to the same bench as Wanda\nsolver.add(bench_assignment['Gwen'] != bench_assignment['Wanda'])\n\n# OPTION CHECKING\noptions = {\n    'A': {'Frank': 1, 'Victor': 1, 'Joan': 2, 'Gwen': 2, 'Henry': 3, 'Wanda': 3, 'Xavier': 4, 'Yvette': 4},\n    'B': {'Gwen': 1, 'Yvette': 1, 'Frank': 2, 'Xavier': 2, 'Joan': 3, 'Wanda': 3, 'Henry': 4, 'Victor': 4},\n    'C': {'Henry': 1, 'Wanda': 1, 'Gwen': 2, 'Xavier': 2, 'Frank': 3, 'Victor': 3, 'Joan': 4, 'Yvette': 4},\n    'D': {'Henry': 1, 'Xavier': 1, 'Joan': 2, 'Wanda': 2, 'Frank': 3, 'Victor': 3, 'Gwen': 4, 'Yvette': 4},\n    'E': {'Henry': 1, 'Yvette': 1, 'Gwen': 2, 'Wanda': 2, 'Frank': 3, 'Victor': 3, 'Joan': 4, 'Xavier': 4}\n}\n\nfor letter, assignment in options.items():\n    solver.push()\n    # Add constraints for the option assignments\n    for s in students:\n        solver.add(bench_assignment[s] == assignment[s])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.\n\nIf Victor is assigned to bench 2 and Wanda is assigned to bench 4, which one of the following must be true?\n\nOptions:\n(A) Frank is assigned to bench 1.\n(B) Gwen is assigned to bench 1.\n(C) Henry is assigned to bench 3.\n(D) Xavier is assigned to bench 1.\n(E) Yvette is assigned to bench 3.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmajors = ['Frank', 'Gwen', 'Henry', 'Joan']\nnonmajors = ['Victor', 'Wanda', 'Xavier', 'Yvette']\nstudents = majors + nonmajors\nbenches = [1, 2, 3, 4]\n\n# Create a Z3 Int variable for each student representing their bench assignment\nbench_assign = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student assigned to a bench between 1 and 4\nfor s in students:\n    solver.add(And(bench_assign[s] >= 1, bench_assign[s] <= 4))\n\n# Exactly two students per bench\nfor b in benches:\n    assigned_to_b = [bench_assign[s] == b for s in students]\n    solver.add(Sum([If(cond, 1, 0) for cond in assigned_to_b]) == 2)\n\n# Exactly one major per bench\nfor b in benches:\n    major_assigned = [bench_assign[m] == b for m in majors]\n    solver.add(Sum([If(cond, 1, 0) for cond in major_assigned]) == 1)\n\n# Frank and Joan assigned to consecutive benches, Frank lower-numbered\nsolver.add(bench_assign['Joan'] == bench_assign['Frank'] + 1)\n\n# Frank assigned to same bench as Victor\nsolver.add(bench_assign['Frank'] == bench_assign['Victor'])\n\n# Gwen not assigned to same bench as Wanda\nsolver.add(bench_assign['Gwen'] != bench_assign['Wanda'])\n\n# Given: Victor assigned to bench 2, Wanda assigned to bench 4\nsolver.add(bench_assign['Victor'] == 2)\nsolver.add(bench_assign['Wanda'] == 4)\n\n# OPTION CHECKING\noptions = {\n    'A': bench_assign['Frank'] == 1,\n    'B': bench_assign['Gwen'] == 1,\n    'C': bench_assign['Henry'] == 3,\n    'D': bench_assign['Xavier'] == 1,\n    'E': bench_assign['Yvette'] == 3\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.\n\nIf Gwen and Henry are not assigned to consecutively numbered benches, which one of the following must be true?\n\nOptions:\n(A) Victor is assigned to bench 2.\n(B) Victor is assigned to bench 3.\n(C) Wanda is assigned to bench 1.\n(D) Wanda is assigned to bench 3.\n(E) Wanda is assigned to bench 4.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmajors = ['Frank', 'Gwen', 'Henry', 'Joan']\nnonmajors = ['Victor', 'Wanda', 'Xavier', 'Yvette']\nstudents = majors + nonmajors\nbenches = [1, 2, 3, 4]\n\n# Create Z3 Int variables for each student representing their bench assignment\nbench_assign = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student assigned to exactly one bench (1 to 4)\nfor s in students:\n    solver.add(And(bench_assign[s] >= 1, bench_assign[s] <= 4))\n\n# Each bench has exactly two students\nfor b in benches:\n    count_on_bench = Sum([If(bench_assign[s] == b, 1, 0) for s in students])\n    solver.add(count_on_bench == 2)\n\n# Exactly one major per bench\nfor b in benches:\n    count_majors = Sum([If(bench_assign[m] == b, 1, 0) for m in majors])\n    solver.add(count_majors == 1)\n\n# Frank and Joan assigned to consecutively numbered benches, Frank's bench lower\nsolver.add(bench_assign['Joan'] == bench_assign['Frank'] + 1)\n\n# Frank assigned to same bench as Victor\nsolver.add(bench_assign['Frank'] == bench_assign['Victor'])\n\n# Gwen not assigned to same bench as Wanda\nsolver.add(bench_assign['Gwen'] != bench_assign['Wanda'])\n\n# Gwen and Henry are NOT assigned to consecutively numbered benches\ndiff_gh = Abs(bench_assign['Gwen'] - bench_assign['Henry'])\nsolver.add(diff_gh != 1)\n\n# OPTION CHECKING\n\noptions = {\n    'A': bench_assign['Victor'] == 2,\n    'B': bench_assign['Victor'] == 3,\n    'C': bench_assign['Wanda'] == 1,\n    'D': bench_assign['Wanda'] == 3,\n    'E': bench_assign['Wanda'] == 4\n}\n\nfor letter, option_constraint in options.items():\n    solver.push()\n    solver.add(Not(option_constraint))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.\n\nIf Henry and Yvette are both assigned to bench 1, which one of the following could be true?\n\nOptions:\n(A) Gwen is assigned to bench 3.\n(B) Joan is assigned to bench 2.\n(C) Wanda is assigned to bench 2.\n(D) Wanda is assigned to bench 3.\n(E) Xavier is assigned to bench 3.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Frank', 'Gwen', 'Henry', 'Joan', 'Victor', 'Wanda', 'Xavier', 'Yvette']\nmajors = ['Frank', 'Gwen', 'Henry', 'Joan']\nnonmajors = ['Victor', 'Wanda', 'Xavier', 'Yvette']\nbenches = [1, 2, 3, 4]\n\n# Create Z3 Int variables for each student representing their bench assignment\nbench = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student is assigned to exactly one bench (bench number between 1 and 4)\nfor s in students:\n    solver.add(And(bench[s] >= 1, bench[s] <= 4))\n\n# Exactly two students per bench\nfor b in benches:\n    assigned_to_b = [bench[s] == b for s in students]\n    solver.add(Sum([If(cond, 1, 0) for cond in assigned_to_b]) == 2)\n\n# Exactly one major per bench\nfor b in benches:\n    major_assigned = [bench[m] == b for m in majors]\n    solver.add(Sum([If(cond, 1, 0) for cond in major_assigned]) == 1)\n\n# Frank and Joan are assigned to consecutively numbered benches, Frank's bench lower\nsolver.add(bench['Joan'] == bench['Frank'] + 1)\n\n# Frank is assigned to the same bench as Victor\nsolver.add(bench['Frank'] == bench['Victor'])\n\n# Gwen is not assigned to the same bench as Wanda\nsolver.add(bench['Gwen'] != bench['Wanda'])\n\n# Henry and Yvette are both assigned to bench 1\nsolver.add(bench['Henry'] == 1)\nsolver.add(bench['Yvette'] == 1)\n\n# OPTION CHECKING\noptions = {\n    'A': bench['Gwen'] == 3,\n    'B': bench['Joan'] == 2,\n    'C': bench['Wanda'] == 2,\n    'D': bench['Wanda'] == 3,\n    'E': bench['Xavier'] == 3\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.\n\nIf Gwen is assigned to bench 4 and Xavier is assigned to bench 3, then any one of the following could be true EXCEPT:\n\nOptions:\n(A) Gwen is assigned to the same bench as Yvette.\n(B) Henry is assigned to the same bench as Wanda.\n(C) Henry is assigned to the same bench as Xavier.\n(D) Joan is assigned to the same bench as Xavier.\n(E) Joan is assigned to the same bench as Yvette.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmajors = ['Frank', 'Gwen', 'Henry', 'Joan']\nnonmajors = ['Victor', 'Wanda', 'Xavier', 'Yvette']\nstudents = majors + nonmajors\nbenches = [1, 2, 3, 4]\n\n# Create a Z3 Int variable for each student representing their bench assignment\nbench = {s: Int(s) for s in students}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each student assigned to a bench number between 1 and 4\nfor s in students:\n    solver.add(And(bench[s] >= 1, bench[s] <= 4))\n\n# Exactly two students assigned to each bench\n# For each bench, count how many students assigned to it and enforce count == 2\nfor b in benches:\n    count_b = Sum([If(bench[s] == b, 1, 0) for s in students])\n    solver.add(count_b == 2)\n\n# Exactly one major assigned to each bench\nfor b in benches:\n    count_major_b = Sum([If(bench[m] == b, 1, 0) for m in majors])\n    solver.add(count_major_b == 1)\n\n# Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench\nsolver.add(bench['Joan'] == bench['Frank'] + 1)\n\n# Frank is assigned to the same bench as Victor\nsolver.add(bench['Frank'] == bench['Victor'])\n\n# Gwen is not assigned to the same bench as Wanda\nsolver.add(bench['Gwen'] != bench['Wanda'])\n\n# Given conditions: Gwen assigned to bench 4, Xavier assigned to bench 3\nsolver.add(bench['Gwen'] == 4)\nsolver.add(bench['Xavier'] == 3)\n\n# OPTION CHECKING\n# Options:\n# (A) Gwen is assigned to the same bench as Yvette.\n# (B) Henry is assigned to the same bench as Wanda.\n# (C) Henry is assigned to the same bench as Xavier.\n# (D) Joan is assigned to the same bench as Xavier.\n# (E) Joan is assigned to the same bench as Yvette.\n\noptions = [\n    bench['Gwen'] == bench['Yvette'],\n    bench['Henry'] == bench['Wanda'],\n    bench['Henry'] == bench['Xavier'],\n    bench['Joan'] == bench['Xavier'],\n    bench['Joan'] == bench['Yvette'],\n]\n\n# Check which options can be true\n# The EXCEPT option means the one that cannot be true given all constraints and the option condition added\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        solver.pop()\n        print(f\"'{chr(65 + i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.\n\nIf Wanda is assigned to a lower-numbered bench than is Joan, then Henry must be assigned to a\n\nOptions:\n(A) lower-numbered bench than is Frank\n(B) lower-numbered bench than is Gwen\n(C) lower-numbered bench than is Xavier\n(D) higher-numbered bench than is Victor\n(E) higher-numbered bench than is Yvette",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Frank', 'Gwen', 'Henry', 'Joan', 'Victor', 'Wanda', 'Xavier', 'Yvette']\nmajors = ['Frank', 'Gwen', 'Henry', 'Joan']\nnonmajors = ['Victor', 'Wanda', 'Xavier', 'Yvette']\nbenches = [1, 2, 3, 4]\n\n# Create Z3 variables: bench assignment for each student\nbench = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student assigned to exactly one bench in 1..4\nfor s in students:\n    solver.add(And(bench[s] >= 1, bench[s] <= 4))\n\n# Exactly two students per bench\nfor b in benches:\n    count = Sum([If(bench[s] == b, 1, 0) for s in students])\n    solver.add(count == 2)\n\n# Exactly one major per bench\nfor b in benches:\n    count_majors = Sum([If(bench[m] == b, 1, 0) for m in majors])\n    solver.add(count_majors == 1)\n\n# Frank and Joan assigned to consecutively numbered benches with Frank lower\nsolver.add(bench['Joan'] == bench['Frank'] + 1)\n\n# Frank assigned to the same bench as Victor\nsolver.add(bench['Frank'] == bench['Victor'])\n\n# Gwen not assigned to the same bench as Wanda\nsolver.add(bench['Gwen'] != bench['Wanda'])\n\n# OPTION CHECKING\n\noptions = [\n    ('A', lambda: bench['Henry'] < bench['Frank']),\n    ('B', lambda: bench['Henry'] < bench['Gwen']),\n    ('C', lambda: bench['Henry'] < bench['Xavier']),\n    ('D', lambda: bench['Henry'] > bench['Victor']),\n    ('E', lambda: bench['Henry'] > bench['Yvette']),\n]\n\n# We add the condition: Wanda assigned to lower-numbered bench than Joan\nsolver.add(bench['Wanda'] < bench['Joan'])\n\nfor letter, condition in options:\n    solver.push()\n    solver.add(Not(condition()))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Eight physics students—four majors: Frank, Gwen, Henry, and Joan; and four nonmajors: Victor, Wanda, Xavier, and Yvette—are being assigned to four laboratory benches, numbered 1 through 4. Each student is assigned to exactly one bench, and exactly two students are assigned to each bench. Assignments of students to benches must conform to the following conditions: Exactly one major is assigned to each bench. Frank and Joan are assigned to consecutively numbered benches, with Frank assigned to the lower-numbered bench. Frank is assigned to the same bench as Victor. Gwen is not assigned to the same bench as Wanda.\n\nWhich one of the following could be the assignments for bench 2 and bench 4?\n\nOptions:\n(A) 2: Gwen, Xavier 4: Henry, Yvette\n(B) 2: Henry, Yvette 4: Joan, Xavier\n(C) 2: Joan, Victor 4: Gwen, Xavier\n(D) 2: Joan, Wanda 4: Gwen, Xavier\n(E) 2: Joan, Xavier 4: Henry, Yvette",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Frank', 'Gwen', 'Henry', 'Joan', 'Victor', 'Wanda', 'Xavier', 'Yvette']\nmajors = ['Frank', 'Gwen', 'Henry', 'Joan']\nnonmajors = ['Victor', 'Wanda', 'Xavier', 'Yvette']\nbenches = [1, 2, 3, 4]\n\n# Create Z3 Int variables for each student representing their assigned bench (1-4)\nbench = {}\nfor s in students:\n    bench[s] = Int(s)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each student assigned to exactly one bench (bench number between 1 and 4)\nfor s in students:\n    solver.add(And(bench[s] >= 1, bench[s] <= 4))\n\n# Exactly two students per bench: For each bench, count number of students assigned is 2\nfor b in benches:\n    assigned_to_b = [If(bench[s] == b, 1, 0) for s in students]\n    solver.add(Sum(assigned_to_b) == 2)\n\n# Exactly one major per bench: For each bench, exactly one major assigned\nfor b in benches:\n    assigned_majors = [If(bench[m] == b, 1, 0) for m in majors]\n    solver.add(Sum(assigned_majors) == 1)\n\n# Frank and Joan assigned to consecutively numbered benches, Frank assigned to lower-numbered bench\nsolver.add(bench['Joan'] == bench['Frank'] + 1)\n\n# Frank assigned to same bench as Victor\nsolver.add(bench['Frank'] == bench['Victor'])\n\n# Gwen not assigned to same bench as Wanda\nsolver.add(bench['Gwen'] != bench['Wanda'])\n\n# OPTION CHECKING\n# Each option specifies the assignments for bench 2 and bench 4\noptions = {\n    'A': {'2': ['Gwen', 'Xavier'], '4': ['Henry', 'Yvette']},\n    'B': {'2': ['Henry', 'Yvette'], '4': ['Joan', 'Xavier']},\n    'C': {'2': ['Joan', 'Victor'], '4': ['Gwen', 'Xavier']},\n    'D': {'2': ['Joan', 'Wanda'], '4': ['Gwen', 'Xavier']},\n    'E': {'2': ['Joan', 'Xavier'], '4': ['Henry', 'Yvette']}\n}\n\nfor option_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add constraints for bench 2 assignments\n    bench2_students = options[option_letter]['2']\n    for s in bench2_students:\n        solver.add(bench[s] == 2)\n    # Add constraints for bench 4 assignments\n    bench4_students = options[option_letter]['4']\n    for s in bench4_students:\n        solver.add(bench[s] == 4)\n    # For students not assigned to bench 2 or 4 in this option, their bench != 2 and !=4 accordingly\n    assigned_students = bench2_students + bench4_students\n    for s in students:\n        if s not in assigned_students:\n            # Their bench is not 2 or 4 if they are not assigned there in this option\n            solver.add(Or(bench[s] != 2, bench[s] != 4))  # but this is not a good constraint, better to only restrict that they are not assigned to these benches if they are not in those benches\n    # Actually the above is ambiguous, better to not add constraints about other students here because they can be assigned to benches 1 or 3.\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.\n\nWhich one of the following is an order in which the messenger could make the deliveries, from first to seventh?\n\nOptions:\n(A) L, N, S, O, M, T, P\n(B) M, T, P, S, L, N, O\n(C) O, S, L, N, M, T, P\n(D) P, N, M, S, O, T, L\n(E) P, T, M, S, L, N, O",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npackages = ['L', 'M', 'N', 'O', 'P', 'S', 'T']\npositions = {p: Int(p) for p in packages}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each package position is between 1 and 7\nfor p in packages:\n    solver.add(And(positions[p] >= 1, positions[p] <= 7))\n\n# All positions are distinct\nsolver.add(Distinct([positions[p] for p in packages]))\n\n# P is delivered either first or seventh\nsolver.add(Or(positions['P'] == 1, positions['P'] == 7))\n\n# N is delivered after L\nsolver.add(positions['N'] > positions['L'])\n\n# T is delivered after M\nsolver.add(positions['T'] > positions['M'])\n\n# Exactly one package between L and O (distance between positions is 2)\ndiff_LO = Abs(positions['L'] - positions['O'])\nsolver.add(diff_LO == 2)\n\n# Exactly one package between M and P (distance between positions is 2)\ndiff_MP = Abs(positions['M'] - positions['P'])\nsolver.add(diff_MP == 2)\n\n# OPTION CHECKING\noptions = [\n    ['L', 'N', 'S', 'O', 'M', 'T', 'P'],  # A\n    ['M', 'T', 'P', 'S', 'L', 'N', 'O'],  # B\n    ['O', 'S', 'L', 'N', 'M', 'T', 'P'],  # C\n    ['P', 'N', 'M', 'S', 'O', 'T', 'L'],  # D\n    ['P', 'T', 'M', 'S', 'L', 'N', 'O']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that positions match the option order\n    for pos, pkg in enumerate(option, start=1):\n        solver.add(positions[pkg] == pos)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.\n\nWhich one of the following could be true?\n\nOptions:\n(A) N is delivered first.\n(B) T is delivered first.\n(C) T is delivered second.\n(D) M is delivered fourth.\n(E) S is delivered seventh.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npackages = ['L', 'M', 'N', 'O', 'P', 'S', 'T']\npositions = range(1, 8)  # Positions 1 through 7\n\n# Create a dictionary mapping package to its delivery position (Int variable)\npos = {pkg: Int(pkg) for pkg in packages}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each package is delivered at a position between 1 and 7\nfor pkg in packages:\n    solver.add(And(pos[pkg] >= 1, pos[pkg] <= 7))\n\n# All packages are delivered at distinct positions\nsolver.add(Distinct([pos[pkg] for pkg in packages]))\n\n# P is delivered either first or seventh\nsolver.add(Or(pos['P'] == 1, pos['P'] == 7))\n\n# N is delivered after L\nsolver.add(pos['N'] > pos['L'])\n\n# T is delivered after M\nsolver.add(pos['T'] > pos['M'])\n\n# Exactly one package between L and O (distance between positions is 2)\ndist_LO = Abs(pos['L'] - pos['O'])\nsolver.add(dist_LO == 2)\n\n# Exactly one package between M and P (distance between positions is 2)\ndist_MP = Abs(pos['M'] - pos['P'])\nsolver.add(dist_MP == 2)\n\n# OPTION CHECKING\noptions = {\n    'A': pos['N'] == 1,\n    'B': pos['T'] == 1,\n    'C': pos['T'] == 2,\n    'D': pos['M'] == 4,\n    'E': pos['S'] == 7,\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.\n\nIf N is delivered fourth, which one of the following could be true?\n\nOptions:\n(A) L is delivered first.\n(B) L is delivered second.\n(C) M is delivered third.\n(D) O is delivered fifth.\n(E) S is delivered first.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npackages = ['L', 'M', 'N', 'O', 'P', 'S', 'T']\npositions = range(1, 8)  # Positions 1 through 7\n\n# Create a Z3 Int variable for the position of each package\npos = {p: Int(p) for p in packages}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each package must be delivered at a unique position between 1 and 7\nfor p in packages:\n    solver.add(And(pos[p] >= 1, pos[p] <= 7))\nsolver.add(Distinct([pos[p] for p in packages]))\n\n# P is delivered either first or seventh\nsolver.add(Or(pos['P'] == 1, pos['P'] == 7))\n\n# N is delivered after L\nsolver.add(pos['N'] > pos['L'])\n\n# T is delivered after M\nsolver.add(pos['T'] > pos['M'])\n\n# Exactly one package between L and O (distance between positions is 2)\nsolver.add(Or(pos['L'] - pos['O'] == 2, pos['O'] - pos['L'] == 2))\n\n# Exactly one package between M and P (distance between positions is 2)\nsolver.add(Or(pos['M'] - pos['P'] == 2, pos['P'] - pos['M'] == 2))\n\n# N is delivered fourth\nsolver.add(pos['N'] == 4)\n\n# OPTION CHECKING\n# For each option, add the specific constraint and check satisfiability\n\noptions = {\n    'A': pos['L'] == 1,\n    'B': pos['L'] == 2,\n    'C': pos['M'] == 3,\n    'D': pos['O'] == 5,\n    'E': pos['S'] == 1,\n}\n\nfor letter, constraint in options.items():\n    solver.push()\n    solver.add(constraint)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.\n\nIf T is delivered fourth, the seventh package delivered must be\n\nOptions:\n(A) L\n(B) N\n(C) O\n(D) P\n(E) S",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npackages = ['L', 'M', 'N', 'O', 'P', 'S', 'T']\npositions = {p: Int(p) for p in packages}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each package delivered at a unique position from 1 to 7\nfor p in packages:\n    solver.add(And(positions[p] >= 1, positions[p] <= 7))\nsolver.add(Distinct([positions[p] for p in packages]))\n\n# P is delivered either first or seventh\nsolver.add(Or(positions['P'] == 1, positions['P'] == 7))\n\n# N is delivered after L\nsolver.add(positions['N'] > positions['L'])\n\n# T is delivered after M\nsolver.add(positions['T'] > positions['M'])\n\n# Exactly one package between L and O (distance between their positions is 2)\ndiff_LO = Abs(positions['L'] - positions['O'])\nsolver.add(diff_LO == 2)\n\n# Exactly one package between M and P (distance between their positions is 2)\ndiff_MP = Abs(positions['M'] - positions['P'])\nsolver.add(diff_MP == 2)\n\n# T is delivered fourth\nsolver.add(positions['T'] == 4)\n\n# OPTION CHECKING\n# Check each option for the seventh delivered package\noptions = ['L', 'N', 'O', 'P', 'S']\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(positions[option] == 7)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A messenger will deliver exactly seven packages—L, M, N, O, P, S, and T—one at a time, not necessarily in that order. The seven deliveries must be made according to the following conditions: P is delivered either first or seventh. The messenger delivers N at some time after delivering L. The messenger delivers T at some time after delivering M. The messenger delivers exactly one package between delivering L and delivering O, whether or not L is delivered before O. The messenger delivers exactly one package between delivering M and delivering P, whether or not M is delivered before P.\n\nIf the messenger delivers M at some time after delivering O, the fifth package delivered could be any one of the following EXCEPT:\n\nOptions:\n(A) L\n(B) M\n(C) N\n(D) S\n(E) T",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npackages = ['L', 'M', 'N', 'O', 'P', 'S', 'T']\npositions = range(1, 8)  # Positions 1 through 7\n\n# Create a variable for the delivery position of each package\npos = {p: Int(p) for p in packages}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each package is delivered at a unique position from 1 to 7\nfor p in packages:\n    solver.add(And(pos[p] >= 1, pos[p] <= 7))\nsolver.add(Distinct([pos[p] for p in packages]))\n\n# P is delivered either first or seventh\nsolver.add(Or(pos['P'] == 1, pos['P'] == 7))\n\n# N is delivered after L\nsolver.add(pos['N'] > pos['L'])\n\n# T is delivered after M\nsolver.add(pos['T'] > pos['M'])\n\n# Exactly one package between L and O (distance = 2)\ndistance_LO = Abs(pos['L'] - pos['O'])\nsolver.add(distance_LO == 2)\n\n# Exactly one package between M and P (distance = 2)\ndistance_MP = Abs(pos['M'] - pos['P'])\nsolver.add(distance_MP == 2)\n\n# M delivered after O (pos['M'] > pos['O'])\nsolver.add(pos['M'] > pos['O'])\n\n# OPTION CHECKING\n# We want to know which package cannot be delivered fifth\n\noptions = ['L', 'M', 'N', 'S', 'T']\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, package in enumerate(options):\n    solver.push()\n    # Add constraint that package is delivered fifth\n    solver.add(pos[package] == 5)\n    if solver.check() == unsat:\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.\n\nWhich one of the following could be an accurate list of the activities participated in by Nguyen, Olson, Pike, Tyner, and Valdez, respectively?\n\nOptions:\n(A) movie, soccer game, soccer game, restaurant, movie\n(B) movie, restaurant, soccer game, soccer game, movie\n(C) soccer game, restaurant, movie, soccer game, movie\n(D) soccer game, restaurant, movie, soccer game, restaurant\n(E) soccer game, restaurant, movie, soccer game, soccer game",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['Nguyen', 'Olson', 'Pike', 'Tyner', 'Valdez']\nactivities = ['movie', 'soccer', 'restaurant']\n\n# Create Z3 variables for each person's activity (0=movie, 1=soccer, 2=restaurant)\nactivity_vars = {p: Int(p) for p in persons}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person participates in exactly one activity (value between 0 and 2)\nfor p in persons:\n    solver.add(And(activity_vars[p] >= 0, activity_vars[p] < len(activities)))\n\n# Constraint 1: Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike.\nsolver.add(activity_vars['Nguyen'] != activity_vars['Olson'])\nsolver.add(activity_vars['Nguyen'] != activity_vars['Pike'])\nsolver.add(activity_vars['Olson'] != activity_vars['Pike'])\n\n# Constraint 2: Exactly two persons go to a soccer game.\nsoccer_count = Sum([If(activity_vars[p] == activities.index('soccer'), 1, 0) for p in persons])\nsolver.add(soccer_count == 2)\n\n# Constraint 3: Tyner and Pike do not participate in the same activity as each other.\nsolver.add(activity_vars['Tyner'] != activity_vars['Pike'])\n\n# Constraint 4: If Nguyen or Valdez goes to a movie, they both go to a movie.\nnguyen_movie = activity_vars['Nguyen'] == activities.index('movie')\nvaldez_movie = activity_vars['Valdez'] == activities.index('movie')\nsolver.add(Implies(Or(nguyen_movie, valdez_movie), And(nguyen_movie, valdez_movie)))\n\n# OPTION CHECKING\noptions = [\n    ['movie', 'soccer', 'soccer', 'restaurant', 'movie'],     # A\n    ['movie', 'restaurant', 'soccer', 'soccer', 'movie'],     # B\n    ['soccer', 'restaurant', 'movie', 'soccer', 'movie'],     # C\n    ['soccer', 'restaurant', 'movie', 'soccer', 'restaurant'],# D\n    ['soccer', 'restaurant', 'movie', 'soccer', 'soccer'],    # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for the option\n    for p, act in zip(persons, option):\n        solver.add(activity_vars[p] == activities.index(act))\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.\n\nIf Valdez goes to a soccer game, then each of the following could be true EXCEPT:\n\nOptions:\n(A) Olson goes to a movie.\n(B) Nguyen goes to a restaurant.\n(C) Nguyen goes to a soccer game.\n(D) Tyner goes to a soccer game.\n(E) Tyner goes to a movie.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['Nguyen', 'Olson', 'Pike', 'Tyner', 'Valdez']\nactivities = ['Movie', 'Soccer', 'Restaurant']\n\n# Map activities to indices\nactivity_indices = {act: i for i, act in enumerate(activities)}\n\n# Create Z3 variables for each person representing their activity\nactivity_vars = {p: Int(p) for p in persons}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person participates in exactly one activity (valid index)\nfor p in persons:\n    solver.add(And(activity_vars[p] >= 0, activity_vars[p] < len(activities)))\n\n# Exactly two persons go to a soccer game\nsoccer_count = Sum([If(activity_vars[p] == activity_indices['Soccer'], 1, 0) for p in persons])\nsolver.add(soccer_count == 2)\n\n# Nguyen and Olson do not participate in the same activity as each other\nsolver.add(activity_vars['Nguyen'] != activity_vars['Olson'])\n\n# Nguyen and Pike do not participate in the same activity as each other\nsolver.add(activity_vars['Nguyen'] != activity_vars['Pike'])\n\n# Olson and Pike do not participate in the same activity as each other\nsolver.add(activity_vars['Olson'] != activity_vars['Pike'])\n\n# Tyner and Pike do not participate in the same activity as each other\nsolver.add(activity_vars['Tyner'] != activity_vars['Pike'])\n\n# If Nguyen or Valdez goes to a movie, they both go to a movie\nnguyen_movie = activity_vars['Nguyen'] == activity_indices['Movie']\nvaldez_movie = activity_vars['Valdez'] == activity_indices['Movie']\nsolver.add(Implies(Or(nguyen_movie, valdez_movie), And(nguyen_movie, valdez_movie)))\n\n# OPTION CHECKING\n# Valdez goes to a soccer game\nsolver.add(activity_vars['Valdez'] == activity_indices['Soccer'])\n\noptions = {\n    'A': activity_vars['Olson'] == activity_indices['Movie'],\n    'B': activity_vars['Nguyen'] == activity_indices['Restaurant'],\n    'C': activity_vars['Nguyen'] == activity_indices['Soccer'],\n    'D': activity_vars['Tyner'] == activity_indices['Soccer'],\n    'E': activity_vars['Tyner'] == activity_indices['Movie'],\n}\n\n# We want to find which option CANNOT be true, so we check which option makes the problem UNSAT\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.\n\nWhich one of the following is a pair of persons who could go to a movie together?\n\nOptions:\n(A) Nguyen and Tyner\n(B) Olson and Tyner\n(C) Olson and Valdez\n(D) Pike and Olson\n(E) Pike and Tyner",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['Nguyen', 'Olson', 'Pike', 'Tyner', 'Valdez']\nactivities = ['Movie', 'Soccer', 'Restaurant']\n\n# Create variables: activity assignment for each person (0=Movie,1=Soccer,2=Restaurant)\nactivity = {p: Int(p) for p in persons}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person assigned to a valid activity\nfor p in persons:\n    solver.add(And(activity[p] >= 0, activity[p] < len(activities)))\n\n# Constraint: Nguyen and Olson do not participate in the same activity\nsolver.add(activity['Nguyen'] != activity['Olson'])\n\n# Neither Nguyen nor Olson participates in the same activity as Pike\nsolver.add(activity['Nguyen'] != activity['Pike'])\nsolver.add(activity['Olson'] != activity['Pike'])\n\n# Exactly two persons go to a soccer game (activity index 1)\nsoccer_count = Sum([If(activity[p] == 1, 1, 0) for p in persons])\nsolver.add(soccer_count == 2)\n\n# Tyner and Pike do not participate in the same activity\nsolver.add(activity['Tyner'] != activity['Pike'])\n\n# If Nguyen or Valdez goes to a movie, then both go to a movie\n# This means: (Nguyen == Movie or Valdez == Movie) => (Nguyen == Movie and Valdez == Movie)\n# Equivalent to: (Nguyen == Movie or Valdez == Movie) => (Nguyen == Movie and Valdez == Movie)\n# Which is equivalent to: (Nguyen == Movie or Valdez == Movie) == (Nguyen == Movie and Valdez == Movie)\n# So Nguyen and Valdez go to movie together or neither goes to movie\nnguyen_movie = activity['Nguyen'] == 0\nvaldez_movie = activity['Valdez'] == 0\nsolver.add(ny_valdez_movie_eq := (nguyen_movie == valdez_movie))\n\n# OPTION CHECKING\noptions = {\n    'A': ('Nguyen', 'Tyner'),\n    'B': ('Olson', 'Tyner'),\n    'C': ('Olson', 'Valdez'),\n    'D': ('Pike', 'Olson'),\n    'E': ('Pike', 'Tyner'),\n}\n\nfor letter, (p1, p2) in options.items():\n    solver.push()\n    # Add constraint that p1 and p2 both go to movie (activity 0)\n    solver.add(activity[p1] == 0)\n    solver.add(activity[p2] == 0)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.\n\nEach of the following statements must be false EXCEPT:\n\nOptions:\n(A) Only Olson goes to a restaurant.\n(B) Only Pike goes to a restaurant.\n(C) Only Tyner goes to a restaurant.\n(D) Only Valdez goes to a restaurant.\n(E) Tyner and Valdez go to a restaurant together.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\npersons = ['Nguyen', 'Olson', 'Pike', 'Tyner', 'Valdez']\nactivities = ['Movie', 'Soccer', 'Restaurant']\n\n# Create Z3 Int variables for each person representing their activity index\nactivity_vars = {p: Int(p) for p in persons}\n\nsolver = Solver()\n\n# Each person's activity is in the range [0, 2]\nfor p in persons:\n    solver.add(And(activity_vars[p] >= 0, activity_vars[p] < len(activities)))\n\n# CONSTRAINTS\n\n# 1) Nguyen and Olson do not participate in the same activity as each other,\n# nor does either one of them participate in the same activity as Pike.\nsolver.add(activity_vars['Nguyen'] != activity_vars['Olson'])\nsolver.add(activity_vars['Nguyen'] != activity_vars['Pike'])\nsolver.add(activity_vars['Olson'] != activity_vars['Pike'])\n\n# 2) Exactly two persons go to a soccer game (activity index 1)\nsoccer_count = Sum([If(activity_vars[p] == 1, 1, 0) for p in persons])\nsolver.add(soccer_count == 2)\n\n# 3) Tyner and Pike do not participate in the same activity\nsolver.add(activity_vars['Tyner'] != activity_vars['Pike'])\n\n# 4) If Nguyen or Valdez goes to a movie, they both go to a movie.\n# Movie index is 0\nnguyen_movie = activity_vars['Nguyen'] == 0\nvaldez_movie = activity_vars['Valdez'] == 0\nsolver.add(Implies(Or(nguyen_movie, valdez_movie), And(nguyen_movie, valdez_movie)))\n\n# OPTION CHECKING\n\noptions = {\n    'A': \"Only Olson goes to a restaurant\",\n    'B': \"Only Pike goes to a restaurant\",\n    'C': \"Only Tyner goes to a restaurant\",\n    'D': \"Only Valdez goes to a restaurant\",\n    'E': \"Tyner and Valdez go to a restaurant together\"\n}\n\n# Restaurant index is 2\n\nfor letter, desc in options.items():\n    solver.push()\n    # Add constraint that the option is true\n    if letter == 'A':\n        # Only Olson goes to a restaurant\n        # Olson is restaurant, others are not restaurant\n        conds = [activity_vars['Olson'] == 2]\n        conds += [activity_vars[p] != 2 for p in persons if p != 'Olson']\n        solver.add(And(conds))\n    elif letter == 'B':\n        # Only Pike goes to a restaurant\n        conds = [activity_vars['Pike'] == 2]\n        conds += [activity_vars[p] != 2 for p in persons if p != 'Pike']\n        solver.add(And(conds))\n    elif letter == 'C':\n        # Only Tyner goes to a restaurant\n        conds = [activity_vars['Tyner'] == 2]\n        conds += [activity_vars[p] != 2 for p in persons if p != 'Tyner']\n        solver.add(And(conds))\n    elif letter == 'D':\n        # Only Valdez goes to a restaurant\n        conds = [activity_vars['Valdez'] == 2]\n        conds += [activity_vars[p] != 2 for p in persons if p != 'Valdez']\n        solver.add(And(conds))\n    elif letter == 'E':\n        # Tyner and Valdez go to a restaurant together\n        solver.add(activity_vars['Tyner'] == 2)\n        solver.add(activity_vars['Valdez'] == 2)\n\n    # Check if the model is satisfiable with the option true\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.\n\nIf Nguyen goes to a soccer game, then which one of the following is a complete and accurate list of the persons any one of whom could go to a movie?\n\nOptions:\n(A) Olson\n(B) Pike, Valdez\n(C) Olson, Tyner\n(D) Pike, Tyner, Valdez\n(E) Olson, Pike, Tyner",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['Nguyen', 'Olson', 'Pike', 'Tyner', 'Valdez']\nactivities = ['Movie', 'Soccer', 'Restaurant']\n\n# Create Z3 Int variables for each person representing their activity index\nactivity_vars = {p: Int(p) for p in persons}\n\n# Initialize solver\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person participates in exactly one activity (activity index between 0 and 2)\nfor p in persons:\n    solver.add(And(activity_vars[p] >= 0, activity_vars[p] < len(activities)))\n\n# Nguyen and Olson do not participate in the same activity\nsolver.add(activity_vars['Nguyen'] != activity_vars['Olson'])\n\n# Neither Nguyen nor Olson participate in the same activity as Pike\nsolver.add(activity_vars['Nguyen'] != activity_vars['Pike'])\nsolver.add(activity_vars['Olson'] != activity_vars['Pike'])\n\n# Exactly two persons go to a soccer game (activity index 1)\nsoccer_count = Sum([If(activity_vars[p] == 1, 1, 0) for p in persons])\nsolver.add(soccer_count == 2)\n\n# Tyner and Pike do not participate in the same activity\nsolver.add(activity_vars['Tyner'] != activity_vars['Pike'])\n\n# If Nguyen or Valdez goes to a movie (activity index 0), then they both go to a movie\nnguyen_movie = activity_vars['Nguyen'] == 0\nvaldez_movie = activity_vars['Valdez'] == 0\nsolver.add(Implies(Or(nguyen_movie, valdez_movie), And(nguyen_movie, valdez_movie)))\n\n# Additional constraint: Nguyen goes to a soccer game (activity index 1)\nsolver.add(activity_vars['Nguyen'] == 1)\n\n# OPTION CHECKING\n# Options:\noptions = {\n    'A': ['Olson'],\n    'B': ['Pike', 'Valdez'],\n    'C': ['Olson', 'Tyner'],\n    'D': ['Pike', 'Tyner', 'Valdez'],\n    'E': ['Olson', 'Pike', 'Tyner']\n}\n\n# For each option, check if it is the complete and accurate list of persons any one of whom could go to a movie\n# That means:\n# - For each person in the option, there exists a model where that person goes to movie\n# - For each person not in the option, there is no model where that person goes to movie\n\nfor opt_letter, opt_persons in options.items():\n    # Check if all persons in opt_persons can go to movie\n    can_all_in_opt_go_movie = True\n    for p in opt_persons:\n        solver.push()\n        solver.add(activity_vars[p] == 0)  # p goes to movie\n        if solver.check() != sat:\n            can_all_in_opt_go_movie = False\n        solver.pop()\n        if not can_all_in_opt_go_movie:\n            break\n    if not can_all_in_opt_go_movie:\n        continue\n\n    # Check if any person not in opt_persons can go to movie (should be false)\n    others = [p for p in persons if p not in opt_persons]\n    can_any_other_go_movie = False\n    for p in others:\n        solver.push()\n        solver.add(activity_vars[p] == 0)  # p goes to movie\n        if solver.check() == sat:\n            can_any_other_go_movie = True\n        solver.pop()\n        if can_any_other_go_movie:\n            break\n\n    if not can_any_other_go_movie:\n        print(f\"'{opt_letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of exactly five persons—Nguyen, Olson, Pike, Tyner, and Valdez—participates in exactly one of three activities: going to a movie, going to a soccer game, or going to a restaurant. The following conditions must apply. Nguyen and Olson do not participate in the same activity as each other, nor does either one of them participate in the same activity as Pike. Exactly two persons go to a soccer game. Tyner and Pike do not participate in the same activity as each other. If Nguyen or Valdez goes to a movie, they both go to a movie.\n\nIf the condition that exactly two persons go to a soccer game is changed to require that exactly three persons go to a soccer game, but all other conditions remain the same, then which one of the following persons must participate in an activity other than going to a soccer game?\n\nOptions:\n(A) Nguyen\n(B) Olson\n(C) Pike\n(D) Tyner\n(E) Valdez",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['Nguyen', 'Olson', 'Pike', 'Tyner', 'Valdez']\nactivities = ['Movie', 'Soccer', 'Restaurant']\n\n# Map activities to indices\nMovie = 0\nSoccer = 1\nRestaurant = 2\n\n# Create Z3 variables for each person's activity\nactivity_vars = {p: Int(p) for p in persons}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person's activity must be valid index\nfor p in persons:\n    solver.add(And(activity_vars[p] >= 0, activity_vars[p] < len(activities)))\n\n# Original constraints except the soccer count changed to exactly three persons\n# 1) Nguyen and Olson do not participate in the same activity as each other\nsolver.add(activity_vars['Nguyen'] != activity_vars['Olson'])\n\n# 2) Neither Nguyen nor Olson participates in the same activity as Pike\nsolver.add(activity_vars['Nguyen'] != activity_vars['Pike'])\nsolver.add(activity_vars['Olson'] != activity_vars['Pike'])\n\n# 3) Exactly three persons go to a soccer game (changed from two)\nsoccer_count = Sum([If(activity_vars[p] == Soccer, 1, 0) for p in persons])\nsolver.add(soccer_count == 3)\n\n# 4) Tyner and Pike do not participate in the same activity\nsolver.add(activity_vars['Tyner'] != activity_vars['Pike'])\n\n# 5) If Nguyen or Valdez goes to a movie, then they both go to a movie\nNguyen_movie = activity_vars['Nguyen'] == Movie\nValdez_movie = activity_vars['Valdez'] == Movie\nsolver.add(Implies(Or(Nguyen_movie, Valdez_movie), And(Nguyen_movie, Valdez_movie)))\n\n# OPTION CHECKING\noptions = ['Nguyen', 'Olson', 'Pike', 'Tyner', 'Valdez']\n\nfor i, person in enumerate(options):\n    solver.push()\n    # Add constraint that this person goes to Soccer (to check if possible)\n    solver.add(activity_vars[person] == Soccer)\n    if solver.check() == sat:\n        # Person can go to soccer, so not necessarily must go to other activity\n        solver.pop()\n    else:\n        # Person must participate in an activity other than soccer\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "In each of two years exactly two of four lawmakers—Feld, Gibson, Hsu, and Ivins—and exactly two of three scientists—Vega, Young, and Zapora—will serve as members of a four-person panel. In each year, one of the members will be chairperson. The chairperson in the first year cannot serve on the panel in the second year. The chairperson in the second year must have served on the panel in the first year. Service on the panel must obey the following conditions: Gibson and Vega do not serve on the panel in the same year as each other. Hsu and Young do not serve on the panel in the same year as each other. Each year, either Ivins or Vega, but not both, serves on the panel.\n\nIF Feld serves on the panel in a given year, any one of the following could serve on the panel that year EXCEPT:\n\nOptions:\n(A) Gibson\n(B) Hsu\n(C) Ivins\n(D) Vega\n(E) Young",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Lawmakers and scientists\nlawmakers = ['Feld', 'Gibson', 'Hsu', 'Ivins']\nscientists = ['Vega', 'Young', 'Zapora']\n\n# Years\nyears = [1, 2]\n\n# Variables: For each year, who serves on the panel (Bool variables)\n# panel_lawmaker[year][lawmaker] = True if lawmaker serves in that year\npanel_lawmaker = {y: {lm: Bool(f\"panel_lawyer_{lm}_{y}\") for lm in lawmakers} for y in years}\npanel_scientist = {y: {sc: Bool(f\"panel_scientist_{sc}_{y}\") for sc in scientists} for y in years}\n\n# Chairperson variables: who is chair in each year (one person from panel)\n# For chair, we create Int variables representing indices of panel members\n# We'll index all 7 members for chair selection\nmembers = lawmakers + scientists\nchair = {y: Int(f\"chair_{y}\") for y in years}  # value in [0..6], representing member index in members\n\n# Map member names to indices\nmember_index = {m: i for i, m in enumerate(members)}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each year: exactly two lawmakers serve\nfor y in years:\n    lm_serving = [panel_lawmaker[y][lm] for lm in lawmakers]\n    solver.add(Sum([If(x, 1, 0) for x in lm_serving]) == 2)\n\n# Each year: exactly two scientists serve\nfor y in years:\n    sc_serving = [panel_scientist[y][sc] for sc in scientists]\n    solver.add(Sum([If(x, 1, 0) for x in sc_serving]) == 2)\n\n# Each year: chairperson is one of the four panel members\nfor y in years:\n    # The chair must be someone serving on the panel this year\n    # So chair[y] in members and that member serves this year\n    chair_y = chair[y]\n    # chair_y must be in [0..6]\n    solver.add(And(chair_y >= 0, chair_y < len(members)))\n    # The member assigned as chair must serve this year\n    # Create a BoolExpr indicating that chair_y member serves\n    # Since chair_y is Int, we use Or conditions\n    chair_serves_conditions = []\n    for i, m in enumerate(members):\n        if m in lawmakers:\n            cond = And(chair_y == i, panel_lawmaker[y][m])\n        else:\n            cond = And(chair_y == i, panel_scientist[y][m])\n        chair_serves_conditions.append(cond)\n    solver.add(Or(chair_serves_conditions))\n\n# The chairperson in the first year cannot serve on the panel in the second year\n# So the person who is chair in year 1 is not on panel in year 2\nchair1 = chair[1]\nfor i, m in enumerate(members):\n    # If chair1 == i then member m is not on panel in year 2\n    if m in lawmakers:\n        not_on_panel = Not(panel_lawmaker[2][m])\n    else:\n        not_on_panel = Not(panel_scientist[2][m])\n    solver.add(Implies(chair1 == i, not_on_panel))\n\n# The chairperson in the second year must have served on the panel in the first year\nchair2 = chair[2]\nchair2_served_in_year1_conditions = []\nfor i, m in enumerate(members):\n    if m in lawmakers:\n        cond = And(chair2 == i, panel_lawmaker[1][m])\n    else:\n        cond = And(chair2 == i, panel_scientist[1][m])\n    chair2_served_in_year1_conditions.append(cond)\nsolver.add(Or(chair2_served_in_year1_conditions))\n\n# Gibson and Vega do not serve on the panel in the same year\nfor y in years:\n    solver.add(Or(Not(panel_lawmaker[y]['Gibson']), Not(panel_scientist[y]['Vega'])))\n\n# Hsu and Young do not serve on the panel in the same year\nfor y in years:\n    solver.add(Or(Not(panel_lawmaker[y]['Hsu']), Not(panel_scientist[y]['Young'])))\n\n# Each year, either Ivins or Vega, but not both, serves on the panel\nfor y in years:\n    ivins_serves = panel_lawmaker[y]['Ivins']\n    vega_serves = panel_scientist[y]['Vega']\n    # Exactly one of Ivins or Vega serves\n    solver.add(Xor(ivins_serves, vega_serves))\n\n# OPTION CHECKING\n\n# We want to test each option:\n# \"IF Feld serves on the panel in a given year, any one of the following could serve on the panel that year EXCEPT:\"\n\n# So for each option X, we check if there exists a year y where:\n# Feld serves on panel in year y\n# The option member serves on panel in year y\n# and the rest of constraints hold\n\n# If for an option it is impossible to have Feld and that member serve together in the same year, that option is the EXCEPT (correct answer)\n\noptions = ['Gibson', 'Hsu', 'Ivins', 'Vega', 'Young']\n\nfor i, option_member in enumerate(options):\n    solver.push()\n    # Add constraint: there exists a year y in {1,2} such that Feld and option_member both serve in year y\n    conds = []\n    for y in years:\n        feld_serves = panel_lawmaker[y]['Feld']\n        if option_member in lawmakers:\n            option_serves = panel_lawmaker[y][option_member]\n        else:\n            option_serves = panel_scientist[y][option_member]\n        conds.append(And(feld_serves, option_serves))\n    solver.add(Or(conds))\n    if solver.check() == sat:\n        # It is possible for Feld and option_member to serve together in some year\n        solver.pop()\n    else:\n        # Not possible, so this is the EXCEPT answer\n        print(f\"'{chr(65+i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "In each of two years exactly two of four lawmakers—Feld, Gibson, Hsu, and Ivins—and exactly two of three scientists—Vega, Young, and Zapora—will serve as members of a four-person panel. In each year, one of the members will be chairperson. The chairperson in the first year cannot serve on the panel in the second year. The chairperson in the second year must have served on the panel in the first year. Service on the panel must obey the following conditions: Gibson and Vega do not serve on the panel in the same year as each other. Hsu and Young do not serve on the panel in the same year as each other. Each year, either Ivins or Vega, but not both, serves on the panel.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Feld is on the panel in the second year.\n(B) Hsu is on the panel in the first year.\n(C) Ivins is on the panel in both years.\n(D) Young is on the panel in both years.\n(E) Zapora is on the panel in the second year.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Lawmakers and Scientists\nlawmakers = ['Feld', 'Gibson', 'Hsu', 'Ivins']\nscientists = ['Vega', 'Young', 'Zapora']\n\n# Years\nyears = [1, 2]\n\n# Create solver\nsolver = Solver()\n\n# Variables for panel membership: panel[person][year] = Bool indicating if person serves in that year\npanel = {}\nfor person in lawmakers + scientists:\n    panel[person] = {}\n    for y in years:\n        panel[person][y] = Bool(f'{person}_Y{y}')\n\n# Variables for chairperson: chair[year] = person who is chair in that year (index)\n# We'll represent chairpersons by separate Int variables ranging over all panel members of that year\n# Since chair must be a member of the panel that year, we will constrain chair accordingly\n\n# Create a list of all persons for indexing\nall_persons = lawmakers + scientists\nnum_persons = len(all_persons)\n\n# Map person to index and back\nperson_to_index = {p: i for i, p in enumerate(all_persons)}\nindex_to_person = {i: p for p, i in person_to_index.items()}\n\n# Chair variables: integer from 0 to num_persons-1 indicating which person is chair in that year\nchair = {}\nfor y in years:\n    chair[y] = Int(f'chair_Y{y}')\n    solver.add(And(chair[y] >= 0, chair[y] < num_persons))\n\n# CONSTRAINTS\n\n# 1) In each year exactly two lawmakers serve\nfor y in years:\n    lawmakers_in_year = [panel[p][y] for p in lawmakers]\n    solver.add(Sum([If(x, 1, 0) for x in lawmakers_in_year]) == 2)\n\n# 2) In each year exactly two scientists serve\nfor y in years:\n    scientists_in_year = [panel[p][y] for p in scientists]\n    solver.add(Sum([If(x, 1, 0) for x in scientists_in_year]) == 2)\n\n# 3) Chairperson in each year is a member of the panel that year\nfor y in years:\n    # chair[y] is index of a person who is on panel in year y\n    # So panel[index_to_person[chair[y]]][y] == True\n    # We will encode this by Or over all persons:\n    # chair[y] == i => panel[person_i][y] == True\n    # This can be encoded using a big Or over persons:\n    chair_constraints = []\n    for i in range(num_persons):\n        person = index_to_person[i]\n        cond = And(chair[y] == i, panel[person][y])\n        chair_constraints.append(cond)\n    solver.add(Or(chair_constraints))\n\n# 4) Chairperson in first year cannot serve in second year\n# That is, the person who is chair in year 1 is not on panel in year 2\nfor i in range(num_persons):\n    person = index_to_person[i]\n    cond = Implies(chair[1] == i, Not(panel[person][2]))\n    solver.add(cond)\n\n# 5) Chairperson in second year must have served in first year\n# That is, the person who is chair in year 2 must be on panel in year 1\nfor i in range(num_persons):\n    person = index_to_person[i]\n    cond = Implies(chair[2] == i, panel[person][1])\n    solver.add(cond)\n\n# 6) Gibson and Vega do not serve on the panel in the same year\nfor y in years:\n    solver.add(Or(Not(panel['Gibson'][y]), Not(panel['Vega'][y])))\n\n# 7) Hsu and Young do not serve on the panel in the same year\nfor y in years:\n    solver.add(Or(Not(panel['Hsu'][y]), Not(panel['Young'][y])))\n\n# 8) Each year, either Ivins or Vega, but not both, serves on the panel\nfor y in years:\n    ivins_on = panel['Ivins'][y]\n    vega_on = panel['Vega'][y]\n    solver.add(Xor(ivins_on, vega_on))\n\n# OPTION CHECKING\n\noptions = {\n    'A': panel['Feld'][2],\n    'B': panel['Hsu'][1],\n    'C': And(panel['Ivins'][1], panel['Ivins'][2]),\n    'D': And(panel['Young'][1], panel['Young'][2]),\n    'E': panel['Zapora'][2]\n}\n\n# We want to find the option that must be true.\n# For each option, check if its negation is satisfiable.\n# If negation is unsat, then the option must be true.\n\nfor letter, expr in options.items():\n    solver.push()\n    solver.add(Not(expr))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "During a period of seven consecutive days—from day 1 through day 7—seven investors—Fennelly, Gupta, Hall, Jones, Knight, Lopez, and Moss—will each view a building site exactly once. Each day exactly one investor will view the site. The investors must view the site in accordance with the following conditions: Fennelly views the site on day 3 or else day 5. Lopez views the site on neither day 4 nor day 6. If Jones views the site on day 1, Hall views the site on day 2. If Knight views the site on day 4, Lopez views the site on day 5. Gupta views the site on the day after the day on which Hall views the site.\n\nWhich one of the following could be the order in which the investors view the site, from day 1 through day 7?\n\nOptions:\n(A) Hall, Gupta, Fennelly, Moss, Knight, Lopez, Jones\n(B) Hall, Gupta, Lopez, Fennelly, Moss, Knight, Jones\n(C) Lopez, Gupta, Hall, Moss, Fennelly, Jones, Knight\n(D) Lopez, Jones, Fennelly, Knight, Hall, Gupta, Moss\n(E) Lopez, Jones, Knight, Moss, Fennelly, Hall, Gupta",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ninvestors = ['Fennelly', 'Gupta', 'Hall', 'Jones', 'Knight', 'Lopez', 'Moss']\ndays = list(range(1, 8))\n\n# Create a variable for each investor representing the day they view the site\nday_of = {inv: Int(inv) for inv in investors}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each investor views the site on a day from 1 to 7\nfor inv in investors:\n    solver.add(And(day_of[inv] >= 1, day_of[inv] <= 7))\n\n# All investors view the site on different days\nsolver.add(Distinct([day_of[inv] for inv in investors]))\n\n# Fennelly views the site on day 3 or else day 5\nsolver.add(Or(day_of['Fennelly'] == 3, day_of['Fennelly'] == 5))\n\n# Lopez views the site on neither day 4 nor day 6\nsolver.add(And(day_of['Lopez'] != 4, day_of['Lopez'] != 6))\n\n# If Jones views the site on day 1, Hall views the site on day 2\nsolver.add(Implies(day_of['Jones'] == 1, day_of['Hall'] == 2))\n\n# If Knight views the site on day 4, Lopez views the site on day 5\nsolver.add(Implies(day_of['Knight'] == 4, day_of['Lopez'] == 5))\n\n# Gupta views the site on the day after the day on which Hall views the site\nsolver.add(day_of['Gupta'] == day_of['Hall'] + 1)\n\n# OPTION CHECKING\noptions = [\n    ['Hall', 'Gupta', 'Fennelly', 'Moss', 'Knight', 'Lopez', 'Jones'],  # A\n    ['Hall', 'Gupta', 'Lopez', 'Fennelly', 'Moss', 'Knight', 'Jones'],  # B\n    ['Lopez', 'Gupta', 'Hall', 'Moss', 'Fennelly', 'Jones', 'Knight'],  # C\n    ['Lopez', 'Jones', 'Fennelly', 'Knight', 'Hall', 'Gupta', 'Moss'],  # D\n    ['Lopez', 'Jones', 'Knight', 'Moss', 'Fennelly', 'Hall', 'Gupta']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that assign each investor to the day according to option\n    for day_index, inv in enumerate(option):\n        solver.add(day_of[inv] == day_index + 1)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "During a period of seven consecutive days—from day 1 through day 7—seven investors—Fennelly, Gupta, Hall, Jones, Knight, Lopez, and Moss—will each view a building site exactly once. Each day exactly one investor will view the site. The investors must view the site in accordance with the following conditions: Fennelly views the site on day 3 or else day 5. Lopez views the site on neither day 4 nor day 6. If Jones views the site on day 1, Hall views the site on day 2. If Knight views the site on day 4, Lopez views the site on day 5. Gupta views the site on the day after the day on which Hall views the site.\n\nIf Jones views the site on day 1, which one of the following investors must view the site on day 4?\n\nOptions:\n(A) Fennelly\n(B) Gupta\n(C) Knight\n(D) Lopez\n(E) Moss",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ninvestors = ['Fennelly', 'Gupta', 'Hall', 'Jones', 'Knight', 'Lopez', 'Moss']\ndays = list(range(1, 8))\n\n# Create a Z3 Int variable for each investor representing the day they view the site\nday_of = {inv: Int(inv) for inv in investors}\n\nsolver = Solver()\n\n# Each investor views the site on exactly one day between 1 and 7\nfor inv in investors:\n    solver.add(And(day_of[inv] >= 1, day_of[inv] <= 7))\n\n# All investors view the site on different days\nsolver.add(Distinct([day_of[inv] for inv in investors]))\n\n# CONSTRAINTS\n\n# Fennelly views the site on day 3 or else day 5\nsolver.add(Or(day_of['Fennelly'] == 3, day_of['Fennelly'] == 5))\n\n# Lopez views the site on neither day 4 nor day 6\nsolver.add(day_of['Lopez'] != 4)\nsolver.add(day_of['Lopez'] != 6)\n\n# If Jones views the site on day 1, Hall views the site on day 2\njones_day1 = (day_of['Jones'] == 1)\nhall_day2 = (day_of['Hall'] == 2)\nsolver.add(Implies(jones_day1, hall_day2))\n\n# If Knight views the site on day 4, Lopez views the site on day 5\nknight_day4 = (day_of['Knight'] == 4)\nlopez_day5 = (day_of['Lopez'] == 5)\nsolver.add(Implies(knight_day4, lopez_day5))\n\n# Gupta views the site the day after Hall views the site\nsolver.add(day_of['Gupta'] == day_of['Hall'] + 1)\n\n# OPTION CHECKING\n# Given Jones views the site on day 1\nsolver.add(day_of['Jones'] == 1)\n\n# We want to find which investor must view the site on day 4\n# Check each option to see if that investor must be on day 4\n\noptions = ['Fennelly', 'Gupta', 'Knight', 'Lopez', 'Moss']\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, inv in enumerate(options):\n    solver.push()\n    # Check if it is possible that the investor is NOT on day 4\n    solver.add(day_of[inv] != 4)\n    if solver.check() == unsat:\n        # If unsat, then the investor must be on day 4\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "During a period of seven consecutive days—from day 1 through day 7—seven investors—Fennelly, Gupta, Hall, Jones, Knight, Lopez, and Moss—will each view a building site exactly once. Each day exactly one investor will view the site. The investors must view the site in accordance with the following conditions: Fennelly views the site on day 3 or else day 5. Lopez views the site on neither day 4 nor day 6. If Jones views the site on day 1, Hall views the site on day 2. If Knight views the site on day 4, Lopez views the site on day 5. Gupta views the site on the day after the day on which Hall views the site.\n\nIf Knight views the site on day 4 and Moss views the site on some day after the day on which Jones views the site, which one of the following must be true?\n\nOptions:\n(A) Jones views the site on day 1.\n(B) Jones views the site on day 2.\n(C) Jones views the site on day 6.\n(D) Moss views the site on day 2.\n(E) Moss views the site on day 6.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ninvestors = ['Fennelly', 'Gupta', 'Hall', 'Jones', 'Knight', 'Lopez', 'Moss']\ndays = range(1, 8)\n\n# Create Int variables for each investor representing the day they view the site\nview_day = {inv: Int(inv) for inv in investors}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each investor views the site on exactly one day between 1 and 7\nfor inv in investors:\n    solver.add(And(view_day[inv] >= 1, view_day[inv] <= 7))\n\n# All investors view the site on distinct days\nsolver.add(Distinct([view_day[inv] for inv in investors]))\n\n# Fennelly views the site on day 3 or day 5\nsolver.add(Or(view_day['Fennelly'] == 3, view_day['Fennelly'] == 5))\n\n# Lopez views the site on neither day 4 nor day 6\nsolver.add(view_day['Lopez'] != 4)\nsolver.add(view_day['Lopez'] != 6)\n\n# If Jones views the site on day 1, then Hall views the site on day 2\nsolver.add(Implies(view_day['Jones'] == 1, view_day['Hall'] == 2))\n\n# If Knight views the site on day 4, then Lopez views the site on day 5\nsolver.add(Implies(view_day['Knight'] == 4, view_day['Lopez'] == 5))\n\n# Gupta views the site the day after Hall views the site\nsolver.add(view_day['Gupta'] == view_day['Hall'] + 1)\n\n# Additional given conditions for the question:\n# Knight views the site on day 4\nsolver.add(view_day['Knight'] == 4)\n\n# Moss views the site on some day after Jones views the site\nsolver.add(view_day['Moss'] > view_day['Jones'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': view_day['Jones'] == 1,\n    'B': view_day['Jones'] == 2,\n    'C': view_day['Jones'] == 6,\n    'D': view_day['Moss'] == 2,\n    'E': view_day['Moss'] == 6,\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    # Add negation of the option condition to check if it can be false\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "During a period of seven consecutive days—from day 1 through day 7—seven investors—Fennelly, Gupta, Hall, Jones, Knight, Lopez, and Moss—will each view a building site exactly once. Each day exactly one investor will view the site. The investors must view the site in accordance with the following conditions: Fennelly views the site on day 3 or else day 5. Lopez views the site on neither day 4 nor day 6. If Jones views the site on day 1, Hall views the site on day 2. If Knight views the site on day 4, Lopez views the site on day 5. Gupta views the site on the day after the day on which Hall views the site.\n\nIf Hall views the site on day 2, which one of the following is a complete and accurate list of investors any one of whom could be the investor who views the site on day 4?\n\nOptions:\n(A) Knight\n(B) Moss\n(C) Jones, Moss\n(D) Knight, Moss\n(E) Jones, Knight, Moss",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ninvestors = ['Fennelly', 'Gupta', 'Hall', 'Jones', 'Knight', 'Lopez', 'Moss']\ndays = list(range(1, 8))\n\n# Create a Z3 Int variable for each investor representing the day they view the site\ninvestor_day = {inv: Int(inv) for inv in investors}\n\nsolver = Solver()\n\n# Each investor views the site on exactly one day between 1 and 7\nfor inv in investors:\n    solver.add(And(investor_day[inv] >= 1, investor_day[inv] <= 7))\n\n# All investors view the site on different days\nsolver.add(Distinct([investor_day[inv] for inv in investors]))\n\n# CONSTRAINTS\n# Fennelly views the site on day 3 or day 5\nf_day3 = investor_day['Fennelly'] == 3\nf_day5 = investor_day['Fennelly'] == 5\nsolver.add(Or(f_day3, f_day5))\n\n# Lopez views the site on neither day 4 nor day 6\nsolver.add(investor_day['Lopez'] != 4)\nsolver.add(investor_day['Lopez'] != 6)\n\n# If Jones views the site on day 1, Hall views the site on day 2\njones_day1 = investor_day['Jones'] == 1\nhall_day2 = investor_day['Hall'] == 2\nsolver.add(Implies(jones_day1, hall_day2))\n\n# If Knight views the site on day 4, Lopez views the site on day 5\nknight_day4 = investor_day['Knight'] == 4\nlopez_day5 = investor_day['Lopez'] == 5\nsolver.add(Implies(knight_day4, lopez_day5))\n\n# Gupta views the site the day after Hall\nsolver.add(investor_day['Gupta'] == investor_day['Hall'] + 1)\n\n# Given condition: Hall views the site on day 2\nsolver.add(investor_day['Hall'] == 2)\n\n# OPTION CHECKING\n# We want to find all investors who could view the site on day 4, given the above constraints\n\npossible_investors_day4 = []\n\nfor i, option_inv in enumerate(investors):\n    solver.push()\n    solver.add(investor_day[option_inv] == 4)\n    if solver.check() == sat:\n        possible_investors_day4.append(option_inv)\n    solver.pop()\n\n# Map options to their sets for comparison\noptions_map = {\n    'A': ['Knight'],\n    'B': ['Moss'],\n    'C': ['Jones', 'Moss'],\n    'D': ['Knight', 'Moss'],\n    'E': ['Jones', 'Knight', 'Moss'],\n}\n\n# Find the option that matches exactly the possible investors on day 4\npossible_set = set(possible_investors_day4)\n\nfor letter, option_list in options_map.items():\n    if set(option_list) == possible_set:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "During a period of seven consecutive days—from day 1 through day 7—seven investors—Fennelly, Gupta, Hall, Jones, Knight, Lopez, and Moss—will each view a building site exactly once. Each day exactly one investor will view the site. The investors must view the site in accordance with the following conditions: Fennelly views the site on day 3 or else day 5. Lopez views the site on neither day 4 nor day 6. If Jones views the site on day 1, Hall views the site on day 2. If Knight views the site on day 4, Lopez views the site on day 5. Gupta views the site on the day after the day on which Hall views the site.\n\nIf Hall views the site on the day after the day Knight views the site and if Fennelly views the site on the day after the day Lopez views the site, then Jones must view the site on day\n\nOptions:\n(A) 1\n(B) 2\n(C) 3\n(D) 4\n(E) 5",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ninvestors = ['Fennelly', 'Gupta', 'Hall', 'Jones', 'Knight', 'Lopez', 'Moss']\ndays = range(1, 8)  # days 1 through 7\n\n# Create a variable for each investor representing the day they view the site\nday_vars = {inv: Int(inv) for inv in investors}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each investor views the site exactly once on a day from 1 to 7\nfor inv in investors:\n    solver.add(And(day_vars[inv] >= 1, day_vars[inv] <= 7))\n\n# All investors must have distinct viewing days\nsolver.add(Distinct([day_vars[inv] for inv in investors]))\n\n# Fennelly views the site on day 3 or day 5\nsolver.add(Or(day_vars['Fennelly'] == 3, day_vars['Fennelly'] == 5))\n\n# Lopez views the site on neither day 4 nor day 6\nsolver.add(And(day_vars['Lopez'] != 4, day_vars['Lopez'] != 6))\n\n# If Jones views the site on day 1, Hall views the site on day 2\nsolver.add(Implies(day_vars['Jones'] == 1, day_vars['Hall'] == 2))\n\n# If Knight views the site on day 4, Lopez views the site on day 5\nsolver.add(Implies(day_vars['Knight'] == 4, day_vars['Lopez'] == 5))\n\n# Gupta views the site on the day after the day on which Hall views the site\nsolver.add(day_vars['Gupta'] == day_vars['Hall'] + 1)\n\n# Additional conditions for the question:\n# Hall views the site on the day after the day Knight views the site\nsolver.add(day_vars['Hall'] == day_vars['Knight'] + 1)\n\n# Fennelly views the site on the day after the day Lopez views the site\nsolver.add(day_vars['Fennelly'] == day_vars['Lopez'] + 1)\n\n# OPTION CHECKING\noptions = ['1', '2', '3', '4', '5']\n\nfor i, option_day_str in enumerate(options):\n    solver.push()\n    option_day = int(option_day_str)\n    # Jones must view the site on the day specified by the option\n    solver.add(day_vars['Jones'] == option_day)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "During a period of seven consecutive days—from day 1 through day 7—seven investors—Fennelly, Gupta, Hall, Jones, Knight, Lopez, and Moss—will each view a building site exactly once. Each day exactly one investor will view the site. The investors must view the site in accordance with the following conditions: Fennelly views the site on day 3 or else day 5. Lopez views the site on neither day 4 nor day 6. If Jones views the site on day 1, Hall views the site on day 2. If Knight views the site on day 4, Lopez views the site on day 5. Gupta views the site on the day after the day on which Hall views the site.\n\nIf the day on which Gupta views the site and the day on which Lopez views the site both come at some time before the day on which Fennelly views the site, which one of the following is an investor who could view the site on day 3?\n\nOptions:\n(A) Fennelly\n(B) Gupta\n(C) Jones\n(D) Knight\n(E) Moss",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ninvestors = ['Fennelly', 'Gupta', 'Hall', 'Jones', 'Knight', 'Lopez', 'Moss']\ndays = range(1, 8)  # days 1 through 7\n\n# Create Z3 Int variables for each investor representing the day they view the site\nday_vars = {inv: Int(inv) for inv in investors}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each investor views the site exactly once on a day between 1 and 7\nfor inv in investors:\n    solver.add(And(day_vars[inv] >= 1, day_vars[inv] <= 7))\n\n# All investors view the site on different days\nsolver.add(Distinct([day_vars[inv] for inv in investors]))\n\n# Fennelly views the site on day 3 or day 5\nsolver.add(Or(day_vars['Fennelly'] == 3, day_vars['Fennelly'] == 5))\n\n# Lopez views the site on neither day 4 nor day 6\nsolver.add(And(day_vars['Lopez'] != 4, day_vars['Lopez'] != 6))\n\n# If Jones views the site on day 1, Hall views the site on day 2\nsolver.add(Implies(day_vars['Jones'] == 1, day_vars['Hall'] == 2))\n\n# If Knight views the site on day 4, Lopez views the site on day 5\nsolver.add(Implies(day_vars['Knight'] == 4, day_vars['Lopez'] == 5))\n\n# Gupta views the site the day after Hall views the site\nsolver.add(day_vars['Gupta'] == day_vars['Hall'] + 1)\n\n# Additional condition given in the question:\n# The day Gupta views the site and the day Lopez views the site both come before the day Fennelly views the site\nsolver.add(day_vars['Gupta'] < day_vars['Fennelly'])\nsolver.add(day_vars['Lopez'] < day_vars['Fennelly'])\n\n# OPTION CHECKING\noptions = ['Fennelly', 'Gupta', 'Jones', 'Knight', 'Moss']\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraint: The investor in the option views the site on day 3\n    solver.add(day_vars[option] == 3)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A zoo's reptile house has a straight row of exactly five consecutive habitats—numbered 1 through 5 from left to right—for housing exactly seven reptiles—four snakes and three lizards. Five of the reptiles are female and two are male. The reptiles must be housed as follows: No habitat houses more than two reptiles. No habitat houses both a snake and a lizard. No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard.\n\nIf habitat 2 contains at least one female snake and habitat 4 contains two male lizards, then which one of the following could be true?\n\nOptions:\n(A) Habitat 3 contains two reptiles.\n(B) Habitat 5 contains two reptiles.\n(C) Habitat 1 contains a female lizard.\n(D) Habitat 2 contains a female lizard.\n(E) Habitat 5 contains a female lizard.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Habitats numbered 1 to 5\nhabitats = [1, 2, 3, 4, 5]\n\n# Reptiles: 7 total: 4 snakes (S1-S4), 3 lizards (L1-L3)\nreptiles = ['S1', 'S2', 'S3', 'S4', 'L1', 'L2', 'L3']\n\n# Sex: 5 female (F), 2 male (M)\n# Assign sex to reptiles:\n# We don't know which snakes/lizards are male/female except constraints\n# We'll create variables for sex: 1=female, 0=male\n\nsex = {r: Int(f\"sex_{r}\") for r in reptiles}  # 1=female, 0=male\n\n# Species type: snake or lizard\nspecies = {}\nfor r in reptiles:\n    if r.startswith('S'):\n        species[r] = 'snake'\n    else:\n        species[r] = 'lizard'\n\n# Location: habitat number 1..5\nlocation = {r: Int(f\"loc_{r}\") for r in reptiles}\n\n# Number of reptiles per habitat: count how many reptiles in each habitat\n# We'll use helper expressions later\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1) Habitat numbers between 1 and 5\nfor r in reptiles:\n    solver.add(And(location[r] >= 1, location[r] <= 5))\n\n# 2) Exactly 7 reptiles: all assigned habitats (done above)\n# 3) Total reptiles: 4 snakes, 3 lizards (given)\n# 4) Sex counts: 5 female, 2 male\nsex_values = [sex[r] for r in reptiles]\nfor r in reptiles:\n    # sex is 0 or 1\n    solver.add(Or(sex[r] == 0, sex[r] == 1))\nsolver.add(Sum(sex_values) == 5)  # 5 females\nsolver.add(Sum([1 - sex[r] for r in reptiles]) == 2)  # 2 males\n\n# 5) No habitat houses more than two reptiles\nfor h in habitats:\n    count_in_h = Sum([If(location[r] == h, 1, 0) for r in reptiles])\n    solver.add(count_in_h <= 2)\n\n# 6) No habitat houses both a snake and a lizard\n# For each habitat, either all reptiles there are snakes or all are lizards or empty\nfor h in habitats:\n    # If habitat h has any snake and any lizard, forbidden\n    has_snake = Or([location[r] == h for r in reptiles if species[r] == 'snake'])\n    has_lizard = Or([location[r] == h for r in reptiles if species[r] == 'lizard'])\n    # Not both true\n    solver.add(Not(And(has_snake, has_lizard)))\n\n# 7) No female snake housed in a habitat immediately next to a habitat housing a male lizard\n# For every female snake r_s and every male lizard r_l:\n# abs(loc[r_s] - loc[r_l]) != 1\n\nfemale_snakes = [r for r in reptiles if species[r] == 'snake']\nmale_lizards = [r for r in reptiles if species[r] == 'lizard']\n\nfor r_s in female_snakes:\n    for r_l in male_lizards:\n        cond_female_snake = sex[r_s] == 1\n        cond_male_lizard = sex[r_l] == 0\n        # If both hold, habitats cannot be adjacent\n        solver.add(Implies(And(cond_female_snake, cond_male_lizard),\n                           Abs(location[r_s] - location[r_l]) != 1))\n\n# 8) Exactly 4 snakes and 3 lizards assigned\n# Enforce species count by assigning distinct reptiles to species sets (already defined)\n# Just check that all reptiles assigned to some habitat, done above\n\n# 9) Given conditions:\n# Habitat 2 contains at least one female snake\n# Habitat 4 contains two male lizards\n\n# Habitat 2 contains at least one female snake\nfemale_snake_in_2 = Or([And(location[r] == 2, sex[r] == 1) for r in female_snakes])\nsolver.add(female_snake_in_2)\n\n# Habitat 4 contains two male lizards\nmale_lizards_in_4 = [And(location[r] == 4, sex[r] == 0) for r in male_lizards]\nsolver.add(Sum([If(cond, 1, 0) for cond in male_lizards_in_4]) == 2)\n\n# 10) All reptiles assigned to habitats, no overlaps on same reptile, done by variables\n\n# OPTION CHECKING\noptions = [\n    # (A) Habitat 3 contains two reptiles.\n    lambda: Sum([If(location[r] == 3, 1, 0) for r in reptiles]) == 2,\n    # (B) Habitat 5 contains two reptiles.\n    lambda: Sum([If(location[r] == 5, 1, 0) for r in reptiles]) == 2,\n    # (C) Habitat 1 contains a female lizard.\n    lambda: Or([And(location[r] == 1, sex[r] == 1) for r in reptiles if species[r] == 'lizard']),\n    # (D) Habitat 2 contains a female lizard.\n    lambda: Or([And(location[r] == 2, sex[r] == 1) for r in reptiles if species[r] == 'lizard']),\n    # (E) Habitat 5 contains a female lizard.\n    lambda: Or([And(location[r] == 5, sex[r] == 1) for r in reptiles if species[r] == 'lizard']),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option())\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A zoo's reptile house has a straight row of exactly five consecutive habitats—numbered 1 through 5 from left to right—for housing exactly seven reptiles—four snakes and three lizards. Five of the reptiles are female and two are male. The reptiles must be housed as follows: No habitat houses more than two reptiles. No habitat houses both a snake and a lizard. No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard.\n\nWhich one of the following must be true?\n\nOptions:\n(A) At least one female reptile is alone in a habitat.\n(B) At least one male reptile is alone in a habitat.\n(C) At least one lizard is alone in a habitat.\n(D) At least one lizard is male.\n(E) At least one snake is male.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nhabitats = [1, 2, 3, 4, 5]\n\n# Reptiles: 7 total\n# 4 snakes (S1, S2, S3, S4), 3 lizards (L1, L2, L3)\n# 5 females, 2 males total\n# We assign indices for reptiles 0..6\n# Let's index reptiles as follows:\n# 0-3: snakes (S0, S1, S2, S3)\n# 4-6: lizards (L4, L5, L6)\n\nreptiles = range(7)\nsnake_indices = [0, 1, 2, 3]\nlizard_indices = [4, 5, 6]\n\n# Gender: 5 females, 2 males\n# We'll represent gender as Bool: True = female, False = male\n# We don't know which are male/female, so we create variables\n\ngender = [Bool(f'gender_{r}') for r in reptiles]  # True = female, False = male\n\n# Habitat assignment: for each reptile, habitat number 1..5\nhabitat = [Int(f'habitat_{r}') for r in reptiles]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each reptile is assigned to a habitat 1..5\nfor r in reptiles:\n    solver.add(And(habitat[r] >= 1, habitat[r] <= 5))\n\n# Exactly 5 females and 2 males\n# Count females: sum of gender[r] == True is 5\nnum_females = Sum([If(g, 1, 0) for g in gender])\nsolver.add(num_females == 5)\n\n# Exactly 2 males\nnum_males = Sum([If(g, 0, 1) for g in gender])\nsolver.add(num_males == 2)\n\n# No habitat houses more than two reptiles\nfor h in habitats:\n    count_in_h = Sum([If(habitat[r] == h, 1, 0) for r in reptiles])\n    solver.add(count_in_h <= 2)\n\n# No habitat houses both a snake and a lizard\n# For each habitat h, either all reptiles there are snakes or all are lizards (or empty)\n# So for each habitat, if there is at least one snake and one lizard assigned there, not allowed\n\nfor h in habitats:\n    snake_in_h = Or([habitat[r] == h for r in snake_indices])\n    lizard_in_h = Or([habitat[r] == h for r in lizard_indices])\n    solver.add(Or(Not(snake_in_h), Not(lizard_in_h)))\n\n# No female snake is housed in a habitat immediately next to a habitat housing a male lizard.\n# For every female snake r_s and every male lizard r_l:\n# abs(habitat[r_s] - habitat[r_l]) != 1\n\nfor r_s in snake_indices:\n    for r_l in lizard_indices:\n        female_snake = gender[r_s] == True\n        male_lizard = gender[r_l] == False\n        # If female snake and male lizard, habitats cannot be adjacent\n        cond = And(female_snake, male_lizard)\n        dist1 = Or(habitat[r_s] == habitat[r_l] + 1, habitat[r_s] == habitat[r_l] - 1)\n        solver.add(Implies(cond, Not(dist1)))\n\n# There are 7 reptiles placed in 5 habitats with max 2 per habitat => exactly 2 habitats have 2 reptiles, 3 habitats have 1 reptile each\n# This is implicitly enforced by above constraints, no need to add explicitly\n\n# OPTION CHECKING\n\n# We'll check each option by adding its negation and seeing if model is satisfiable.\n# If negation is unsat, option must be true.\n\noptions = {\n    'A': \"At least one female reptile is alone in a habitat.\",\n    'B': \"At least one male reptile is alone in a habitat.\",\n    'C': \"At least one lizard is alone in a habitat.\",\n    'D': \"At least one lizard is male.\",\n    'E': \"At least one snake is male.\"\n}\n\ndef reptile_alone_condition(r):\n    # Reptile r is alone in its habitat if no other reptile shares the habitat\n    return And([If(habitat[r_other] == habitat[r], r_other == r, True) for r_other in reptiles])\n\ndef at_least_one_reptile_alone(gender_cond=None, species_cond=None):\n    # gender_cond: function taking r and gender[r], returns Bool or None\n    # species_cond: function taking r, returns Bool or None\n    # Return a Z3 expression that at least one reptile satisfies conditions and is alone\n    conds = []\n    for r in reptiles:\n        cond_gender = True if gender_cond is None else gender_cond(r, gender[r])\n        cond_species = True if species_cond is None else species_cond(r)\n        alone = reptile_alone_condition(r)\n        conds.append(And(cond_gender, cond_species, alone))\n    return Or(conds)\n\ndef at_least_one_lizard_male():\n    # At least one lizard is male\n    conds = []\n    for r in lizard_indices:\n        conds.append(gender[r] == False)\n    return Or(conds)\n\ndef at_least_one_snake_male():\n    conds = []\n    for r in snake_indices:\n        conds.append(gender[r] == False)\n    return Or(conds)\n\n# Check options in order:\n\n# (A) At least one female reptile is alone in a habitat.\n# Negation: No female reptile is alone in a habitat.\nsolver.push()\nno_female_alone = Not(at_least_one_reptile_alone(gender_cond=lambda r,g: g == True))\nsolver.add(no_female_alone)\nif solver.check() == unsat:\n    print(\"'A'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (B) At least one male reptile is alone in a habitat.\n# Negation: No male reptile is alone in a habitat.\nsolver.push()\nno_male_alone = Not(at_least_one_reptile_alone(gender_cond=lambda r,g: g == False))\nsolver.add(no_male_alone)\nif solver.check() == unsat:\n    print(\"'B'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (C) At least one lizard is alone in a habitat.\n# Negation: No lizard is alone in a habitat.\nsolver.push()\nno_lizard_alone = Not(at_least_one_reptile_alone(species_cond=lambda r: r in lizard_indices))\nsolver.add(no_lizard_alone)\nif solver.check() == unsat:\n    print(\"'C'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (D) At least one lizard is male.\n# Negation: No lizard is male (all lizards female)\nsolver.push()\nno_lizard_male = Not(at_least_one_lizard_male())\nsolver.add(no_lizard_male)\nif solver.check() == unsat:\n    print(\"'D'\")\n    solver.pop()\nelse:\n    solver.pop()\n\n# (E) At least one snake is male.\n# Negation: No snake is male (all snakes female)\nsolver.push()\nno_snake_male = Not(at_least_one_snake_male())\nsolver.add(no_snake_male)\nif solver.check() == unsat:\n    print(\"'E'\")\n    solver.pop()\nelse:\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A zoo's reptile house has a straight row of exactly five consecutive habitats—numbered 1 through 5 from left to right—for housing exactly seven reptiles—four snakes and three lizards. Five of the reptiles are female and two are male. The reptiles must be housed as follows: No habitat houses more than two reptiles. No habitat houses both a snake and a lizard. No female snake is housed in a habitat that is immediately next to a habitat housing a male lizard.\n\nIf habitat 3 is empty, and no snake is housed in a habitat that is immediately next to a habitat containing a snake, then which one of the following could be false?\n\nOptions:\n(A) All snakes are housed in even-numbered habitats.\n(B) None of the lizards is male.\n(C) No snake is alone in a habitat.\n(D) No lizard is housed in a habitat that is immediately next to a habitat containing a lizard.\n(E) Exactly one habitat contains exactly one reptile.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nhabitats = [1, 2, 3, 4, 5]\nnum_habitats = len(habitats)\n\n# Reptiles: 7 total\n# 4 snakes (S), 3 lizards (L)\n# 5 female (F), 2 male (M)\n# Each reptile indexed 0..6\nreptiles = list(range(7))\n\n# For each reptile:\n# habitat assigned (0..4 for habitats 1..5)\n# species: 0=snake, 1=lizard\n# sex: 0=female, 1=male\n\n# Assign species and sex fixed by problem statement:\n# 4 snakes: reptiles 0..3\n# 3 lizards: reptiles 4..6\n# 5 female, 2 male total\n\n# We'll assign sex variables for each reptile\nspecies = [0]*4 + [1]*3  # 0=snake,1=lizard\n\n# Create Z3 variables\nhab = [Int(f'hab_{i}') for i in reptiles]  # habitat index 0..4\nsex = [Int(f'sex_{i}') for i in reptiles]  # 0=female,1=male\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Habitats must be in 0..4 (representing habitats 1..5)\nfor i in reptiles:\n    solver.add(And(hab[i] >= 0, hab[i] < num_habitats))\n\n# Species fixed:\n# snakes: reptiles 0..3\nfor i in range(4):\n    # species[i] == 0 snake\n    pass\n# lizards: reptiles 4..6\nfor i in range(4,7):\n    # species[i] == 1 lizard\n    pass\n\n# Sex variables: 0=female,1=male\nfor i in reptiles:\n    solver.add(Or(sex[i] == 0, sex[i] == 1))\n\n# Exactly 5 female, 2 male\nsolver.add(Sum([If(sex[i] == 0, 1, 0) for i in reptiles]) == 5)\nsolver.add(Sum([If(sex[i] == 1, 1, 0) for i in reptiles]) == 2)\n\n# No habitat houses more than two reptiles\nfor h in range(num_habitats):\n    count_in_h = Sum([If(hab[i] == h, 1, 0) for i in reptiles])\n    solver.add(count_in_h <= 2)\n\n# No habitat houses both a snake and a lizard\nfor h in range(num_habitats):\n    snakes_in_h = Sum([If(And(hab[i] == h, species[i] == 0), 1, 0) for i in reptiles])\n    lizards_in_h = Sum([If(And(hab[i] == h, species[i] == 1), 1, 0) for i in reptiles])\n    solver.add(Or(snakes_in_h == 0, lizards_in_h == 0))\n\n# No female snake is housed in a habitat immediately next to a habitat housing a male lizard.\n# For each female snake, check habitats adjacent to its habitat for male lizard\nfor i in range(4):  # snakes 0..3\n    is_female_snake = sex[i] == 0\n    hab_i = hab[i]\n    for j in range(4,7):  # lizards 4..6\n        is_male_lizard = sex[j] == 1\n        hab_j = hab[j]\n        # habitats adjacent if abs(hab_i - hab_j) == 1\n        adjacent = Or(hab_i == hab_j + 1, hab_i == hab_j - 1)\n        # If female snake at hab_i and male lizard at hab_j adjacent => forbidden\n        solver.add(Implies(And(is_female_snake, adjacent, is_male_lizard), False))\n\n# Habitat 3 is empty (habitat index 2)\nfor i in reptiles:\n    solver.add(hab[i] != 2)\n\n# No snake is housed in a habitat immediately next to a habitat containing a snake.\n# For every snake, habitats adjacent to its habitat do not contain snake.\nfor i in range(4):\n    hab_i = hab[i]\n    for j in range(4):\n        if i != j:\n            hab_j = hab[j]\n            adjacent = Or(hab_i == hab_j + 1, hab_i == hab_j - 1)\n            # If habitats adjacent, can't both be snakes (they are)\n            solver.add(Not(adjacent))\n\n# We will check which option could be false.\n# Options:\n# (A) All snakes are housed in even-numbered habitats.\n# (B) None of the lizards is male.\n# (C) No snake is alone in a habitat.\n# (D) No lizard is housed in a habitat that is immediately next to a habitat containing a lizard.\n# (E) Exactly one habitat contains exactly one reptile.\n\n# We will test each option by adding the negation of that option and checking satisfiability.\n# If satisfiable, then that option could be false.\n\noptions = {}\n\n# Helper: habitat number from index: index 0..4 => habitat 1..5\ndef hab_num(h):\n    return h + 1\n\n# (A) All snakes are housed in even-numbered habitats.\n# Negation: Exists a snake in an odd-numbered habitat\nA_neg = Or([hab[i] % 2 == 0 for i in range(4)])  # Even habitat index means habitat number odd (index 0=hab1)\n# But habitat number even means index is odd (index 1=hab2)\n# So even-numbered habitats are indices 1 and 3\n# So snake habitat index must be 1 or 3\n# So negation is snake in habitat index 0,2,4 (odd-numbered habitats are 1,3,5 => indices 0,2,4)\n# So negation: Exists snake in odd-numbered habitat index in {0,2,4}\nA_neg = Or([hab[i] == 0 for i in range(4)] + [hab[i] == 2 for i in range(4)] + [hab[i] == 4 for i in range(4)])\n\noptions['A'] = A_neg\n\n# (B) None of the lizards is male.\n# Negation: Exists a male lizard\nB_neg = Or([sex[i] == 1 for i in range(4,7)])\noptions['B'] = B_neg\n\n# (C) No snake is alone in a habitat.\n# Negation: Exists a snake alone in a habitat\n# For each snake, count reptiles in its habitat == 1\nC_neg_parts = []\nfor i in range(4):\n    h_i = hab[i]\n    count_in_h = Sum([If(hab[j] == h_i, 1, 0) for j in reptiles])\n    alone = count_in_h == 1\n    C_neg_parts.append(alone)\nC_neg = Or(C_neg_parts)\noptions['C'] = C_neg\n\n# (D) No lizard is housed in a habitat immediately next to a habitat containing a lizard.\n# Negation: Exists lizard adjacent to another lizard\nD_neg_parts = []\nfor i in range(4,7):\n    for j in range(i+1,7):\n        hab_i = hab[i]\n        hab_j = hab[j]\n        adjacent = Or(hab_i == hab_j + 1, hab_i == hab_j - 1)\n        D_neg_parts.append(adjacent)\nD_neg = Or(D_neg_parts)\noptions['D'] = D_neg\n\n# (E) Exactly one habitat contains exactly one reptile.\n# Negation: Number of habitats with exactly one reptile != 1\n# Count habitats with exactly one reptile\none_reptile_counts = []\nfor h in range(num_habitats):\n    count_in_h = Sum([If(hab[i] == h, 1, 0) for i in reptiles])\n    one_reptile_counts.append(If(count_in_h == 1, 1, 0))\nsum_one_reptile = Sum(one_reptile_counts)\nE_neg = Or(sum_one_reptile != 1)\noptions['E'] = E_neg\n\n# OPTION CHECKING\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.\n\nWhich one of the following could be an accurate matching of film buffs to films?\n\nOptions:\n(A) Ginnie: the Hitchcock film; Ian: the Kurosawa film; Marcos: the Hitchcock film\n(B) Ginnie: the Kurosawa film; Ian: the Fellini film; Viktor: the Fellini film\n(C) Ian: the Hitchcock film; Reveka: the Kurosawa film; Viktor: the Fellini film\n(D) Marcos: the Kurosawa film; Reveka: the Kurosawa film; Viktor: the Kurosawa film\n(E) Marcos: the Hitchcock film; Reveka: the Hitchcock film; Yow: the Hitchcock film",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfilm_buffs = ['Ginnie', 'Ian', 'Lianna', 'Marcos', 'Reveka', 'Viktor', 'Yow']\nfilms = ['Fellini', 'Hitchcock', 'Kurosawa']\n\n# Create Int variables for each film buff representing the film they see\nbuff_films = {buff: Int(buff) for buff in film_buffs}\n\n# Map films to indices\nfellini = films.index('Fellini')\nhitchcock = films.index('Hitchcock')\nkurosawa = films.index('Kurosawa')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each buff sees exactly one film (0, 1, or 2)\nfor buff in film_buffs:\n    solver.add(And(buff_films[buff] >= 0, buff_films[buff] < len(films)))\n\n# Count how many see each film\nfellini_count = Sum([If(buff_films[buff] == fellini, 1, 0) for buff in film_buffs])\nhitchcock_count = Sum([If(buff_films[buff] == hitchcock, 1, 0) for buff in film_buffs])\nkurosawa_count = Sum([If(buff_films[buff] == kurosawa, 1, 0) for buff in film_buffs])\n\n# Exactly twice as many see Hitchcock as see Fellini\nsolver.add(hitchcock_count == 2 * fellini_count)\n\n# Ginnie and Reveka do not see the same film\nsolver.add(buff_films['Ginnie'] != buff_films['Reveka'])\n\n# Ian and Marcos do not see the same film\nsolver.add(buff_films['Ian'] != buff_films['Marcos'])\n\n# Viktor and Yow see the same film\nsolver.add(buff_films['Viktor'] == buff_films['Yow'])\n\n# Lianna sees the Hitchcock film\nsolver.add(buff_films['Lianna'] == hitchcock)\n\n# Ginnie sees either Fellini or Kurosawa\ngn_fellini = buff_films['Ginnie'] == fellini\ngn_kurosawa = buff_films['Ginnie'] == kurosawa\nsolver.add(Or([gn_fellini, gn_kurosawa]))\n\n# OPTION CHECKING\noptions = [\n    {'Ginnie': hitchcock, 'Ian': kurosawa, 'Marcos': hitchcock},  # A\n    {'Ginnie': kurosawa, 'Ian': fellini, 'Viktor': fellini},      # B\n    {'Ian': hitchcock, 'Reveka': kurosawa, 'Viktor': fellini},   # C\n    {'Marcos': kurosawa, 'Reveka': kurosawa, 'Viktor': kurosawa}, # D\n    {'Marcos': hitchcock, 'Reveka': hitchcock, 'Yow': hitchcock}  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints from option\n    for buff, film_idx in option.items():\n        solver.add(buff_films[buff] == film_idx)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.\n\nEach of the following must be false EXCEPT:\n\nOptions:\n(A) Reveka is the only film buff to see the Fellini film.\n(B) Reveka is the only film buff to see the Hitchcock film.\n(C) Yow is the only film buff to see the Kurosawa film.\n(D) Exactly two film buffs see the Kurosawa film.\n(E) Exactly three film buffs see the Hitchcock film.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfilm_buffs = ['Ginnie', 'Ian', 'Lianna', 'Marcos', 'Reveka', 'Viktor', 'Yow']\nfilms = ['Fellini', 'Hitchcock', 'Kurosawa']\n\n# Map film buffs to Z3 Int variables representing the film they see\nbuff_film = {buff: Int(buff) for buff in film_buffs}\n\nsolver = Solver()\n\n# Each buff sees exactly one film (0=Fellini,1=Hitchcock,2=Kurosawa)\nfor buff in film_buffs:\n    solver.add(And(buff_film[buff] >= 0, buff_film[buff] < len(films)))\n\n# CONSTRAINTS\n\n# Exactly twice as many see Hitchcock as see Fellini\n# Count how many see each film\nfellini_count = Sum([If(buff_film[buff] == 0, 1, 0) for buff in film_buffs])\nhitchcock_count = Sum([If(buff_film[buff] == 1, 1, 0) for buff in film_buffs])\nkurosawa_count = Sum([If(buff_film[buff] == 2, 1, 0) for buff in film_buffs])\n\nsolver.add(hitchcock_count == 2 * fellini_count)\n\n# Ginnie and Reveka do not see the same film\nsolver.add(buff_film['Ginnie'] != buff_film['Reveka'])\n\n# Ian and Marcos do not see the same film\nsolver.add(buff_film['Ian'] != buff_film['Marcos'])\n\n# Viktor and Yow see the same film\nsolver.add(buff_film['Viktor'] == buff_film['Yow'])\n\n# Lianna sees the Hitchcock film\nsolver.add(buff_film['Lianna'] == 1)\n\n# Ginnie sees either Fellini or Kurosawa\nsolver.add(Or(buff_film['Ginnie'] == 0, buff_film['Ginnie'] == 2))\n\n# OPTION CHECKING\noptions = ['A', 'B', 'C', 'D', 'E']\n\n# Each option must be false except one, so check which option being true is consistent\nfor i, option in enumerate(options):\n    solver.push()\n    # Add the negation of all other options and the current option as true\n    # Define option conditions\n    # We want exactly one option to be true and all others false\n    # So for each option, check if it can be true while others false\n\n    # Option A: Reveka is the only buff to see Fellini\n    optA = And(buff_film['Reveka'] == 0,\n               fellini_count == 1)\n\n    # Option B: Reveka is the only buff to see Hitchcock\n    optB = And(buff_film['Reveka'] == 1,\n               hitchcock_count == 1)\n\n    # Option C: Yow is the only buff to see Kurosawa\n    optC = And(buff_film['Yow'] == 2,\n               kurosawa_count == 1)\n\n    # Option D: Exactly two buffs see Kurosawa\n    optD = (kurosawa_count == 2)\n\n    # Option E: Exactly three buffs see Hitchcock\n    optE = (hitchcock_count == 3)\n\n    option_exprs = [optA, optB, optC, optD, optE]\n\n    # Current option true\n    solver.add(option_exprs[i])\n\n    # All other options false\n    for j, other_opt in enumerate(option_exprs):\n        if j != i:\n            solver.add(Not(other_opt))\n\n    if solver.check() == sat:\n        print(f\"'{option}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.\n\nWhich one of the following could be a complete and accurate list of the film buffs who do NOT see the Hitchcock film?\n\nOptions:\n(A) Ginnie, Marcos\n(B) Ginnie Reveka\n(C) Ginnie, Ian, Reveka\n(D) Ginnie, Marcos, Yow\n(E) Ginnie, Viktor, Yow",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfilm_buffs = ['Ginnie', 'Ian', 'Lianna', 'Marcos', 'Reveka', 'Viktor', 'Yow']\nfilms = ['Fellini', 'Hitchcock', 'Kurosawa']\n\n# Map buffs to Z3 Int variables representing the film they see (0=Fellini,1=Hitchcock,2=Kurosawa)\nbuff_film = {buff: Int(buff) for buff in film_buffs}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each buff sees exactly one film (value in [0..2])\nfor buff in film_buffs:\n    solver.add(And(buff_film[buff] >= 0, buff_film[buff] < len(films)))\n\n# Exactly twice as many see Hitchcock as see Fellini\nfellini_count = Sum([If(buff_film[buff] == films.index('Fellini'), 1, 0) for buff in film_buffs])\nhitchcock_count = Sum([If(buff_film[buff] == films.index('Hitchcock'), 1, 0) for buff in film_buffs])\nkurosawa_count = Sum([If(buff_film[buff] == films.index('Kurosawa'), 1, 0) for buff in film_buffs])\nsolver.add(hitchcock_count == 2 * fellini_count)\n\n# Ginnie and Reveka do not see the same film\nsolver.add(buff_film['Ginnie'] != buff_film['Reveka'])\n\n# Ian and Marcos do not see the same film\nsolver.add(buff_film['Ian'] != buff_film['Marcos'])\n\n# Viktor and Yow see the same film\nsolver.add(buff_film['Viktor'] == buff_film['Yow'])\n\n# Lianna sees the Hitchcock film\nsolver.add(buff_film['Lianna'] == films.index('Hitchcock'))\n\n# Ginnie sees either Fellini or Kurosawa\nsolver.add(Or(buff_film['Ginnie'] == films.index('Fellini'), buff_film['Ginnie'] == films.index('Kurosawa')))\n\n# OPTION CHECKING\noptions = {\n    'A': ['Ginnie', 'Marcos'],\n    'B': ['Ginnie', 'Reveka'],\n    'C': ['Ginnie', 'Ian', 'Reveka'],\n    'D': ['Ginnie', 'Marcos', 'Yow'],\n    'E': ['Ginnie', 'Viktor', 'Yow']\n}\n\nfor opt_letter, not_hitchcock_buffs in options.items():\n    solver.push()\n    # Add constraints that buffs in not_hitchcock_buffs do NOT see Hitchcock\n    for buff in not_hitchcock_buffs:\n        solver.add(buff_film[buff] != films.index('Hitchcock'))\n    # Buffs NOT in not_hitchcock_buffs must see Hitchcock\n    buffs_not_in_option = [b for b in film_buffs if b not in not_hitchcock_buffs]\n    for buff in buffs_not_in_option:\n        solver.add(buff_film[buff] == films.index('Hitchcock'))\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.\n\nIf exactly one film buff sees the Kurosawa film, then which one of the following must be true?\n\nOptions:\n(A) Viktor sees the Hitchcock film.\n(B) Ginnie sees the Fellini film.\n(C) Marcos sees the Fellini film.\n(D) Ian sees the Fellini film.\n(E) Reveka sees the Hitchcock film.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfilm_buffs = ['Ginnie', 'Ian', 'Lianna', 'Marcos', 'Reveka', 'Viktor', 'Yow']\ndirectors = ['Fellini', 'Hitchcock', 'Kurosawa']\n\n# Map directors to indices\nFELLINI = 0\nHITCHCOCK = 1\nKUROSAWA = 2\n\n# Create a variable for each film buff representing the film they see\nseen = {fb: Int(fb) for fb in film_buffs}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each film buff sees exactly one film (domain constraint)\nfor fb in film_buffs:\n    solver.add(And(seen[fb] >= 0, seen[fb] < len(directors)))\n\n# Exactly twice as many see Hitchcock as Fellini\n# Count how many see each film\nfellini_count = Sum([If(seen[fb] == FELLINI, 1, 0) for fb in film_buffs])\nhitchcock_count = Sum([If(seen[fb] == HITCHCOCK, 1, 0) for fb in film_buffs])\nkurosawa_count = Sum([If(seen[fb] == KUROSAWA, 1, 0) for fb in film_buffs])\n\nsolver.add(hitchcock_count == 2 * fellini_count)\n\n# Ginnie and Reveka do not see the same film\nsolver.add(seen['Ginnie'] != seen['Reveka'])\n\n# Ian and Marcos do not see the same film\nsolver.add(seen['Ian'] != seen['Marcos'])\n\n# Viktor and Yow see the same film\nsolver.add(seen['Viktor'] == seen['Yow'])\n\n# Lianna sees the Hitchcock film\nsolver.add(seen['Lianna'] == HITCHCOCK)\n\n# Ginnie sees either Fellini or Kurosawa\nsolver.add(Or(seen['Ginnie'] == FELLINI, seen['Ginnie'] == KUROSAWA))\n\n# Exactly one film buff sees Kurosawa\nsolver.add(kurosawa_count == 1)\n\n# OPTION CHECKING\noptions = [\n    ('A', seen['Viktor'] == HITCHCOCK),\n    ('B', seen['Ginnie'] == FELLINI),\n    ('C', seen['Marcos'] == FELLINI),\n    ('D', seen['Ian'] == FELLINI),\n    ('E', seen['Reveka'] == HITCHCOCK)\n]\n\nfor letter, option_constraint in options:\n    solver.push()\n    solver.add(Not(option_constraint))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Ginnie sees a different film than Ian does.\n(B) Ian sees a different film than Lianna does.\n(C) Ian sees a different film than Viktor does.\n(D) Ian, Lianna, and Viktor do not all see the same film.\n(E) Ginnie, Lianna, and Marcos do not all see the same film.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfilm_buffs = ['Ginnie', 'Ian', 'Lianna', 'Marcos', 'Reveka', 'Viktor', 'Yow']\ndirectors = ['Fellini', 'Hitchcock', 'Kurosawa']\n\n# Map film buffs to Int variables representing film indices\nseen = {fb: Int(fb) for fb in film_buffs}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each film buff sees exactly one of the three films\nfor fb in film_buffs:\n    solver.add(And(seen[fb] >= 0, seen[fb] < len(directors)))\n\n# Exactly twice as many see Hitchcock as see Fellini\n# Count how many see each film\nfellini_count = Sum([If(seen[fb] == directors.index('Fellini'), 1, 0) for fb in film_buffs])\nhitchcock_count = Sum([If(seen[fb] == directors.index('Hitchcock'), 1, 0) for fb in film_buffs])\nkurosawa_count = Sum([If(seen[fb] == directors.index('Kurosawa'), 1, 0) for fb in film_buffs])\n\nsolver.add(hitchcock_count == 2 * fellini_count)\nsolver.add(fellini_count + hitchcock_count + kurosawa_count == 7)\n\n# Ginnie and Reveka do not see the same film\nsolver.add(seen['Ginnie'] != seen['Reveka'])\n\n# Ian and Marcos do not see the same film\nsolver.add(seen['Ian'] != seen['Marcos'])\n\n# Viktor and Yow see the same film\nsolver.add(seen['Viktor'] == seen['Yow'])\n\n# Lianna sees Hitchcock film\nsolver.add(seen['Lianna'] == directors.index('Hitchcock'))\n\n# Ginnie sees either Fellini or Kurosawa\nsolver.add(Or(seen['Ginnie'] == directors.index('Fellini'), seen['Ginnie'] == directors.index('Kurosawa')))\n\n# OPTION CHECKING\noptions = {\n    'A': seen['Ginnie'] != seen['Ian'],\n    'B': seen['Ian'] != seen['Lianna'],\n    'C': seen['Ian'] != seen['Viktor'],\n    'D': Not(And(seen['Ian'] == seen['Lianna'], seen['Lianna'] == seen['Viktor'])),\n    'E': Not(And(seen['Ginnie'] == seen['Lianna'], seen['Lianna'] == seen['Marcos']))\n}\n\nfor option_letter, condition in options.items():\n    solver.push()\n    solver.add(Not(condition))  # Negate the option to test if it must be true\n    if solver.check() == unsat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.\n\nIf Viktor sees the same film as Ginnie does, then which one of the following could be true?\n\nOptions:\n(A) Ginnie sees the Fellini film.\n(B) Ian sees the Hitchcock film.\n(C) Reveka sees the Kurosawa film.\n(D) Viktor sees the Hitchcock film.\n(E) Yow sees the Fellini film.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfilm_buffs = ['Ginnie', 'Ian', 'Lianna', 'Marcos', 'Reveka', 'Viktor', 'Yow']\nfilms = ['Fellini', 'Hitchcock', 'Kurosawa']\n\n# Create Z3 Int variables for each film buff, representing the film they see\nbuff_films = {buff: Int(buff) for buff in film_buffs}\n\n# Create a Solver instance\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each buff's film must be a valid index (0,1,2)\nfor buff in film_buffs:\n    solver.add(And(buff_films[buff] >= 0, buff_films[buff] < len(films)))\n\n# Count how many see each film\n# Create integer variables for counts\ncount_fellini = Int('count_fellini')\ncount_hitchcock = Int('count_hitchcock')\ncount_kurosawa = Int('count_kurosawa')\n\n# Counts are sums of buffs seeing each film\nsolver.add(count_fellini == Sum([If(buff_films[buff] == films.index('Fellini'), 1, 0) for buff in film_buffs]))\nsolver.add(count_hitchcock == Sum([If(buff_films[buff] == films.index('Hitchcock'), 1, 0) for buff in film_buffs]))\nsolver.add(count_kurosawa == Sum([If(buff_films[buff] == films.index('Kurosawa'), 1, 0) for buff in film_buffs]))\n\n# Exactly twice as many see Hitchcock as Fellini\nsolver.add(count_hitchcock == 2 * count_fellini)\n\n# Ginnie and Reveka do not see the same film\nsolver.add(buff_films['Ginnie'] != buff_films['Reveka'])\n\n# Ian and Marcos do not see the same film\nsolver.add(buff_films['Ian'] != buff_films['Marcos'])\n\n# Viktor and Yow see the same film\nsolver.add(buff_films['Viktor'] == buff_films['Yow'])\n\n# Lianna sees the Hitchcock film\nsolver.add(buff_films['Lianna'] == films.index('Hitchcock'))\n\n# Ginnie sees either Fellini or Kurosawa\nsolver.add(Or(buff_films['Ginnie'] == films.index('Fellini'), buff_films['Ginnie'] == films.index('Kurosawa')))\n\n# Additional condition: Viktor sees the same film as Ginnie\nsolver.add(buff_films['Viktor'] == buff_films['Ginnie'])\n\n# OPTION CHECKING\n# Options:\n# (A) Ginnie sees the Fellini film.\n# (B) Ian sees the Hitchcock film.\n# (C) Reveka sees the Kurosawa film.\n# (D) Viktor sees the Hitchcock film.\n# (E) Yow sees the Fellini film.\n\noptions = [\n    buff_films['Ginnie'] == films.index('Fellini'),\n    buff_films['Ian'] == films.index('Hitchcock'),\n    buff_films['Reveka'] == films.index('Kurosawa'),\n    buff_films['Viktor'] == films.index('Hitchcock'),\n    buff_films['Yow'] == films.index('Fellini')\n]\n\nfor i, option_constraint in enumerate(options):\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly seven film buffs—Ginnie, Ian, Lianna, Marcos, Reveka, Viktor, and Yow—attend a showing of classic films. Three films are shown, one directed by Fellini, one by Hitchcock, and one by Kurosawa. Each of the film buffs sees exactly one of the three films. The films are shown only once, one film at a time. The following restrictions must apply: Exactly twice as many of the film buffs see the Hitchcock film as see the Fellini film. Ginnie and Reveka do not see the same film as each other. Ian and Marcos do not see the same film as each other. Viktor and Yow see the same film as each other. Lianna sees the Hitchcock film. Ginnie sees either the Fellini film or the Kurosawa film.\n\nEach of the following could be complete and accurate list of the film buffs who see the Fellini film EXCEPT:\n\nOptions:\n(A) Ginnie, Ian\n(B) Ginnie, Marcos\n(C) Ian, Reveka\n(D) Marcos, Reveka\n(E) Viktor, Yow",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfilm_buffs = ['Ginnie', 'Ian', 'Lianna', 'Marcos', 'Reveka', 'Viktor', 'Yow']\nfilms = ['Fellini', 'Hitchcock', 'Kurosawa']\n\n# Map film buffs to Int variables representing films they see (0:Fellini,1:Hitchcock,2:Kurosawa)\nbuff_film = {buff: Int(buff) for buff in film_buffs}\n\n# Helper: film indices\nFELLINI = films.index('Fellini')\nHITCHCOCK = films.index('Hitchcock')\nKUROSAWA = films.index('Kurosawa')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each buff sees exactly one film\nfor buff in film_buffs:\n    solver.add(And(buff_film[buff] >= 0, buff_film[buff] < len(films)))\n\n# Exactly twice as many see Hitchcock as Fellini\nfellini_count = Sum([If(buff_film[buff] == FELLINI, 1, 0) for buff in film_buffs])\nhitchcock_count = Sum([If(buff_film[buff] == HITCHCOCK, 1, 0) for buff in film_buffs])\nsolver.add(hitchcock_count == 2 * fellini_count)\n\n# Ginnie and Reveka do not see the same film\nsolver.add(buff_film['Ginnie'] != buff_film['Reveka'])\n\n# Ian and Marcos do not see the same film\nsolver.add(buff_film['Ian'] != buff_film['Marcos'])\n\n# Viktor and Yow see the same film\nsolver.add(buff_film['Viktor'] == buff_film['Yow'])\n\n# Lianna sees the Hitchcock film\nsolver.add(buff_film['Lianna'] == HITCHCOCK)\n\n# Ginnie sees either Fellini or Kurosawa\nsolver.add(Or(buff_film['Ginnie'] == FELLINI, buff_film['Ginnie'] == KUROSAWA))\n\n# OPTION CHECKING\noptions = {\n    'A': ['Ginnie', 'Ian'],\n    'B': ['Ginnie', 'Marcos'],\n    'C': ['Ian', 'Reveka'],\n    'D': ['Marcos', 'Reveka'],\n    'E': ['Viktor', 'Yow']\n}\n\nfor letter, fellini_list in options.items():\n    solver.push()\n    # Add constraints that exactly these buffs see Fellini film\n    # So buffs in fellini_list see Fellini\n    for buff in fellini_list:\n        solver.add(buff_film[buff] == FELLINI)\n    # Buffs not in fellini_list do not see Fellini\n    for buff in film_buffs:\n        if buff not in fellini_list:\n            solver.add(buff_film[buff] != FELLINI)\n    # Check satisfiability\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Six cars are to be arranged in a straight line, and will be numbered 1 through 6, in order, from the front of the line to the back of the line. Each car is exactly one color: two are green, two are orange, and two are purple. The arrangement of cars is restricted as follows: No car can be the same color as any car next to it in line. Either car 5 or car 6 must be purple. Car 1 cannot be orange. Car 4 cannot be green.\n\nThe cars in which one of the following pairs CANNOT be the same color as each other?\n\nOptions:\n(A) cars 1 and 4\n(B) cars 1 and 5\n(C) cars 3 and 5\n(D) cars 3 and 6\n(E) cars 4 and 6",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npositions = range(1, 7)\ncolors = ['green', 'orange', 'purple']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Create a variable for each car's color (0=green,1=orange,2=purple)\ncar_color = {pos: Int(f'car_{pos}_color') for pos in positions}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each car's color is in {0,1,2}\nfor pos in positions:\n    solver.add(And(car_color[pos] >= 0, car_color[pos] < len(colors)))\n\n# Exactly two cars are green, two are orange, two are purple\nfor c in colors:\n    count_c = Sum([If(car_color[pos] == color_indices[c], 1, 0) for pos in positions])\n    solver.add(count_c == 2)\n\n# No two adjacent cars have the same color\nfor pos in range(1, 6):\n    solver.add(car_color[pos] != car_color[pos + 1])\n\n# Either car 5 or car 6 must be purple\nsolver.add(Or(car_color[5] == color_indices['purple'], car_color[6] == color_indices['purple']))\n\n# Car 1 cannot be orange\nsolver.add(car_color[1] != color_indices['orange'])\n\n# Car 4 cannot be green\nsolver.add(car_color[4] != color_indices['green'])\n\n# OPTION CHECKING\n# For each option, add constraint that the two cars are the same color and check satisfiability\noptions = [\n    (1, 4),  # A\n    (1, 5),  # B\n    (3, 5),  # C\n    (3, 6),  # D\n    (4, 6)   # E\n]\n\nfor i, (c1, c2) in enumerate(options):\n    solver.push()\n    solver.add(car_color[c1] == car_color[c2])\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Six cars are to be arranged in a straight line, and will be numbered 1 through 6, in order, from the front of the line to the back of the line. Each car is exactly one color: two are green, two are orange, and two are purple. The arrangement of cars is restricted as follows: No car can be the same color as any car next to it in line. Either car 5 or car 6 must be purple. Car 1 cannot be orange. Car 4 cannot be green.\n\nIf car 2 is the same color as car 4, then which one of the following statements must be true?\n\nOptions:\n(A) Car 1 is purple.\n(B) Car 2 is orange.\n(C) Car 3 is green.\n(D) Car 5 is purple.\n(E) Car 6 is green",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'orange', 'purple']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Create Z3 Int variables for each car's color (0=green,1=orange,2=purple)\ncars = ['car1', 'car2', 'car3', 'car4', 'car5', 'car6']\ncar_color = {car: Int(car) for car in cars}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each car color is in range 0..2\nfor car in cars:\n    solver.add(And(car_color[car] >= 0, car_color[car] < len(colors)))\n\n# Exactly two cars of each color\n# Count occurrences of each color\nfor c in colors:\n    c_idx = color_indices[c]\n    count_c = Sum([If(car_color[car] == c_idx, 1, 0) for car in cars])\n    solver.add(count_c == 2)\n\n# No two adjacent cars can have the same color\nfor i in range(len(cars) - 1):\n    solver.add(car_color[cars[i]] != car_color[cars[i+1]])\n\n# Either car5 or car6 must be purple\npurple_idx = color_indices['purple']\nsolver.add(Or(car_color['car5'] == purple_idx, car_color['car6'] == purple_idx))\n\n# Car1 cannot be orange\norange_idx = color_indices['orange']\nsolver.add(car_color['car1'] != orange_idx)\n\n# Car4 cannot be green\ngreen_idx = color_indices['green']\nsolver.add(car_color['car4'] != green_idx)\n\n# Additional condition: car2 is the same color as car4\nsolver.add(car_color['car2'] == car_color['car4'])\n\n# OPTION CHECKING\n# Options:\n# (A) Car1 is purple.\n# (B) Car2 is orange.\n# (C) Car3 is green.\n# (D) Car5 is purple.\n# (E) Car6 is green.\n\noptions = {\n    'A': car_color['car1'] == purple_idx,\n    'B': car_color['car2'] == orange_idx,\n    'C': car_color['car3'] == green_idx,\n    'D': car_color['car5'] == purple_idx,\n    'E': car_color['car6'] == green_idx,\n}\n\n# We want to find which option must be true.\n# So for each option, check if the negation is satisfiable with all constraints.\n# The correct option will be the one whose negation is unsat.\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Six cars are to be arranged in a straight line, and will be numbered 1 through 6, in order, from the front of the line to the back of the line. Each car is exactly one color: two are green, two are orange, and two are purple. The arrangement of cars is restricted as follows: No car can be the same color as any car next to it in line. Either car 5 or car 6 must be purple. Car 1 cannot be orange. Car 4 cannot be green.\n\nIf car 4 is purple, which one of the following must be true?\n\nOptions:\n(A) Car 1 is orange.\n(B) Car 2 is green.\n(C) Car 3 is orange.\n(D) Car 5 is green.\n(E) Car 6 is purple.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['green', 'orange', 'purple']\ncolor_indices = {color: i for i, color in enumerate(colors)}\n\n# Create Int variables for each car's color (0=green,1=orange,2=purple)\ncars = [Int(f'car{i}') for i in range(1, 7)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each car's color is in range 0..2\nfor car in cars:\n    solver.add(And(car >= 0, car < len(colors)))\n\n# Exactly two cars are green, two are orange, two are purple\ngreen_count = Sum([If(car == color_indices['green'], 1, 0) for car in cars])\norange_count = Sum([If(car == color_indices['orange'], 1, 0) for car in cars])\npurple_count = Sum([If(car == color_indices['purple'], 1, 0) for car in cars])\nsolver.add(green_count == 2)\nsolver.add(orange_count == 2)\nsolver.add(purple_count == 2)\n\n# No two adjacent cars have the same color\nfor i in range(5):\n    solver.add(cars[i] != cars[i+1])\n\n# Either car 5 or car 6 must be purple\nsolver.add(Or(cars[4] == color_indices['purple'], cars[5] == color_indices['purple']))\n\n# Car 1 cannot be orange\nsolver.add(cars[0] != color_indices['orange'])\n\n# Car 4 cannot be green\nsolver.add(cars[3] != color_indices['green'])\n\n# Additional condition: Car 4 is purple\nsolver.add(cars[3] == color_indices['purple'])\n\n# OPTION CHECKING\n# Options:\n# (A) Car 1 is orange.\n# (B) Car 2 is green.\n# (C) Car 3 is orange.\n# (D) Car 5 is green.\n# (E) Car 6 is purple.\n\noptions = [\n    cars[0] == color_indices['orange'],  # A\n    cars[1] == color_indices['green'],   # B\n    cars[2] == color_indices['orange'],  # C\n    cars[4] == color_indices['green'],   # D\n    cars[5] == color_indices['purple']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))  # Check if option can be false\n    if solver.check() == unsat:\n        # Option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Six cars are to be arranged in a straight line, and will be numbered 1 through 6, in order, from the front of the line to the back of the line. Each car is exactly one color: two are green, two are orange, and two are purple. The arrangement of cars is restricted as follows: No car can be the same color as any car next to it in line. Either car 5 or car 6 must be purple. Car 1 cannot be orange. Car 4 cannot be green.\n\nWhich one of the following statements must be false?\n\nOptions:\n(A) Car 2 is green.\n(B) Car 4 is orange.\n(C) Car 5 is purple.\n(D) Car 6 is orange.\n(E) Car 6 is green.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npositions = range(1, 7)\ncolors = ['green', 'orange', 'purple']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Create Z3 Int variables for each car's color\ncar_color = {pos: Int(f'car_{pos}_color') for pos in positions}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each car's color is an integer index in [0, 2]\nfor pos in positions:\n    solver.add(And(car_color[pos] >= 0, car_color[pos] < len(colors)))\n\n# Exactly two cars per color: count occurrences of each color must be 2\nfor c_idx in range(len(colors)):\n    count_c = Sum([If(car_color[pos] == c_idx, 1, 0) for pos in positions])\n    solver.add(count_c == 2)\n\n# No adjacent cars can be the same color\nfor pos in range(1, 6):\n    solver.add(car_color[pos] != car_color[pos + 1])\n\n# Either car 5 or car 6 must be purple (purple index = 2)\nsolver.add(Or(car_color[5] == color_indices['purple'], car_color[6] == color_indices['purple']))\n\n# Car 1 cannot be orange (orange index = 1)\nsolver.add(car_color[1] != color_indices['orange'])\n\n# Car 4 cannot be green (green index = 0)\nsolver.add(car_color[4] != color_indices['green'])\n\n# OPTION CHECKING\n# Define the options as constraints\noptions = {\n    'A': car_color[2] == color_indices['green'],   # Car 2 is green\n    'B': car_color[4] == color_indices['orange'],  # Car 4 is orange\n    'C': car_color[5] == color_indices['purple'],  # Car 5 is purple\n    'D': car_color[6] == color_indices['orange'],  # Car 6 is orange\n    'E': car_color[6] == color_indices['green'],   # Car 6 is green\n}\n\n# We want to find which option must be false\n# So for each option, check if it is possible (i.e., satisfiable)\n# The one that is NOT satisfiable must be false\n\nfor letter, constraint in options.items():\n    solver.push()\n    solver.add(constraint)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.\n\nIf Neptune arrived after Kashmir, which one of the following must be false?\n\nOptions:\n(A) Jewel was the second of the boats to arrive.\n(B) Kashmir was the fifth of the boats to arrive.\n(C) Neptune was the third of the boats to arrive.\n(D) Ojibwa was the sixth of the boats to arrive.\n(E) Spain was the seventh of the boats to arrive.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nboats = ['Jewel', 'Kashmir', 'Neptune', 'Ojibwa', 'Pacific', 'Spain', 'Tornado', 'Valhalla']\nboat_indices = {b: i for i, b in enumerate(boats)}\n\n# Create integer variables for arrival positions (1 to 8)\narrival = {b: Int(b) for b in boats}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each boat arrives at a unique position from 1 to 8\nfor b in boats:\n    solver.add(And(arrival[b] >= 1, arrival[b] <= 8))\nsolver.add(Distinct([arrival[b] for b in boats]))\n\n# Given ordering constraints:\n# Tornado arrived before Spain but after Jewel.\nsolver.add(arrival['Jewel'] < arrival['Tornado'])\nsolver.add(arrival['Tornado'] < arrival['Spain'])\n\n# Neptune arrived before Tornado.\nsolver.add(arrival['Neptune'] < arrival['Tornado'])\n\n# Kashmir arrived after Jewel but before Spain.\nsolver.add(arrival['Jewel'] < arrival['Kashmir'])\nsolver.add(arrival['Kashmir'] < arrival['Spain'])\n\n# Spain arrived before Ojibwa.\nsolver.add(arrival['Spain'] < arrival['Ojibwa'])\n\n# Additional condition: Neptune arrived after Kashmir.\nsolver.add(arrival['Neptune'] > arrival['Kashmir'])\n\n# OPTION CHECKING\noptions = {\n    'A': arrival['Jewel'] == 2,\n    'B': arrival['Kashmir'] == 5,\n    'C': arrival['Neptune'] == 3,\n    'D': arrival['Ojibwa'] == 6,\n    'E': arrival['Spain'] == 7,\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add the option constraint\n    solver.add(options[letter])\n    # Check if the model is satisfiable with the option true\n    if solver.check() == unsat:\n        # If unsat, the option must be false\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.\n\nOf the eight boats, what is the maximum number that could have arrived before Jewel?\n\nOptions:\n(A) none\n(B) one\n(C) two\n(D) three\n(E) four",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nboats = ['Jewel', 'Kashmir', 'Neptune', 'Ojibwa', 'Pacific', 'Spain', 'Tornado', 'Valhalla']\nboat_indices = {b: i for i, b in enumerate(boats)}\n\n# Create Z3 Int variables representing the arrival order (0 earliest, 7 latest)\narrival = {b: Int(b) for b in boats}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each boat has a unique arrival time between 0 and 7\nfor b in boats:\n    solver.add(And(arrival[b] >= 0, arrival[b] < 8))\nsolver.add(Distinct([arrival[b] for b in boats]))\n\n# Tornado arrived before Spain but after Jewel: Jewel < Tornado < Spain\nsolver.add(arrival['Jewel'] < arrival['Tornado'])\nsolver.add(arrival['Tornado'] < arrival['Spain'])\n\n# Neptune arrived before Tornado\nsolver.add(arrival['Neptune'] < arrival['Tornado'])\n\n# Kashmir arrived after Jewel but before Spain: Jewel < Kashmir < Spain\nsolver.add(arrival['Jewel'] < arrival['Kashmir'])\nsolver.add(arrival['Kashmir'] < arrival['Spain'])\n\n# Spain arrived before Ojibwa\nsolver.add(arrival['Spain'] < arrival['Ojibwa'])\n\n# OPTION CHECKING\n\noptions = ['none', 'one', 'two', 'three', 'four']\n\n# We want to find the maximum number of boats that could have arrived before Jewel.\n# For each option, we add a constraint that exactly that many boats arrived before Jewel.\n# Check from largest to smallest to find the maximum feasible number.\n\nfor i in reversed(range(len(options))):\n    solver.push()\n    # Count how many boats arrived before Jewel\n    before_jewel = [arrival[b] < arrival['Jewel'] for b in boats if b != 'Jewel']\n    # Sum of boats arriving before Jewel\n    # Create Bool variables for each boat if it arrived before Jewel\n    bools = [If(cond, 1, 0) for cond in before_jewel]\n    total_before = Sum(bools)\n    solver.add(total_before == i)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.\n\nOf the eight boats, if Valhalla was the second to arrive, then which one of the following CANNOT be true?\n\nOptions:\n(A) Jewel was the third to arrive.\n(B) Jewel was the first to arrive.\n(C) Kashmir was the third to arrive.\n(D) Pacific was the third to arrive.\n(E) Tornado was the third to arrive.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nboats = ['Jewel', 'Kashmir', 'Neptune', 'Ojibwa', 'Pacific', 'Spain', 'Tornado', 'Valhalla']\nboat_indices = {b: Int(b) for b in boats}\nnum_boats = len(boats)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each boat's arrival position is between 1 and 8\nfor b in boats:\n    solver.add(And(boat_indices[b] >= 1, boat_indices[b] <= num_boats))\n\n# All boats arrive at distinct times\nsolver.add(Distinct([boat_indices[b] for b in boats]))\n\n# Given constraints:\n# Tornado arrived before Spain but after Jewel.\nsolver.add(boat_indices['Jewel'] < boat_indices['Tornado'])\nsolver.add(boat_indices['Tornado'] < boat_indices['Spain'])\n\n# Neptune arrived before Tornado.\nsolver.add(boat_indices['Neptune'] < boat_indices['Tornado'])\n\n# Kashmir arrived after Jewel but before Spain.\nsolver.add(boat_indices['Jewel'] < boat_indices['Kashmir'])\nsolver.add(boat_indices['Kashmir'] < boat_indices['Spain'])\n\n# Spain arrived before Ojibwa.\nsolver.add(boat_indices['Spain'] < boat_indices['Ojibwa'])\n\n# Valhalla was the second to arrive.\nsolver.add(boat_indices['Valhalla'] == 2)\n\n# OPTION CHECKING\noptions = {\n    'A': boat_indices['Jewel'] == 3,\n    'B': boat_indices['Jewel'] == 1,\n    'C': boat_indices['Kashmir'] == 3,\n    'D': boat_indices['Pacific'] == 3,\n    'E': boat_indices['Tornado'] == 3,\n}\n\nfor option_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[option_letter])\n    if solver.check() == unsat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.\n\nIf Valhalla arrived before Neptune but after Pacific, which one of the following could be true?\n\nOptions:\n(A) Tornado arrived before Valhalla.\n(B) Kashmir arrived before Pacific.\n(C) Ojibwa was not the last of the boats to arrive.\n(D) Spain arrived before Valhalla.\n(E) Spain was not the seventh of the boats to arrive.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nboats = ['Jewel', 'Kashmir', 'Neptune', 'Ojibwa', 'Pacific', 'Spain', 'Tornado', 'Valhalla']\nboat_indices = {b: Int(b) for b in boats}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each boat arrives at a unique time from 1 to 8\nfor b in boats:\n    solver.add(And(boat_indices[b] >= 1, boat_indices[b] <= 8))\nsolver.add(Distinct([boat_indices[b] for b in boats]))\n\n# Given constraints:\n# Tornado arrived before Spain but after Jewel: Jewel < Tornado < Spain\nsolver.add(boat_indices['Jewel'] < boat_indices['Tornado'])\nsolver.add(boat_indices['Tornado'] < boat_indices['Spain'])\n\n# Neptune arrived before Tornado\nsolver.add(boat_indices['Neptune'] < boat_indices['Tornado'])\n\n# Kashmir arrived after Jewel but before Spain\nsolver.add(boat_indices['Jewel'] < boat_indices['Kashmir'])\nsolver.add(boat_indices['Kashmir'] < boat_indices['Spain'])\n\n# Spain arrived before Ojibwa\nsolver.add(boat_indices['Spain'] < boat_indices['Ojibwa'])\n\n# Valhalla arrived before Neptune but after Pacific\nsolver.add(boat_indices['Pacific'] < boat_indices['Valhalla'])\nsolver.add(boat_indices['Valhalla'] < boat_indices['Neptune'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': boat_indices['Tornado'] < boat_indices['Valhalla'],  # Tornado arrived before Valhalla\n    'B': boat_indices['Kashmir'] < boat_indices['Pacific'],  # Kashmir arrived before Pacific\n    'C': boat_indices['Ojibwa'] != 8,                        # Ojibwa was not last\n    'D': boat_indices['Spain'] < boat_indices['Valhalla'],  # Spain arrived before Valhalla\n    'E': boat_indices['Spain'] != 7                          # Spain was not seventh\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly eight boats—Jewel, Kashmir, Neptune, Ojibwa, Pacific, Spain, Tornado, and Valhalla—arrived at a dock. No boat arrived at the same time as any other boat. The boats arrived in an order consistent with the following conditions: Tornado arrived before Spain but after Jewel. Neptune arrived before Tornado. Kashmir arrived after Jewel but before Spain. Spain arrived before Ojibwa.\n\nOf the boats, what are, respectively, the minimum number and the maximum number that could have arrived before Kashmir?\n\nOptions:\n(A) one, five\n(B) two, five\n(C) three, five\n(D) one, six\n(E) two, six",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nboats = ['Jewel', 'Kashmir', 'Neptune', 'Ojibwa', 'Pacific', 'Spain', 'Tornado', 'Valhalla']\nn = len(boats)\n\n# Create Z3 Int variables for arrival positions (0 is earliest, 7 is latest)\narrival = {}\nfor b in boats:\n    arrival[b] = Int(b)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each boat's arrival time is between 0 and 7\nfor b in boats:\n    solver.add(And(arrival[b] >= 0, arrival[b] < n))\n\n# All arrival times are distinct (no ties)\nsolver.add(Distinct([arrival[b] for b in boats]))\n\n# Given conditions:\n\n# Tornado arrived before Spain but after Jewel.\nsolver.add(arrival['Tornado'] < arrival['Spain'])\nsolver.add(arrival['Tornado'] > arrival['Jewel'])\n\n# Neptune arrived before Tornado.\nsolver.add(arrival['Neptune'] < arrival['Tornado'])\n\n# Kashmir arrived after Jewel but before Spain.\nsolver.add(arrival['Kashmir'] > arrival['Jewel'])\nsolver.add(arrival['Kashmir'] < arrival['Spain'])\n\n# Spain arrived before Ojibwa.\nsolver.add(arrival['Spain'] < arrival['Ojibwa'])\n\n# OPTION CHECKING\n\n# We want to find the minimum and maximum number of boats that could have arrived before Kashmir.\n\n# Number of boats arrived before Kashmir = count of boats with arrival time < arrival[Kashmir]\n# We exclude Kashmir itself.\n\n# We'll check for each possible count from 0 to 7 if it is possible.\n\npossible_counts = []\n\nfor count in range(n):\n    solver.push()\n    # Count how many boats arrived before Kashmir\n    # Create Bool variables for each boat indicating if it arrived before Kashmir\n    bools = []\n    for b in boats:\n        if b != 'Kashmir':\n            bools.append(arrival[b] < arrival['Kashmir'])\n    # Sum of these bools == count\n    solver.add(Sum([If(cond, 1, 0) for cond in bools]) == count)\n    if solver.check() == sat:\n        possible_counts.append(count)\n    solver.pop()\n\nmin_count = min(possible_counts)\nmax_count = max(possible_counts)\n\n# Now check which option matches (min_count, max_count)\noptions = [\n    (1,5),\n    (2,5),\n    (3,5),\n    (1,6),\n    (2,6)\n]\n\nfor i, (min_opt, max_opt) in enumerate(options):\n    if min_count == min_opt and max_count == max_opt:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.\n\nWhich one of the following could be a complete and accurate list of the kinds of trees in the park?\n\nOptions:\n(A) firs, maples\n(B) firs, laurels, oaks\n(C) firs, laurels, pines, spruces\n(D) firs, laurels, spruces, yews\n(E) firs, maples, oaks, spruces, yews",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrees = ['firs', 'laurels', 'maples', 'oaks', 'pines', 'spruces', 'yews']\n# Create a Bool variable for each tree indicating presence in the park\npresence = {t: Bool(t) for t in trees}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# At most five kinds of trees in the park\nnum_trees = Sum([If(presence[t], 1, 0) for t in trees])\nsolver.add(num_trees <= 5)\n\n# If maples are in the park, yews are not\nsolver.add(Implies(presence['maples'], Not(presence['yews'])))\n\n# If firs are in the park, pines are not\nsolver.add(Implies(presence['firs'], Not(presence['pines'])))\n\n# If yews are not in the park, then either laurels or oaks, but not both, are in the park\nno_yews = Not(presence['yews'])\nlaurels_xor_oaks = Xor(presence['laurels'], presence['oaks'])\nsolver.add(Implies(no_yews, laurels_xor_oaks))\n\n# If it is not the case that the park contains both laurels and oaks,\n# then it contains firs and spruces\nnot_both_laurels_oaks = Not(And(presence['laurels'], presence['oaks']))\nsolver.add(Implies(not_both_laurels_oaks, And(presence['firs'], presence['spruces'])))\n\n# OPTION CHECKING\noptions = [\n    ['firs', 'maples'],                                # A\n    ['firs', 'laurels', 'oaks'],                       # B\n    ['firs', 'laurels', 'pines', 'spruces'],           # C\n    ['firs', 'laurels', 'spruces', 'yews'],            # D\n    ['firs', 'maples', 'oaks', 'spruces', 'yews']      # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that exactly the trees in option are present, others absent\n    for t in trees:\n        if t in option:\n            solver.add(presence[t] == True)\n        else:\n            solver.add(presence[t] == False)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.\n\nIf neither maples nor spruces are in the park, then which one of the following could be true?\n\nOptions:\n(A) Exactly four kinds of trees are in the park.\n(B) Exactly five kinds of trees are in the park.\n(C) Laurels are not in the park.\n(D) Oaks are not in the park.\n(E) Yews are not in the park.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrees = ['firs', 'laurels', 'maples', 'oaks', 'pines', 'spruces', 'yews']\n# Create a Bool variable for each tree indicating if it is in the park\nin_park = {tree: Bool(tree) for tree in trees}\n\nsolver = Solver()\n\n# Constraint: At most 5 kinds of trees\nnum_in_park = Sum([If(in_park[tree], 1, 0) for tree in trees])\nsolver.add(num_in_park <= 5)\n\n# Conditions:\n# 1. If maples are in the park, yews are not.\nsolver.add(Implies(in_park['maples'], Not(in_park['yews'])))\n\n# 2. If firs are in the park, pines are not.\nsolver.add(Implies(in_park['firs'], Not(in_park['pines'])))\n\n# 3. If yews are not in the park, then either laurels or oaks, but not both, are in the park.\n# This means: Not(yews) -> (laurels XOR oaks)\nlaurels_xor_oaks = Xor(in_park['laurels'], in_park['oaks'])\nsolver.add(Implies(Not(in_park['yews']), laurels_xor_oaks))\n\n# 4. If it is not the case that the park contains both laurels and oaks,\n# then it contains firs and spruces.\n# That is: If not (laurels and oaks), then firs and spruces\nsolver.add(Implies(Not(And(in_park['laurels'], in_park['oaks'])), And(in_park['firs'], in_park['spruces'])))\n\n# Additional given condition for the question:\n# Neither maples nor spruces are in the park\nsolver.add(Not(in_park['maples']))\nsolver.add(Not(in_park['spruces']))\n\n# OPTION CHECKING\noptions = [\n    num_in_park == 4,         # (A) Exactly four kinds of trees are in the park.\n    num_in_park == 5,         # (B) Exactly five kinds of trees are in the park.\n    Not(in_park['laurels']),  # (C) Laurels are not in the park.\n    Not(in_park['oaks']),     # (D) Oaks are not in the park.\n    Not(in_park['yews'])      # (E) Yews are not in the park.\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Neither firs nor laurels are in the park.\n(B) Neither laurels, oaks, nor yews are in the park.\n(C) Neither laurels nor spruces are in the park.\n(D) Neither maples nor yews are in the park.\n(E) Neither oaks nor spruces are in the park.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrees = ['firs', 'laurels', 'maples', 'oaks', 'pines', 'spruces', 'yews']\ntree_vars = {t: Bool(t) for t in trees}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# At most five kinds of trees in the park\nnum_trees = Sum([If(tree_vars[t], 1, 0) for t in trees])\nsolver.add(num_trees <= 5)\n\n# If maples are in the park, yews are not\nsolver.add(Implies(tree_vars['maples'], Not(tree_vars['yews'])))\n\n# If firs are in the park, pines are not\nsolver.add(Implies(tree_vars['firs'], Not(tree_vars['pines'])))\n\n# If yews are not in the park, then either laurels or oaks, but not both, are in the park\nsolver.add(Implies(Not(tree_vars['yews']),\n                   Xor(tree_vars['laurels'], tree_vars['oaks'])))\n\n# If it is not the case that the park contains both laurels and oaks,\n# then it contains firs and spruces\nsolver.add(Implies(Not(And(tree_vars['laurels'], tree_vars['oaks'])),\n                   And(tree_vars['firs'], tree_vars['spruces'])))\n\n# OPTION CHECKING\noptions = {\n    'A': And(Not(tree_vars['firs']), Not(tree_vars['laurels'])),\n    'B': And(Not(tree_vars['laurels']), Not(tree_vars['oaks']), Not(tree_vars['yews'])),\n    'C': And(Not(tree_vars['laurels']), Not(tree_vars['spruces'])),\n    'D': And(Not(tree_vars['maples']), Not(tree_vars['yews'])),\n    'E': And(Not(tree_vars['oaks']), Not(tree_vars['spruces']))\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.\n\nIf firs are not in the park, then which one of the following must be true?\n\nOptions:\n(A) Maples are not in the park.\n(B) Spruces are not in the park.\n(C) Yews are not in the park.\n(D) Pines are in the park.\n(E) Spruces are in the park.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Tree kinds\ntrees = ['firs', 'laurels', 'maples', 'oaks', 'pines', 'spruces', 'yews']\ntree_vars = {t: Bool(t) for t in trees}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# At most five kinds of trees in the park\nsolver.add(Sum([If(tree_vars[t], 1, 0) for t in trees]) <= 5)\n\n# If maples are in the park, yews are not\nsolver.add(Implies(tree_vars['maples'], Not(tree_vars['yews'])))\n\n# If firs are in the park, pines are not\nsolver.add(Implies(tree_vars['firs'], Not(tree_vars['pines'])))\n\n# If yews are not in the park, then either laurels or oaks, but not both, are in the park\nlaurels_or_oaks = Xor(tree_vars['laurels'], tree_vars['oaks'])\nsolver.add(Implies(Not(tree_vars['yews']), laurels_or_oaks))\n\n# If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces\nboth_laurels_oaks = And(tree_vars['laurels'], tree_vars['oaks'])\nsolver.add(Implies(Not(both_laurels_oaks), And(tree_vars['firs'], tree_vars['spruces'])))\n\n# OPTION CHECKING\n# Given: firs are not in the park\nsolver.add(tree_vars['firs'] == False)\n\noptions = {\n    'A': Not(tree_vars['maples']),    # Maples are not in the park\n    'B': Not(tree_vars['spruces']),   # Spruces are not in the park\n    'C': Not(tree_vars['yews']),      # Yews are not in the park\n    'D': tree_vars['pines'],          # Pines are in the park\n    'E': tree_vars['spruces'],        # Spruces are in the park\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    # Check if condition must be true: add negation and check for unsat\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.\n\nIf pines are in the park, then which one of the following must be true?\n\nOptions:\n(A) Exactly four kinds of trees are in the park.\n(B) Exactly five kinds of trees are in the park.\n(C) Neither firs nor maples are in the park.\n(D) Neither firs nor oaks are in the park.\n(E) Neither laurels nor maples are in the park.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrees = ['firs', 'laurels', 'maples', 'oaks', 'pines', 'spruces', 'yews']\ntree_vars = {t: Bool(t) for t in trees}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# At most five kinds of trees in the park\nnum_trees = Sum([If(tree_vars[t], 1, 0) for t in trees])\nsolver.add(num_trees <= 5)\n\n# If maples are in the park, yews are not\nsolver.add(Implies(tree_vars['maples'], Not(tree_vars['yews'])))\n\n# If firs are in the park, pines are not\nsolver.add(Implies(tree_vars['firs'], Not(tree_vars['pines'])))\n\n# If yews are not in the park, then either laurels or oaks, but not both, are in the park\nsolver.add(Implies(Not(tree_vars['yews']),\n                   Xor(tree_vars['laurels'], tree_vars['oaks'])))\n\n# If it is not the case that the park contains both laurels and oaks,\n# then it contains firs and spruces\nboth_laurels_oaks = And(tree_vars['laurels'], tree_vars['oaks'])\nsolver.add(Implies(Not(both_laurels_oaks),\n                   And(tree_vars['firs'], tree_vars['spruces'])))\n\n# OPTION CHECKING\noptions = [\n    # (A) Exactly four kinds of trees are in the park.\n    num_trees == 4,\n    # (B) Exactly five kinds of trees are in the park.\n    num_trees == 5,\n    # (C) Neither firs nor maples are in the park.\n    And(Not(tree_vars['firs']), Not(tree_vars['maples'])),\n    # (D) Neither firs nor oaks are in the park.\n    And(Not(tree_vars['firs']), Not(tree_vars['oaks'])),\n    # (E) Neither laurels nor maples are in the park.\n    And(Not(tree_vars['laurels']), Not(tree_vars['maples']))\n]\n\n# We want to find which option must be true if pines are in the park.\n# So we add pines=True and check which options are always true.\n\n# For each option, check if there is a model with pines=True and option=False.\n# If no such model exists, option must be true.\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(tree_vars['pines'])  # pines in the park\n    solver.add(Not(opt))             # option is false\n    if solver.check() == unsat:\n        # option must be true if pines are in the park\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A park contains at most five of seven kinds of trees—firs, laurels, maples, oaks, pines, spruces, and yews—consistent with the following conditions: If maples are in the park, yews are not. If firs are in the park, pines are not. If yews are not in the park, then either laurels or oaks, but not both, are in the park. If it is not the case that the park contains both laurels and oaks, then it contains firs and spruces.\n\nEach of the following could be an accurate, partial list of the kinds of trees in the park EXCEPT:\n\nOptions:\n(A) oaks, spruces\n(B) oaks, yews\n(C) firs, laurels, oaks\n(D) firs, maples, oaks\n(E) laurels, maples, oaks",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrees = ['firs', 'laurels', 'maples', 'oaks', 'pines', 'spruces', 'yews']\ntree_vars = {t: Bool(t) for t in trees}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# At most five kinds of trees\nsolver.add(Sum([If(tree_vars[t], 1, 0) for t in trees]) <= 5)\n\n# If maples are in the park, yews are not\nsolver.add(Implies(tree_vars['maples'], Not(tree_vars['yews'])))\n\n# If firs are in the park, pines are not\nsolver.add(Implies(tree_vars['firs'], Not(tree_vars['pines'])))\n\n# If yews are not in the park, then either laurels or oaks, but not both, are in the park\nsolver.add(Implies(Not(tree_vars['yews']),\n                   Xor(tree_vars['laurels'], tree_vars['oaks'])))\n\n# If it is not the case that the park contains both laurels and oaks,\n# then it contains firs and spruces\nnot_laurels_and_oaks = Not(And(tree_vars['laurels'], tree_vars['oaks']))\nsolver.add(Implies(not_laurels_and_oaks,\n                   And(tree_vars['firs'], tree_vars['spruces'])))\n\n# OPTION CHECKING\noptions = {\n    'A': ['oaks', 'spruces'],\n    'B': ['oaks', 'yews'],\n    'C': ['firs', 'laurels', 'oaks'],\n    'D': ['firs', 'maples', 'oaks'],\n    'E': ['laurels', 'maples', 'oaks']\n}\n\nfor letter, included_trees in options.items():\n    solver.push()\n    # Add constraints that these trees are in the park\n    for t in included_trees:\n        solver.add(tree_vars[t])\n    # Check if it's possible that these trees are in the park (partial list)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Four married couples—Francisco and Gabrielle, Kyoko and Lee, Olivia and Peter, Raymond and Simone—will dine together at the same circular table. Each person will sit in a different one of the eight chairs evenly spaced around the table. The chairs are numbered from 1 through 8 with successively numbered chairs next to each other and chair 1 next to chair 8. Seating arrangements must meet the following conditions: No person sits next to her or his spouse. Simone sits in chair 1 and Raymond sits in chair 4. Neither Peter nor Olivia sits next to Raymond. Neither Kyoko nor Lee sits next to Gabrielle.\n\nWhich one of the following could be the list of people sitting in chairs 5 through 8, respectively?\n\nOptions:\n(A) Francisco, Olivia, Gabrielle, Peter\n(B) Francisco, Gabrielle, Peter, Lee\n(C) Olivia, Gabrielle, Peter, Kyoko\n(D) Gabrielle, Lee, Olivia, Kyoko\n(E) Lee, Olivia, Francisco, Kyoko",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Francisco', 'Gabrielle', 'Kyoko', 'Lee', 'Olivia', 'Peter', 'Raymond', 'Simone']\nchairs = list(range(1, 9))\n\n# Create a mapping from person to a Z3 Int variable representing their chair number\nchair_of = {p: Int(p) for p in people}\n\n# Helper sets\nspouses = [('Francisco', 'Gabrielle'), ('Kyoko', 'Lee'), ('Olivia', 'Peter'), ('Raymond', 'Simone')]\n# For quick spouse lookup\nspouse_of = {}\nfor p1, p2 in spouses:\n    spouse_of[p1] = p2\n    spouse_of[p2] = p1\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person sits in a chair from 1 to 8\nfor p in people:\n    solver.add(And(chair_of[p] >= 1, chair_of[p] <= 8))\n\n# All chairs are distinct (no two people share the same chair)\nsolver.add(Distinct([chair_of[p] for p in people]))\n\n# Simone sits in chair 1 and Raymond sits in chair 4\nsolver.add(chair_of['Simone'] == 1)\nsolver.add(chair_of['Raymond'] == 4)\n\n# No person sits next to his or her spouse\n# Define a function to check adjacency around the circular table\ndef adjacent(c1, c2):\n    return Or(c1 == ((c2 % 8) + 1), c1 == ((c2 + 6) % 8) + 1)\n\nfor p in people:\n    sp = spouse_of[p]\n    c1 = chair_of[p]\n    c2 = chair_of[sp]\n    solver.add(Not(adjacent(c1, c2)))\n\n# Neither Peter nor Olivia sits next to Raymond\nfor p in ['Peter', 'Olivia']:\n    solver.add(Not(adjacent(chair_of[p], chair_of['Raymond'])))\n\n# Neither Kyoko nor Lee sits next to Gabrielle\nfor p in ['Kyoko', 'Lee']:\n    solver.add(Not(adjacent(chair_of[p], chair_of['Gabrielle'])))\n\n# OPTION CHECKING\noptions = {\n    'A': ['Francisco', 'Olivia', 'Gabrielle', 'Peter'],\n    'B': ['Francisco', 'Gabrielle', 'Peter', 'Lee'],\n    'C': ['Olivia', 'Gabrielle', 'Peter', 'Kyoko'],\n    'D': ['Gabrielle', 'Lee', 'Olivia', 'Kyoko'],\n    'E': ['Lee', 'Olivia', 'Francisco', 'Kyoko'],\n}\n\nfor letter, option_people in options.items():\n    solver.push()\n    # Add constraints that chairs 5 through 8 are occupied by the people in option_people respectively\n    solver.add(chair_of[option_people[0]] == 5)\n    solver.add(chair_of[option_people[1]] == 6)\n    solver.add(chair_of[option_people[2]] == 7)\n    solver.add(chair_of[option_people[3]] == 8)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Four married couples—Francisco and Gabrielle, Kyoko and Lee, Olivia and Peter, Raymond and Simone—will dine together at the same circular table. Each person will sit in a different one of the eight chairs evenly spaced around the table. The chairs are numbered from 1 through 8 with successively numbered chairs next to each other and chair 1 next to chair 8. Seating arrangements must meet the following conditions: No person sits next to her or his spouse. Simone sits in chair 1 and Raymond sits in chair 4. Neither Peter nor Olivia sits next to Raymond. Neither Kyoko nor Lee sits next to Gabrielle.\n\nIf neither Gabrielle nor Lee sits next to Raymond, which one of the following must be true?\n\nOptions:\n(A) Francisco sits next to Raymond.\n(B) Olivia sits next to Simone.\n(C) Francisco sits in chair 3.\n(D) Olivia sits in chair 6.\n(E) Olivia sits in chair 7.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['Francisco', 'Gabrielle', 'Kyoko', 'Lee', 'Olivia', 'Peter', 'Raymond', 'Simone']\nnum_chairs = 8\n\n# Map person name to index\nperson_idx = {p: i for i, p in enumerate(persons)}\n\n# Create a variable for each person representing their chair (1 to 8)\nchairs = [Int(p) for p in persons]\n\nsolver = Solver()\n\n# Each chair number is between 1 and 8\nfor c in chairs:\n    solver.add(And(c >= 1, c <= num_chairs))\n\n# All chairs assigned are distinct\nsolver.add(Distinct(chairs))\n\n# Helper function: next to each other in circular table\ndef next_to(a, b):\n    # Two chairs are next to each other if their numbers differ by 1 mod 8\n    diff = Abs(a - b)\n    return Or(diff == 1, diff == 7)\n\n# Spouses pairs\nspouses = [('Francisco', 'Gabrielle'), ('Kyoko', 'Lee'), ('Olivia', 'Peter'), ('Raymond', 'Simone')]\n\n# No person sits next to spouse\nfor (p1, p2) in spouses:\n    solver.add(Not(next_to(chairs[person_idx[p1]], chairs[person_idx[p2]])))\n\n# Simone sits in chair 1\nsolver.add(chairs[person_idx['Simone']] == 1)\n\n# Raymond sits in chair 4\nsolver.add(chairs[person_idx['Raymond']] == 4)\n\n# Neither Peter nor Olivia sits next to Raymond\nsolver.add(Not(next_to(chairs[person_idx['Peter']], chairs[person_idx['Raymond']])))\nsolver.add(Not(next_to(chairs[person_idx['Olivia']], chairs[person_idx['Raymond']])))\n\n# Neither Kyoko nor Lee sits next to Gabrielle\nsolver.add(Not(next_to(chairs[person_idx['Kyoko']], chairs[person_idx['Gabrielle']])))\nsolver.add(Not(next_to(chairs[person_idx['Lee']], chairs[person_idx['Gabrielle']])))\n\n# Additional condition for the question:\n# Neither Gabrielle nor Lee sits next to Raymond\nsolver.add(Not(next_to(chairs[person_idx['Gabrielle']], chairs[person_idx['Raymond']])))\nsolver.add(Not(next_to(chairs[person_idx['Lee']], chairs[person_idx['Raymond']])))\n\n# OPTION CHECKING\noptions = [\n    # (A) Francisco sits next to Raymond\n    chairs[person_idx['Francisco']], chairs[person_idx['Raymond']], lambda: next_to(chairs[person_idx['Francisco']], chairs[person_idx['Raymond']]),\n    # (B) Olivia sits next to Simone\n    chairs[person_idx['Olivia']], chairs[person_idx['Simone']], lambda: next_to(chairs[person_idx['Olivia']], chairs[person_idx['Simone']]),\n    # (C) Francisco sits in chair 3\n    chairs[person_idx['Francisco']], 3,\n    # (D) Olivia sits in chair 6\n    chairs[person_idx['Olivia']], 6,\n    # (E) Olivia sits in chair 7\n    chairs[person_idx['Olivia']], 7,\n]\n\n# We want to find which option must be true.\n# That means: for each option, check if adding the negation of that option is UNSAT.\n# If negation is UNSAT, then the option must be true.\n\n# Define helper to check negation of each option\ndef check_option_must_be_true(option_letter):\n    solver.push()\n    if option_letter == 'A':\n        # Negation: Francisco NOT next to Raymond\n        solver.add(Not(next_to(chairs[person_idx['Francisco']], chairs[person_idx['Raymond']])))\n    elif option_letter == 'B':\n        # Negation: Olivia NOT next to Simone\n        solver.add(Not(next_to(chairs[person_idx['Olivia']], chairs[person_idx['Simone']])))\n    elif option_letter == 'C':\n        # Negation: Francisco NOT in chair 3\n        solver.add(chairs[person_idx['Francisco']] != 3)\n    elif option_letter == 'D':\n        # Negation: Olivia NOT in chair 6\n        solver.add(chairs[person_idx['Olivia']] != 6)\n    elif option_letter == 'E':\n        # Negation: Olivia NOT in chair 7\n        solver.add(chairs[person_idx['Olivia']] != 7)\n    else:\n        solver.pop()\n        return False\n\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    if check_option_must_be_true(letter):\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Four married couples—Francisco and Gabrielle, Kyoko and Lee, Olivia and Peter, Raymond and Simone—will dine together at the same circular table. Each person will sit in a different one of the eight chairs evenly spaced around the table. The chairs are numbered from 1 through 8 with successively numbered chairs next to each other and chair 1 next to chair 8. Seating arrangements must meet the following conditions: No person sits next to her or his spouse. Simone sits in chair 1 and Raymond sits in chair 4. Neither Peter nor Olivia sits next to Raymond. Neither Kyoko nor Lee sits next to Gabrielle.\n\nIf Lee sits in chair 2, which one of the following must be true?\n\nOptions:\n(A) Peter sits next to Gabrielle.\n(B) Kyoko sits next to Simone.\n(C) Francisco sits next to Lee.\n(D) Gabrielle sits in chair 5.\n(E) Olivia sits in chair 6.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Francisco', 'Gabrielle', 'Kyoko', 'Lee', 'Olivia', 'Peter', 'Raymond', 'Simone']\nnum_chairs = 8\nchairs = list(range(1, num_chairs + 1))\n\n# Map person to Z3 Int variable representing their chair number\nseat = {p: Int(p) for p in people}\n\n# Helper function to check if two chairs are adjacent in the circular table\ndef adjacent(c1, c2):\n    diff = If(Or(c1 == 1, c2 == 1), \n              Or(Abs(c1 - c2) == 1, Abs(c1 - c2) == 7),\n              Abs(c1 - c2) == 1)\n    return diff\n\n# Because chair 1 is next to chair 8, adjacency means difference of 1 or 7 mod 8\ndef adjacent_expr(c1, c2):\n    diff = If(Or(c1 == 1, c2 == 1),\n              Or(Abs(c1 - c2) == 1, Abs(c1 - c2) == 7),\n              Abs(c1 - c2) == 1)\n    return diff\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person sits in a chair from 1 to 8\nfor p in people:\n    solver.add(And(seat[p] >= 1, seat[p] <= 8))\n\n# All chairs assigned are distinct\nsolver.add(Distinct([seat[p] for p in people]))\n\n# Simone sits in chair 1\nsolver.add(seat['Simone'] == 1)\n# Raymond sits in chair 4\nsolver.add(seat['Raymond'] == 4)\n\n# No person sits next to his/her spouse\n# Spouses: Francisco-Gabrielle, Kyoko-Lee, Olivia-Peter, Raymond-Simone\nspouses = [('Francisco', 'Gabrielle'), ('Kyoko', 'Lee'), ('Olivia', 'Peter'), ('Raymond', 'Simone')]\nfor (p1, p2) in spouses:\n    solver.add(Not(adjacent_expr(seat[p1], seat[p2])))\n\n# Neither Peter nor Olivia sits next to Raymond\nsolver.add(Not(adjacent_expr(seat['Peter'], seat['Raymond'])))\nsolver.add(Not(adjacent_expr(seat['Olivia'], seat['Raymond'])))\n\n# Neither Kyoko nor Lee sits next to Gabrielle\nsolver.add(Not(adjacent_expr(seat['Kyoko'], seat['Gabrielle'])))\nsolver.add(Not(adjacent_expr(seat['Lee'], seat['Gabrielle'])))\n\n# Lee sits in chair 2 (given condition for the question)\nsolver.add(seat['Lee'] == 2)\n\n# OPTION CHECKING\n# Options:\n# (A) Peter sits next to Gabrielle.\n# (B) Kyoko sits next to Simone.\n# (C) Francisco sits next to Lee.\n# (D) Gabrielle sits in chair 5.\n# (E) Olivia sits in chair 6.\n\noptions = {\n    'A': adjacent_expr(seat['Peter'], seat['Gabrielle']),\n    'B': adjacent_expr(seat['Kyoko'], seat['Simone']),\n    'C': adjacent_expr(seat['Francisco'], seat['Lee']),\n    'D': seat['Gabrielle'] == 5,\n    'E': seat['Olivia'] == 6\n}\n\n# We must find which option MUST be true.\n# To do this, for each option:\n#   Check if adding NOT(option) is UNSAT (contradiction)\n#   If so, the option must be true.\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Four married couples—Francisco and Gabrielle, Kyoko and Lee, Olivia and Peter, Raymond and Simone—will dine together at the same circular table. Each person will sit in a different one of the eight chairs evenly spaced around the table. The chairs are numbered from 1 through 8 with successively numbered chairs next to each other and chair 1 next to chair 8. Seating arrangements must meet the following conditions: No person sits next to her or his spouse. Simone sits in chair 1 and Raymond sits in chair 4. Neither Peter nor Olivia sits next to Raymond. Neither Kyoko nor Lee sits next to Gabrielle.\n\nIf both Francisco and Gabrielle sit next to Raymond, which one of the following is a complete and accurate list of people any one of whom could sit next to Olivia?\n\nOptions:\n(A) Francisco, Gabrielle, Kyoko\n(B) Lee, Simone, Kyoko\n(C) Lee, Gabrielle, Kyoko\n(D) Francisco, Lee, Gabrielle, Kyoko\n(E) Lee, Simone, Gabrielle, Kyoko",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Francisco', 'Gabrielle', 'Kyoko', 'Lee', 'Olivia', 'Peter', 'Raymond', 'Simone']\nnum_chairs = 8\n\n# Map each person to an integer index\nperson_idx = {p: i for i, p in enumerate(people)}\n\n# Create Z3 Int variables for each person representing their chair number (1 to 8)\nchairs = {p: Int(p) for p in people}\n\n# Helper functions\ndef next_to(c1, c2):\n    # Chairs are in a circle from 1 to 8; two chairs are next to each other if they differ by 1 or are 1 and 8\n    diff = Abs(c1 - c2)\n    return Or(diff == 1, And(c1 == 1, c2 == 8), And(c1 == 8, c2 == 1))\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each person sits in a chair numbered 1 to 8\nfor p in people:\n    solver.add(And(chairs[p] >= 1, chairs[p] <= num_chairs))\n\n# All chairs are distinct (everyone in a different chair)\nsolver.add(Distinct([chairs[p] for p in people]))\n\n# Spouses\nspouses = [('Francisco', 'Gabrielle'), ('Kyoko', 'Lee'), ('Olivia', 'Peter'), ('Raymond', 'Simone')]\n\n# No person sits next to their spouse\nfor (p1, p2) in spouses:\n    solver.add(Not(next_to(chairs[p1], chairs[p2])))\n\n# Simone sits in chair 1\nsolver.add(chairs['Simone'] == 1)\n\n# Raymond sits in chair 4\nsolver.add(chairs['Raymond'] == 4)\n\n# Neither Peter nor Olivia sits next to Raymond\nsolver.add(Not(next_to(chairs['Peter'], chairs['Raymond'])))\nsolver.add(Not(next_to(chairs['Olivia'], chairs['Raymond'])))\n\n# Neither Kyoko nor Lee sits next to Gabrielle\nsolver.add(Not(next_to(chairs['Kyoko'], chairs['Gabrielle'])))\nsolver.add(Not(next_to(chairs['Lee'], chairs['Gabrielle'])))\n\n# Additional condition: Both Francisco and Gabrielle sit next to Raymond\nsolver.add(next_to(chairs['Francisco'], chairs['Raymond']))\nsolver.add(next_to(chairs['Gabrielle'], chairs['Raymond']))\n\n# OPTION CHECKING\noptions = [\n    ['Francisco', 'Gabrielle', 'Kyoko'],\n    ['Lee', 'Simone', 'Kyoko'],\n    ['Lee', 'Gabrielle', 'Kyoko'],\n    ['Francisco', 'Lee', 'Gabrielle', 'Kyoko'],\n    ['Lee', 'Simone', 'Gabrielle', 'Kyoko']\n]\n\n# We want to find the complete and accurate list of people any one of whom could sit next to Olivia\n# So for each option, we check if it is exactly the set of possible neighbors of Olivia under the constraints\n\n# Determine all possible people who can sit next to Olivia\n# We'll find all people p != Olivia such that there exists a seating arrangement satisfying constraints\n# with p next to Olivia.\n\npossible_neighbors = set()\n\nfor p in people:\n    if p == 'Olivia':\n        continue\n    # Check if p can sit next to Olivia\n    solver.push()\n    solver.add(next_to(chairs[p], chairs['Olivia']))\n    if solver.check() == sat:\n        possible_neighbors.add(p)\n    solver.pop()\n\n# Now check which option matches exactly the possible_neighbors set\nfor i, option in enumerate(options):\n    option_set = set(option)\n    # The option must be exactly the set of possible neighbors\n    if option_set == possible_neighbors:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Zeno's Unfinished Furniture sells exactly five types of furniture—footstools, hutches, sideboards, tables, and vanities. Irene buys just four items, each of a different type, and each made entirely of one kind of wood—maple, oak, pine, or rosewood. The following conditions govern Irene's purchases: Any vanity she buys is maple. Any rosewood item she buys is a sideboard. If she buys a vanity, she does not buy a footstool. If Irene buys a footstool, she also buys a table made of the same wood. Irene does not buy an oak table. Exactly two of the items she buys are made of the same kind of wood as each other.\n\nIf Irene buys one item made of rosewood and two items made of maple, then which one of the following pairs could be two of the items she buys?\n\nOptions:\n(A) a rosewood sideboard and an oak footstool\n(B) an oak hutch and a pine sideboard\n(C) an oak hutch and a maple table\n(D) a maple sideboard and a maple vanity\n(E) a maple hutch and a maple table",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfurniture = ['footstool', 'hutch', 'sideboard', 'table', 'vanity']\nwoods = ['maple', 'oak', 'pine', 'rosewood']\n\n# Map furniture and woods to indices\nfurniture_idx = {f: i for i, f in enumerate(furniture)}\nwoods_idx = {w: i for i, w in enumerate(woods)}\n\n# Irene buys exactly 4 items, each different furniture type\n# Variables: For each furniture type, an Int representing the wood type or -1 if not bought\n# -1 means not bought\nitems = {f: Int(f) for f in furniture}\n\nsolver = Solver()\n\n# Each item is either not bought (-1) or bought with a wood type index (0..3)\nfor f in furniture:\n    solver.add(Or(items[f] == -1, And(items[f] >= 0, items[f] < len(woods))))\n\n# Exactly 4 items are bought (not -1)\nbought_flags = [items[f] != -1 for f in furniture]\nsolver.add(Sum([If(flag, 1, 0) for flag in bought_flags]) == 4)\n\n# Each bought item has a different furniture type (already ensured by keys)\n\n# Conditions:\n\n# 1) Any vanity she buys is maple.\nvanity = items['vanity']\nsolver.add(Or(vanity == -1, vanity == woods_idx['maple']))\n\n# 2) Any rosewood item she buys is a sideboard.\n# So if any item is rosewood, it must be the sideboard.\nfor f in furniture:\n    if f != 'sideboard':\n        solver.add(items[f] != woods_idx['rosewood'])\n\n# 3) If she buys a vanity, she does not buy a footstool.\nfootstool = items['footstool']\nsolver.add(Or(vanity == -1, footstool == -1))\n\n# 4) If she buys a footstool, she also buys a table made of the same wood.\ntable = items['table']\nsame_wood = footstool == table\nsolver.add(Or(footstool == -1, And(table != -1, same_wood)))\n\n# 5) Irene does not buy an oak table.\nsolver.add(table != woods_idx['oak'])\n\n# 6) Exactly two of the items she buys are made of the same kind of wood as each other.\n# So among the 4 bought items, exactly one wood is repeated twice, and the other two woods are different.\n# Count the woods of bought items\nbought_items = [items[f] for f in furniture if f != 'dummy']  # list of all items\n# But we have to consider only bought items, so we filter with != -1\n# We'll collect the woods of bought items in a list\n# To do this, we create a list of bought items' woods:\nbought_woods = []\nfor f in furniture:\n    bought_woods.append(items[f])\n\n# Constraint: exactly 4 bought items, so 4 woods != -1\n# Count frequencies of woods among bought items\n# We'll create 4 variables for woods of bought items (filtering out -1)\n# Since we know exactly 4 items bought, we can create a list of 4 wood variables\n# But we have items dict with 5 items, some -1\n# So we create a list of 4 wood variables representing bought items\n# We'll create a function to get bought woods\n# Instead, we create a list of wood variables for bought items:\nbought_woods_vars = []\nfor f in furniture:\n    bought_woods_vars.append(items[f])\n\n# We want to assert there are exactly two items with the same wood,\n# and the other two items are different woods from these two and from each other.\n\n# Because 4 items bought, and exactly one pair of woods is repeated twice,\n# the wood counts are: one wood appears twice, and two other woods appear once each.\n\n# We can write a helper function to count how many times each wood appears among bought items.\n# Since Z3 has no direct way to count frequencies, we do it manually.\n\n# Create a list of booleans for each wood per item\nwood_counts = []\nfor w in range(len(woods)):\n    count = Sum([If(bought_woods_vars[i] == w, 1, 0) for i in range(len(bought_woods_vars))])\n    wood_counts.append(count)\n\n# Constraint: Exactly one wood count is 2, and exactly two wood counts are 1, and one wood count is 0\nsolver.add(Sum([If(c == 2, 1, 0) for c in wood_counts]) == 1)\nsolver.add(Sum([If(c == 1, 1, 0) for c in wood_counts]) == 2)\nsolver.add(Sum([If(c == 0, 1, 0) for c in wood_counts]) == 1)\n\n# Additional given for the question:\n# If Irene buys one item made of rosewood and two items made of maple\n# So among the 4 items:\n# rosewood count == 1\n# maple count == 2\nsolver.add(wood_counts[woods_idx['rosewood']] == 1)\nsolver.add(wood_counts[woods_idx['maple']] == 2)\n\n# OPTION CHECKING\noptions = [\n    ('rosewood sideboard', 'oak footstool'),\n    ('oak hutch', 'pine sideboard'),\n    ('oak hutch', 'maple table'),\n    ('maple sideboard', 'maple vanity'),\n    ('maple hutch', 'maple table'),\n]\n\ndef parse_item(text):\n    # text format: \"<wood> <furniture>\"\n    w, f = text.split()\n    return f, w\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that these two items are bought with specified wood and furniture\n    # They must be among the 4 items bought\n    f1, w1 = parse_item(option[0])\n    f2, w2 = parse_item(option[1])\n\n    # Both items must be bought with specified wood\n    solver.add(items[f1] == woods_idx[w1])\n    solver.add(items[f2] == woods_idx[w2])\n\n    # Check if satisfiable\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Zeno's Unfinished Furniture sells exactly five types of furniture—footstools, hutches, sideboards, tables, and vanities. Irene buys just four items, each of a different type, and each made entirely of one kind of wood—maple, oak, pine, or rosewood. The following conditions govern Irene's purchases: Any vanity she buys is maple. Any rosewood item she buys is a sideboard. If she buys a vanity, she does not buy a footstool. If Irene buys a footstool, she also buys a table made of the same wood. Irene does not buy an oak table. Exactly two of the items she buys are made of the same kind of wood as each other.\n\nWhich one of the following is a complete and accurate list of all the woods any footstool that Irene buys could be made of?\n\nOptions:\n(A) maple, oak\n(B) maple, pine\n(C) maple, rosewood\n(D) maple, oak, pine\n(E) maple, oak, pine, rosewood",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfurniture = ['footstool', 'hutch', 'sideboard', 'table', 'vanity']\nwoods = ['maple', 'oak', 'pine', 'rosewood']\n\n# Create Z3 Int variables for each furniture type Irene buys\n# Value = index of wood type in woods list\n# If Irene does not buy that furniture, assign -1\nitems = dict()\nfor f in furniture:\n    items[f] = Int(f)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Irene buys exactly 4 items, each of different furniture types\n# So exactly one furniture type is not bought (value == -1)\n# Others must be assigned a wood index between 0 and 3\nfor f in furniture:\n    solver.add(Or(items[f] == -1, And(items[f] >= 0, items[f] < len(woods))))\n\n# Exactly one furniture type is not bought\nnot_bought = [items[f] == -1 for f in furniture]\nsolver.add(Sum([If(cond, 1, 0) for cond in not_bought]) == 1)\n\n# The 4 bought items have distinct furniture types (already ensured by not_bought)\n# Each bought item has distinct furniture type (trivially true as keys differ)\n# The 4 items have different furniture types (already ensured by keys)\n# But woods can repeat subject to constraints\n\n# Each of the 4 items is of a different furniture type (already true)\n# Each item is made entirely of one kind of wood (already modeled)\n\n# Condition 1: Any vanity she buys is maple.\n# If vanity is bought (items['vanity'] != -1), then wood = maple (index 0)\nsolver.add(Implies(items['vanity'] != -1, items['vanity'] == woods.index('maple')))\n\n# Condition 2: Any rosewood item she buys is a sideboard.\n# If any item is rosewood, then it must be sideboard\n# So for all furniture except sideboard, if bought, wood != rosewood\nfor f in furniture:\n    if f != 'sideboard':\n        solver.add(Implies(items[f] != -1, items[f] != woods.index('rosewood')))\n# Also sideboard can be rosewood or not, no restriction here\n\n# Condition 3: If she buys a vanity, she does not buy a footstool.\nsolver.add(Implies(items['vanity'] != -1, items['footstool'] == -1))\n\n# Condition 4: If Irene buys a footstool, she also buys a table made of the same wood.\n# So if footstool bought, table bought and same wood\nsolver.add(Implies(items['footstool'] != -1,\n                   And(items['table'] != -1,\n                       items['footstool'] == items['table'])))\n\n# Condition 5: Irene does not buy an oak table.\n# Oak index is 1\nsolver.add(items['table'] != woods.index('oak'))\n\n# Condition 6: Exactly two of the items she buys are made of the same kind of wood as each other.\n# That is, among the 4 bought items, exactly one wood occurs twice, and others once.\n# So count wood occurrences among bought items == 4 items\nbought_items = [items[f] for f in furniture if f != 'not_bought']  # placeholder, we do below\n\n# Get list of bought items variables (wood indices)\nbought_vars = []\nfor f in furniture:\n    bought_vars.append(items[f])\n\n# Only consider those bought (items[f] != -1)\n# Extract wood indices of bought items\n# We will count how many times each wood appears among bought items\n\n# Create indicator variables for each wood and each item\nindicators = []\nfor w in range(len(woods)):\n    indicators.append([Bool(f'{f}_is_{woods[w]}') for f in furniture])\n\nfor i, f in enumerate(furniture):\n    for w in range(len(woods)):\n        solver.add(indicators[w][i] == (items[f] == w))\n\n# Count how many items are bought (items[f] != -1)\nnum_bought = Sum([If(items[f] != -1, 1, 0) for f in furniture])\nsolver.add(num_bought == 4)\n\n# For each wood, count how many times it appears among bought items\nwood_counts = []\nfor w in range(len(woods)):\n    count = Sum([If(indicators[w][i], 1, 0) for i in range(len(furniture))])\n    wood_counts.append(count)\n\n# Exactly one wood appears twice, others once or zero\n# So wood_counts contains one 2, two 1s, and one 0 (since 4 items total)\n# Because total items = 4\n# So sum of wood_counts = 4\nsolver.add(Sum(wood_counts) == 4)\n\n# One wood count == 2\ntwo_counts = [wood_counts[w] == 2 for w in range(len(woods))]\nsolver.add(Or(two_counts))\n\n# Exactly one wood count == 2\nsolver.add(Sum([If(cond, 1, 0) for cond in two_counts]) == 1)\n\n# The other wood counts are 1 or 0\n# We know total items =4 and one wood is 2, so others sum to 2\n# So the two other woods can be 1 and 1, or 2 and 0, but only one wood is 2\n# So the other wood counts must be 1 or 0 but not 2\nfor w in range(len(woods)):\n    solver.add(Or(wood_counts[w] == 0, wood_counts[w] == 1, wood_counts[w] == 2))\n\n# The wood with count 2 is unique (already constrained)\n\n# OPTION CHECKING\n# We want to find the complete and accurate list of all woods any footstool Irene buys could be made of\n\n# Footstool can be -1 (not bought) or wood index 0..3\n# We want to find all possible woods for footstool among solutions\n\npossible_woods = set()\n\nfor wood_idx in range(len(woods)):\n    solver.push()\n    # Add constraint that footstool is bought and has wood wood_idx\n    solver.add(items['footstool'] == wood_idx)\n    if solver.check() == sat:\n        possible_woods.add(woods[wood_idx])\n    solver.pop()\n\n# Print the letter of the correct option based on possible_woods\n\n# Options:\noptions = {\n    'A': set(['maple', 'oak']),\n    'B': set(['maple', 'pine']),\n    'C': set(['maple', 'rosewood']),\n    'D': set(['maple', 'oak', 'pine']),\n    'E': set(['maple', 'oak', 'pine', 'rosewood'])\n}\n\nfor letter, woods_set in options.items():\n    if possible_woods == woods_set:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Zeno's Unfinished Furniture sells exactly five types of furniture—footstools, hutches, sideboards, tables, and vanities. Irene buys just four items, each of a different type, and each made entirely of one kind of wood—maple, oak, pine, or rosewood. The following conditions govern Irene's purchases: Any vanity she buys is maple. Any rosewood item she buys is a sideboard. If she buys a vanity, she does not buy a footstool. If Irene buys a footstool, she also buys a table made of the same wood. Irene does not buy an oak table. Exactly two of the items she buys are made of the same kind of wood as each other.\n\nSuppose Irene buys a footstool. Then which one of the following is a complete and accurate list of items any one of which she could buy in maple?\n\nOptions:\n(A) footstool, hutch, sideboard, table, vanity\n(B) footstool, hutch, sideboard, table\n(C) footstool, hutch, sideboard\n(D) footstool, hutch\n(E) footstool",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfurniture_types = ['footstool', 'hutch', 'sideboard', 'table', 'vanity']\nwoods = ['maple', 'oak', 'pine', 'rosewood']\n\n# Variables: Irene buys exactly 4 items, each a different furniture type\n# For each furniture type, variable indicates the wood type or -1 if not bought\n# We'll use an Int variable per furniture type: -1 means not bought, 0..3 means wood index\nfurniture = {f: Int(f) for f in furniture_types}\n\nsolver = Solver()\n\n# Each furniture variable is either -1 (not bought) or a valid wood index\nfor f in furniture_types:\n    solver.add(Or(furniture[f] == -1, And(furniture[f] >= 0, furniture[f] < len(woods))))\n\n# Exactly 4 items bought (exactly 4 variables != -1)\nbought = [furniture[f] != -1 for f in furniture_types]\nsolver.add(Sum([If(cond, 1, 0) for cond in bought]) == 4)\n\n# All bought furniture types are distinct by definition (since they are different types)\n# They are distinct furniture types, so no need to enforce distinct types\n\n# Each bought furniture is made entirely of one wood type (already modeled)\n\n# Constraints:\n\n# 1) Any vanity bought is maple\nvanity = furniture['vanity']\nsolver.add(Implies(vanity != -1, vanity == woods.index('maple')))\n\n# 2) Any rosewood item bought is a sideboard\n# So if any furniture other than sideboard is rosewood, not allowed\nfor f in furniture_types:\n    if f != 'sideboard':\n        solver.add(furniture[f] != woods.index('rosewood'))\n\n# 3) If she buys a vanity, she does not buy a footstool\nsolver.add(Implies(vanity != -1, furniture['footstool'] == -1))\n\n# 4) If she buys a footstool, she also buys a table made of the same wood\nfootstool = furniture['footstool']\ntable = furniture['table']\nsolver.add(Implies(footstool != -1,\n                   And(table != -1, table == footstool)))\n\n# 5) Irene does not buy an oak table\nsolver.add(table != woods.index('oak'))\n\n# 6) Exactly two of the items she buys are made of the same kind of wood\n# So among the 4 bought items, exactly one wood appears twice, others once\n# Gather the woods of bought items\nbought_woods = [furniture[f] for f in furniture_types if True]  # all, but filter later\n\n# Filter only bought items\nbought_woods_vars = []\nfor f in furniture_types:\n    bought_woods_vars.append(furniture[f])\n\n# We want to consider only those furniture bought (furniture[f] != -1)\n# Count occurrences of each wood among bought items\n# For this, create indicator variables for each wood and furniture\nindicators = []\nfor w in range(len(woods)):\n    for f in furniture_types:\n        ind = Bool(f\"{f}_is_{woods[w]}\")\n        solver.add(ind == (furniture[f] == w))\n        indicators.append(ind)\n\n# We need to enforce that exactly 4 furniture are bought (already done)\n# And among the bought furniture, exactly one wood appears twice,\n# the others appear once, and no other duplicates.\n\n# Count how many times each wood appears among the bought furniture\nwood_counts = []\nfor w in range(len(woods)):\n    count = Sum([If(furniture[f] == w, 1, 0) for f in furniture_types])\n    wood_counts.append(count)\n\n# Exactly one wood count is 2, others are 0 or 1\ntwo_count_woods = [wood_counts[w] == 2 for w in range(len(woods))]\n# Exactly one wood count is 2\nsolver.add(Sum([If(cond, 1, 0) for cond in two_count_woods]) == 1)\n# All wood counts <= 2\nfor w in range(len(woods)):\n    solver.add(wood_counts[w] <= 2)\n# Sum of wood counts = 4 (already guaranteed by sum of bought furniture)\nsolver.add(Sum(wood_counts) == 4)\n\n# Now, the question:\n# Suppose Irene buys a footstool.\n# Then which is the complete and accurate list of items any one of which she could buy in maple?\n\n# So add footstool bought constraint\nsolver.add(footstool != -1)\n\n# For each option, check if the set of furniture that can possibly be maple matches the option\n\n# We will check each option:\n# For each option, we add a constraint that maple furniture is only from the option list,\n# and that any furniture outside the option list is not maple.\n# Then check satisfiability.\n\noptions = {\n    'A': ['footstool', 'hutch', 'sideboard', 'table', 'vanity'],\n    'B': ['footstool', 'hutch', 'sideboard', 'table'],\n    'C': ['footstool', 'hutch', 'sideboard'],\n    'D': ['footstool', 'hutch'],\n    'E': ['footstool']\n}\n\n# For each option:\n# 1) For furniture in option: can be maple or not maple (no restriction)\n# 2) For furniture NOT in option: cannot be maple\n\n# Also, we must ensure that for each furniture in the option, there is some model where it is maple\n# i.e. for each furniture in option, check if maple possible\n# and for furniture not in option, check maple impossible\n\n# To check if furniture f can be maple, push solver, add furniture[f] == maple, check sat\n# To check if furniture f cannot be maple, push solver, add furniture[f] == maple, check unsat\n\n# We want the option where all furniture in option can be maple, and all furniture not in option cannot be maple\n\nfor letter, furn_list in options.items():\n    # Check all furniture in option can be maple\n    can_all_in_option_maple = True\n    for f in furn_list:\n        solver.push()\n        solver.add(furniture[f] == woods.index('maple'))\n        if solver.check() != sat:\n            can_all_in_option_maple = False\n        solver.pop()\n        if not can_all_in_option_maple:\n            break\n    if not can_all_in_option_maple:\n        continue\n\n    # Check all furniture not in option cannot be maple\n    cannot_out_option_maple = True\n    for f in furniture_types:\n        if f not in furn_list:\n            solver.push()\n            solver.add(furniture[f] == woods.index('maple'))\n            if solver.check() == sat:\n                cannot_out_option_maple = False\n            solver.pop()\n            if not cannot_out_option_maple:\n                break\n    if cannot_out_option_maple and can_all_in_option_maple:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Zeno's Unfinished Furniture sells exactly five types of furniture—footstools, hutches, sideboards, tables, and vanities. Irene buys just four items, each of a different type, and each made entirely of one kind of wood—maple, oak, pine, or rosewood. The following conditions govern Irene's purchases: Any vanity she buys is maple. Any rosewood item she buys is a sideboard. If she buys a vanity, she does not buy a footstool. If Irene buys a footstool, she also buys a table made of the same wood. Irene does not buy an oak table. Exactly two of the items she buys are made of the same kind of wood as each other.\n\nIf Irene does not buy an item made of maple, then each of the following must be true EXCEPT:\n\nOptions:\n(A) Irene buys a footstool.\n(B) Irene buys a pine hutch.\n(C) Irene buys a rosewood sideboard.\n(D) Irene buys exactly one item made of oak.\n(E) Irene buys exactly two items made of pine.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfurniture = ['footstool', 'hutch', 'sideboard', 'table', 'vanity']\nwoods = ['maple', 'oak', 'pine', 'rosewood']\n\n# Irene buys exactly 4 items, each a different furniture type\n# Create variables for each furniture type: -1 means not bought, otherwise index of wood\n# We'll use Int variables with domain -1 (not bought) or 0..3 (wood index)\nitems = dict()\nfor f in furniture:\n    items[f] = Int(f)\n\nsolver = Solver()\n\n# Constraints on domain: either -1 (not bought) or 0..3 (wood index)\nfor f in furniture:\n    solver.add(Or(items[f] == -1, And(items[f] >= 0, items[f] < len(woods))))\n\n# Exactly 4 items bought, all different furniture types => exactly one furniture type is -1\nbought = [items[f] != -1 for f in furniture]\nsolver.add(Sum([If(cond, 1, 0) for cond in bought]) == 4)\n\n# The 4 items bought are all different furniture types (already ensured by definition)\n\n# Each item bought is made entirely of one kind of wood (already modeled)\n\n# Conditions:\n\n# 1) Any vanity she buys is maple.\n# If vanity bought (items['vanity'] != -1), then items['vanity'] == maple(0)\nvanity_bought = items['vanity'] != -1\nsolver.add(Implies(vanity_bought, items['vanity'] == woods.index('maple')))\n\n# 2) Any rosewood item she buys is a sideboard.\n# For each furniture type f, if bought and wood is rosewood (3), then f == 'sideboard'\nfor f in furniture:\n    bought_f = items[f] != -1\n    rosewood_f = items[f] == woods.index('rosewood')\n    if f == 'sideboard':\n        # no restriction here\n        continue\n    else:\n        # If bought and rosewood, then f != f (contradiction), so force not rosewood if not sideboard\n        solver.add(Implies(And(bought_f, rosewood_f), False))\n\n# 3) If she buys a vanity, she does not buy a footstool.\n# If vanity_bought then items['footstool'] == -1\nsolver.add(Implies(vanity_bought, items['footstool'] == -1))\n\n# 4) If Irene buys a footstool, she also buys a table made of the same wood.\nfootstool_bought = items['footstool'] != -1\ntable_bought = items['table'] != -1\n# If footstool bought, then table bought and same wood\nsolver.add(Implies(footstool_bought, And(table_bought, items['table'] == items['footstool'])))\n\n# 5) Irene does not buy an oak table.\n# Table not oak or not bought\nsolver.add(Or(items['table'] == -1, items['table'] != woods.index('oak')))\n\n# 6) Exactly two of the items she buys are made of the same kind of wood as each other.\n# Among the 4 bought items, exactly one wood appears twice, and the other two woods appear once each.\n# So total 4 items, with two same-wood items and two other distinct woods.\n# Get list of woods of bought items\nbought_items = [items[f] for f in furniture if f != '']  # We'll filter below\n\n# We want to consider only bought items\nbought_vars = []\nfor f in furniture:\n    bought_vars.append(items[f])\n\n# Collect wood indices of bought items\n# We'll create a list of wood indices of bought items only\nwood_vars = []\nfor f in furniture:\n    wood_vars.append(items[f])\n\n# We want to consider only items bought (items[f] != -1)\n# Count how many items bought\n# Using Z3 functions to count wood occurrences\n\n# Create list of woods of bought items (exclude -1)\nwood_bought_vars = []\nfor f in furniture:\n    # Create a variable that is wood if bought else -1\n    wood_bought_vars.append(items[f])\n\n# We want to enforce that among the 4 bought items, exactly one wood appears twice, others once.\n# Let's collect the woods of bought items into a list (exclude -1)\n# Since exactly 4 items bought, we can create a list of 4 wood indices (exclude -1)\n\n# Create list of wood indices of bought items (length 4)\nwood_list = []\nfor f in furniture:\n    wood_list.append(items[f])\n\n# Filter: only those where items[f] != -1\n# We'll create a list of wood indices that are bought\nwood_bought_only = []\nfor f in furniture:\n    cond = items[f] != -1\n    wood_bought_only.append((cond, items[f]))\n\n# We want to enforce that exactly 4 items are bought, so exactly 4 wood indices are valid\n\n# Create a list of wood indices of bought items (length 4)\n# We will create 4 Int variables for wood indices of bought items\nwood_bought = [Int(f'wood_bought_{i}') for i in range(4)]\n\n# Link wood_bought variables to items bought\n# We don't know which furniture items correspond to wood_bought[i], so we create constraints\n# We'll create a constraint that wood_bought is a permutation of the wood indices of the 4 bought items\n\n# Collect furniture bought indices\nbought_furnitures = [f for f in furniture]\n\n# Create list of furniture bought variables (items[f]) with conditions items[f] != -1\n# We know exactly 4 items bought, so the 4 wood_bought variables must equal the wood indices of the 4 bought items in some order\n\n# We'll create a helper function to get the wood indices of bought items\n# We'll create a list of 4 Int variables for the wood indices of bought items, and constrain that they are equal to the wood indices of the 4 bought items\n\n# Create a list of wood indices of furniture items bought (items[f] != -1)\n# We create an array of 5 variables, some may be -1, but exactly 4 will be != -1\n\n# Create a list of 5 wood variables (items[f])\nwood_vars_all = [items[f] for f in furniture]\n\n# We want to select exactly 4 of these that are != -1 and assign to wood_bought variables\n\n# Create constraints that wood_bought variables are exactly the 4 wood indices of items bought\n# For each wood_bought[i], it equals one of the wood_vars_all that is != -1\nfor i in range(4):\n    conds = []\n    for j in range(5):\n        conds.append(And(wood_bought[i] == wood_vars_all[j], wood_vars_all[j] != -1))\n    solver.add(Or(conds))\n\n# All wood_bought variables are distinct or not? We know exactly two items share a wood, so among wood_bought variables:\n# Exactly one wood appears twice, and the other two appear once\n\n# Count occurrences of each wood in wood_bought\n# We'll create count variables for each wood\ncounts = []\nfor w in range(len(woods)):\n    count_w = Sum([If(wood_bought[i] == w, 1, 0) for i in range(4)])\n    counts.append(count_w)\n\n# Exactly one wood count is 2, two woods count is 1, one wood count is 0\ntwo_count = Sum([If(counts[w] == 2, 1, 0) for w in range(len(woods))])\none_count = Sum([If(counts[w] == 1, 1, 0) for w in range(len(woods))])\nzero_count = Sum([If(counts[w] == 0, 1, 0) for w in range(len(woods))])\n\nsolver.add(two_count == 1)\nsolver.add(one_count == 2)\nsolver.add(zero_count == 1)\n\n# The 4 items bought are different furniture types, so no duplicates furniture type\n# Already ensured by items[f] == -1 or >=0 and exactly one furniture type is -1\n\n# Now we implement the condition \"If Irene does not buy an item made of maple, then each of the following must be true EXCEPT:\"\n\n# So we add the condition: no maple item bought\nno_maple = And([items[f] != woods.index('maple') for f in furniture])\n\n# We will check each option by adding the no_maple condition and the negation of each option, then check satisfiability\n\noptions = dict()\n\n# (A) Irene buys a footstool.\n# footstool bought: items['footstool'] != -1\noptions['A'] = items['footstool'] != -1\n\n# (B) Irene buys a pine hutch.\n# hutch bought and hutch is pine (2)\noptions['B'] = And(items['hutch'] != -1, items['hutch'] == woods.index('pine'))\n\n# (C) Irene buys a rosewood sideboard.\n# sideboard bought and sideboard is rosewood (3)\noptions['C'] = And(items['sideboard'] != -1, items['sideboard'] == woods.index('rosewood'))\n\n# (D) Irene buys exactly one item made of oak.\n# Count oak items among bought items == 1\noak_count = Sum([If(And(items[f] != -1, items[f] == woods.index('oak')), 1, 0) for f in furniture])\noptions['D'] = oak_count == 1\n\n# (E) Irene buys exactly two items made of pine.\npine_count = Sum([If(And(items[f] != -1, items[f] == woods.index('pine')), 1, 0) for f in furniture])\noptions['E'] = pine_count == 2\n\n# OPTION CHECKING\n# For each option, check if no_maple => option\n# So check if no_maple and not option is satisfiable\n# If satisfiable, then option is NOT necessarily true when no_maple, so that option is the EXCEPT\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add no_maple condition\n    solver.add(no_maple)\n    # Add negation of option\n    solver.add(Not(options[letter]))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Six racehorses—K, L, M, N, O, and P—will be assigned to six positions arranged in a straight line and numbered consecutively 1 through 6. The horses are assigned to the positions, one horse per position, according to the following conditions: K and L must be assigned to positions that are separated from each other by exactly one position. K and N cannot be assigned to positions that are next to each other. N must be assigned to a higher-numbered position than M. P must be assigned to position 3.\n\nWhich one of the following lists an acceptable assignment of horses to positions 1 though 6, respectively?\n\nOptions:\n(A) K, L, P, M, N, O\n(B) M, K, P, L, N, O\n(C) M, N, K, P, L, O\n(D) N, O, P, K, M, L\n(E) O, M, P, L, N, K",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nhorses = ['K', 'L', 'M', 'N', 'O', 'P']\npositions = range(1, 7)  # Positions 1 through 6\n\n# Create a dictionary mapping each horse to its position (Z3 Int variable)\npos = {h: Int(h) for h in horses}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each horse must be assigned a position between 1 and 6\nfor h in horses:\n    solver.add(And(pos[h] >= 1, pos[h] <= 6))\n\n# All horses must occupy distinct positions\nsolver.add(Distinct([pos[h] for h in horses]))\n\n# K and L must be assigned to positions separated by exactly one position\ndiff_KL = Abs(pos['K'] - pos['L'])\nsolver.add(diff_KL == 2)\n\n# K and N cannot be assigned to adjacent positions\ndiff_KN = Abs(pos['K'] - pos['N'])\nsolver.add(diff_KN != 1)\n\n# N must be assigned to a higher-numbered position than M\nsolver.add(pos['N'] > pos['M'])\n\n# P must be assigned to position 3\nsolver.add(pos['P'] == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': ['K', 'L', 'P', 'M', 'N', 'O'],\n    'B': ['M', 'K', 'P', 'L', 'N', 'O'],\n    'C': ['M', 'N', 'K', 'P', 'L', 'O'],\n    'D': ['N', 'O', 'P', 'K', 'M', 'L'],\n    'E': ['O', 'M', 'P', 'L', 'N', 'K'],\n}\n\nfor letter, assignment in options.items():\n    solver.push()\n    # Add constraints that positions match the assignment\n    # assignment[i] is the horse at position i+1\n    for i, horse_at_pos in enumerate(assignment):\n        solver.add(pos[horse_at_pos] == i + 1)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Six racehorses—K, L, M, N, O, and P—will be assigned to six positions arranged in a straight line and numbered consecutively 1 through 6. The horses are assigned to the positions, one horse per position, according to the following conditions: K and L must be assigned to positions that are separated from each other by exactly one position. K and N cannot be assigned to positions that are next to each other. N must be assigned to a higher-numbered position than M. P must be assigned to position 3.\n\nWhich one of the following CANNOT be true?\n\nOptions:\n(A) K is assigned to position 2.\n(B) L is assigned to position 2.\n(C) M is assigned to position 1.\n(D) M is assigned to position 5.\n(E) O is assigned to position 2.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nhorses = ['K', 'L', 'M', 'N', 'O', 'P']\npositions = range(1, 7)\n\n# Create a variable for each horse's position\npos = {h: Int(h) for h in horses}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each horse assigned to a position between 1 and 6\nfor h in horses:\n    solver.add(And(pos[h] >= 1, pos[h] <= 6))\n\n# All positions are distinct (one horse per position)\nsolver.add(Distinct([pos[h] for h in horses]))\n\n# K and L must be assigned to positions separated by exactly one position\ndiff_KL = Abs(pos['K'] - pos['L'])\nsolver.add(diff_KL == 2)\n\n# K and N cannot be assigned to positions next to each other\ndiff_KN = Abs(pos['K'] - pos['N'])\nsolver.add(diff_KN != 1)\n\n# N must be assigned to a higher-numbered position than M\nsolver.add(pos['N'] > pos['M'])\n\n# P must be assigned to position 3\nsolver.add(pos['P'] == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': pos['K'] == 2,\n    'B': pos['L'] == 2,\n    'C': pos['M'] == 1,\n    'D': pos['M'] == 5,\n    'E': pos['O'] == 2,\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Six racehorses—K, L, M, N, O, and P—will be assigned to six positions arranged in a straight line and numbered consecutively 1 through 6. The horses are assigned to the positions, one horse per position, according to the following conditions: K and L must be assigned to positions that are separated from each other by exactly one position. K and N cannot be assigned to positions that are next to each other. N must be assigned to a higher-numbered position than M. P must be assigned to position 3.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Either K or else L is assigned to position 2.\n(B) Either K or else L is assigned to position 4.\n(C) Either M or else N is assigned to position 2.\n(D) Either M or else N is assigned to position 5.\n(E) Either M or else O is assigned to position 6.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nhorses = ['K', 'L', 'M', 'N', 'O', 'P']\npositions = list(range(1, 7))\n\n# Create Int variables for each horse representing their position\npos = {h: Int(h) for h in horses}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each horse assigned to a position between 1 and 6\nfor h in horses:\n    solver.add(And(pos[h] >= 1, pos[h] <= 6))\n\n# All positions must be distinct (one horse per position)\nsolver.add(Distinct([pos[h] for h in horses]))\n\n# K and L must be assigned to positions separated by exactly one position\ndiff_KL = Abs(pos['K'] - pos['L'])\nsolver.add(diff_KL == 2)\n\n# K and N cannot be assigned to positions next to each other\ndiff_KN = Abs(pos['K'] - pos['N'])\nsolver.add(diff_KN != 1)\n\n# N must be assigned to a higher-numbered position than M\nsolver.add(pos['N'] > pos['M'])\n\n# P must be assigned to position 3\nsolver.add(pos['P'] == 3)\n\n# OPTION CHECKING\n\noptions = {\n    'A': Or(pos['K'] == 2, pos['L'] == 2),\n    'B': Or(pos['K'] == 4, pos['L'] == 4),\n    'C': Or(pos['M'] == 2, pos['N'] == 2),\n    'D': Or(pos['M'] == 5, pos['N'] == 5),\n    'E': Or(pos['M'] == 6, pos['O'] == 6)\n}\n\n# We want to find which option must be true, i.e., which option is true in all solutions.\n# For each option, check if its negation is satisfiable with the constraints.\n# If negation is UNSAT, then the option must be true.\n\nfor option_letter, option_cond in options.items():\n    solver.push()\n    # Add negation of the option condition\n    solver.add(Not(option_cond))\n    if solver.check() == unsat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Six racehorses—K, L, M, N, O, and P—will be assigned to six positions arranged in a straight line and numbered consecutively 1 through 6. The horses are assigned to the positions, one horse per position, according to the following conditions: K and L must be assigned to positions that are separated from each other by exactly one position. K and N cannot be assigned to positions that are next to each other. N must be assigned to a higher-numbered position than M. P must be assigned to position 3.\n\nWhich one of the following CANNOT be true?\n\nOptions:\n(A) L and N are assigned to positions that are next to each other.\n(B) M and K are assigned to positions that are next to each other.\n(C) M and O are assigned to positions that are next to each other.\n(D) L and N are assigned to positions that are separated from each other by exactly one position.\n(E) M and P are assigned to positions that are separated from each other by exactly one position.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nhorses = ['K', 'L', 'M', 'N', 'O', 'P']\npositions = range(1, 7)\n\n# Create Z3 Int variables for each horse's position\npos = {h: Int(h) for h in horses}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each horse's position is between 1 and 6\nfor h in horses:\n    solver.add(And(pos[h] >= 1, pos[h] <= 6))\n\n# All positions are distinct\nsolver.add(Distinct([pos[h] for h in horses]))\n\n# K and L must be assigned to positions separated by exactly one position\ndiff_KL = Abs(pos['K'] - pos['L'])\nsolver.add(diff_KL == 2)\n\n# K and N cannot be assigned to adjacent positions\ndiff_KN = Abs(pos['K'] - pos['N'])\nsolver.add(diff_KN != 1)\n\n# N must be assigned to a higher-numbered position than M\nsolver.add(pos['N'] > pos['M'])\n\n# P must be assigned to position 3\nsolver.add(pos['P'] == 3)\n\n# OPTION CHECKING\n\n# Define helper functions for adjacency and separation by exactly one position\ndef adjacent(h1, h2):\n    return Or([Abs(pos[h1] - pos[h2]) == 1])\n\ndef separated_by_one(h1, h2):\n    return Or([Abs(pos[h1] - pos[h2]) == 2])\n\noptions = {\n    'A': adjacent('L', 'N'),\n    'B': adjacent('M', 'K'),\n    'C': adjacent('M', 'O'),\n    'D': separated_by_one('L', 'N'),\n    'E': separated_by_one('M', 'P'),\n}\n\nfor opt_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add the option's condition\n    solver.add(options[opt_letter])\n    # Check if the model is satisfiable with the option condition\n    if solver.check() == unsat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.\n\nWhich one of the following could be true?\n\nOptions:\n(A) The linguist learns three languages—Rundi, Swahili, and Tigrinya.\n(B) The linguist learns three languages—Swahili, Tigrinya, and Yoruba.\n(C) The historian learns three languages—Rundi, Swahili, and Tigrinya.\n(D) The historian learns three languages—Swahili, Tigrinya, and Yoruba.\n(E) The paleontologist learns three languages—Rundi, Swahili, and Tigrinya.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nresearchers = ['Geologist', 'Historian', 'Linguist', 'Paleontologist']\nlanguages = ['Rundi', 'Swahili', 'Tigrinya', 'Yoruba']\n\n# Create Bool variables: learns[researcher][language] == True if researcher learns that language\nlearns = {}\nfor r in researchers:\n    for l in languages:\n        learns[(r,l)] = Bool(f\"{r}_{l}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each researcher learns at least one and at most three languages\nfor r in researchers:\n    lang_list = [learns[(r,l)] for l in languages]\n    solver.add(Sum([If(b,1,0) for b in lang_list]) >= 1)\n    solver.add(Sum([If(b,1,0) for b in lang_list]) <= 3)\n\n# Exactly one researcher learns Rundi\nrundi_learners = [learns[(r,'Rundi')] for r in researchers]\nsolver.add(Sum([If(b,1,0) for b in rundi_learners]) == 1)\n\n# Exactly two researchers learn Swahili\nswahili_learners = [learns[(r,'Swahili')] for r in researchers]\nsolver.add(Sum([If(b,1,0) for b in swahili_learners]) == 2)\n\n# Exactly two researchers learn Tigrinya\ntigrinya_learners = [learns[(r,'Tigrinya')] for r in researchers]\nsolver.add(Sum([If(b,1,0) for b in tigrinya_learners]) == 2)\n\n# Exactly three researchers learn Yoruba\nyoruba_learners = [learns[(r,'Yoruba')] for r in researchers]\nsolver.add(Sum([If(b,1,0) for b in yoruba_learners]) == 3)\n\n# Any language learned by the linguist or paleontologist is not learned by the geologist\nfor l in languages:\n    linguist_learns = learns[('Linguist', l)]\n    paleontologist_learns = learns[('Paleontologist', l)]\n    geologist_learns = learns[('Geologist', l)]\n    # If Linguist or Paleontologist learns l, then Geologist does not learn l\n    solver.add(Implies(Or(linguist_learns, paleontologist_learns), Not(geologist_learns)))\n\n# Any language learned by the geologist is learned by the historian\nfor l in languages:\n    geologist_learns = learns[('Geologist', l)]\n    historian_learns = learns[('Historian', l)]\n    solver.add(Implies(geologist_learns, historian_learns))\n\n# OPTION CHECKING\n\n# Define a helper function to add constraints for a researcher learning exactly the given languages (and only those)\ndef researcher_learns_exactly(r, langs):\n    # langs is a list of language strings\n    constraints = []\n    for l in languages:\n        if l in langs:\n            constraints.append(learns[(r,l)] == True)\n        else:\n            constraints.append(learns[(r,l)] == False)\n    return constraints\n\noptions = [\n    ('A', 'Linguist', ['Rundi', 'Swahili', 'Tigrinya']),\n    ('B', 'Linguist', ['Swahili', 'Tigrinya', 'Yoruba']),\n    ('C', 'Historian', ['Rundi', 'Swahili', 'Tigrinya']),\n    ('D', 'Historian', ['Swahili', 'Tigrinya', 'Yoruba']),\n    ('E', 'Paleontologist', ['Rundi', 'Swahili', 'Tigrinya']),\n]\n\nfor (letter, researcher, langs) in options:\n    solver.push()\n    solver.add(researcher_learns_exactly(researcher, langs))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.\n\nIf the linguist learns three of the languages, then which one of the following must be true?\n\nOptions:\n(A) The linguist learns Tigrinya.\n(B) The linguist learns Rundi.\n(C) The linguist learns Swahili.\n(D) The paleontologist learns Rundi.\n(E) The paleontologist learns Swahili.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nresearchers = ['Geologist', 'Historian', 'Linguist', 'Paleontologist']\nlanguages = ['Rundi', 'Swahili', 'Tigrinya', 'Yoruba']\n\n# Create a dictionary of Bool variables: researcher x language -> Bool\nlearns = {}\nfor r in researchers:\n    for l in languages:\n        learns[(r, l)] = Bool(f\"{r}_{l}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each researcher learns at least one and at most three languages\nfor r in researchers:\n    learned_langs = [learns[(r, l)] for l in languages]\n    solver.add(Sum([If(b, 1, 0) for b in learned_langs]) >= 1)\n    solver.add(Sum([If(b, 1, 0) for b in learned_langs]) <= 3)\n\n# 2. Exactly one researcher learns Rundi\nsolver.add(Sum([If(learns[(r, 'Rundi')], 1, 0) for r in researchers]) == 1)\n\n# 3. Exactly two researchers learn Swahili\nsolver.add(Sum([If(learns[(r, 'Swahili')], 1, 0) for r in researchers]) == 2)\n\n# 4. Exactly two researchers learn Tigrinya\nsolver.add(Sum([If(learns[(r, 'Tigrinya')], 1, 0) for r in researchers]) == 2)\n\n# 5. Exactly three researchers learn Yoruba\nsolver.add(Sum([If(learns[(r, 'Yoruba')], 1, 0) for r in researchers]) == 3)\n\n# 6. Any language learned by the linguist or paleontologist is not learned by the geologist\nfor l in languages:\n    linguist_learns = learns[('Linguist', l)]\n    paleontologist_learns = learns[('Paleontologist', l)]\n    geologist_learns = learns[('Geologist', l)]\n    # If Linguist or Paleontologist learn l then Geologist does not learn l\n    solver.add(Implies(Or(linguist_learns, paleontologist_learns), Not(geologist_learns)))\n\n# 7. Any language learned by the geologist is learned by the historian\nfor l in languages:\n    geologist_learns = learns[('Geologist', l)]\n    historian_learns = learns[('Historian', l)]\n    solver.add(Implies(geologist_learns, historian_learns))\n\n# The question: If the linguist learns three of the languages, then which one must be true?\n\n# We will check each option by adding the condition that linguist learns exactly 3 languages,\n# and the negation of the option, and see if the solver is unsat (meaning option must be true).\n\n# Condition: Linguist learns exactly 3 languages\nlinguist_langs = [learns[('Linguist', l)] for l in languages]\nlinguist_three = Sum([If(b, 1, 0) for b in linguist_langs]) == 3\n\noptions = {\n    'A': learns[('Linguist', 'Tigrinya')],\n    'B': learns[('Linguist', 'Rundi')],\n    'C': learns[('Linguist', 'Swahili')],\n    'D': learns[('Paleontologist', 'Rundi')],\n    'E': learns[('Paleontologist', 'Swahili')],\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(linguist_three)\n    # Add negation of the option to test if option must be true\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.\n\nEach of the following could be true of the researcher who learns Rundi EXCEPT:\n\nOptions:\n(A) The researcher also learns Tigrinya but not Swahili.\n(B) The researcher learns neither Tigrinya nor Swahili.\n(C) The researcher also learns Tigrinya but not Yoruba.\n(D) The researcher also learns both Tigrinya and Yoruba.\n(E) The researcher also learns Yoruba but not Tigrinya.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nresearchers = ['Geologist', 'Historian', 'Linguist', 'Paleontologist']\nlanguages = ['Rundi', 'Swahili', 'Tigrinya', 'Yoruba']\n\n# Create a dictionary of Bool variables: researcher x language\n# True means the researcher learns that language\nlearns = {}\nfor r in researchers:\n    for l in languages:\n        learns[(r,l)] = Bool(f\"{r}_{l}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each researcher learns at least one and at most three languages\nfor r in researchers:\n    learned_langs = [learns[(r,l)] for l in languages]\n    solver.add(Sum([If(x,1,0) for x in learned_langs]) >= 1)\n    solver.add(Sum([If(x,1,0) for x in learned_langs]) <= 3)\n\n# Exactly one researcher learns Rundi\nsolver.add(Sum([If(learns[(r,'Rundi')],1,0) for r in researchers]) == 1)\n\n# Exactly two researchers learn Swahili\nsolver.add(Sum([If(learns[(r,'Swahili')],1,0) for r in researchers]) == 2)\n\n# Exactly two researchers learn Tigrinya\nsolver.add(Sum([If(learns[(r,'Tigrinya')],1,0) for r in researchers]) == 2)\n\n# Exactly three researchers learn Yoruba\nsolver.add(Sum([If(learns[(r,'Yoruba')],1,0) for r in researchers]) == 3)\n\n# Any language learned by the linguist or paleontologist is not learned by the geologist\nfor l in languages:\n    lang_learned_by_linguist_or_paleo = Or(learns[('Linguist',l)], learns[('Paleontologist',l)])\n    solver.add(Implies(lang_learned_by_linguist_or_paleo, Not(learns[('Geologist',l)])))\n\n# Any language learned by the geologist is learned by the historian\nfor l in languages:\n    solver.add(Implies(learns[('Geologist',l)], learns[('Historian',l)]))\n\n# OPTION CHECKING\n# Options (A) through (E) describe properties of the researcher who learns Rundi.\n# For each option, we add constraints that the Rundi learner satisfies the option's description,\n# and check if the entire model is satisfiable.\n# The EXCEPT option is the one that makes the model unsatisfiable.\n\n# Helper: find the researcher who learns Rundi\ndef rundi_learner_constraint(r):\n    return learns[(r,'Rundi')]\n\n# For each option, add constraints describing that option about the Rundi learner\n\n# (A) The researcher also learns Tigrinya but not Swahili.\n# So: Tigrinya = True, Swahili = False for the Rundi learner\ndef option_A():\n    clauses = []\n    for r in researchers:\n        cond = And(\n            rundi_learner_constraint(r),\n            learns[(r,'Tigrinya')],\n            Not(learns[(r,'Swahili')])\n        )\n        clauses.append(cond)\n    return Or(clauses)\n\n# (B) The researcher learns neither Tigrinya nor Swahili.\n# So: Tigrinya = False, Swahili = False for the Rundi learner\ndef option_B():\n    clauses = []\n    for r in researchers:\n        cond = And(\n            rundi_learner_constraint(r),\n            Not(learns[(r,'Tigrinya')]),\n            Not(learns[(r,'Swahili')])\n        )\n        clauses.append(cond)\n    return Or(clauses)\n\n# (C) The researcher also learns Tigrinya but not Yoruba.\n# So: Tigrinya = True, Yoruba = False for the Rundi learner\ndef option_C():\n    clauses = []\n    for r in researchers:\n        cond = And(\n            rundi_learner_constraint(r),\n            learns[(r,'Tigrinya')],\n            Not(learns[(r,'Yoruba')])\n        )\n        clauses.append(cond)\n    return Or(clauses)\n\n# (D) The researcher also learns both Tigrinya and Yoruba.\n# So: Tigrinya = True, Yoruba = True for the Rundi learner\ndef option_D():\n    clauses = []\n    for r in researchers:\n        cond = And(\n            rundi_learner_constraint(r),\n            learns[(r,'Tigrinya')],\n            learns[(r,'Yoruba')]\n        )\n        clauses.append(cond)\n    return Or(clauses)\n\n# (E) The researcher also learns Yoruba but not Tigrinya.\n# So: Yoruba = True, Tigrinya = False for the Rundi learner\ndef option_E():\n    clauses = []\n    for r in researchers:\n        cond = And(\n            rundi_learner_constraint(r),\n            learns[(r,'Yoruba')],\n            Not(learns[(r,'Tigrinya')])\n        )\n        clauses.append(cond)\n    return Or(clauses)\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, opt_func in enumerate(options):\n    solver.push()\n    solver.add(opt_func())\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        solver.pop()\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.\n\nEach of the following could be a complete and accurate list of the researchers who learn both Swahili and Yoruba EXCEPT:\n\nOptions:\n(A) the historian\n(B) the paleontologist\n(C) the historian, the linguist\n(D) the historian, the paleontologist\n(E) the linguist, the paleontologist",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nresearchers = ['geologist', 'historian', 'linguist', 'paleontologist']\nlanguages = ['Rundi', 'Swahili', 'Tigrinya', 'Yoruba']\n\n# Create a dictionary for each researcher and language: Bool variable indicating if researcher learns language\nlearns = {}\nfor r in researchers:\n    for l in languages:\n        learns[(r,l)] = Bool(f\"{r}_{l}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each researcher learns at least one and at most three languages\nfor r in researchers:\n    langs_learned = [learns[(r,l)] for l in languages]\n    solver.add(Sum([If(b,1,0) for b in langs_learned]) >= 1)\n    solver.add(Sum([If(b,1,0) for b in langs_learned]) <= 3)\n\n# Exactly one researcher learns Rundi\nsolver.add(Sum([If(learns[(r,'Rundi')],1,0) for r in researchers]) == 1)\n\n# Exactly two researchers learn Swahili\nsolver.add(Sum([If(learns[(r,'Swahili')],1,0) for r in researchers]) == 2)\n\n# Exactly two researchers learn Tigrinya\nsolver.add(Sum([If(learns[(r,'Tigrinya')],1,0) for r in researchers]) == 2)\n\n# Exactly three researchers learn Yoruba\nsolver.add(Sum([If(learns[(r,'Yoruba')],1,0) for r in researchers]) == 3)\n\n# Any language learned by the linguist or paleontologist is not learned by the geologist\nfor l in languages:\n    linguist_or_paleo_learns = Or(learns[('linguist',l)], learns[('paleontologist',l)])\n    geologist_learns = learns[('geologist',l)]\n    solver.add(Implies(linguist_or_paleo_learns, Not(geologist_learns)))\n\n# Any language learned by the geologist is learned by the historian\nfor l in languages:\n    geologist_learns = learns[('geologist',l)]\n    historian_learns = learns[('historian',l)]\n    solver.add(Implies(geologist_learns, historian_learns))\n\n# OPTION CHECKING\n# Each option is a possible complete and accurate list of researchers who learn both Swahili and Yoruba.\n# We check which options can be true given the constraints.\n\n# Define the sets of researchers who learn both Swahili and Yoruba for each option\noptions = {\n    'A': ['historian'],\n    'B': ['paleontologist'],\n    'C': ['historian', 'linguist'],\n    'D': ['historian', 'paleontologist'],\n    'E': ['linguist', 'paleontologist'],\n}\n\nfor opt_letter, sw_yo_learners in options.items():\n    solver.push()\n    # Researchers in sw_yo_learners learn both Swahili and Yoruba\n    for r in researchers:\n        if r in sw_yo_learners:\n            solver.add(learns[(r,'Swahili')] == True)\n            solver.add(learns[(r,'Yoruba')] == True)\n        else:\n            # Researchers not in the list do NOT learn both Swahili and Yoruba\n            # So at least one of Swahili or Yoruba is not learned by them\n            solver.add(Or(learns[(r,'Swahili')] == False, learns[(r,'Yoruba')] == False))\n    # Check if model is satisfiable with this option\n    if solver.check() == unsat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.\n\nIf the geologist learns exactly two of the languages, then which one of the following could be true?\n\nOptions:\n(A) The paleontologist learns Rundi.\n(B) The paleontologist learns Swahili.\n(C) The historian learns Rundi.\n(D) The paleontologist learns exactly three of the languages.\n(E) The historian learns exactly two of the languages.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nresearchers = ['Geologist', 'Historian', 'Linguist', 'Paleontologist']\nlanguages = ['Rundi', 'Swahili', 'Tigrinya', 'Yoruba']\n\n# Create variables: researcher_learns[r][l] = Bool if researcher r learns language l\nresearcher_learns = {}\nfor r in researchers:\n    for l in languages:\n        researcher_learns[(r, l)] = Bool(f\"{r}_{l}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each researcher learns at least one and at most three languages\nfor r in researchers:\n    langs = [researcher_learns[(r, l)] for l in languages]\n    solver.add(Sum([If(lang, 1, 0) for lang in langs]) >= 1)\n    solver.add(Sum([If(lang, 1, 0) for lang in langs]) <= 3)\n\n# Exactly one researcher learns Rundi\nsolver.add(Sum([If(researcher_learns[(r, 'Rundi')], 1, 0) for r in researchers]) == 1)\n\n# Exactly two researchers learn Swahili\nsolver.add(Sum([If(researcher_learns[(r, 'Swahili')], 1, 0) for r in researchers]) == 2)\n\n# Exactly two researchers learn Tigrinya\nsolver.add(Sum([If(researcher_learns[(r, 'Tigrinya')], 1, 0) for r in researchers]) == 2)\n\n# Exactly three researchers learn Yoruba\nsolver.add(Sum([If(researcher_learns[(r, 'Yoruba')], 1, 0) for r in researchers]) == 3)\n\n# Any language learned by linguist or paleontologist is not learned by geologist\nfor l in languages:\n    solver.add(Implies(Or(researcher_learns[('Linguist', l)], researcher_learns[('Paleontologist', l)]),\n                       Not(researcher_learns[('Geologist', l)])))\n\n# Any language learned by geologist is learned by historian\nfor l in languages:\n    solver.add(Implies(researcher_learns[('Geologist', l)], researcher_learns[('Historian', l)]))\n\n# The geologist learns exactly two languages\ngeologist_langs = [researcher_learns[('Geologist', l)] for l in languages]\nsolver.add(Sum([If(lang, 1, 0) for lang in geologist_langs]) == 2)\n\n# OPTION CHECKING\noptions = [\n    # (A) The paleontologist learns Rundi.\n    researcher_learns[('Paleontologist', 'Rundi')],\n    # (B) The paleontologist learns Swahili.\n    researcher_learns[('Paleontologist', 'Swahili')],\n    # (C) The historian learns Rundi.\n    researcher_learns[('Historian', 'Rundi')],\n    # (D) The paleontologist learns exactly three of the languages.\n    And(Sum([If(researcher_learns[('Paleontologist', l)], 1, 0) for l in languages]) == 3),\n    # (E) The historian learns exactly two of the languages.\n    And(Sum([If(researcher_learns[('Historian', l)], 1, 0) for l in languages]) == 2)\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Fewer of the languages are learned by the historian than are learned by the paleontologist.\n(B) Fewer of the languages are learned by the geologist than are learned by the historian.\n(C) Fewer of the languages are learned by the geologist than are learned by the linguist.\n(D) Fewer of the languages are learned by the paleontologist than are learned by the linguist.\n(E) Fewer of the languages are learned by the paleontologist than are learned by the historian.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nresearchers = ['Geologist', 'Historian', 'Linguist', 'Paleontologist']\nlanguages = ['Rundi', 'Swahili', 'Tigrinya', 'Yoruba']\n\n# Create variables: learns[r][l] = Bool indicating if researcher r learns language l\nlearns = {}\nfor r in researchers:\n    for l in languages:\n        learns[(r, l)] = Bool(f\"{r}_{l}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each researcher learns at least one and at most three languages\nfor r in researchers:\n    count = Sum([If(learns[(r, l)], 1, 0) for l in languages])\n    solver.add(count >= 1, count <= 3)\n\n# Exactly one researcher learns Rundi\nsolver.add(Sum([If(learns[(r, 'Rundi')], 1, 0) for r in researchers]) == 1)\n\n# Exactly two researchers learn Swahili\nsolver.add(Sum([If(learns[(r, 'Swahili')], 1, 0) for r in researchers]) == 2)\n\n# Exactly two researchers learn Tigrinya\nsolver.add(Sum([If(learns[(r, 'Tigrinya')], 1, 0) for r in researchers]) == 2)\n\n# Exactly three researchers learn Yoruba\nsolver.add(Sum([If(learns[(r, 'Yoruba')], 1, 0) for r in researchers]) == 3)\n\n# Any language learned by the linguist or paleontologist is not learned by the geologist\nfor l in languages:\n    linguist_learns = learns[('Linguist', l)]\n    paleontologist_learns = learns[('Paleontologist', l)]\n    geologist_learns = learns[('Geologist', l)]\n    # If Linguist or Paleontologist learns l, Geologist does not learn l\n    solver.add(Implies(Or(linguist_learns, paleontologist_learns), Not(geologist_learns)))\n\n# Any language learned by the geologist is learned by the historian\nfor l in languages:\n    geologist_learns = learns[('Geologist', l)]\n    historian_learns = learns[('Historian', l)]\n    solver.add(Implies(geologist_learns, historian_learns))\n\n# OPTION CHECKING\noptions = [\n    # (A) Fewer languages learned by Historian than Paleontologist\n    ('A', lambda: Sum([If(learns[('Historian', l)], 1, 0) for l in languages]) < Sum([If(learns[('Paleontologist', l)], 1, 0) for l in languages])),\n    # (B) Fewer languages learned by Geologist than Historian\n    ('B', lambda: Sum([If(learns[('Geologist', l)], 1, 0) for l in languages]) < Sum([If(learns[('Historian', l)], 1, 0) for l in languages])),\n    # (C) Fewer languages learned by Geologist than Linguist\n    ('C', lambda: Sum([If(learns[('Geologist', l)], 1, 0) for l in languages]) < Sum([If(learns[('Linguist', l)], 1, 0) for l in languages])),\n    # (D) Fewer languages learned by Paleontologist than Linguist\n    ('D', lambda: Sum([If(learns[('Paleontologist', l)], 1, 0) for l in languages]) < Sum([If(learns[('Linguist', l)], 1, 0) for l in languages])),\n    # (E) Fewer languages learned by Paleontologist than Historian\n    ('E', lambda: Sum([If(learns[('Paleontologist', l)], 1, 0) for l in languages]) < Sum([If(learns[('Historian', l)], 1, 0) for l in languages]))\n]\n\nfor letter, cond in options:\n    solver.push()\n    # Add negation of option condition to check if it can be false\n    solver.add(Not(cond()))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "To prepare for fieldwork, exactly four different researchers—a geologist, a historian, a linguist, and a paleontologist—will learn at least one and at most three of four languages—Rundi, Swahili, Tigrinya, and Yoruba. They must learn the languages according to the following specifications: Exactly one researcher learns Rundi. Exactly two researchers learn Swahili. Exactly two researchers learn Tigrinya. Exactly three researchers learn Yoruba. Any language learned by the linguist or paleontologist is not learned by the geologist. Any language learned by the geologist is learned by the historian.\n\nIf exactly two of the languages are learned by the historian, then which one of the following must be true?\n\nOptions:\n(A) The paleontologist does not learn Rundi.\n(B) The geologist does not learn Swahili.\n(C) The linguist does not learn Rundi.\n(D) The historian does not learn Rundi.\n(E) The paleontologist does not learn Swahili.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nresearchers = ['Geologist', 'Historian', 'Linguist', 'Paleontologist']\nlanguages = ['Rundi', 'Swahili', 'Tigrinya', 'Yoruba']\n\n# Create a dictionary of Bool variables: learns[r][l] is True if researcher r learns language l\nlearns = {r: {l: Bool(f'{r}_{l}') for l in languages} for r in researchers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each language is learned by a specified number of researchers\n# Exactly one researcher learns Rundi\nsolver.add(Sum([If(learns[r]['Rundi'], 1, 0) for r in researchers]) == 1)\n# Exactly two researchers learn Swahili\nsolver.add(Sum([If(learns[r]['Swahili'], 1, 0) for r in researchers]) == 2)\n# Exactly two researchers learn Tigrinya\nsolver.add(Sum([If(learns[r]['Tigrinya'], 1, 0) for r in researchers]) == 2)\n# Exactly three researchers learn Yoruba\nsolver.add(Sum([If(learns[r]['Yoruba'], 1, 0) for r in researchers]) == 3)\n\n# Each researcher learns at least one and at most three languages\nfor r in researchers:\n    total_langs = Sum([If(learns[r][l], 1, 0) for l in languages])\n    solver.add(total_langs >= 1)\n    solver.add(total_langs <= 3)\n\n# Any language learned by the linguist or paleontologist is not learned by the geologist\nfor l in languages:\n    solver.add(Or(Not(learns['Linguist'][l]), Not(learns['Geologist'][l])))\n    solver.add(Or(Not(learns['Paleontologist'][l]), Not(learns['Geologist'][l])))\n\n# Any language learned by the geologist is learned by the historian\nfor l in languages:\n    solver.add(Implies(learns['Geologist'][l], learns['Historian'][l]))\n\n# The condition: exactly two of the languages are learned by the historian\nhistorian_langs = [learns['Historian'][l] for l in languages]\nsolver.add(Sum([If(x,1,0) for x in historian_langs]) == 2)\n\n# OPTION CHECKING\noptions = {\n    'A': Not(learns['Paleontologist']['Rundi']),\n    'B': Not(learns['Geologist']['Swahili']),\n    'C': Not(learns['Linguist']['Rundi']),\n    'D': Not(learns['Historian']['Rundi']),\n    'E': Not(learns['Paleontologist']['Swahili']),\n}\n\nfor letter, constraint in options.items():\n    solver.push()\n    solver.add(Not(constraint))  # Check if the negation is satisfiable\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "During three days—Monday through Wednesday—a health officer will inspect exactly six buildings—three hotels: Grace, Jacaranda, and Lido; and three restaurants: Seville, Vesuvio, and Zeno. Each day, exactly two buildings are inspected: one in the morning and one in the afternoon. Inspections must occur according to the following conditions: Hotels are not inspected on Wednesday. Grace is inspected at some time before Jacaranda. Grace is not inspected on the same day as Seville. If Zeno is inspected in the morning, Lido is also inspected in the morning.\n\nWhich one of the following could be the order in which the buildings are inspected, listed in order from Monday morning through Wednesday afternoon?\n\nOptions:\n(A) Grace, Seville, Jacaranda, Lido, Vesuvio, Zeno\n(B) Grace, Vesuvio, Zeno, Jacaranda, Lido, Seville\n(C) Lido, Jacaranda, Grace, Vesuvio, Zeno, Seville\n(D) Lido, Seville, Grace, Jacaranda, Zeno, Vesuvio\n(E) Zeno, Grace, Jacaranda, Lido, Seville, Vesuvio",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Monday', 'Tuesday', 'Wednesday']\ntimes = ['Morning', 'Afternoon']\nbuildings = ['Grace', 'Jacaranda', 'Lido', 'Seville', 'Vesuvio', 'Zeno']\nhotels = ['Grace', 'Jacaranda', 'Lido']\nrestaurants = ['Seville', 'Vesuvio', 'Zeno']\n\n# Map building to index\nbldg_idx = {b: i for i, b in enumerate(buildings)}\n\n# Create variables: inspection order from 0 to 5, each assigned a building index\n# order[0] = building inspected Monday morning, order[1] Monday afternoon, ... order[5] Wednesday afternoon\norder = [Int(f'order_{i}') for i in range(6)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each order position must be a valid building index\nfor pos in range(6):\n    solver.add(And(order[pos] >= 0, order[pos] < len(buildings)))\n\n# All buildings are inspected exactly once\nsolver.add(Distinct(order))\n\n# Hotels are not inspected on Wednesday (positions 4 and 5 correspond to Wednesday morning and afternoon)\nwed_positions = [4,5]\nfor pos in wed_positions:\n    for h in hotels:\n        solver.add(order[pos] != bldg_idx[h])\n\n# Grace is inspected before Jacaranda\ngrace_pos = Int('grace_pos')\njacaranda_pos = Int('jacaranda_pos')\nsolver.add(grace_pos >= 0, grace_pos < 6)\nsolver.add(jacaranda_pos >= 0, jacaranda_pos < 6)\nfor pos in range(6):\n    solver.add(If(order[pos] == bldg_idx['Grace'], grace_pos == pos, True))\n    solver.add(If(order[pos] == bldg_idx['Jacaranda'], jacaranda_pos == pos, True))\nsolver.add(grace_pos < jacaranda_pos)\n\n# Grace is not inspected on the same day as Seville\n# Days: positions 0-1 Monday, 2-3 Tuesday, 4-5 Wednesday\n# So for each day, Grace and Seville cannot both be in the two positions\nfor day_idx in range(3):\n    day_positions = [day_idx*2, day_idx*2 +1]\n    for pos1 in day_positions:\n        for pos2 in day_positions:\n            if pos1 != pos2:\n                solver.add(Or(order[pos1] != bldg_idx['Grace'], order[pos2] != bldg_idx['Seville']))\n\n# If Zeno is inspected in the morning, Lido is inspected in the morning\n# Morning positions are 0,2,4\nzeno_morning_positions = [0,2,4]\nlido_morning_positions = [0,2,4]\n# For each morning position, if Zeno is inspected then Lido must be inspected at some morning position (not necessarily same time)\nfor pos in zeno_morning_positions:\n    zeno_here = order[pos] == bldg_idx['Zeno']\n    # Lido inspected in any morning position\n    lido_in_morning = Or([order[m] == bldg_idx['Lido'] for m in lido_morning_positions])\n    solver.add(Implies(zeno_here, lido_in_morning))\n\n# OPTION CHECKING\noptions = [\n    ['Grace', 'Seville', 'Jacaranda', 'Lido', 'Vesuvio', 'Zeno'],  # A\n    ['Grace', 'Vesuvio', 'Zeno', 'Jacaranda', 'Lido', 'Seville'],  # B\n    ['Lido', 'Jacaranda', 'Grace', 'Vesuvio', 'Zeno', 'Seville'],  # C\n    ['Lido', 'Seville', 'Grace', 'Jacaranda', 'Zeno', 'Vesuvio'],  # D\n    ['Zeno', 'Grace', 'Jacaranda', 'Lido', 'Seville', 'Vesuvio']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that order matches the option\n    for pos in range(6):\n        solver.add(order[pos] == bldg_idx[option[pos]])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "During three days—Monday through Wednesday—a health officer will inspect exactly six buildings—three hotels: Grace, Jacaranda, and Lido; and three restaurants: Seville, Vesuvio, and Zeno. Each day, exactly two buildings are inspected: one in the morning and one in the afternoon. Inspections must occur according to the following conditions: Hotels are not inspected on Wednesday. Grace is inspected at some time before Jacaranda. Grace is not inspected on the same day as Seville. If Zeno is inspected in the morning, Lido is also inspected in the morning.\n\nWhich one of the following could be the buildings inspected in the mornings, listed in order from Monday through Wednesday?\n\nOptions:\n(A) Grace, Jacaranda, Zeno\n(B) Jacaranda, Vesuvio, Seville\n(C) Lido, Jacaranda, Vesuvio\n(D) Seville, Jacaranda, Vesuvio\n(E) Seville, Lido, Zeno",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Mon', 'Tue', 'Wed']\ntimes = ['Morning', 'Afternoon']\n\n# Buildings\nhotels = ['Grace', 'Jacaranda', 'Lido']\nrestaurants = ['Seville', 'Vesuvio', 'Zeno']\nbuildings = hotels + restaurants\n\n# Map building names to indices for Z3 variables\nbldg_indices = {b: i for i, b in enumerate(buildings)}\n\n# Variables: inspection[day][time] = building index inspected at that day and time\ninspection = {}\nfor d in days:\n    for t in times:\n        inspection[(d, t)] = Int(f'inspect_{d}_{t}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each inspection variable must be a valid building index\nfor d in days:\n    for t in times:\n        solver.add(And(inspection[(d, t)] >= 0, inspection[(d, t)] < len(buildings)))\n\n# All six inspections are distinct buildings\nall_inspections = [inspection[(d, t)] for d in days for t in times]\nsolver.add(Distinct(all_inspections))\n\n# Constraint 1: Hotels are not inspected on Wednesday\nfor t in times:\n    for h in hotels:\n        solver.add(inspection[('Wed', t)] != bldg_indices[h])\n\n# Constraint 2: Grace is inspected before Jacaranda (Grace inspection time < Jacaranda inspection time)\n# Define a helper function to get a numeric order for inspections: Monday Morning=0, Monday Afternoon=1, ..., Wednesday Afternoon=5\ndef inspection_order(day, time):\n    day_index = days.index(day)\n    time_index = times.index(time)\n    return day_index * 2 + time_index\n\n# Find variables for Grace and Jacaranda inspection times\n# We will find the inspection order for Grace and Jacaranda by checking all inspections\n# Create integer variables for inspection order of Grace and Jacaranda\ngrace_order = Int('grace_order')\njacaranda_order = Int('jacaranda_order')\n\n# For Grace: grace_order == inspection order of the slot where inspection == Grace index\n# For Jacaranda: jacaranda_order == inspection order of the slot where inspection == Jacaranda index\n\n# Create constraints to link grace_order and jacaranda_order to their inspection slots\ngrace_constraints = []\njacaranda_constraints = []\nfor d in days:\n    for t in times:\n        ord_val = inspection_order(d, t)\n        # If inspection at (d,t) == Grace index then grace_order == ord_val\n        grace_constraints.append(If(inspection[(d, t)] == bldg_indices['Grace'], grace_order == ord_val, True))\n        # If inspection at (d,t) == Jacaranda index then jacaranda_order == ord_val\n        jacaranda_constraints.append(If(inspection[(d, t)] == bldg_indices['Jacaranda'], jacaranda_order == ord_val, True))\n\nsolver.add(And(grace_constraints))\nsolver.add(And(jacaranda_constraints))\n\n# Grace inspected before Jacaranda\nsolver.add(grace_order < jacaranda_order)\n\n# Constraint 3: Grace is not inspected on the same day as Seville\n# For each day, Grace and Seville cannot both be inspected that day\nfor d in days:\n    grace_on_day = Or([inspection[(d, t)] == bldg_indices['Grace'] for t in times])\n    seville_on_day = Or([inspection[(d, t)] == bldg_indices['Seville'] for t in times])\n    solver.add(Not(And(grace_on_day, seville_on_day)))\n\n# Constraint 4: If Zeno is inspected in the morning, Lido is also inspected in the morning\n# For each day, if morning inspection is Zeno, then morning inspection is Lido (which is impossible)\n# But since only one building per slot, it means if Zeno is inspected in morning on any day, Lido is also inspected in morning on same day\n# This means that if Zeno is morning inspected on a day, then Lido must also be morning inspected on that day.\n# But there is only one morning inspection per day, so this is impossible unless Zeno and Lido are inspected in morning on different days.\n# The problem states: \"If Zeno is inspected in the morning, Lido is also inspected in the morning.\" \n# This means on any day where Zeno is morning inspected, Lido must be morning inspected on some day (not necessarily same day).\n# The problem is slightly ambiguous but usually means: if Zeno is morning inspected at all, then Lido is morning inspected at some day.\n# So: (exists day d: inspection[d, Morning] == Zeno) => (exists day d: inspection[d, Morning] == Lido)\n# Implement this implication:\n\n# Create bool variables for Zeno morning and Lido morning inspections\nzeno_morning = Or([inspection[(d, 'Morning')] == bldg_indices['Zeno'] for d in days])\nlido_morning = Or([inspection[(d, 'Morning')] == bldg_indices['Lido'] for d in days])\nsolver.add(Implies(zeno_morning, lido_morning))\n\n# OPTION CHECKING\noptions = [\n    ['Grace', 'Jacaranda', 'Zeno'],      # A\n    ['Jacaranda', 'Vesuvio', 'Seville'], # B\n    ['Lido', 'Jacaranda', 'Vesuvio'],    # C\n    ['Seville', 'Jacaranda', 'Vesuvio'], # D\n    ['Seville', 'Lido', 'Zeno'],          # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that morning inspections are exactly as in option\n    for d_index, bldg_name in enumerate(option):\n        day = days[d_index]\n        # Morning inspection must be this building\n        solver.add(inspection[(day, 'Morning')] == bldg_indices[bldg_name])\n    # Check if satisfiable\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "During three days—Monday through Wednesday—a health officer will inspect exactly six buildings—three hotels: Grace, Jacaranda, and Lido; and three restaurants: Seville, Vesuvio, and Zeno. Each day, exactly two buildings are inspected: one in the morning and one in the afternoon. Inspections must occur according to the following conditions: Hotels are not inspected on Wednesday. Grace is inspected at some time before Jacaranda. Grace is not inspected on the same day as Seville. If Zeno is inspected in the morning, Lido is also inspected in the morning.\n\nWhich one of the following is a pair of buildings that, if inspected on the same day as each other, must be inspected on Monday?\n\nOptions:\n(A) Grace and Jacaranda\n(B) Grace and Vesuvio\n(C) Jacaranda and Lido\n(D) Lido and Seville\n(E) Lido and Vesuvio",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Days and times\ndays = ['Monday', 'Tuesday', 'Wednesday']\ntimes = ['Morning', 'Afternoon']\n\n# Buildings\nhotels = ['Grace', 'Jacaranda', 'Lido']\nrestaurants = ['Seville', 'Vesuvio', 'Zeno']\nbuildings = hotels + restaurants\n\n# Create a mapping from building to inspection day and time\n# day_vars[b] = Int variable representing the day index (0=Monday, 1=Tuesday, 2=Wednesday)\n# time_vars[b] = Int variable representing time index (0=Morning, 1=Afternoon)\nday_vars = {b: Int(b + '_day') for b in buildings}\ntime_vars = {b: Int(b + '_time') for b in buildings}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each building inspected exactly once on a valid day and time\nfor b in buildings:\n    solver.add(And(day_vars[b] >= 0, day_vars[b] < len(days)))\n    solver.add(And(time_vars[b] >= 0, time_vars[b] < len(times)))\n\n# Exactly two buildings inspected each day: one in morning, one in afternoon\n# For each day, count how many buildings inspected in morning and afternoon\nfor d in range(len(days)):\n    morning_count = Sum([If(And(day_vars[b] == d, time_vars[b] == 0), 1, 0) for b in buildings])\n    afternoon_count = Sum([If(And(day_vars[b] == d, time_vars[b] == 1), 1, 0) for b in buildings])\n    # Exactly one building inspected in morning and one in afternoon per day\n    solver.add(morning_count == 1)\n    solver.add(afternoon_count == 1)\n\n# Each building inspected exactly once - all day/time pairs distinct\n# No two buildings have same day and time\nfor i in range(len(buildings)):\n    for j in range(i+1, len(buildings)):\n        b1 = buildings[i]\n        b2 = buildings[j]\n        solver.add(Or(day_vars[b1] != day_vars[b2], time_vars[b1] != time_vars[b2]))\n\n# Hotels are not inspected on Wednesday (day 2)\nfor h in hotels:\n    solver.add(day_vars[h] != 2)\n\n# Grace is inspected before Jacaranda (Grace day < Jacaranda day OR\n# if same day, Grace time < Jacaranda time)\ngrace_day = day_vars['Grace']\ngrace_time = time_vars['Grace']\njacaranda_day = day_vars['Jacaranda']\njacaranda_time = time_vars['Jacaranda']\n\ngrace_before_jacaranda = Or(\n    grace_day < jacaranda_day,\n    And(grace_day == jacaranda_day, grace_time < jacaranda_time)\n)\nsolver.add(grace_before_jacaranda)\n\n# Grace is not inspected on the same day as Seville\nsolver.add(grace_day != day_vars['Seville'])\n\n# If Zeno is inspected in the morning, Lido is also inspected in the morning\nzeno_morning = time_vars['Zeno'] == 0\nlido_morning = time_vars['Lido'] == 0\nsolver.add(Implies(zeno_morning, lido_morning))\n\n# OPTION CHECKING\n# Each option is a pair of buildings that if inspected on the same day,\n# then they must be inspected on Monday (day 0)\n\noptions = [\n    ('Grace', 'Jacaranda'),   # A\n    ('Grace', 'Vesuvio'),     # B\n    ('Jacaranda', 'Lido'),    # C\n    ('Lido', 'Seville'),      # D\n    ('Lido', 'Vesuvio')       # E\n]\n\nfor i, (b1, b2) in enumerate(options):\n    solver.push()\n    # Add constraint: b1 and b2 inspected on the same day\n    solver.add(day_vars[b1] == day_vars[b2])\n    # Add constraint: their day is NOT Monday (0)\n    solver.add(day_vars[b1] != 0)\n    # Check if this is satisfiable with all other constraints\n    if solver.check() == unsat:\n        # If unsat, then if b1 and b2 inspected same day, must be Monday\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "During three days—Monday through Wednesday—a health officer will inspect exactly six buildings—three hotels: Grace, Jacaranda, and Lido; and three restaurants: Seville, Vesuvio, and Zeno. Each day, exactly two buildings are inspected: one in the morning and one in the afternoon. Inspections must occur according to the following conditions: Hotels are not inspected on Wednesday. Grace is inspected at some time before Jacaranda. Grace is not inspected on the same day as Seville. If Zeno is inspected in the morning, Lido is also inspected in the morning.\n\nIf Grace is inspected on Tuesday, which one of the following could be the buildings inspected in the afternoons, listed in order from Monday through Wednesday?\n\nOptions:\n(A) Lido, Jacaranda, Vesuvio\n(B) Lido, Jacaranda, Zeno\n(C) Lido, Vesuvio, Zeno\n(D) Seville, Grace, Vesuvio\n(E) Seville, Jacaranda, Lido",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Monday', 'Tuesday', 'Wednesday']\ntimes = ['Morning', 'Afternoon']\n\nhotels = ['Grace', 'Jacaranda', 'Lido']\nrestaurants = ['Seville', 'Vesuvio', 'Zeno']\nbuildings = hotels + restaurants\n\nday_indices = {d: i for i, d in enumerate(days)}\ntime_indices = {t: i for i, t in enumerate(times)}\nbuilding_indices = {b: i for i, b in enumerate(buildings)}\n\n# Create variables: building inspected at each day and time\n# inspections[day][time] = building index\ninspections = [[Int(f'inspection_{d}_{t}') for t in range(2)] for d in range(3)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each inspection must be a valid building index\nfor d in range(3):\n    for t in range(2):\n        solver.add(And(inspections[d][t] >= 0, inspections[d][t] < len(buildings)))\n\n# Exactly six buildings inspected, all different\nall_inspections = [inspections[d][t] for d in range(3) for t in range(2)]\nsolver.add(Distinct(all_inspections))\n\n# Each day: exactly two buildings inspected, one morning and one afternoon (already modeled)\n\n# Hotels are not inspected on Wednesday (day 2)\nfor t in range(2):\n    for h in hotels:\n        h_idx = building_indices[h]\n        solver.add(inspections[day_indices['Wednesday']][t] != h_idx)\n\n# Grace is inspected at some time before Jacaranda\n# Find the day and time of Grace and Jacaranda, then enforce Grace < Jacaranda in order\n# We'll encode order as day*2 + time (morning=0, afternoon=1)\ndef building_order(building_name):\n    b_idx = building_indices[building_name]\n    order = Int(f'order_{building_name}')\n    # order is day*2 + time of inspection of building_name\n    # We create constraints to link order with inspections\n    # order = sum over d,t: (d*2 + t) * (inspections[d][t] == b_idx)\n    # Since only one inspection per building, this is valid\n    order_exprs = []\n    for d in range(3):\n        for t in range(2):\n            cond = inspections[d][t] == b_idx\n            order_exprs.append(If(cond, d*2 + t, 0))\n    # order == sum of above\n    solver.add(order == Sum(order_exprs))\n    return order\n\norder_grace = building_order('Grace')\norder_jacaranda = building_order('Jacaranda')\nsolver.add(order_grace < order_jacaranda)\n\n# Grace is not inspected on the same day as Seville\n# For each day, Grace and Seville cannot both be inspected that day\ngrace_idx = building_indices['Grace']\nseville_idx = building_indices['Seville']\nfor d in range(3):\n    grace_in_day = Or([inspections[d][t] == grace_idx for t in range(2)])\n    seville_in_day = Or([inspections[d][t] == seville_idx for t in range(2)])\n    solver.add(Not(And(grace_in_day, seville_in_day)))\n\n# If Zeno is inspected in the morning, Lido is also inspected in the morning\nzeno_idx = building_indices['Zeno']\nlido_idx = building_indices['Lido']\nfor d in range(3):\n    zeno_morning = inspections[d][time_indices['Morning']] == zeno_idx\n    lido_morning = inspections[d][time_indices['Morning']] == lido_idx\n    solver.add(Implies(zeno_morning, lido_morning))\n\n# Additional condition: Grace is inspected on Tuesday\ntuesday = day_indices['Tuesday']\n# Grace is inspected on Tuesday morning or afternoon\nsolver.add(Or([inspections[tuesday][t] == grace_idx for t in range(2)]))\n\n# OPTION CHECKING\noptions = {\n    'A': ['Lido', 'Jacaranda', 'Vesuvio'],\n    'B': ['Lido', 'Jacaranda', 'Zeno'],\n    'C': ['Lido', 'Vesuvio', 'Zeno'],\n    'D': ['Seville', 'Grace', 'Vesuvio'],\n    'E': ['Seville', 'Jacaranda', 'Lido']\n}\n\nfor letter, afternoon_buildings in options.items():\n    solver.push()\n    # Add constraints that afternoons are as given, in order Monday to Wednesday\n    for d in range(3):\n        b_idx = building_indices[afternoon_buildings[d]]\n        solver.add(inspections[d][time_indices['Afternoon']] == b_idx)\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "During three days—Monday through Wednesday—a health officer will inspect exactly six buildings—three hotels: Grace, Jacaranda, and Lido; and three restaurants: Seville, Vesuvio, and Zeno. Each day, exactly two buildings are inspected: one in the morning and one in the afternoon. Inspections must occur according to the following conditions: Hotels are not inspected on Wednesday. Grace is inspected at some time before Jacaranda. Grace is not inspected on the same day as Seville. If Zeno is inspected in the morning, Lido is also inspected in the morning.\n\nIf Seville is inspected on Monday morning, which one of the following must be true?\n\nOptions:\n(A) Grace is inspected on Tuesday afternoon.\n(B) Jacaranda is inspected on Monday afternoon.\n(C) Lido is inspected on Tuesday morning.\n(D) Vesuvio is inspected on Wednesday morning.\n(E) Zeno is inspected on Wednesday morning.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndays = ['Monday', 'Tuesday', 'Wednesday']\ntimes = ['Morning', 'Afternoon']\nbuildings = ['Grace', 'Jacaranda', 'Lido', 'Seville', 'Vesuvio', 'Zeno']\nhotels = ['Grace', 'Jacaranda', 'Lido']\nrestaurants = ['Seville', 'Vesuvio', 'Zeno']\n\n# Map buildings to indices\nbld_idx = {b: i for i, b in enumerate(buildings)}\nday_idx = {d: i for i, d in enumerate(days)}\ntime_idx = {t: i for i, t in enumerate(times)}\n\n# Create variables: For each building, assign inspection day and time\n# day_bld[b] in [0..2], time_bld[b] in [0..1]\nday_bld = {}\ntime_bld = {}\nfor b in buildings:\n    day_bld[b] = Int(f'day_{b}')\n    time_bld[b] = Int(f'time_{b}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each building inspected exactly once: day in [0..2], time in [0..1]\nfor b in buildings:\n    solver.add(And(day_bld[b] >= 0, day_bld[b] <= 2))\n    solver.add(And(time_bld[b] >= 0, time_bld[b] <= 1))\n\n# Each day has exactly two inspections: one morning, one afternoon\n# For each day d and time t, exactly one building inspected\nfor d in days:\n    d_i = day_idx[d]\n    for t in times:\n        t_i = time_idx[t]\n        inspected = []\n        for b in buildings:\n            cond = And(day_bld[b] == d_i, time_bld[b] == t_i)\n            inspected.append(cond)\n        solver.add(Sum([If(c, 1, 0) for c in inspected]) == 1)\n\n# No building inspected more than once (implied by unique day/time assignment)\n# But explicitly: all buildings have unique (day,time) pairs\ninspection_pairs = [ (day_bld[b], time_bld[b]) for b in buildings ]\n# We ensure all pairs are distinct\npairs = []\nfor b in buildings:\n    pairs.append((day_bld[b], time_bld[b]))\n# To ensure pairs distinct, encode as integer: day*2 + time\npairs_int = [ day_bld[b]*2 + time_bld[b] for b in buildings ]\nsolver.add(Distinct(pairs_int))\n\n# Hotels are not inspected on Wednesday (day 2)\nfor h in hotels:\n    solver.add(day_bld[h] != day_idx['Wednesday'])\n\n# Grace is inspected before Jacaranda (time order over days and times)\n# Define function to convert (day,time) to a single integer for ordering\ndef inspection_order(b):\n    return day_bld[b]*2 + time_bld[b]\nsolver.add(inspection_order('Grace') < inspection_order('Jacaranda'))\n\n# Grace is not inspected on the same day as Seville\nsolver.add(day_bld['Grace'] != day_bld['Seville'])\n\n# If Zeno is inspected in the morning, Lido is also inspected in the morning\nz_morning = time_bld['Zeno'] == time_idx['Morning']\nl_morning = time_bld['Lido'] == time_idx['Morning']\nsolver.add(Implies(z_morning, l_morning))\n\n# OPTION CHECKING\n# Given: Seville is inspected on Monday morning\nsolver.push()\nsolver.add(day_bld['Seville'] == day_idx['Monday'])\nsolver.add(time_bld['Seville'] == time_idx['Morning'])\n\noptions = {\n    'A': And(day_bld['Grace'] == day_idx['Tuesday'], time_bld['Grace'] == time_idx['Afternoon']),\n    'B': And(day_bld['Jacaranda'] == day_idx['Monday'], time_bld['Jacaranda'] == time_idx['Afternoon']),\n    'C': And(day_bld['Lido'] == day_idx['Tuesday'], time_bld['Lido'] == time_idx['Morning']),\n    'D': And(day_bld['Vesuvio'] == day_idx['Wednesday'], time_bld['Vesuvio'] == time_idx['Morning']),\n    'E': And(day_bld['Zeno'] == day_idx['Wednesday'], time_bld['Zeno'] == time_idx['Morning']),\n}\n\n# We want to find which option must be true, i.e., which option is true in all models\n# For each option, check if adding its negation is unsat (contradiction)\ncorrect_option = None\nfor opt_letter, opt_constraint in options.items():\n    solver.push()\n    solver.add(Not(opt_constraint))\n    if solver.check() == unsat:\n        correct_option = opt_letter\n        solver.pop()\n        break\n    solver.pop()\n\nsolver.pop()\n\nprint(f\"'{correct_option}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) Fu and Gianola vote the same way on the tax bill.\n(B) Gianola and Herstein vote the same way on the recreation bill.\n(C) Gianola and Herstein vote the same way on the school bill.\n(D) Fu votes for one of the bills and Gianola votes for two of the bills.\n(E) Fu votes for two of the bills and Gianola votes for two of the bills.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Council members and bills\nmembers = ['Fu', 'Gianola', 'Herstein']\nbills = ['Recreation', 'School', 'Tax']\n\n# Create a dictionary of boolean variables: vote[member][bill] = True if member votes for bill\nvote = {}\nfor m in members:\n    vote[m] = {}\n    for b in bills:\n        vote[m][b] = Bool(f\"vote_{m}_{b}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each member votes for at least one bill and against at least one bill\nfor m in members:\n    votes_for = [vote[m][b] for b in bills]\n    votes_against = [Not(vote[m][b]) for b in bills]\n    solver.add(Or(votes_for))     # at least one for\n    solver.add(Or(votes_against)) # at least one against\n\n# Exactly two members vote for the recreation bill\nrecreation_votes = [vote[m]['Recreation'] for m in members]\nsolver.add(Sum([If(rv, 1, 0) for rv in recreation_votes]) == 2)\n\n# Exactly one member votes for the school bill\nschool_votes = [vote[m]['School'] for m in members]\nsolver.add(Sum([If(sv, 1, 0) for sv in school_votes]) == 1)\n\n# Exactly one member votes for the tax bill\ntax_votes = [vote[m]['Tax'] for m in members]\nsolver.add(Sum([If(tv, 1, 0) for tv in tax_votes]) == 1)\n\n# Fu votes for the recreation bill and against the school bill\nsolver.add(vote['Fu']['Recreation'] == True)\nsolver.add(vote['Fu']['School'] == False)\n\n# Gianola votes against the recreation bill\nsolver.add(vote['Gianola']['Recreation'] == False)\n\n# Herstein votes against the tax bill\nsolver.add(vote['Herstein']['Tax'] == False)\n\n# OPTION CHECKING\noptions = [\n    # (A) Fu and Gianola vote the same way on the tax bill.\n    vote['Fu']['Tax'] == vote['Gianola']['Tax'],\n    # (B) Gianola and Herstein vote the same way on the recreation bill.\n    vote['Gianola']['Recreation'] == vote['Herstein']['Recreation'],\n    # (C) Gianola and Herstein vote the same way on the school bill.\n    vote['Gianola']['School'] == vote['Herstein']['School'],\n    # (D) Fu votes for one of the bills and Gianola votes for two of the bills.\n    And(\n        Sum([If(vote['Fu'][b], 1, 0) for b in bills]) == 1,\n        Sum([If(vote['Gianola'][b], 1, 0) for b in bills]) == 2\n    ),\n    # (E) Fu votes for two of the bills and Gianola votes for two of the bills.\n    And(\n        Sum([If(vote['Fu'][b], 1, 0) for b in bills]) == 2,\n        Sum([If(vote['Gianola'][b], 1, 0) for b in bills]) == 2\n    )\n]\n\nfor i, option_constraint in enumerate(options):\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.\n\nIf the set of members of the council who vote against the school bill is the same set of members who vote against the tax bill, then which one of the following statements must be true?\n\nOptions:\n(A) Fu votes for the tax bill.\n(B) Gianola votes for the recreation bill.\n(C) Gianola votes against the school bill.\n(D) Herstein votes against the recreation bill.\n(E) Herstein votes against the school bill.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['Fu', 'Gianola', 'Herstein']\nbills = ['recreation', 'school', 'tax']\n\n# Create boolean variables: vote_for[member][bill] = True if member votes for bill, else False\nvote_for = {}\nfor m in members:\n    for b in bills:\n        vote_for[(m,b)] = Bool(f\"{m}_{b}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each member votes for at least one bill and against at least one bill\nfor m in members:\n    votes = [vote_for[(m,b)] for b in bills]\n    solver.add(Or(votes))  # at least one True (for)\n    solver.add(Or([Not(v) for v in votes]))  # at least one False (against)\n\n# Exactly two members vote for the recreation bill\nrecreation_votes = [vote_for[(m,'recreation')] for m in members]\nsolver.add(Sum([If(v,1,0) for v in recreation_votes]) == 2)\n\n# Exactly one member votes for the school bill\nschool_votes = [vote_for[(m,'school')] for m in members]\nsolver.add(Sum([If(v,1,0) for v in school_votes]) == 1)\n\n# Exactly one member votes for the tax bill\ntax_votes = [vote_for[(m,'tax')] for m in members]\nsolver.add(Sum([If(v,1,0) for v in tax_votes]) == 1)\n\n# Fu votes for recreation and against school\nsolver.add(vote_for[('Fu','recreation')] == True)\nsolver.add(vote_for[('Fu','school')] == False)\n\n# Gianola votes against recreation\nsolver.add(vote_for[('Gianola','recreation')] == False)\n\n# Herstein votes against tax\nsolver.add(vote_for[('Herstein','tax')] == False)\n\n# The set of members who vote against school is the same as the set who vote against tax\n# For each member, vote against school == vote against tax\nfor m in members:\n    solver.add((Not(vote_for[(m,'school')]) == Not(vote_for[(m,'tax')])))\n\n# OPTION CHECKING\n\noptions = {\n    'A': vote_for[('Fu','tax')] == True,\n    'B': vote_for[('Gianola','recreation')] == True,\n    'C': vote_for[('Gianola','school')] == False,\n    'D': vote_for[('Herstein','recreation')] == False,\n    'E': vote_for[('Herstein','school')] == False\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.\n\nIf Gianola votes for the tax bill, then which one of the following statements could be true?\n\nOptions:\n(A) Fu and Gianola each vote for exactly one bill.\n(B) Gianola and Herstein each vote for exactly one bill.\n(C) Fu votes for exactly two bills.\n(D) Gianola votes for the recreation bill.\n(E) Herstein votes against the recreation bill.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Council members and bills\nmembers = ['Fu', 'Gianola', 'Herstein']\nbills = ['Recreation', 'School', 'Tax']\n\n# Create a dictionary of vote variables: vote[member][bill] = Bool indicating if member votes FOR the bill\nvote = {}\nfor m in members:\n    vote[m] = {}\n    for b in bills:\n        vote[m][b] = Bool(f'vote_{m}_{b}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each member votes for at least one bill and against at least one bill\nfor m in members:\n    votes_for = [vote[m][b] for b in bills]\n    votes_against = [Not(vote[m][b]) for b in bills]\n    solver.add(Or(votes_for))      # at least one for\n    solver.add(Or(votes_against))  # at least one against\n\n# Exactly two members vote for the recreation bill\nrec_votes = [vote[m]['Recreation'] for m in members]\nsolver.add(PbEq([(v,1) for v in rec_votes], 2))\n\n# Exactly one member votes for the school bill\nschool_votes = [vote[m]['School'] for m in members]\nsolver.add(PbEq([(v,1) for v in school_votes], 1))\n\n# Exactly one member votes for the tax bill\ntax_votes = [vote[m]['Tax'] for m in members]\nsolver.add(PbEq([(v,1) for v in tax_votes], 1))\n\n# Fu votes for the recreation bill and against the school bill\nsolver.add(vote['Fu']['Recreation'] == True)\nsolver.add(vote['Fu']['School'] == False)\n\n# Gianola votes against the recreation bill\nsolver.add(vote['Gianola']['Recreation'] == False)\n\n# Herstein votes against the tax bill\nsolver.add(vote['Herstein']['Tax'] == False)\n\n# Additional condition: Gianola votes for the tax bill\nsolver.add(vote['Gianola']['Tax'] == True)\n\n# OPTION CHECKING\n# Options:\n# (A) Fu and Gianola each vote for exactly one bill.\n# (B) Gianola and Herstein each vote for exactly one bill.\n# (C) Fu votes for exactly two bills.\n# (D) Gianola votes for the recreation bill.\n# (E) Herstein votes against the recreation bill.\n\noptions = {\n    'A': And(\n        PbEq([(vote['Fu'][b],1) for b in bills], 1),\n        PbEq([(vote['Gianola'][b],1) for b in bills], 1)\n    ),\n    'B': And(\n        PbEq([(vote['Gianola'][b],1) for b in bills], 1),\n        PbEq([(vote['Herstein'][b],1) for b in bills], 1)\n    ),\n    'C': PbEq([(vote['Fu'][b],1) for b in bills], 2),\n    'D': vote['Gianola']['Recreation'] == True,\n    'E': Not(vote['Herstein']['Recreation'])\n}\n\nfor letter in ['A','B','C','D','E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.\n\nIf Gianola votes for exactly two of the three bills, which one of the following statements must be true?\n\nOptions:\n(A) Fu votes for the tax bill.\n(B) Gianola votes for the recreation bill.\n(C) Gianola votes for the school bill.\n(D) Gianola votes against the tax bill.\n(E) Herstein votes for the school bill.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['Fu', 'Gianola', 'Herstein']\nbills = ['Recreation', 'School', 'Tax']\n\n# Create variables: vote[m][b] = 1 if member m votes for bill b, else 0\nvote = {}\nfor m in members:\n    for b in bills:\n        vote[(m, b)] = Int(f'vote_{m}_{b}')\n\nsolver = Solver()\n\n# Each vote is either 0 (against) or 1 (for)\nfor m in members:\n    for b in bills:\n        solver.add(Or(vote[(m, b)] == 0, vote[(m, b)] == 1))\n\n# CONSTRAINTS\n\n# Each member votes for at least one bill and against at least one bill\nfor m in members:\n    votes_for = Sum([vote[(m, b)] for b in bills])\n    solver.add(votes_for >= 1)\n    solver.add(votes_for <= 2)  # since 3 votes total, at least one against means at most 2 for\n\n# Exactly two members vote for the recreation bill\nrec_for = Sum([vote[(m, 'Recreation')] for m in members])\nsolver.add(rec_for == 2)\n\n# Exactly one member votes for the school bill\nschool_for = Sum([vote[(m, 'School')] for m in members])\nsolver.add(school_for == 1)\n\n# Exactly one member votes for the tax bill\ntax_for = Sum([vote[(m, 'Tax')] for m in members])\nsolver.add(tax_for == 1)\n\n# Fu votes for the recreation bill and against the school bill\nsolver.add(vote[('Fu', 'Recreation')] == 1)\nsolver.add(vote[('Fu', 'School')] == 0)\n\n# Gianola votes against the recreation bill\nsolver.add(vote[('Gianola', 'Recreation')] == 0)\n\n# Herstein votes against the tax bill\nsolver.add(vote[('Herstein', 'Tax')] == 0)\n\n# Gianola votes for exactly two of the three bills\ngianola_votes_for = Sum([vote[('Gianola', b)] for b in bills])\nsolver.add(gianola_votes_for == 2)\n\n# OPTION CHECKING\n\noptions = {\n    'A': vote[('Fu', 'Tax')] == 1,\n    'B': vote[('Gianola', 'Recreation')] == 1,\n    'C': vote[('Gianola', 'School')] == 1,\n    'D': vote[('Gianola', 'Tax')] == 0,\n    'E': vote[('Herstein', 'School')] == 1,\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Morrisville's town council has exactly three members: Fu, Gianola, and Herstein. During one week, the council members vote on exactly three bills: a recreation bill, a school bill, and a tax bill. Each council member votes either for or against each bill. The following is known: Each member of the council votes for at least one of the bills and against at least one of the bills. Exactly two members of the council vote for the recreation bill. Exactly one member of the council votes for the school bill. Exactly one member of the council votes for the tax bill. Fu votes for the recreation bill and against the school bill. Gianola votes against the recreation bill. Herstein votes against the tax bill.\n\nIf one of the members of the council votes against exactly the same bills as does another member of the council, then which one of the following statements must be true?\n\nOptions:\n(A) Fu votes for the tax bill.\n(B) Gianola votes for the recreation bill.\n(C) Gianola votes against the school bill.\n(D) Gianola votes for exactly one bill\n(E) Herstein votes for exactly one bill.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['Fu', 'Gianola', 'Herstein']\nbills = ['Recreation', 'School', 'Tax']\n\n# Create vote variables: vote[m][b] = 1 if member m votes FOR bill b, else 0 (AGAINST)\nvote = {m: {b: Int(f'vote_{m}_{b}') for b in bills} for m in members}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each vote is either 0 (against) or 1 (for)\nfor m in members:\n    for b in bills:\n        solver.add(Or(vote[m][b] == 0, vote[m][b] == 1))\n\n# Each member votes for at least one bill and against at least one bill\nfor m in members:\n    sum_for = Sum([vote[m][b] for b in bills])\n    solver.add(sum_for >= 1)\n    solver.add(sum_for <= 2)  # since 3 bills total, voting for at least one and against at least one means sum_for in [1,2]\n\n# Exactly two members vote for the recreation bill\nrec_for = Sum([vote[m]['Recreation'] for m in members])\nsolver.add(rec_for == 2)\n\n# Exactly one member votes for the school bill\nschool_for = Sum([vote[m]['School'] for m in members])\nsolver.add(school_for == 1)\n\n# Exactly one member votes for the tax bill\ntax_for = Sum([vote[m]['Tax'] for m in members])\nsolver.add(tax_for == 1)\n\n# Fu votes for the recreation bill and against the school bill\nsolver.add(vote['Fu']['Recreation'] == 1)\nsolver.add(vote['Fu']['School'] == 0)\n\n# Gianola votes against the recreation bill\nsolver.add(vote['Gianola']['Recreation'] == 0)\n\n# Herstein votes against the tax bill\nsolver.add(vote['Herstein']['Tax'] == 0)\n\n# OPTION CHECKING\n\n# We want to find which option must be true if one member votes against exactly the same bills as another member.\n# That means: For some pair of distinct members, the sets of bills they vote AGAINST are identical.\n# Since vote is 1 for FOR and 0 for AGAINST, voting against bills is represented by vote == 0.\n# So for members m1 and m2, for all bills b: vote[m1][b] == vote[m2][b] or vote[m1][b] != vote[m2][b].\n# We want to assert that there exists a pair of members with identical AGAINST votes:\n# For all bills b, (vote[m1][b] == 0) iff (vote[m2][b] == 0)\n# Equivalently, vote[m1][b] == vote[m2][b] for all b.\n\n# We will add the constraint that there exists a pair of distinct members with identical votes (thus identical AGAINST votes as well),\n# because if they vote the same FOR bills, they vote the same AGAINST bills.\n\n# So add constraint: Or(\n#   And(vote['Fu'][b] == vote['Gianola'][b] for b in bills),\n#   And(vote['Fu'][b] == vote['Herstein'][b] for b in bills),\n#   And(vote['Gianola'][b] == vote['Herstein'][b] for b in bills)\n# )\n\nidentical_votes_pairs = [\n    And([vote['Fu'][b] == vote['Gianola'][b] for b in bills]),\n    And([vote['Fu'][b] == vote['Herstein'][b] for b in bills]),\n    And([vote['Gianola'][b] == vote['Herstein'][b] for b in bills])\n]\n\nsolver.add(Or(identical_votes_pairs))\n\n# Define options as constraints to check which must be true\n\noptions = {\n    'A': vote['Fu']['Tax'] == 1,\n    'B': vote['Gianola']['Recreation'] == 1,\n    'C': vote['Gianola']['School'] == 0,\n    'D': Sum([vote['Gianola'][b] for b in bills]) == 1,\n    'E': Sum([vote['Herstein'][b] for b in bills]) == 1\n}\n\n# For each option, check if the negation is satisfiable with the constraints.\n# The correct option is the one whose negation is unsatisfiable (i.e., the option must be true).\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(Not(options[letter]))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.\n\nIf exactly four bills are paid on Wednesday, then those four bills could be\n\nOptions:\n(A) 1, 3, 4, and 6\n(B) 1, 3, 5, and 6\n(C) 2, 4, 5, and 7\n(D) 3, 4, 5, and 7\n(E) 3, 4, 6, and 7",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbills = [1, 2, 3, 4, 5, 6, 7]\ndays = ['Wednesday', 'Thursday']\n# Map days to integers: 0 for Wednesday, 1 for Thursday\nWED = 0\nTHU = 1\n\n# Create variables: bill_day[bill] = day bill is paid (0 or 1)\nbill_day = {}\nfor b in bills:\n    bill_day[b] = Int(f'bill_{b}_day')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each bill is paid either Wednesday or Thursday\nfor b in bills:\n    solver.add(Or(bill_day[b] == WED, bill_day[b] == THU))\n\n# Either 3 or 4 bills must be paid on Wednesday\nwednesday_count = Sum([If(bill_day[b] == WED, 1, 0) for b in bills])\nsolver.add(Or(wednesday_count == 3, wednesday_count == 4))\n\n# Bill 1 cannot be paid on the same day as bill 5\nsolver.add(bill_day[1] != bill_day[5])\n\n# Bill 2 must be paid on Thursday\nsolver.add(bill_day[2] == THU)\n\n# Bill 4 must be paid on the same day as bill 7\nsolver.add(bill_day[4] == bill_day[7])\n\n# If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday\nsolver.add(Implies(bill_day[6] == WED, bill_day[7] == THU))\n\n# OPTION CHECKING\noptions = {\n    'A': [1, 3, 4, 6],\n    'B': [1, 3, 5, 6],\n    'C': [2, 4, 5, 7],\n    'D': [3, 4, 5, 7],\n    'E': [3, 4, 6, 7]\n}\n\nfor letter, weds_bills in options.items():\n    solver.push()\n    # Add constraint that exactly these four bills are paid on Wednesday\n    # So for each bill in weds_bills, day == WED\n    # For bills not in weds_bills, day == THU\n    for b in bills:\n        if b in weds_bills:\n            solver.add(bill_day[b] == WED)\n        else:\n            solver.add(bill_day[b] == THU)\n    # Also enforce that number of bills on Wednesday is exactly 4 (already implied)\n    solver.add(wednesday_count == 4)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.\n\nWhich one of the following is a complete and accurate list of the bills any one of which could be among the bills paid on Wednesday?\n\nOptions:\n(A) 3, 5, and 6\n(B) 1, 3, 4, 6, and 7\n(C) 1, 3, 4, 5, 6, and 7\n(D) 2, 3, 4, 5, 6, and 7\n(E) 1, 2, 3, 4, 5, 6, and 7",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbills = [1, 2, 3, 4, 5, 6, 7]\n# 0 for Wednesday, 1 for Thursday\npay_day = {b: Int(f\"bill{b}\") for b in bills}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each bill is either paid on Wednesday (0) or Thursday (1)\nfor b in bills:\n    solver.add(Or(pay_day[b] == 0, pay_day[b] == 1))\n\n# Either 3 or 4 bills paid on Wednesday\nnum_wed = Sum([If(pay_day[b] == 0, 1, 0) for b in bills])\nsolver.add(Or(num_wed == 3, num_wed == 4))\n\n# Bill 1 and Bill 5 not on same day\nsolver.add(pay_day[1] != pay_day[5])\n\n# Bill 2 must be paid on Thursday\nsolver.add(pay_day[2] == 1)\n\n# Bill 4 and Bill 7 on same day\nsolver.add(pay_day[4] == pay_day[7])\n\n# If Bill 6 on Wednesday, Bill 7 on Thursday\nsolver.add(Implies(pay_day[6] == 0, pay_day[7] == 1))\n\n# OPTION CHECKING\n\noptions = {\n    'A': [3, 5, 6],\n    'B': [1, 3, 4, 6, 7],\n    'C': [1, 3, 4, 5, 6, 7],\n    'D': [2, 3, 4, 5, 6, 7],\n    'E': [1, 2, 3, 4, 5, 6, 7]\n}\n\n# We want to find which option is the complete and accurate list of bills\n# that could be among those paid on Wednesday.\n\n# For each option, check if the set of bills that can be on Wednesday exactly matches the option list.\n\n# First, find all bills that can be paid on Wednesday in any solution\n\n# We'll find for each bill if there exists a solution where it is paid on Wednesday\n\nbills_that_can_be_wed = []\n\nfor b in bills:\n    solver.push()\n    # Add constraint bill b is paid on Wednesday\n    solver.add(pay_day[b] == 0)\n    if solver.check() == sat:\n        bills_that_can_be_wed.append(b)\n    solver.pop()\n\n# Now check each option if it matches bills_that_can_be_wed exactly\n\nfor letter, option_bills in options.items():\n    # Sort both lists and compare\n    if sorted(option_bills) == sorted(bills_that_can_be_wed):\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.\n\nIf bill 2 and bill 6 are paid on different days from each other, which one of the following must be true?\n\nOptions:\n(A) Exactly three bills are paid on Wednesday.\n(B) Exactly three bills are paid on Thursday.\n(C) Bill 1 is paid on the same day as bill 4.\n(D) Bill 2 is paid on the same day as bill 3.\n(E) Bill 5 is paid on the same day as bill 7.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbills = [1, 2, 3, 4, 5, 6, 7]\n# Days: 0 = Wednesday, 1 = Thursday\nWED = 0\nTHU = 1\n\n# Create variables: day[bill] = 0 or 1\nday = {}\nfor b in bills:\n    day[b] = Int(f'day_{b}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each bill is paid on Wednesday or Thursday\nfor b in bills:\n    solver.add(Or(day[b] == WED, day[b] == THU))\n\n# Either 3 or 4 bills are paid on Wednesday\nnum_wed = Sum([If(day[b] == WED, 1, 0) for b in bills])\nsolver.add(Or(num_wed == 3, num_wed == 4))\n\n# Bill 1 cannot be paid on the same day as bill 5\nsolver.add(day[1] != day[5])\n\n# Bill 2 must be paid on Thursday\nsolver.add(day[2] == THU)\n\n# Bill 4 must be paid on the same day as bill 7\nsolver.add(day[4] == day[7])\n\n# If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday\nsolver.add(Implies(day[6] == WED, day[7] == THU))\n\n# Additional condition: Bill 2 and bill 6 are paid on different days\nsolver.add(day[2] != day[6])\n\n# OPTION CHECKING\n# Options:\n# (A) Exactly three bills are paid on Wednesday.\n# (B) Exactly three bills are paid on Thursday.\n# (C) Bill 1 is paid on the same day as bill 4.\n# (D) Bill 2 is paid on the same day as bill 3.\n# (E) Bill 5 is paid on the same day as bill 7.\n\noptions = [\n    num_wed == 3,\n    Sum([If(day[b] == THU, 1, 0) for b in bills]) == 3,\n    day[1] == day[4],\n    day[2] == day[3],\n    day[5] == day[7],\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add negation of the option to see if it's always true\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.\n\nIf bill 6 is paid on Wednesday, which one of the following bills must also be paid on Wednesday?\n\nOptions:\n(A) 1\n(B) 3\n(C) 4\n(D) 5\n(E) 7",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbills = [1, 2, 3, 4, 5, 6, 7]\ndays = ['Wednesday', 'Thursday']\n\n# Create Z3 Int variables for each bill: 0 for Wednesday, 1 for Thursday\nbill_day = {b: Int(f'bill_{b}_day') for b in bills}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each bill is either 0 (Wednesday) or 1 (Thursday)\nfor b in bills:\n    solver.add(Or(bill_day[b] == 0, bill_day[b] == 1))\n\n# Exactly 3 or 4 bills paid on Wednesday\nwednesday_count = Sum([If(bill_day[b] == 0, 1, 0) for b in bills])\nsolver.add(Or(wednesday_count == 3, wednesday_count == 4))\n\n# Bill 1 not on the same day as bill 5\nsolver.add(bill_day[1] != bill_day[5])\n\n# Bill 2 must be paid on Thursday\nsolver.add(bill_day[2] == 1)\n\n# Bill 4 must be paid on the same day as bill 7\nsolver.add(bill_day[4] == bill_day[7])\n\n# If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday\nsolver.add(Implies(bill_day[6] == 0, bill_day[7] == 1))\n\n# OPTION CHECKING\n# Condition: bill 6 is paid on Wednesday\nsolver.add(bill_day[6] == 0)\n\noptions = {\n    'A': 1,\n    'B': 3,\n    'C': 4,\n    'D': 5,\n    'E': 7\n}\n\nfor letter, b in options.items():\n    solver.push()\n    # Add constraint that the bill b is NOT paid on Wednesday (i.e., day != 0)\n    solver.add(bill_day[b] != 0)\n    if solver.check() == unsat:\n        # If unsat, bill b must be paid on Wednesday\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.\n\nIf bill 4 is paid on Thursday, which one of the following is a pair of bills that could also be paid on Thursday?\n\nOptions:\n(A) 1 and 5\n(B) 1 and 7\n(C) 3 and 5\n(D) 3 and 6\n(E) 6 and 7",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbills = [1, 2, 3, 4, 5, 6, 7]\ndays = ['Wednesday', 'Thursday']\n\n# Map days to indices for Z3 variables\nday_indices = {'Wednesday': 0, 'Thursday': 1}\n\n# Create Z3 variables: bill_day[bill] = 0 if Wednesday, 1 if Thursday\nbill_day = {}\nfor bill in bills:\n    bill_day[bill] = Int(f'bill_{bill}_day')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each bill is paid either Wednesday (0) or Thursday (1)\nfor bill in bills:\n    solver.add(And(bill_day[bill] >= 0, bill_day[bill] <= 1))\n\n# Either three or four bills are paid on Wednesday, rest on Thursday\nnum_wednesday = Sum([If(bill_day[bill] == day_indices['Wednesday'], 1, 0) for bill in bills])\nsolver.add(Or(num_wednesday == 3, num_wednesday == 4))\n\n# Bill 1 cannot be paid on the same day as bill 5\nsolver.add(bill_day[1] != bill_day[5])\n\n# Bill 2 must be paid on Thursday\nsolver.add(bill_day[2] == day_indices['Thursday'])\n\n# Bill 4 must be paid on the same day as bill 7\nsolver.add(bill_day[4] == bill_day[7])\n\n# If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday\ncond_6_wed = bill_day[6] == day_indices['Wednesday']\ncond_7_thu = bill_day[7] == day_indices['Thursday']\nsolver.add(Implies(cond_6_wed, cond_7_thu))\n\n# Given condition: Bill 4 is paid on Thursday\nsolver.add(bill_day[4] == day_indices['Thursday'])\n\n# OPTION CHECKING\noptions = {\n    'A': (1, 5),\n    'B': (1, 7),\n    'C': (3, 5),\n    'D': (3, 6),\n    'E': (6, 7)\n}\n\nfor option_letter, (bill_a, bill_b) in options.items():\n    solver.push()\n    # Add constraint that both bills in the pair are paid on Thursday\n    solver.add(bill_day[bill_a] == day_indices['Thursday'])\n    solver.add(bill_day[bill_b] == day_indices['Thursday'])\n    if solver.check() == sat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "On a Tuesday, an accountant has exactly seven bills—numbered 1 through 7—to pay by Thursday of the same week. The accountant will pay each bill only once according to the following rules: Either three or four of the seven bills must be paid on Wednesday, the rest on Thursday. Bill 1 cannot be paid on the same day as bill 5. Bill 2 must be paid on Thursday. Bill 4 must be paid on the same day as bill 7. If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday.\n\nWhich one of the following statements must be true?\n\nOptions:\n(A) If bill 2 is paid on Thursday, bill 3 is paid on Wednesday.\n(B) If bill 4 is paid on Thursday, bill 1 is paid on Wednesday.\n(C) If bill 4 is paid on Thursday, bill 3 is paid on Wednesday.\n(D) If bill 6 is paid on Thursday, bill 3 is also paid on Thursday.\n(E) If bill 6 is paid on Thursday, bill 4 is also paid on Thursday.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbills = [1, 2, 3, 4, 5, 6, 7]\n\n# Define days as integers: 0 = Wednesday, 1 = Thursday\nWED = 0\nTHU = 1\n\n# Create Z3 Int variables for each bill's payment day\npay_day = {}\nfor b in bills:\n    pay_day[b] = Int(f\"bill_{b}_day\")\n\n# List of all pay_day variables\npay_days_list = [pay_day[b] for b in bills]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each bill is paid either on Wednesday or Thursday\nfor b in bills:\n    solver.add(Or(pay_day[b] == WED, pay_day[b] == THU))\n\n# Exactly 3 or 4 bills are paid on Wednesday, rest on Thursday\nnum_wed = Sum([If(pay_day[b] == WED, 1, 0) for b in bills])\nsolver.add(Or(num_wed == 3, num_wed == 4))\n\n# Bill 1 cannot be paid on the same day as bill 5\nsolver.add(pay_day[1] != pay_day[5])\n\n# Bill 2 must be paid on Thursday\nsolver.add(pay_day[2] == THU)\n\n# Bill 4 must be paid on the same day as bill 7\nsolver.add(pay_day[4] == pay_day[7])\n\n# If bill 6 is paid on Wednesday, bill 7 must be paid on Thursday\n# This is equivalent to: If bill 6 == WED then bill 7 == THU\nsolver.add(Implies(pay_day[6] == WED, pay_day[7] == THU))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) If bill 2 is paid on Thursday, bill 3 is paid on Wednesday.\n    # Bill 2 is always Thursday, so this means: pay_day[3] == WED\n    # So check if pay_day[3] == WED must be true\n    (\"A\", pay_day[2] == THU, pay_day[3] == WED),\n\n    # (B) If bill 4 is paid on Thursday, bill 1 is paid on Wednesday.\n    (\"B\", pay_day[4] == THU, pay_day[1] == WED),\n\n    # (C) If bill 4 is paid on Thursday, bill 3 is paid on Wednesday.\n    (\"C\", pay_day[4] == THU, pay_day[3] == WED),\n\n    # (D) If bill 6 is paid on Thursday, bill 3 is also paid on Thursday.\n    (\"D\", pay_day[6] == THU, pay_day[3] == THU),\n\n    # (E) If bill 6 is paid on Thursday, bill 4 is also paid on Thursday.\n    (\"E\", pay_day[6] == THU, pay_day[4] == THU),\n]\n\nfor letter, premise, conclusion in options:\n    solver.push()\n    # Add premise\n    solver.add(premise)\n    # Add negation of conclusion to test if conclusion must be true\n    solver.add(Not(conclusion))\n    result = solver.check()\n    solver.pop()\n    # If unsat, conclusion must be true under premise\n    if result == unsat:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Two mannequins—1 and 2—will be dressed for display in outfits chosen from ten articles of clothing. Each article is in exactly one of three colors: navy, red, or yellow. There are three hats—one in each color; three jackets—one in each color; three skirts—one in each color; and one red tie. Each mannequin wears exactly one of the hats, one of the jackets, and one of the skirts. Furthermore, their outfits must meet the following restrictions: Neither mannequin wears all three colors. Each mannequin wears a hat in a different color from the jacket it wears. Mannequin 2 wears the navy skirt. Mannequin 1 wears the tie.\n\nWhich one of the following could be complete outfits for the two mannequins?\n\nOptions:\n(A) mannequin 1: navy hat, red jacket, yellow skirt, red tie mannequin 2: red hat, navy jacket, navy skirt\n(B) mannequin 1: red hat, red jacket, yellow skirt, red tie mannequin 2: yellow hat, navy jacket, navy skirt\n(C) mannequin 1: red hat, yellow jacket, red skirt, red tie mannequin 2: yellow hat, navy jacket, yellow skirt\n(D) mannequin 1: yellow hat, red jacket, yellow skirt, red tie mannequin 2: red hat, navy jacket, navy skirt\n(E) mannequin 1: yellow hat, yellow jacket, red skirt mannequin 2: red hat, navy jacket, navy skirt",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\ncolors = ['navy', 'red', 'yellow']\ncolor_index = {c: i for i, c in enumerate(colors)}\n\n# Clothing items categories and colors:\nhats = ['navy_hat', 'red_hat', 'yellow_hat']\njackets = ['navy_jacket', 'red_jacket', 'yellow_jacket']\nskirts = ['navy_skirt', 'red_skirt', 'yellow_skirt']\nties = ['red_tie']  # only one tie, red\n\n# Mannequins\nmannequins = [1, 2]\n\n# Variables: For each mannequin, the color of hat, jacket, skirt, and if mannequin 1 wears the tie (boolean)\nhat = {m: Int(f'hat_{m}') for m in mannequins}\njacket = {m: Int(f'jacket_{m}') for m in mannequins}\nskirt = {m: Int(f'skirt_{m}') for m in mannequins}\ntie = {m: Bool(f'tie_{m}') for m in mannequins}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each clothing color variable must be in [0..2] corresponding to colors navy, red, yellow\nfor m in mannequins:\n    solver.add(And(hat[m] >= 0, hat[m] < 3))\n    solver.add(And(jacket[m] >= 0, jacket[m] < 3))\n    solver.add(And(skirt[m] >= 0, skirt[m] < 3))\n\n# Each mannequin wears exactly one hat, one jacket, one skirt\n# Already modeled by variables with domain 0..2\n\n# There are exactly one hat, jacket, skirt of each color in total (one per color)\n# So hats, jackets, skirts are distinct sets of colors:\n# But since hats, jackets, skirts are separate sets, no need to enforce distinctness across categories\n# But each category has exactly one of each color, so the color indices are fixed per item\n\n# The tie is only red and only one tie exists, so only mannequin 1 can wear the tie\nsolver.add(tie[1] == True)\nsolver.add(tie[2] == False)\n\n# Mannequin 2 wears the navy skirt\nsolver.add(skirt[2] == color_index['navy'])\n\n# Neither mannequin wears all three colors\n# For each mannequin, the set of colors worn (hat, jacket, skirt, tie if worn) must not include all three colors\n\n# Function to get colors worn by mannequin m\n# Tie is always red if worn, so if tie[m] is True, add red color index (1)\ndef wears_all_three_colors(m):\n    # Collect colors worn by mannequin m\n    colors_worn = [hat[m], jacket[m], skirt[m]]\n    # If tie is worn, add red color index\n    if tie[m]:\n        # tie is red, so add color_index['red'] = 1\n        # But tie[m] is BoolRef, we can't use if in Python\n        # So model as a set of colors worn including tie if tie[m] == True\n        # We will check if all three colors are present\n        pass\n\n# To check that mannequin m does not wear all three colors:\n# The colors worn are hat[m], jacket[m], skirt[m], and if tie[m] is True, also red (1)\n# We want to assert that not all three colors (0,1,2) appear in these items\n\n# We can create boolean variables indicating if a color is worn\ndef color_worn(m, c):\n    # c in [0,1,2]\n    # Returns BoolRef if mannequin m wears color c in any item\n    hat_c = hat[m] == c\n    jacket_c = jacket[m] == c\n    skirt_c = skirt[m] == c\n    if c == color_index['red']:\n        # If tie[m] is worn, tie is red, so red is worn\n        return Or([hat_c, jacket_c, skirt_c, tie[m]])\n    else:\n        return Or([hat_c, jacket_c, skirt_c])\n\nfor m in mannequins:\n    # The mannequin does NOT wear all three colors\n    # So the sum of colors worn < 3\n    worn_color_bools = [color_worn(m, c) for c in range(3)]\n    # Sum of worn colors as integer\n    worn_colors_ints = [If(b, 1, 0) for b in worn_color_bools]\n    solver.add(Sum(worn_colors_ints) < 3)\n\n# Each mannequin wears a hat in a different color from the jacket it wears\nfor m in mannequins:\n    solver.add(hat[m] != jacket[m])\n\n# OPTION CHECKING\n\n# Define options as dictionaries of assignments\noptions = {\n    'A': {\n        1: {'hat': 'navy', 'jacket': 'red', 'skirt': 'yellow', 'tie': True},\n        2: {'hat': 'red', 'jacket': 'navy', 'skirt': 'navy', 'tie': False},\n    },\n    'B': {\n        1: {'hat': 'red', 'jacket': 'red', 'skirt': 'yellow', 'tie': True},\n        2: {'hat': 'yellow', 'jacket': 'navy', 'skirt': 'navy', 'tie': False},\n    },\n    'C': {\n        1: {'hat': 'red', 'jacket': 'yellow', 'skirt': 'red', 'tie': True},\n        2: {'hat': 'yellow', 'jacket': 'navy', 'skirt': 'yellow', 'tie': False},\n    },\n    'D': {\n        1: {'hat': 'yellow', 'jacket': 'red', 'skirt': 'yellow', 'tie': True},\n        2: {'hat': 'red', 'jacket': 'navy', 'skirt': 'navy', 'tie': False},\n    },\n    'E': {\n        1: {'hat': 'yellow', 'jacket': 'yellow', 'skirt': 'red', 'tie': False},\n        2: {'hat': 'red', 'jacket': 'navy', 'skirt': 'navy', 'tie': False},\n    },\n}\n\nfor opt_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    opt = options[opt_letter]\n    # Add option constraints\n    for m in mannequins:\n        solver.add(hat[m] == color_index[opt[m]['hat']])\n        solver.add(jacket[m] == color_index[opt[m]['jacket']])\n        solver.add(skirt[m] == color_index[opt[m]['skirt']])\n        solver.add(tie[m] == opt[m]['tie'])\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Two mannequins—1 and 2—will be dressed for display in outfits chosen from ten articles of clothing. Each article is in exactly one of three colors: navy, red, or yellow. There are three hats—one in each color; three jackets—one in each color; three skirts—one in each color; and one red tie. Each mannequin wears exactly one of the hats, one of the jackets, and one of the skirts. Furthermore, their outfits must meet the following restrictions: Neither mannequin wears all three colors. Each mannequin wears a hat in a different color from the jacket it wears. Mannequin 2 wears the navy skirt. Mannequin 1 wears the tie.\n\nIf all four of the red articles of clothing are included in the two mannequins' outfits, which one of the following must be true?\n\nOptions:\n(A) Mannequin 1 wears the red hat.\n(B) Mannequin 1 wears the yellow jacket.\n(C) Mannequin 2 wears the navy jacket.\n(D) Mannequin 1 wears no navy articles of clothing.\n(E) Mannequin 2 wears no yellow articles of clothing.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncolors = ['navy', 'red', 'yellow']\nitems = ['hat', 'jacket', 'skirt']\nmannequins = [1, 2]\n\n# Map clothing articles to their colors\n# Hats: navy_hat, red_hat, yellow_hat\n# Jackets: navy_jacket, red_jacket, yellow_jacket\n# Skirts: navy_skirt, red_skirt, yellow_skirt\n# Tie: red_tie (only one tie, red color)\n\n# We represent the color chosen for each type of clothing on each mannequin\n# Variables: color index for each clothing type per mannequin\n# For skirts, mannequin 2 wears navy skirt (fixed)\n# For mannequin 1, skirt color is variable but must be one of the three colors\n\n# Create Z3 Int variables for each clothing type per mannequin\nhat = {m: Int(f'hat_{m}') for m in mannequins}\njacket = {m: Int(f'jacket_{m}') for m in mannequins}\nskirt = {m: Int(f'skirt_{m}') for m in mannequins}\ntie_worn_by_1 = Bool('tie_worn_by_1')  # Mannequin 1 wears the tie (fixed True)\n\n# Since tie is only worn by mannequin 1, and tie is red\n# The tie counts as a red article for mannequin 1\n\n# We will model the tie as an extra red article worn by mannequin 1\n\n# The problem states:\n# - Each mannequin wears exactly one hat, jacket, skirt\n# - Mannequin 2 wears navy skirt (color index 0)\n# - Mannequin 1 wears the tie (red)\n# - Neither mannequin wears all three colors\n# - Each mannequin wears a hat in a different color from the jacket it wears\n# - All four red articles are included in the two mannequins' outfits\n\n# The four red articles are:\n# red_hat, red_jacket, red_skirt, red_tie\n# All must be worn between the two mannequins\n\n# Therefore, the red tie is worn by mannequin 1 (given)\n# So the other three red articles (red_hat, red_jacket, red_skirt) must be distributed between mannequins 1 and 2\n\n# We will check each option by adding the option's constraint and checking satisfiability\n\nsolver = Solver()\n\n# Constraints on color indices: 0 = navy, 1 = red, 2 = yellow\nfor m in mannequins:\n    for item_dict in [hat, jacket, skirt]:\n        solver.add(And(item_dict[m] >= 0, item_dict[m] < 3))\n\n# Mannequin 2 wears navy skirt\nsolver.add(skirt[2] == 0)  # navy = 0\n\n# Mannequin 1 wears the tie (red)\n# We represent the tie as an extra red article worn by mannequin 1, so mannequin 1 has red tie (fixed)\n\n# Neither mannequin wears all three colors\n# For each mannequin, colors worn in hat, jacket, skirt (and tie for mannequin 1)\n# must be at most two different colors\n\n# Define a function to count distinct colors worn by a mannequin\ndef distinct_colors(m):\n    colors_list = [hat[m], jacket[m], skirt[m]]\n    if m == 1:\n        # Tie is red (color 1)\n        # So include tie color in colors\n        # We will count distinct colors including tie\n        # Use a set of expressions to count distinct colors\n        # We'll create a list of expressions and count distinct values\n        # Since Z3 doesn't have a direct distinct count, we encode it manually:\n        # We'll create Bool variables for each color indicating if that color is worn\n        worn_red = Or([hat[m] == 1, jacket[m] == 1, skirt[m] == 1, True])  # tie is red, so always True\n        worn_navy = Or([hat[m] == 0, jacket[m] == 0, skirt[m] == 0])\n        worn_yellow = Or([hat[m] == 2, jacket[m] == 2, skirt[m] == 2])\n        # Count how many of worn_red, worn_navy, worn_yellow are True\n        # Sum of these Bool values <= 2\n        # We will return these Bool expressions\n        return [worn_red, worn_navy, worn_yellow]\n    else:\n        # Mannequin 2 does not wear the tie\n        worn_red = Or([hat[m] == 1, jacket[m] == 1, skirt[m] == 1])\n        worn_navy = Or([hat[m] == 0, jacket[m] == 0, skirt[m] == 0])\n        worn_yellow = Or([hat[m] == 2, jacket[m] == 2, skirt[m] == 2])\n        return [worn_red, worn_navy, worn_yellow]\n\n# Add constraints that each mannequin wears at most two colors\nfor m in mannequins:\n    worn_colors = distinct_colors(m)\n    # Sum of worn_colors (Bool) <= 2\n    # Convert Bools to Ints for sum\n    worn_ints = [If(c, 1, 0) for c in worn_colors]\n    solver.add(Sum(worn_ints) <= 2)\n\n# Each mannequin wears a hat in a different color from the jacket it wears\nfor m in mannequins:\n    solver.add(hat[m] != jacket[m])\n\n# All four red articles are included in the two mannequins' outfits\n# The four red articles: red_hat, red_jacket, red_skirt, red_tie\n# Red tie is worn by mannequin 1 (given)\n# The other three red articles must be worn by mannequins 1 and 2 combined\n\n# Let's define Bool variables indicating if a red article is worn by mannequin 1 or 2\nred_hat_1 = hat[1] == 1\nred_hat_2 = hat[2] == 1\nred_jacket_1 = jacket[1] == 1\nred_jacket_2 = jacket[2] == 1\nred_skirt_1 = skirt[1] == 1\nred_skirt_2 = skirt[2] == 1\n\n# The red articles red_hat, red_jacket, red_skirt must be worn by one of the mannequins\n# So the sum of red articles worn by mannequin 1 and 2 for each category is exactly 1\nsolver.add(Or([red_hat_1, red_hat_2]))\nsolver.add(Or([red_jacket_1, red_jacket_2]))\nsolver.add(Or([red_skirt_1, red_skirt_2]))\n\n# Also, since there is only one red article per category, the articles cannot be worn by both mannequins simultaneously\nsolver.add(Not(And(red_hat_1, red_hat_2)))\nsolver.add(Not(And(red_jacket_1, red_jacket_2)))\nsolver.add(Not(And(red_skirt_1, red_skirt_2)))\n\n# Each mannequin wears exactly one hat, jacket, skirt (already ensured by variable domains)\n\n# Now, to check each option, we add the option constraint and check satisfiability\n\noptions = {\n    'A': hat[1] == 1,           # Mannequin 1 wears the red hat\n    'B': jacket[1] == 2,        # Mannequin 1 wears the yellow jacket\n    'C': jacket[2] == 0,        # Mannequin 2 wears the navy jacket\n    'D': And(hat[1] != 0, jacket[1] != 0, skirt[1] != 0),  # Mannequin 1 wears no navy articles\n    'E': And(hat[2] != 2, jacket[2] != 2, skirt[2] != 2),  # Mannequin 2 wears no yellow articles\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        # Check if the negation is unsat (must be true)\n        solver.pop()\n    else:\n        # If cond is unsat, then option cannot be true\n        solver.pop()\n        continue\n    # Now check if the negation is unsat (i.e., cond must be true)\n    solver.push()\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.\n\nWhich one of the following must be true?\n\nOptions:\n(A) The French award is presented at some time before the Japanese award is presented.\n(B) The French award is presented at some time before the Swahili award is presented.\n(C) The German award is presented at some time before the Korean award is presented.\n(D) The German award is presented at some time before the Swahili award is presented.\n(E) The Swahili award is presented at some time before the Hebrew award is presented.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlanguages = ['French', 'German', 'Hebrew', 'Japanese', 'Korean', 'Latin', 'Swahili']\nnum_awards = len(languages)\n\n# Create a variable for each language representing its position (1 to 7)\npositions = {lang: Int(lang) for lang in languages}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each position is between 1 and 7\nfor lang in languages:\n    solver.add(And(positions[lang] >= 1, positions[lang] <= num_awards))\n\n# All positions are distinct\nsolver.add(Distinct([positions[lang] for lang in languages]))\n\n# The German award is not presented first\nsolver.add(positions['German'] != 1)\n\n# The Hebrew award is presented before the Korean award\nsolver.add(positions['Hebrew'] < positions['Korean'])\n\n# The Latin award is presented before the Japanese award\nsolver.add(positions['Latin'] < positions['Japanese'])\n\n# The French award is immediately before or after the Hebrew award\ndiff_french_hebrew = Abs(positions['French'] - positions['Hebrew'])\nsolver.add(Or(diff_french_hebrew == 1))\n\n# The Korean award is immediately before or after the Latin award\ndiff_korean_latin = Abs(positions['Korean'] - positions['Latin'])\nsolver.add(Or(diff_korean_latin == 1))\n\n# OPTION CHECKING\noptions = [\n    # (A) The French award is presented before the Japanese award\n    positions['French'] < positions['Japanese'],\n\n    # (B) The French award is presented before the Swahili award\n    positions['French'] < positions['Swahili'],\n\n    # (C) The German award is presented before the Korean award\n    positions['German'] < positions['Korean'],\n\n    # (D) The German award is presented before the Swahili award\n    positions['German'] < positions['Swahili'],\n\n    # (E) The Swahili award is presented before the Hebrew award\n    positions['Swahili'] < positions['Hebrew'],\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))  # Check if option can be false\n    if solver.check() == unsat:\n        # option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.\n\nIf the Hebrew award is presented fourth, which one of the following must be true?\n\nOptions:\n(A) The French award is presented fifth.\n(B) The German award is presented third.\n(C) The Japanese award is presented sixth.\n(D) The Korean award is presented fifth.\n(E) The Swahili award is presented first.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nawards = ['French', 'German', 'Hebrew', 'Japanese', 'Korean', 'Latin', 'Swahili']\npositions = range(1, 8)  # Positions 1 to 7\n\n# Create a Z3 Int variable for the position of each award\naward_pos = {}\nfor award in awards:\n    award_pos[award] = Int(award)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each award position is between 1 and 7\nfor award in awards:\n    solver.add(And(award_pos[award] >= 1, award_pos[award] <= 7))\n\n# All awards have distinct positions\nsolver.add(Distinct([award_pos[award] for award in awards]))\n\n# The German award is not presented first\nsolver.add(award_pos['German'] != 1)\n\n# The Hebrew award is presented before the Korean award\nsolver.add(award_pos['Hebrew'] < award_pos['Korean'])\n\n# The Latin award is presented before the Japanese award\nsolver.add(award_pos['Latin'] < award_pos['Japanese'])\n\n# The French award is presented immediately before or immediately after the Hebrew award\ndiff_french_hebrew = Abs(award_pos['French'] - award_pos['Hebrew'])\nsolver.add(Or(diff_french_hebrew == 1))\n\n# The Korean award is presented immediately before or immediately after the Latin award\ndiff_korean_latin = Abs(award_pos['Korean'] - award_pos['Latin'])\nsolver.add(Or(diff_korean_latin == 1))\n\n# Hebrew award is presented fourth\nsolver.add(award_pos['Hebrew'] == 4)\n\n# OPTION CHECKING\noptions = {\n    'A': award_pos['French'] == 5,\n    'B': award_pos['German'] == 3,\n    'C': award_pos['Japanese'] == 6,\n    'D': award_pos['Korean'] == 5,\n    'E': award_pos['Swahili'] == 1\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.\n\nIf the German award is presented third, which one of the following could be true?\n\nOptions:\n(A) The French award is presented fourth.\n(B) The Japanese award is presented fifth.\n(C) The Japanese award is presented sixth.\n(D) The Korean award is presented second.\n(E) The Swahili award is presented fifth.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nawards = ['French', 'German', 'Hebrew', 'Japanese', 'Korean', 'Latin', 'Swahili']\npositions = range(1, 8)  # Positions 1 through 7\n\n# Create a dictionary mapping awards to their position variables\naward_pos = {award: Int(award) for award in awards}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each award position must be between 1 and 7\nfor award in awards:\n    solver.add(And(award_pos[award] >= 1, award_pos[award] <= 7))\n\n# All awards must have distinct positions\nsolver.add(Distinct([award_pos[award] for award in awards]))\n\n# The German award is not presented first\nsolver.add(award_pos['German'] != 1)\n\n# The Hebrew award is presented before the Korean award\nsolver.add(award_pos['Hebrew'] < award_pos['Korean'])\n\n# The Latin award is presented before the Japanese award\nsolver.add(award_pos['Latin'] < award_pos['Japanese'])\n\n# The French award is immediately before or immediately after the Hebrew award\ndiff_french_hebrew = Abs(award_pos['French'] - award_pos['Hebrew'])\nsolver.add(Or(diff_french_hebrew == 1))\n\n# The Korean award is immediately before or immediately after the Latin award\ndiff_korean_latin = Abs(award_pos['Korean'] - award_pos['Latin'])\nsolver.add(Or(diff_korean_latin == 1))\n\n# The German award is presented third (given condition)\nsolver.add(award_pos['German'] == 3)\n\n# OPTION CHECKING\noptions = [\n    ('A', award_pos['French'] == 4),\n    ('B', award_pos['Japanese'] == 5),\n    ('C', award_pos['Japanese'] == 6),\n    ('D', award_pos['Korean'] == 2),\n    ('E', award_pos['Swahili'] == 5),\n]\n\nfor letter, condition in options:\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.\n\nThe earliest that the Japanese award could be presented is\n\nOptions:\n(A) third\n(B) fourth\n(C) fifth\n(D) sixth\n(E) seventh",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlanguages = ['French', 'German', 'Hebrew', 'Japanese', 'Korean', 'Latin', 'Swahili']\nlang_idx = {lang: i for i, lang in enumerate(languages)}\n\n# Create Z3 variables for the position of each award (1 to 7)\npositions = {}\nfor lang in languages:\n    positions[lang] = Int(lang)\n    \n# CONSTRAINTS\nsolver = Solver()\n\n# Each position is between 1 and 7\nfor lang in languages:\n    solver.add(And(positions[lang] >= 1, positions[lang] <= 7))\n\n# All positions are distinct\nsolver.add(Distinct([positions[lang] for lang in languages]))\n\n# The German award is not presented first\nsolver.add(positions['German'] != 1)\n\n# The Hebrew award is presented before the Korean award\nsolver.add(positions['Hebrew'] < positions['Korean'])\n\n# The Latin award is presented before the Japanese award\nsolver.add(positions['Latin'] < positions['Japanese'])\n\n# The French award is presented immediately before or immediately after the Hebrew award\nf_before_h = positions['French'] == positions['Hebrew'] - 1\nf_after_h = positions['French'] == positions['Hebrew'] + 1\nsolver.add(Or([f_before_h, f_after_h]))\n\n# The Korean award is presented immediately before or immediately after the Latin award\nk_before_l = positions['Korean'] == positions['Latin'] - 1\nk_after_l = positions['Korean'] == positions['Latin'] + 1\nsolver.add(Or([k_before_l, k_after_l]))\n\n# OPTION CHECKING\noptions = [3, 4, 5, 6, 7]  # Possible earliest positions for Japanese award\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that Japanese award is at position opt or earlier\n    # Since we want earliest possible, we check if Japanese can be at position opt\n    solver.add(positions['Japanese'] == opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.\n\nIf the Japanese award is presented at some time before the Swahili award is presented, any of the following could be true EXCEPT:\n\nOptions:\n(A) The German award is presented immediately before the French award is presented.\n(B) The German award is presented immediately before the Japanese award is presented.\n(C) The Hebrew award is presented immediately before the Latin award is presented.\n(D) The Korean award is presented immediately before the Japanese award is presented.\n(E) The Swahili award is presented immediately before the German award is presented.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlanguages = ['French', 'German', 'Hebrew', 'Japanese', 'Korean', 'Latin', 'Swahili']\nlang_indices = {lang: i for i, lang in enumerate(languages)}\n\n# Create Z3 Int variables for the position of each award (1 through 7)\npositions = {}\nfor lang in languages:\n    positions[lang] = Int(lang)\n    \nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each position must be between 1 and 7\nfor lang in languages:\n    solver.add(And(positions[lang] >= 1, positions[lang] <= 7))\n\n# All positions are distinct\nsolver.add(Distinct([positions[lang] for lang in languages]))\n\n# The German award is not presented first\nsolver.add(positions['German'] != 1)\n\n# The Hebrew award is presented before the Korean award\nsolver.add(positions['Hebrew'] < positions['Korean'])\n\n# The Latin award is presented before the Japanese award\nsolver.add(positions['Latin'] < positions['Japanese'])\n\n# The French award is immediately before or immediately after the Hebrew award\nf_before_h = positions['French'] + 1 == positions['Hebrew']\nf_after_h = positions['French'] - 1 == positions['Hebrew']\nsolver.add(Or(f_before_h, f_after_h))\n\n# The Korean award is immediately before or immediately after the Latin award\nk_before_l = positions['Korean'] + 1 == positions['Latin']\nk_after_l = positions['Korean'] - 1 == positions['Latin']\nsolver.add(Or(k_before_l, k_after_l))\n\n# Japanese award is presented before Swahili award (given condition for the question)\nsolver.add(positions['Japanese'] < positions['Swahili'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': positions['German'] + 1 == positions['French'],\n    'B': positions['German'] + 1 == positions['Japanese'],\n    'C': positions['Hebrew'] + 1 == positions['Latin'],\n    'D': positions['Korean'] + 1 == positions['Japanese'],\n    'E': positions['Swahili'] + 1 == positions['German'],\n}\n\n# We want to find which option is NOT possible (i.e., adding the option makes the problem unsat)\nfor option_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[option_letter])\n    if solver.check() == unsat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A college dean will present seven awards for outstanding language research. The awards—one for French, one for German, one for Hebrew, one for Japanese, one for Korean, one for Latin, and one for Swahili—must be presented consecutively, one at a time, in conformity with the following constraints: The German award is not presented first. The Hebrew award is presented at some time before the Korean award is presented. The Latin award is presented at some time before the Japanese award is presented. The French award is presented either immediately before or immediately after the Hebrew award is presented. The Korean award is presented either immediately before or immediately after the Latin award is presented.\n\nThe order in which the awards are presented is completely determined if which one of the following is true?\n\nOptions:\n(A) The French award is presented immediately before the German award is presented, and the Korean award is presented immediately before the Latin award is presented.\n(B) The French award is presented immediately before the Hebrew award is presented, and the Hebrew award is presented immediately before the Korean award is presented.\n(C) The French award is presented immediately before the Latin award is presented, and the Korean award is presented immediately before the Japanese award is presented.\n(D) The German award is presented immediately before the French award is presented, and the Latin award is presented immediately before the Japanese award is presented.\n(E) The German award is presented immediately before the Korean award is presented, and the Hebrew award is presented immediately before the French award is presented.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nawards = ['French', 'German', 'Hebrew', 'Japanese', 'Korean', 'Latin', 'Swahili']\naward_indices = {award: i for i, award in enumerate(awards)}\n\n# Create Z3 Int variables for the positions of each award (1 to 7)\npositions = {award: Int(award) for award in awards}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each award position is between 1 and 7\nfor award in awards:\n    solver.add(And(positions[award] >= 1, positions[award] <= 7))\n\n# All positions are distinct\nsolver.add(Distinct([positions[award] for award in awards]))\n\n# The German award is not presented first\nsolver.add(positions['German'] != 1)\n\n# The Hebrew award is presented before the Korean award\nsolver.add(positions['Hebrew'] < positions['Korean'])\n\n# The Latin award is presented before the Japanese award\nsolver.add(positions['Latin'] < positions['Japanese'])\n\n# The French award is presented immediately before or immediately after the Hebrew award\ndiff_french_hebrew = Abs(positions['French'] - positions['Hebrew'])\nsolver.add(Or(diff_french_hebrew == 1))\n\n# The Korean award is presented immediately before or immediately after the Latin award\ndiff_korean_latin = Abs(positions['Korean'] - positions['Latin'])\nsolver.add(Or(diff_korean_latin == 1))\n\n# OPTION CHECKING\n\n# Define helper function for immediate adjacency constraints\ndef adjacency_constraint(a1, a2, before=True):\n    if before:\n        return positions[a1] + 1 == positions[a2]\n    else:\n        return positions[a2] + 1 == positions[a1]\n\noptions = [\n    # (A)\n    And(positions['French'] + 1 == positions['German'], positions['Korean'] + 1 == positions['Latin']),\n    # (B)\n    And(positions['French'] + 1 == positions['Hebrew'], positions['Hebrew'] + 1 == positions['Korean']),\n    # (C)\n    And(positions['French'] + 1 == positions['Latin'], positions['Korean'] + 1 == positions['Japanese']),\n    # (D)\n    And(positions['German'] + 1 == positions['French'], positions['Latin'] + 1 == positions['Japanese']),\n    # (E)\n    And(positions['German'] + 1 == positions['Korean'], positions['Hebrew'] + 1 == positions['French']),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    # Check if the order is uniquely determined by checking if there is exactly one solution\n    if solver.check() == sat:\n        model = solver.model()\n        # To check uniqueness, try to find a different solution\n        solver.push()\n        diff = []\n        for award in awards:\n            diff.append(positions[award] != model[positions[award]])\n        solver.add(Or(diff))\n        if solver.check() == unsat:\n            print(f\"'{chr(65 + i)}'\")\n            solver.pop()\n            solver.pop()\n            break\n        solver.pop()\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly six piano classes are given sequentially on Monday: two with more than one student and four with exactly one student. Exactly four females—Gimena, Holly, Iyanna, and Kate—and five males—Leung, Nate, Oscar, Pedro, and Saul—attend these classes. Each student attends exactly one class. The following must obtain: Iyanna and Leung together constitute one class. Pedro and exactly two others together constitute one class. Kate is the first female, but not the first student, to attend a class. Gimena's class is at some time after Iyanna's but at sometime before Pedro's. Oscar's class is at some time after Gimena's.\n\nWhich one of the following students could attend the first class?\n\nOptions:\n(A) Holly\n(B) Leung\n(C) Oscar\n(D) Pedro\n(E) Saul",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Gimena', 'Holly', 'Iyanna', 'Kate', 'Leung', 'Nate', 'Oscar', 'Pedro', 'Saul']\nfemales = ['Gimena', 'Holly', 'Iyanna', 'Kate']\nmales = ['Leung', 'Nate', 'Oscar', 'Pedro', 'Saul']\n\n# Create Int variables for each student representing their class number (1 to 6)\nclass_num = {s: Int(s) for s in students}\n\n# Each class number is between 1 and 6\nsolver = Solver()\nfor s in students:\n    solver.add(And(class_num[s] >= 1, class_num[s] <= 6))\n\n# There are exactly 6 classes, numbered 1 to 6\n# Each student attends exactly one class (already modeled by class_num)\n\n# Classes have students assigned, we need to group students by class\n# For that, create a function that returns the list of students in a given class\ndef students_in_class(c):\n    return [s for s in students]\n\n# Constraint: Two classes have more than one student, four classes have exactly one student\n# So total students = 9\n# Two classes have >1 student: so at least 2 students each in those two classes\n# Four classes have exactly 1 student each\n# Total classes = 6\n# So the classes distribution is: 2 classes with multiple students, 4 classes with exactly one student\n# We will enforce that exactly two classes have size >1 and four classes have size ==1\n\nclass_sizes = [Int(f'class_size_{i}') for i in range(1,7)]\nfor i in range(6):\n    # class_size_i is number of students in class i+1\n    # class_size_i = sum of (class_num[s] == i+1) for all s\n    count_students = [If(class_num[s] == i+1, 1, 0) for s in students]\n    solver.add(class_sizes[i] == Sum(count_students))\n\n# Exactly two classes have size > 1\ntwo_classes_gt1 = [class_sizes[i] > 1 for i in range(6)]\nsolver.add(Sum([If(cond, 1, 0) for cond in two_classes_gt1]) == 2)\n\n# Exactly four classes have size == 1\nfour_classes_eq1 = [class_sizes[i] == 1 for i in range(6)]\nsolver.add(Sum([If(cond, 1, 0) for cond in four_classes_eq1]) == 4)\n\n# Constraint: Iyanna and Leung together constitute one class\n# So they are in the same class\nsolver.add(class_num['Iyanna'] == class_num['Leung'])\n\n# Constraint: Pedro and exactly two others together constitute one class\n# So Pedro's class has exactly 3 students: Pedro + 2 others\n# So class_size of Pedro's class is 3\n# Identify Pedro's class index (1 to 6)\npedro_class = class_num['Pedro']\n# class_size[pedro_class - 1] == 3\n# Since class_size is an array indexed 0..5, and pedro_class is Int var, we need to express this\n# Use a helper constraint: class_sizes[pedro_class - 1] == 3\n# We can express this with a sum of conditions:\n# sum of (class_num[s] == pedro_class) == 3\ncount_pedro_class = [If(class_num[s] == pedro_class, 1, 0) for s in students]\nsolver.add(Sum(count_pedro_class) == 3)\n\n# Constraint: Kate is the first female, but not the first student, to attend a class\n# So Kate's class number > 1\nsolver.add(class_num['Kate'] > 1)\n# For all other females, Kate's class number < their class number\nfor f in females:\n    if f != 'Kate':\n        solver.add(class_num['Kate'] < class_num[f])\n\n# Constraint: Gimena's class is after Iyanna's but before Pedro's\nsolver.add(class_num['Gimena'] > class_num['Iyanna'])\nsolver.add(class_num['Gimena'] < class_num['Pedro'])\n\n# Constraint: Oscar's class is after Gimena's\nsolver.add(class_num['Oscar'] > class_num['Gimena'])\n\n# Constraint: Each student attends exactly one class (already modeled)\n\n# Additional constraints:\n# All class numbers must be assigned so that each student is in exactly one class (done)\n# Classes have students assigned according to constraints above\n\n# OPTION CHECKING\noptions = ['Holly', 'Leung', 'Oscar', 'Pedro', 'Saul']\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraint that the first class (class number 1) is attended by the option student\n    solver.add(class_num[option] == 1)\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly six piano classes are given sequentially on Monday: two with more than one student and four with exactly one student. Exactly four females—Gimena, Holly, Iyanna, and Kate—and five males—Leung, Nate, Oscar, Pedro, and Saul—attend these classes. Each student attends exactly one class. The following must obtain: Iyanna and Leung together constitute one class. Pedro and exactly two others together constitute one class. Kate is the first female, but not the first student, to attend a class. Gimena's class is at some time after Iyanna's but at sometime before Pedro's. Oscar's class is at some time after Gimena's.\n\nIf Oscar and Pedro do not attend the same class as each other, then which one of the following could be true?\n\nOptions:\n(A) Gimena attends the fifth class.\n(B) Holly attends the third class.\n(C) Iyanna attends the fourth class.\n(D) Nate attends the fifth class.\n(E) Saul attends the second class.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Students\nfemales = ['Gimena', 'Holly', 'Iyanna', 'Kate']\nmales = ['Leung', 'Nate', 'Oscar', 'Pedro', 'Saul']\nstudents = females + males\n\n# Classes: 6 classes numbered 1 to 6\nnum_classes = 6\nclasses = list(range(1, num_classes + 1))\n\n# Each student attends exactly one class\nstudent_class = {s: Int(s) for s in students}\n\n# Each class has either exactly 1 student or more than 1 student\n# Given: exactly six classes, exactly two have more than one student, and four have exactly one student\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each student's class is between 1 and 6\nfor s in students:\n    solver.add(And(student_class[s] >= 1, student_class[s] <= 6))\n\n# There are 6 classes total, we assign students to classes\n# We need to enforce the number of students per class:\n# Exactly 2 classes have more than one student\n# Exactly 4 classes have exactly one student\n\n# Count number of students per class\n# For each class c, count how many students assigned to it\nstudents_in_class = []\nfor c in classes:\n    in_class = [If(student_class[s] == c, 1, 0) for s in students]\n    count = Sum(in_class)\n    students_in_class.append(count)\n\n# Exactly two classes have more than one student\nmore_than_one = [If(students_in_class[c - 1] > 1, 1, 0) for c in classes]\nsolver.add(Sum(more_than_one) == 2)\n\n# Exactly four classes have exactly one student\nexactly_one = [If(students_in_class[c - 1] == 1, 1, 0) for c in classes]\nsolver.add(Sum(exactly_one) == 4)\n\n# Each student attends exactly one class (already ensured by variable domain)\n\n# Iyanna and Leung together constitute one class\n# Means Iyanna and Leung are in the same class\nsolver.add(student_class['Iyanna'] == student_class['Leung'])\n\n# Pedro and exactly two others together constitute one class\n# Pedro is in a class with exactly three students total\npedro_class = student_class['Pedro']\npedro_class_size = Sum([If(student_class[s] == pedro_class, 1, 0) for s in students])\nsolver.add(pedro_class_size == 3)\n\n# Kate is the first female, but not the first student, to attend a class\n# Kate's class number is less than any other female's class number (except herself)\n# Kate is NOT in the first class (class 1), but she is the first female to attend a class\n\n# Kate is not in the first class\nsolver.add(student_class['Kate'] != 1)\n\n# Kate's class is earlier than all other females' classes (except herself)\nfor f in females:\n    if f != 'Kate':\n        solver.add(student_class['Kate'] < student_class[f])\n\n# Gimena's class is after Iyanna's but before Pedro's\nsolver.add(student_class['Gimena'] > student_class['Iyanna'])\nsolver.add(student_class['Gimena'] < student_class['Pedro'])\n\n# Oscar's class is after Gimena's\nsolver.add(student_class['Oscar'] > student_class['Gimena'])\n\n# Additional constraint given in question:\n# Oscar and Pedro do NOT attend the same class\nsolver.add(student_class['Oscar'] != student_class['Pedro'])\n\n# OPTION CHECKING\n\n# Options:\n# (A) Gimena attends the fifth class.\n# (B) Holly attends the third class.\n# (C) Iyanna attends the fourth class.\n# (D) Nate attends the fifth class.\n# (E) Saul attends the second class.\n\noptions = [\n    ('A', student_class['Gimena'] == 5),\n    ('B', student_class['Holly'] == 3),\n    ('C', student_class['Iyanna'] == 4),\n    ('D', student_class['Nate'] == 5),\n    ('E', student_class['Saul'] == 2),\n]\n\nfor letter, cond in options:\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly six piano classes are given sequentially on Monday: two with more than one student and four with exactly one student. Exactly four females—Gimena, Holly, Iyanna, and Kate—and five males—Leung, Nate, Oscar, Pedro, and Saul—attend these classes. Each student attends exactly one class. The following must obtain: Iyanna and Leung together constitute one class. Pedro and exactly two others together constitute one class. Kate is the first female, but not the first student, to attend a class. Gimena's class is at some time after Iyanna's but at sometime before Pedro's. Oscar's class is at some time after Gimena's.\n\nSuppose the condition that Oscar attends a class after Gimena is replaced with the condition that Oscar attends a class before Gimena and after Kate. If all the other conditions remain the same, then which class must Holly attend?\n\nOptions:\n(A) the second\n(B) the third\n(C) the fourth\n(D) the fifth\n(E) the sixth",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstudents = ['Gimena', 'Holly', 'Iyanna', 'Kate', 'Leung', 'Nate', 'Oscar', 'Pedro', 'Saul']\nfemales = ['Gimena', 'Holly', 'Iyanna', 'Kate']\nmales = ['Leung', 'Nate', 'Oscar', 'Pedro', 'Saul']\nnum_classes = 6\n\n# Each student attends exactly one class (class indices 1 to 6)\nclass_of = {s: Int(s) for s in students}\n\nsolver = Solver()\n\n# Classes are numbered 1 through 6\nfor s in students:\n    solver.add(And(class_of[s] >= 1, class_of[s] <= num_classes))\n\n# There are exactly six classes held sequentially on Monday\n# Two classes have more than one student, four classes have exactly one student\n\n# We will count the number of students per class\nstudents_in_class = [Sum([If(class_of[s] == i, 1, 0) for s in students]) for i in range(1, num_classes+1)]\n\n# Two classes with more than one student\nmore_than_one = [students_in_class[i] > 1 for i in range(num_classes)]\nsolver.add(Sum([If(cond, 1, 0) for cond in more_than_one]) == 2)\n\n# Four classes with exactly one student\nexactly_one = [students_in_class[i] == 1 for i in range(num_classes)]\nsolver.add(Sum([If(cond, 1, 0) for cond in exactly_one]) == 4)\n\n# Each student attends exactly one class (already ensured by class_of variables)\n\n# Iyanna and Leung together constitute one class\n# So Iyanna and Leung are in the same class\nsolver.add(class_of['Iyanna'] == class_of['Leung'])\n\n# Pedro and exactly two others together constitute one class\n# So Pedro's class has exactly 3 students\npedro_class = class_of['Pedro']\nsolver.add(Sum([If(class_of[s] == pedro_class, 1, 0) for s in students]) == 3)\n\n# Kate is the first female, but not the first student, to attend a class\n# So Kate's class is the earliest among females\nkate_class = class_of['Kate']\n# Kate is not the first student overall (class 1)\nsolver.add(kate_class != 1)\n# For all other females, Kate's class < their class\nfor f in females:\n    if f != 'Kate':\n        solver.add(kate_class < class_of[f])\n\n# Gimena's class is at some time after Iyanna's but before Pedro's\nsolver.add(class_of['Gimena'] > class_of['Iyanna'])\nsolver.add(class_of['Gimena'] < class_of['Pedro'])\n\n# Oscar's class is at some time after Gimena's\n# REPLACED: Oscar attends a class before Gimena and after Kate\n# So Kate < Oscar < Gimena\nsolver.add(class_of['Oscar'] > class_of['Kate'])\nsolver.add(class_of['Oscar'] < class_of['Gimena'])\n\n# OPTION CHECKING\n# Check which class Holly attends\n\n# Since we want to find Holly's class, we check all options for Holly's class\noptions = [1,2,3,4,5,6]\n# The problem options are (A) second, (B) third, (C) fourth, (D) fifth, (E) sixth\noption_letters = ['A','B','C','D','E']\noption_classes = [2,3,4,5,6]\n\nfor i, c in enumerate(option_classes):\n    solver.push()\n    solver.add(class_of['Holly'] == c)\n    if solver.check() == sat:\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "This morning, a bakery makes exactly one delivery, consisting of exactly six loaves of bread. Each of the loaves is exactly one of three kinds: oatmeal, rye, or wheat, and each is either sliced or unsliced. The loaves that the bakery delivers this morning must be consistent with the following: There are at least two kinds of loaves. There are no more than three rye loaves. There is no unsliced wheat loaf. There is at least one unsliced oatmeal loaf. If two or more of the loaves are unsliced, then at least one of the unsliced loaves is rye.\n\nWhich one of the following could be a complete and accurate list of the loaves that the bakery delivers?\n\nOptions:\n(A) six unsliced oatmeal loaves\n(B) five unsliced oatmeal loaves, one sliced rye loaf\n(C) five unsliced oatmeal loaves, one unsliced wheat loaf\n(D) four unsliced oatmeal loaves, two unsliced rye loaves\n(E) four unsliced oatmeal loaves, two sliced wheat loaves",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nkinds = ['oatmeal', 'rye', 'wheat']\nslices = ['sliced', 'unsliced']\n\nnum_loaves = 6\n\n# Each loaf has a kind and a slice status\nloaf_kind = [Int(f'kind_{i}') for i in range(num_loaves)]\nloaf_slice = [Int(f'slice_{i}') for i in range(num_loaves)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each loaf kind is 0 (oatmeal), 1 (rye), or 2 (wheat)\nfor i in range(num_loaves):\n    solver.add(And(loaf_kind[i] >= 0, loaf_kind[i] < len(kinds)))\n    solver.add(And(loaf_slice[i] >= 0, loaf_slice[i] < len(slices)))\n\n# There are at least two kinds of loaves\nkinds_present = [Bool(f'kind_present_{k}') for k in range(len(kinds))]\nfor k in range(len(kinds)):\n    kind_in_loaves = [loaf_kind[i] == k for i in range(num_loaves)]\n    solver.add(kinds_present[k] == Or(kind_in_loaves))\nsolver.add(Sum([If(kinds_present[k], 1, 0) for k in range(len(kinds))]) >= 2)\n\n# No more than three rye loaves (rye is kind index 1)\nrye_count = Sum([If(loaf_kind[i] == 1, 1, 0) for i in range(num_loaves)])\nsolver.add(rye_count <= 3)\n\n# No unsliced wheat loaf (wheat is kind index 2, unsliced is slice index 1)\nfor i in range(num_loaves):\n    solver.add(Not(And(loaf_kind[i] == 2, loaf_slice[i] == 1)))\n\n# At least one unsliced oatmeal loaf (oatmeal is kind index 0, unsliced is slice index 1)\nunsliced_oatmeal = [And(loaf_kind[i] == 0, loaf_slice[i] == 1) for i in range(num_loaves)]\nsolver.add(Or(unsliced_oatmeal))\n\n# If two or more loaves are unsliced, then at least one unsliced loaf is rye (kind 1)\nunsliced_loaves = [loaf_slice[i] == 1 for i in range(num_loaves)]\nunsliced_count = Sum([If(unsliced_loaves[i], 1, 0) for i in range(num_loaves)])\n\nunsliced_rye = [And(loaf_kind[i] == 1, loaf_slice[i] == 1) for i in range(num_loaves)]\nunsliced_rye_exists = Or(unsliced_rye)\n\n# If unsliced_count >= 2 then unsliced_rye_exists\nsolver.add(Implies(unsliced_count >= 2, unsliced_rye_exists))\n\n# OPTION CHECKING\noptions = [\n    # (A) six unsliced oatmeal loaves\n    [(0,1)]*6,\n    # (B) five unsliced oatmeal loaves, one sliced rye loaf\n    [(0,1)]*5 + [(1,0)],\n    # (C) five unsliced oatmeal loaves, one unsliced wheat loaf\n    [(0,1)]*5 + [(2,1)],\n    # (D) four unsliced oatmeal loaves, two unsliced rye loaves\n    [(0,1)]*4 + [(1,1)]*2,\n    # (E) four unsliced oatmeal loaves, two sliced wheat loaves\n    [(0,1)]*4 + [(2,0)]*2\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that each loaf matches the option exactly\n    for j in range(num_loaves):\n        solver.add(loaf_kind[j] == option[j][0])\n        solver.add(loaf_slice[j] == option[j][1])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "This morning, a bakery makes exactly one delivery, consisting of exactly six loaves of bread. Each of the loaves is exactly one of three kinds: oatmeal, rye, or wheat, and each is either sliced or unsliced. The loaves that the bakery delivers this morning must be consistent with the following: There are at least two kinds of loaves. There are no more than three rye loaves. There is no unsliced wheat loaf. There is at least one unsliced oatmeal loaf. If two or more of the loaves are unsliced, then at least one of the unsliced loaves is rye.\n\nEach of the following could be a complete and accurate list of the unsliced loaves that the bakery delivers EXCEPT:\n\nOptions:\n(A) three oatmeal loaves\n(B) three oatmeal loaves, one rye loaf\n(C) two oatmeal loaves, two rye loaves\n(D) two oatmeal loaves, three rye loaves\n(E) one oatmeal loaf, one rye loaf",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nkinds = ['oatmeal', 'rye', 'wheat']\nnum_loaves = 6\n\n# For each loaf, define kind and sliced status\n# kind[i]: 0=oatmeal,1=rye,2=wheat\n# sliced[i]: 0=unsliced,1=sliced\nkind = [Int(f'kind_{i}') for i in range(num_loaves)]\nsliced = [Int(f'sliced_{i}') for i in range(num_loaves)]\n\nsolver = Solver()\n\n# Each loaf kind in [0..2]\nfor i in range(num_loaves):\n    solver.add(And(kind[i] >= 0, kind[i] < len(kinds)))\n\n# Each loaf sliced in {0,1}\nfor i in range(num_loaves):\n    solver.add(Or(sliced[i] == 0, sliced[i] == 1))\n\n# CONSTRAINTS\n\n# 1) There are at least two kinds of loaves\n# Count kinds present\nkind_present = [Bool(f'kind_present_{k}') for k in range(len(kinds))]\nfor k in range(len(kinds)):\n    # kind_present[k] is true if any loaf is of kind k\n    present_loaves = [kind[i] == k for i in range(num_loaves)]\n    solver.add(kind_present[k] == Or(present_loaves))\nsolver.add(Sum([If(kind_present[k], 1, 0) for k in range(len(kinds))]) >= 2)\n\n# 2) No more than three rye loaves\nrye_count = Sum([If(kind[i] == 1, 1, 0) for i in range(num_loaves)])\nsolver.add(rye_count <= 3)\n\n# 3) No unsliced wheat loaf\nfor i in range(num_loaves):\n    # If kind is wheat (2), sliced must be 1 (sliced)\n    solver.add(Implies(kind[i] == 2, sliced[i] == 1))\n\n# 4) At least one unsliced oatmeal loaf\nunsliced_oatmeal_count = Sum([If(And(kind[i] == 0, sliced[i] == 0), 1, 0) for i in range(num_loaves)])\nsolver.add(unsliced_oatmeal_count >= 1)\n\n# 5) If two or more loaves are unsliced, then at least one unsliced loaf is rye\nunsliced_count = Sum([If(sliced[i] == 0, 1, 0) for i in range(num_loaves)])\nunsliced_rye_count = Sum([If(And(sliced[i] == 0, kind[i] == 1), 1, 0) for i in range(num_loaves)])\nsolver.add(Implies(unsliced_count >= 2, unsliced_rye_count >= 1))\n\n# OPTION CHECKING\n\n# Each option gives a proposed complete list of unsliced loaves by kind counts\n# We check if the unsliced loaves can match that option under the constraints\n\noptions = [\n    {'oatmeal':3, 'rye':0, 'wheat':0},  # A: three oatmeal loaves\n    {'oatmeal':3, 'rye':1, 'wheat':0},  # B: three oatmeal loaves, one rye loaf\n    {'oatmeal':2, 'rye':2, 'wheat':0},  # C: two oatmeal loaves, two rye loaves\n    {'oatmeal':2, 'rye':3, 'wheat':0},  # D: two oatmeal loaves, three rye loaves\n    {'oatmeal':1, 'rye':1, 'wheat':0}   # E: one oatmeal loaf, one rye loaf\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints to force unsliced loaves to match the option exactly\n\n    # Count unsliced loaves by kind\n    unsliced_oatmeal = Sum([If(And(sliced[j]==0, kind[j]==0), 1, 0) for j in range(num_loaves)])\n    unsliced_rye = Sum([If(And(sliced[j]==0, kind[j]==1), 1, 0) for j in range(num_loaves)])\n    unsliced_wheat = Sum([If(And(sliced[j]==0, kind[j]==2), 1, 0) for j in range(num_loaves)])\n\n    # Enforce unsliced loaves counts as per option\n    solver.add(unsliced_oatmeal == option['oatmeal'])\n    solver.add(unsliced_rye == option['rye'])\n    solver.add(unsliced_wheat == option['wheat'])\n\n    # Also enforce total unsliced loaves equals sum of option values\n    total_unsliced = option['oatmeal'] + option['rye'] + option['wheat']\n    solver.add(unsliced_count == total_unsliced)\n\n    # Check if satisfiable\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        # This option cannot be a complete and accurate list of unsliced loaves\n        print(f\"'{chr(65+i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "This morning, a bakery makes exactly one delivery, consisting of exactly six loaves of bread. Each of the loaves is exactly one of three kinds: oatmeal, rye, or wheat, and each is either sliced or unsliced. The loaves that the bakery delivers this morning must be consistent with the following: There are at least two kinds of loaves. There are no more than three rye loaves. There is no unsliced wheat loaf. There is at least one unsliced oatmeal loaf. If two or more of the loaves are unsliced, then at least one of the unsliced loaves is rye.\n\nWhich one of the following statements CANNOT be true?\n\nOptions:\n(A) The only unsliced loaves are oatmeal loaves.\n(B) The only sliced loaves are rye loaves.\n(C) The only unsliced loaves are rye loaves.\n(D) The number of sliced loaves is exactly one greater than the number of sliced oatmeal loaves.\n(E) The number of unsliced loaves is exactly one greater than the number of unsliced oatmeal loaves.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nkinds = ['oatmeal', 'rye', 'wheat']\nslices = ['sliced', 'unsliced']\n\n# Variables for each loaf: kind and slice status\n# We'll represent kind as Int in [0..2], slice as Int in [0..1]\n# 0 = oatmeal, 1 = rye, 2 = wheat\n# 0 = sliced, 1 = unsliced\nloaf_kind = [Int(f'kind_{i}') for i in range(6)]\nloaf_slice = [Int(f'slice_{i}') for i in range(6)]\n\nsolver = Solver()\n\n# Each loaf kind in [0..2]\nfor i in range(6):\n    solver.add(And(loaf_kind[i] >= 0, loaf_kind[i] < 3))\n# Each loaf slice in [0..1]\nfor i in range(6):\n    solver.add(And(loaf_slice[i] >= 0, loaf_slice[i] < 2))\n\n# CONSTRAINTS\n# 1) At least two kinds of loaves\n# Collect booleans for presence of each kind\nkind_present = [Bool(f'kind_present_{k}') for k in range(3)]\nfor k in range(3):\n    presence_k = Or([loaf_kind[i] == k for i in range(6)])\n    solver.add(kind_present[k] == presence_k)\nsolver.add(Sum([If(kind_present[k], 1, 0) for k in range(3)]) >= 2)\n\n# 2) No more than three rye loaves (rye is kind=1)\nrye_count = Sum([If(loaf_kind[i] == 1, 1, 0) for i in range(6)])\nsolver.add(rye_count <= 3)\n\n# 3) No unsliced wheat loaf (wheat=2, unsliced=1)\nfor i in range(6):\n    solver.add(Not(And(loaf_kind[i] == 2, loaf_slice[i] == 1)))\n\n# 4) At least one unsliced oatmeal loaf (oatmeal=0, unsliced=1)\nunsliced_oatmeal_count = Sum([If(And(loaf_kind[i] == 0, loaf_slice[i] == 1), 1, 0) for i in range(6)])\nsolver.add(unsliced_oatmeal_count >= 1)\n\n# 5) If two or more loaves are unsliced, then at least one of the unsliced loaves is rye\nunsliced_count = Sum([If(loaf_slice[i] == 1, 1, 0) for i in range(6)])\nunsliced_rye_count = Sum([If(And(loaf_slice[i] == 1, loaf_kind[i] == 1), 1, 0) for i in range(6)])\n# If unsliced_count >= 2 then unsliced_rye_count >= 1\nunsliced_condition = Implies(unsliced_count >= 2, unsliced_rye_count >= 1)\nsolver.add(unsliced_condition)\n\n# OPTION CHECKING\n\n# We will check for each option if it can be true under the constraints.\n# If it cannot be true, print the letter and stop.\n\n# (A) The only unsliced loaves are oatmeal loaves.\n# Means: For all i, if unsliced then kind == oatmeal (0)\ndef option_A():\n    conds = []\n    for i in range(6):\n        conds.append(Implies(loaf_slice[i] == 1, loaf_kind[i] == 0))\n    return And(conds)\n\n# (B) The only sliced loaves are rye loaves.\n# For all i, if sliced then kind == rye (1)\ndef option_B():\n    conds = []\n    for i in range(6):\n        conds.append(Implies(loaf_slice[i] == 0, loaf_kind[i] == 1))\n    return And(conds)\n\n# (C) The only unsliced loaves are rye loaves.\n# For all i, if unsliced then kind == rye (1)\ndef option_C():\n    conds = []\n    for i in range(6):\n        conds.append(Implies(loaf_slice[i] == 1, loaf_kind[i] == 1))\n    return And(conds)\n\n# (D) The number of sliced loaves is exactly one greater than the number of sliced oatmeal loaves.\n# sliced count = sliced oatmeal count + 1\nsliced_count = Sum([If(loaf_slice[i] == 0, 1, 0) for i in range(6)])\nsliced_oatmeal_count = Sum([If(And(loaf_slice[i] == 0, loaf_kind[i] == 0), 1, 0) for i in range(6)])\ndef option_D():\n    return sliced_count == sliced_oatmeal_count + 1\n\n# (E) The number of unsliced loaves is exactly one greater than the number of unsliced oatmeal loaves.\n# unsliced_count = unsliced_oatmeal_count + 1\ndef option_E():\n    return unsliced_count == unsliced_oatmeal_count + 1\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\nfor i, opt_func in enumerate(options):\n    solver.push()\n    solver.add(opt_func())\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "This morning, a bakery makes exactly one delivery, consisting of exactly six loaves of bread. Each of the loaves is exactly one of three kinds: oatmeal, rye, or wheat, and each is either sliced or unsliced. The loaves that the bakery delivers this morning must be consistent with the following: There are at least two kinds of loaves. There are no more than three rye loaves. There is no unsliced wheat loaf. There is at least one unsliced oatmeal loaf. If two or more of the loaves are unsliced, then at least one of the unsliced loaves is rye.\n\nWhich one of the following statements must be true?\n\nOptions:\n(A) At least one of the loaves is rye.\n(B) At least one of the loaves is wheat.\n(C) At least one of the loaves is sliced.\n(D) No more than four oatmeal loaves are sliced.\n(E) No more than four wheat loaves are sliced.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nkinds = ['oatmeal', 'rye', 'wheat']\nslice_status = ['sliced', 'unsliced']\nnum_loaves = 6\n\n# Variables: For each loaf, kind and slice status\n# kind[i]: Int variable in [0..2] representing kind of loaf i\n# sliced[i]: Bool variable, True if sliced, False if unsliced\nkind = [Int(f'kind_{i}') for i in range(num_loaves)]\nsliced = [Bool(f'sliced_{i}') for i in range(num_loaves)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each loaf's kind is valid\nfor i in range(num_loaves):\n    solver.add(And(kind[i] >= 0, kind[i] < len(kinds)))\n\n# There are at least two kinds of loaves\n# Count how many kinds appear among the 6 loaves\n# We create Bool variables for each kind presence\nkind_present = [Bool(f'kind_present_{k}') for k in range(len(kinds))]\nfor k in range(len(kinds)):\n    # kind_present[k] is True if any loaf is of kind k\n    presence_k = [kind[i] == k for i in range(num_loaves)]\n    solver.add(kind_present[k] == Or(presence_k))\n\n# Sum of kind_present must be at least 2\nsolver.add(Sum([If(kind_present[k], 1, 0) for k in range(len(kinds))]) >= 2)\n\n# No more than three rye loaves (rye is kind 1)\nrye_count = Sum([If(kind[i] == 1, 1, 0) for i in range(num_loaves)])\nsolver.add(rye_count <= 3)\n\n# No unsliced wheat loaf (wheat is kind 2)\nfor i in range(num_loaves):\n    # If kind is wheat (2), then loaf must be sliced (sliced[i] == True)\n    solver.add(Implies(kind[i] == 2, sliced[i] == True))\n\n# At least one unsliced oatmeal loaf (oatmeal is kind 0)\nunsliced_oatmeal = [And(kind[i] == 0, sliced[i] == False) for i in range(num_loaves)]\nsolver.add(Or(unsliced_oatmeal))\n\n# If two or more loaves are unsliced, then at least one of the unsliced loaves is rye\nunsliced_loaves = [Not(sliced[i]) for i in range(num_loaves)]\nunsliced_count = Sum([If(unsliced_loaves[i], 1, 0) for i in range(num_loaves)])\n\nunsliced_rye = [And(kind[i] == 1, Not(sliced[i])) for i in range(num_loaves)]\n\n# If unsliced_count >= 2 => Or(unsliced_rye)\nsolver.add(Implies(unsliced_count >= 2, Or(unsliced_rye)))\n\n# OPTION CHECKING\n\n# Define option constraints as functions returning BoolRef\ndef option_A():\n    # (A) At least one of the loaves is rye\n    return rye_count >= 1\n\ndef option_B():\n    # (B) At least one of the loaves is wheat (kind 2)\n    wheat_count = Sum([If(kind[i] == 2, 1, 0) for i in range(num_loaves)])\n    return wheat_count >= 1\n\ndef option_C():\n    # (C) At least one of the loaves is sliced\n    sliced_count = Sum([If(sliced[i], 1, 0) for i in range(num_loaves)])\n    return sliced_count >= 1\n\ndef option_D():\n    # (D) No more than four oatmeal loaves are sliced\n    oatmeal_sliced_count = Sum([If(And(kind[i] == 0, sliced[i] == True), 1, 0) for i in range(num_loaves)])\n    return oatmeal_sliced_count <= 4\n\ndef option_E():\n    # (E) No more than four wheat loaves are sliced\n    wheat_sliced_count = Sum([If(And(kind[i] == 2, sliced[i] == True), 1, 0) for i in range(num_loaves)])\n    return wheat_sliced_count <= 4\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\n# For each option, check if the negation is satisfiable (i.e., if the option is NOT necessarily true)\n# The correct option must be true in all models satisfying the constraints,\n# so the negation is unsat.\n\nfor i, opt_func in enumerate(options):\n    solver.push()\n    # Add negation of option constraint\n    solver.add(Not(opt_func()))\n    if solver.check() == unsat:\n        # Negation unsat means option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "This morning, a bakery makes exactly one delivery, consisting of exactly six loaves of bread. Each of the loaves is exactly one of three kinds: oatmeal, rye, or wheat, and each is either sliced or unsliced. The loaves that the bakery delivers this morning must be consistent with the following: There are at least two kinds of loaves. There are no more than three rye loaves. There is no unsliced wheat loaf. There is at least one unsliced oatmeal loaf. If two or more of the loaves are unsliced, then at least one of the unsliced loaves is rye.\n\nIf the bakery delivers exactly four wheat loaves, then the bakery could also deliver\n\nOptions:\n(A) one sliced rye loaf and one unsliced rye loaf\n(B) one sliced oatmeal loaf and one unsliced oatmeal loaf\n(C) two unsliced rye loaves\n(D) two unsliced oatmeal loaves\n(E) two sliced oatmeal loaves",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nkinds = ['oatmeal', 'rye', 'wheat']\nslicings = ['sliced', 'unsliced']\n\n# For each of the 6 loaves, define kind and slicing variables\nloaf_kind = [Int(f'kind_{i}') for i in range(6)]\nloaf_slice = [Int(f'slice_{i}') for i in range(6)]\n\n# Map kinds and slicings to indices\nkind_indices = {k: i for i, k in enumerate(kinds)}\nslice_indices = {s: i for i, s in enumerate(slicings)}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each loaf kind is in [0..2]\nfor i in range(6):\n    solver.add(And(loaf_kind[i] >= 0, loaf_kind[i] < len(kinds)))\n\n# Each loaf slicing is in [0..1]\nfor i in range(6):\n    solver.add(And(loaf_slice[i] >= 0, loaf_slice[i] < len(slicings)))\n\n# Exactly six loaves (given)\n\n# There are at least two kinds of loaves\n# Count distinct kinds present\n# Use Bool variables to indicate presence of each kind\nkind_present = [Bool(f'kind_present_{kinds[i]}') for i in range(len(kinds))]\nfor i in range(len(kinds)):\n    presence_conditions = [loaf_kind[j] == i for j in range(6)]\n    solver.add(kind_present[i] == Or(presence_conditions))\nsolver.add(Sum([If(kind_present[i], 1, 0) for i in range(len(kinds))]) >= 2)\n\n# There are no more than three rye loaves\nrye_count = Sum([If(loaf_kind[i] == kind_indices['rye'], 1, 0) for i in range(6)])\nsolver.add(rye_count <= 3)\n\n# There is no unsliced wheat loaf\nfor i in range(6):\n    solver.add(Or(loaf_kind[i] != kind_indices['wheat'], loaf_slice[i] != slice_indices['unsliced']))\n\n# There is at least one unsliced oatmeal loaf\nunsliced_oatmeal_conditions = [And(loaf_kind[i] == kind_indices['oatmeal'], loaf_slice[i] == slice_indices['unsliced']) for i in range(6)]\nsolver.add(Or(unsliced_oatmeal_conditions))\n\n# If two or more loaves are unsliced, then at least one unsliced loaf is rye\nunsliced_count = Sum([If(loaf_slice[i] == slice_indices['unsliced'], 1, 0) for i in range(6)])\nunsliced_rye_condition = Or([And(loaf_slice[i] == slice_indices['unsliced'], loaf_kind[i] == kind_indices['rye']) for i in range(6)])\nsolver.add(Implies(unsliced_count >= 2, unsliced_rye_condition))\n\n# Condition: The bakery delivers exactly four wheat loaves\nwheat_count = Sum([If(loaf_kind[i] == kind_indices['wheat'], 1, 0) for i in range(6)])\nsolver.add(wheat_count == 4)\n\n# OPTION CHECKING\n# Options:\n# (A) one sliced rye loaf and one unsliced rye loaf\n# (B) one sliced oatmeal loaf and one unsliced oatmeal loaf\n# (C) two unsliced rye loaves\n# (D) two unsliced oatmeal loaves\n# (E) two sliced oatmeal loaves\n\noptions = [\n    # A\n    [And(loaf_kind[i] == kind_indices['rye'], loaf_slice[i] == slice_indices['sliced']) for i in range(6)],\n    # B\n    [And(loaf_kind[i] == kind_indices['oatmeal'], loaf_slice[i] == slice_indices['sliced']) for i in range(6)],\n    # C\n    [And(loaf_kind[i] == kind_indices['rye'], loaf_slice[i] == slice_indices['unsliced']) for i in range(6)],\n    # D\n    [And(loaf_kind[i] == kind_indices['oatmeal'], loaf_slice[i] == slice_indices['unsliced']) for i in range(6)],\n    # E\n    [And(loaf_kind[i] == kind_indices['oatmeal'], loaf_slice[i] == slice_indices['sliced']) for i in range(6)],\n]\n\n# Since each option describes the two non-wheat loaves, we must check if the bakery could deliver\n# exactly four wheat loaves plus the two loaves described by each option.\n\n# For each option, we add constraints that exactly two loaves are non-wheat and match the option's description.\n\nfor idx, option in enumerate(options):\n    solver.push()\n    # We already have 4 wheat loaves constraint\n\n    # The two non-wheat loaves must match the option's description\n\n    # Count non-wheat loaves\n    non_wheat_indices = [i for i in range(6)]\n    # We want exactly two non-wheat loaves\n    non_wheat_loaves = [loaf_kind[i] != kind_indices['wheat'] for i in range(6)]\n    solver.add(Sum([If(non_wheat_loaves[i], 1, 0) for i in range(6)]) == 2)\n\n    # Now enforce that these two non-wheat loaves correspond exactly to the option's description:\n    # For option (A), one sliced rye and one unsliced rye\n    # For option (B), one sliced oatmeal and one unsliced oatmeal\n    # For option (C), two unsliced rye\n    # For option (D), two unsliced oatmeal\n    # For option (E), two sliced oatmeal\n\n    # Extract non-wheat loaves indices dynamically\n    # We'll find exactly two loaves that are non-wheat, and assign their kinds and slicings accordingly\n\n    # Create a list of Bool variables indicating which loaves are the non-wheat ones\n    is_non_wheat = [loaf_kind[i] != kind_indices['wheat'] for i in range(6)]\n\n    # Create a list of indices of non-wheat loaves (to be exactly 2)\n    # We don't have direct indexing in Z3, so we will enforce:\n    # Exactly two loaves satisfy is_non_wheat\n    # Their kinds and slicings match the option's description\n\n    # We can create two Int variables to represent the indices of the two non-wheat loaves\n    # But to avoid complexity, we can instead enforce that the multiset of non-wheat loaves matches the option\n\n    # Collect kinds and slicings of non-wheat loaves\n    non_wheat_kinds = []\n    non_wheat_slicings = []\n    for i in range(6):\n        # We want to enforce that if loaf i is non-wheat, then its kind and slicing are among those in the option\n        # But the option specifies exactly two loaves with specific kinds and slicings\n        # So we will count how many loaves match each kind and slicing in the option\n\n        # We'll count how many non-wheat loaves are of each kind and slicing as per option\n\n        pass\n\n    # To handle this cleanly, we will count the number of non-wheat loaves that are:\n    # For each kind and slicing in option, count how many loaves have that kind and slicing\n\n    # For option (A): one sliced rye and one unsliced rye\n    # So total 2 non-wheat loaves: one sliced rye, one unsliced rye\n\n    # For option (B): one sliced oatmeal and one unsliced oatmeal\n    # For option (C): two unsliced rye\n    # For option (D): two unsliced oatmeal\n    # For option (E): two sliced oatmeal\n\n    # We will count the number of loaves matching each kind and slicing in the option,\n    # and ensure they sum to 2 non-wheat loaves.\n\n    # Create counts for each kind and slicing pair in the option\n\n    # Define helper function to enforce counts for option\n    def enforce_option_counts(slv, option_idx):\n        if option_idx == 0:\n            # A: one sliced rye, one unsliced rye\n            count_sliced_rye = Sum([If(And(loaf_kind[i] == kind_indices['rye'], loaf_slice[i] == slice_indices['sliced']), 1, 0) for i in range(6)])\n            count_unsliced_rye = Sum([If(And(loaf_kind[i] == kind_indices['rye'], loaf_slice[i] == slice_indices['unsliced']), 1, 0) for i in range(6)])\n            slv.add(count_sliced_rye == 1)\n            slv.add(count_unsliced_rye == 1)\n        elif option_idx == 1:\n            # B: one sliced oatmeal, one unsliced oatmeal\n            count_sliced_oatmeal = Sum([If(And(loaf_kind[i] == kind_indices['oatmeal'], loaf_slice[i] == slice_indices['sliced']), 1, 0) for i in range(6)])\n            count_unsliced_oatmeal = Sum([If(And(loaf_kind[i] == kind_indices['oatmeal'], loaf_slice[i] == slice_indices['unsliced']), 1, 0) for i in range(6)])\n            slv.add(count_sliced_oatmeal == 1)\n            slv.add(count_unsliced_oatmeal == 1)\n        elif option_idx == 2:\n            # C: two unsliced rye\n            count_unsliced_rye = Sum([If(And(loaf_kind[i] == kind_indices['rye'], loaf_slice[i] == slice_indices['unsliced']), 1, 0) for i in range(6)])\n            slv.add(count_unsliced_rye == 2)\n        elif option_idx == 3:\n            # D: two unsliced oatmeal\n            count_unsliced_oatmeal = Sum([If(And(loaf_kind[i] == kind_indices['oatmeal'], loaf_slice[i] == slice_indices['unsliced']), 1, 0) for i in range(6)])\n            slv.add(count_unsliced_oatmeal == 2)\n        elif option_idx == 4:\n            # E: two sliced oatmeal\n            count_sliced_oatmeal = Sum([If(And(loaf_kind[i] == kind_indices['oatmeal'], loaf_slice[i] == slice_indices['sliced']), 1, 0) for i in range(6)])\n            slv.add(count_sliced_oatmeal == 2)\n\n    enforce_option_counts(solver, idx)\n\n    if solver.check() == sat:\n        print(f\"'{chr(65+idx)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "The six messages on an answering machine were each left by one of Fleure, Greta, Hildy, Liam, Pasquale, or Theodore, consistent with the following: At most one person left more than one message. No person left more than three messages. If the first message is Hildy's, the last is Pasquale's. If Greta left any message, Fleure and Pasquale did also. If Fleure left any message, Pasquale and Theodore did also, all of Pasquale's preceding any of Theodore's. If Pasquale left any message, Hildy and Liam did also, all of Hildy's preceding any of Liam's.\n\nWhich one of the following could be a complete and accurate list of the messages left on the answering machine, from first to last?\n\nOptions:\n(A) Fleure's, Pasquale's, Theodore's, Hildy's, Pasquale's, Liam's\n(B) Greta's, Pasquale's, Theodore's, Theodore's, Hildy's, Liam's\n(C) Hildy's, Hildy's, Hildy's, Liam's, Pasquale's, Theodore's\n(D) Pasquale's, Hildy's, Fleure's, Liam's, Theodore's, Theodore's\n(E) Pasquale's, Hildy's, Theodore's, Hildy's, Liam's, Liam's",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['Fleure', 'Greta', 'Hildy', 'Liam', 'Pasquale', 'Theodore']\nn_messages = 6\n\n# Map person to index\nperson_index = {p: i for i, p in enumerate(persons)}\n\n# Variables: message[i] is the person index who left message i (0-based)\nmessage = [Int(f'm{i}') for i in range(n_messages)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each message is left by a valid person\nfor i in range(n_messages):\n    solver.add(And(message[i] >= 0, message[i] < len(persons)))\n\n# Count messages per person\ncounts = [Int(f'count_{p}') for p in persons]\nfor i, p in enumerate(persons):\n    # counts[i] = number of messages left by person i\n    occurrences = [If(message[j] == i, 1, 0) for j in range(n_messages)]\n    solver.add(counts[i] == Sum(occurrences))\n\n# At most one person left more than one message\nmore_than_one = [counts[i] > 1 for i in range(len(persons))]\nsolver.add(Sum([If(cond, 1, 0) for cond in more_than_one]) <= 1)\n\n# No person left more than three messages\nfor i in range(len(persons)):\n    solver.add(counts[i] <= 3)\n\n# If the first message is Hildy's, the last is Pasquale's.\nfirst_is_hildy = message[0] == person_index['Hildy']\nlast_is_pasquale = message[-1] == person_index['Pasquale']\nsolver.add(Implies(first_is_hildy, last_is_pasquale))\n\n# If Greta left any message, Fleure and Pasquale did also.\ngreta_left = counts[person_index['Greta']] > 0\nfleure_left = counts[person_index['Fleure']] > 0\npasquale_left = counts[person_index['Pasquale']] > 0\nsolver.add(Implies(greta_left, And(fleure_left, pasquale_left)))\n\n# If Fleure left any message, Pasquale and Theodore did also,\n# all of Pasquale's preceding any of Theodore's.\nfleure_left = counts[person_index['Fleure']] > 0\npasquale_left = counts[person_index['Pasquale']] > 0\ntheodore_left = counts[person_index['Theodore']] > 0\nsolver.add(Implies(fleure_left, And(pasquale_left, theodore_left)))\n\n# All of Pasquale's messages precede any of Theodore's messages\n# Find all indices of Pasquale and Theodore messages\npasquale_indices = [If(message[i] == person_index['Pasquale'], i, -1) for i in range(n_messages)]\ntheodore_indices = [If(message[i] == person_index['Theodore'], i, n_messages) for i in range(n_messages)]\n\n# For all pairs (p_index, t_index), p_index < t_index\nfor pi in pasquale_indices:\n    for ti in theodore_indices:\n        solver.add(Implies(And(pi >= 0, ti < n_messages), pi < ti))\n\n# If Pasquale left any message, Hildy and Liam did also,\n# all of Hildy's preceding any of Liam's.\npasquale_left = counts[person_index['Pasquale']] > 0\nhildy_left = counts[person_index['Hildy']] > 0\nliam_left = counts[person_index['Liam']] > 0\nsolver.add(Implies(pasquale_left, And(hildy_left, liam_left)))\n\n# All of Hildy's messages precede any of Liam's messages\nhildy_indices = [If(message[i] == person_index['Hildy'], i, -1) for i in range(n_messages)]\nliam_indices = [If(message[i] == person_index['Liam'], i, n_messages) for i in range(n_messages)]\n\nfor hi in hildy_indices:\n    for li in liam_indices:\n        solver.add(Implies(And(hi >= 0, li < n_messages), hi < li))\n\n# OPTION CHECKING\noptions = [\n    ['Fleure', 'Pasquale', 'Theodore', 'Hildy', 'Pasquale', 'Liam'],\n    ['Greta', 'Pasquale', 'Theodore', 'Theodore', 'Hildy', 'Liam'],\n    ['Hildy', 'Hildy', 'Hildy', 'Liam', 'Pasquale', 'Theodore'],\n    ['Pasquale', 'Hildy', 'Fleure', 'Liam', 'Theodore', 'Theodore'],\n    ['Pasquale', 'Hildy', 'Theodore', 'Hildy', 'Liam', 'Liam']\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that message[i] == person_index(option[i])\n    for j in range(n_messages):\n        solver.add(message[j] == person_index[option[j]])\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "The six messages on an answering machine were each left by one of Fleure, Greta, Hildy, Liam, Pasquale, or Theodore, consistent with the following: At most one person left more than one message. No person left more than three messages. If the first message is Hildy's, the last is Pasquale's. If Greta left any message, Fleure and Pasquale did also. If Fleure left any message, Pasquale and Theodore did also, all of Pasquale's preceding any of Theodore's. If Pasquale left any message, Hildy and Liam did also, all of Hildy's preceding any of Liam's.\n\nThe first and last messages on the answering machine could be the first and second messages left by which one of the following?\n\nOptions:\n(A) Fleure\n(B) Hildy\n(C) Liam\n(D) Pasquale\n(E) Theodore",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Fleure', 'Greta', 'Hildy', 'Liam', 'Pasquale', 'Theodore']\nnum_messages = 6\n\n# Map person to index\nperson_idx = {p: i for i, p in enumerate(people)}\n\n# Variables: message[i] = person who left message i (0-based)\nmessage = [Int(f'm{i}') for i in range(num_messages)]\n\nsolver = Solver()\n\n# Each message must be left by one of the six people\nfor i in range(num_messages):\n    solver.add(And(message[i] >= 0, message[i] < len(people)))\n\n# Count how many messages each person left\n# Create Int variables for counts\ncounts = [Int(f'count_{p}') for p in people]\n\nfor i, p in enumerate(people):\n    # count how many times p appears in message\n    count_expr = Sum([If(message[j] == i, 1, 0) for j in range(num_messages)])\n    solver.add(counts[i] == count_expr)\n\n# At most one person left more than one message\n# Count how many people have count > 1\nmore_than_one_flags = [Bool(f'mto_{p}') for p in people]\nfor i in range(len(people)):\n    solver.add(more_than_one_flags[i] == (counts[i] > 1))\nsolver.add(Sum([If(more_than_one_flags[i], 1, 0) for i in range(len(people))]) <= 1)\n\n# No person left more than three messages\nfor i in range(len(people)):\n    solver.add(counts[i] <= 3)\n\n# If the first message is Hildy's, the last is Pasquale's.\nfirst_is_hildy = message[0] == person_idx['Hildy']\nlast_is_pasquale = message[-1] == person_idx['Pasquale']\nsolver.add(Implies(first_is_hildy, last_is_pasquale))\n\n# If Greta left any message, Fleure and Pasquale did also.\ngreta_left_any = counts[person_idx['Greta']] > 0\nfleure_left_any = counts[person_idx['Fleure']] > 0\npasquale_left_any = counts[person_idx['Pasquale']] > 0\nsolver.add(Implies(greta_left_any, And(fleure_left_any, pasquale_left_any)))\n\n# If Fleure left any message, Pasquale and Theodore did also,\n# all of Pasquale's preceding any of Theodore's.\n\nfleure_left = counts[person_idx['Fleure']] > 0\npasquale_left = counts[person_idx['Pasquale']] > 0\ntheodore_left = counts[person_idx['Theodore']] > 0\n\nsolver.add(Implies(fleure_left, And(pasquale_left, theodore_left)))\n\n# Pasquale's messages precede Theodore's messages\n# For each message index i and j, if message[i] == Pasquale and message[j] == Theodore then i < j\nfor i in range(num_messages):\n    for j in range(num_messages):\n        cond = And(message[i] == person_idx['Pasquale'], message[j] == person_idx['Theodore'])\n        solver.add(Implies(cond, i < j))\n\n# If Pasquale left any message, Hildy and Liam did also,\n# all of Hildy's preceding any of Liam's.\n\npasquale_left = counts[person_idx['Pasquale']] > 0\nhildy_left = counts[person_idx['Hildy']] > 0\nliam_left = counts[person_idx['Liam']] > 0\n\nsolver.add(Implies(pasquale_left, And(hildy_left, liam_left)))\n\n# Hildy's messages precede Liam's messages\nfor i in range(num_messages):\n    for j in range(num_messages):\n        cond = And(message[i] == person_idx['Hildy'], message[j] == person_idx['Liam'])\n        solver.add(Implies(cond, i < j))\n\n# OPTION CHECKING\n# The question: The first and last messages could be the first and second messages left by which one of the following?\n# That means: For each option person P, check if there exists an assignment such that:\n# - message[0] and message[5] are both P\n# - The message[0] is P's first message left\n# - The message[5] is P's second message left\n# Since messages are in order, the first message left by P is message[0], the second is message[5].\n# So P must have at least 2 messages, and these must be the first and last messages overall.\n# We test each option by adding constraints and checking satisfiability.\n\noptions = ['Fleure', 'Hildy', 'Liam', 'Pasquale', 'Theodore']\n\nfor i, option in enumerate(options):\n    solver.push()\n    p_idx = person_idx[option]\n\n    # First and last messages are left by option\n    solver.add(message[0] == p_idx)\n    solver.add(message[-1] == p_idx)\n\n    # Find all message indices where option left message\n    # We want to ensure message[0] is the first message left by option\n    # and message[5] is the second message left by option\n    # So option must have at least 2 messages\n    solver.add(counts[p_idx] >= 2)\n\n    # Collect indices where option left a message\n    # Since we cannot get list of indices directly, we enforce:\n    # There is exactly one message before index 5 with message == p_idx (which is at index 0)\n    # So no other messages from option between 1 and 4 inclusive\n    # Because message[0] is first message left by option\n    # and message[5] is second message left by option\n\n    # Count how many messages left by option before index 5 (excluding 5)\n    left_before_5 = Sum([If(message[j] == p_idx, 1, 0) for j in range(5)])\n    # This must be exactly 1 (the message at index 0)\n    solver.add(left_before_5 == 1)\n\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "The six messages on an answering machine were each left by one of Fleure, Greta, Hildy, Liam, Pasquale, or Theodore, consistent with the following: At most one person left more than one message. No person left more than three messages. If the first message is Hildy's, the last is Pasquale's. If Greta left any message, Fleure and Pasquale did also. If Fleure left any message, Pasquale and Theodore did also, all of Pasquale's preceding any of Theodore's. If Pasquale left any message, Hildy and Liam did also, all of Hildy's preceding any of Liam's.\n\nIf Greta left the fifth message, then which one of the following messages CANNOT have been left by Theodore?\n\nOptions:\n(A) the first message\n(B) the second message\n(C) the third message\n(D) the fourth message\n(E) the sixth message",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Fleure', 'Greta', 'Hildy', 'Liam', 'Pasquale', 'Theodore']\nnum_messages = 6\n\n# Map people to indices for easy comparison\nperson_idx = {p: i for i, p in enumerate(people)}\n\n# Variables: message[i] = index of person who left message i (0-based)\nmessages = [Int(f'msg_{i}') for i in range(num_messages)]\n\n# Create solver instance\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each message must be left by one of the six people\nfor m in messages:\n    solver.add(And(m >= 0, m < len(people)))\n\n# Count messages per person\ncounts = [Int(f'count_{p}') for p in people]\nfor i, p in enumerate(people):\n    # counts[i] = number of messages left by person i\n    count_expr = [If(messages[j] == i, 1, 0) for j in range(num_messages)]\n    solver.add(counts[i] == Sum(count_expr))\n\n# At most one person left more than one message\n# Count how many people have counts[i] > 1\nmore_than_one = [If(counts[i] > 1, 1, 0) for i in range(len(people))]\nsolver.add(Sum(more_than_one) <= 1)\n\n# No person left more than three messages\nfor c in counts:\n    solver.add(c <= 3)\n\n# Constraint: If the first message is Hildy's, the last is Pasquale's.\n# first message index 0, last message index 5\nsolver.add(Implies(messages[0] == person_idx['Hildy'], messages[5] == person_idx['Pasquale']))\n\n# Constraint: If Greta left any message, Fleure and Pasquale did also.\n# If Greta count > 0 then Fleure count > 0 and Pasquale count > 0\nsolver.add(Implies(counts[person_idx['Greta']] > 0,\n                   And(counts[person_idx['Fleure']] > 0, counts[person_idx['Pasquale']] > 0)))\n\n# Constraint: If Fleure left any message, Pasquale and Theodore did also,\n# all of Pasquale's preceding any of Theodore's.\nsolver.add(Implies(counts[person_idx['Fleure']] > 0,\n                   And(counts[person_idx['Pasquale']] > 0,\n                       counts[person_idx['Theodore']] > 0)))\n\n# Pasquale messages precede all Theodore messages:\n# For every Pasquale message index p_i and Theodore message index t_i, p_i < t_i\n# Collect indices of Pasquale and Theodore messages\npasquale_indices = [i for i in range(num_messages)]\ntheodore_indices = [i for i in range(num_messages)]\n\n# We need to encode: For all p_i with messages[p_i] == Pasquale,\n# and for all t_i with messages[t_i] == Theodore, p_i < t_i\n# Because Z3 does not support quantifiers easily here, do it by pairwise constraints:\nfor p_i in range(num_messages):\n    for t_i in range(num_messages):\n        cond = And(messages[p_i] == person_idx['Pasquale'], messages[t_i] == person_idx['Theodore'])\n        solver.add(Implies(cond, p_i < t_i))\n\n# Constraint: If Pasquale left any message, Hildy and Liam did also,\n# all of Hildy's preceding any of Liam's.\nsolver.add(Implies(counts[person_idx['Pasquale']] > 0,\n                   And(counts[person_idx['Hildy']] > 0,\n                       counts[person_idx['Liam']] > 0)))\n\n# Hildy messages precede all Liam messages\nfor h_i in range(num_messages):\n    for l_i in range(num_messages):\n        cond = And(messages[h_i] == person_idx['Hildy'], messages[l_i] == person_idx['Liam'])\n        solver.add(Implies(cond, h_i < l_i))\n\n# Additional given condition: Greta left the fifth message (index 4)\nsolver.add(messages[4] == person_idx['Greta'])\n\n# OPTION CHECKING\n# We want to find which message Theodore cannot have left given Greta left 5th message.\n\noptions = ['A', 'B', 'C', 'D', 'E']  # Corresponding to messages 1 to 6\n\n# Map option letter to message index (0-based)\noption_to_index = {\n    'A': 0,\n    'B': 1,\n    'C': 2,\n    'D': 3,\n    'E': 5,\n}\n\nfor opt in options:\n    solver.push()\n    # Add constraint that Theodore left the message corresponding to option\n    solver.add(messages[option_to_index[opt]] == person_idx['Theodore'])\n    if solver.check() == unsat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "The six messages on an answering machine were each left by one of Fleure, Greta, Hildy, Liam, Pasquale, or Theodore, consistent with the following: At most one person left more than one message. No person left more than three messages. If the first message is Hildy's, the last is Pasquale's. If Greta left any message, Fleure and Pasquale did also. If Fleure left any message, Pasquale and Theodore did also, all of Pasquale's preceding any of Theodore's. If Pasquale left any message, Hildy and Liam did also, all of Hildy's preceding any of Liam's.\n\nEach of the following must be true EXCEPT:\n\nOptions:\n(A) Liam left at least one message.\n(B) Theodore left at least one message.\n(C) Hildy left at least one message.\n(D) Exactly one person left at least two messages.\n(E) At least four people left messages.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Fleure', 'Greta', 'Hildy', 'Liam', 'Pasquale', 'Theodore']\nnum_messages = 6\n\n# Map person to index\nperson_idx = {p: i for i, p in enumerate(people)}\n\n# Variables: message_sender[i] = index of person who left message i (0-based)\nmessage_sender = [Int(f'msg_{i}') for i in range(num_messages)]\n\n# Number of messages each person left\nmessages_count = [Int(f'count_{p}') for p in people]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each message is left by exactly one of the six people\nfor i in range(num_messages):\n    solver.add(And(message_sender[i] >= 0, message_sender[i] < len(people)))\n\n# Count messages per person\nfor i, p in enumerate(people):\n    count_exprs = [If(message_sender[m] == i, 1, 0) for m in range(num_messages)]\n    solver.add(messages_count[i] == Sum(count_exprs))\n\n# At most one person left more than one message\nmore_than_one = [messages_count[i] > 1 for i in range(len(people))]\n# Count how many have more than one message\nmore_than_one_count = Int('more_than_one_count')\nsolver.add(more_than_one_count == Sum([If(cond, 1, 0) for cond in more_than_one]))\nsolver.add(more_than_one_count <= 1)\n\n# No person left more than three messages\nfor c in messages_count:\n    solver.add(c <= 3)\n\n# If the first message is Hildy's, the last is Pasquale's.\nfirst_is_hildy = message_sender[0] == person_idx['Hildy']\nlast_is_pasquale = message_sender[-1] == person_idx['Pasquale']\nsolver.add(Implies(first_is_hildy, last_is_pasquale))\n\n# If Greta left any message, Fleure and Pasquale did also.\ngreta_left = messages_count[person_idx['Greta']] > 0\nfleure_left = messages_count[person_idx['Fleure']] > 0\npasquale_left = messages_count[person_idx['Pasquale']] > 0\nsolver.add(Implies(greta_left, And(fleure_left, pasquale_left)))\n\n# If Fleure left any message, Pasquale and Theodore did also,\n# all of Pasquale's preceding any of Theodore's.\nfleure_left = messages_count[person_idx['Fleure']] > 0\npasquale_left = messages_count[person_idx['Pasquale']] > 0\ntheodore_left = messages_count[person_idx['Theodore']] > 0\nsolver.add(Implies(fleure_left, And(pasquale_left, theodore_left)))\n\n# Pasquale's messages precede Theodore's messages\n# For every Pasquale message index p_i and Theodore message index t_i: p_i < t_i\n\n# Get indices of Pasquale and Theodore messages\npasquale_positions = [i for i in range(num_messages)]\ntheodore_positions = [i for i in range(num_messages)]\n\npasquale_msgs = [Bool(f'pasquale_msg_{i}') for i in range(num_messages)]\ntheodore_msgs = [Bool(f'theodore_msg_{i}') for i in range(num_messages)]\n\nfor i in range(num_messages):\n    solver.add(pasquale_msgs[i] == (message_sender[i] == person_idx['Pasquale']))\n    solver.add(theodore_msgs[i] == (message_sender[i] == person_idx['Theodore']))\n\n# For all pairs (p_i, t_j) where p_i is Pasquale message, t_j is Theodore message: p_i < t_j\nfor i in range(num_messages):\n    for j in range(num_messages):\n        solver.add(Implies(And(pasquale_msgs[i], theodore_msgs[j]), i < j))\n\n# If Pasquale left any message, Hildy and Liam did also,\n# all of Hildy's preceding any of Liam's.\n\npasquale_left = messages_count[person_idx['Pasquale']] > 0\nhildy_left = messages_count[person_idx['Hildy']] > 0\nliam_left = messages_count[person_idx['Liam']] > 0\n\nsolver.add(Implies(pasquale_left, And(hildy_left, liam_left)))\n\n# Hildy's messages precede Liam's messages\nhildy_msgs = [Bool(f'hildy_msg_{i}') for i in range(num_messages)]\nliam_msgs = [Bool(f'liam_msg_{i}') for i in range(num_messages)]\n\nfor i in range(num_messages):\n    solver.add(hildy_msgs[i] == (message_sender[i] == person_idx['Hildy']))\n    solver.add(liam_msgs[i] == (message_sender[i] == person_idx['Liam']))\n\nfor i in range(num_messages):\n    for j in range(num_messages):\n        solver.add(Implies(And(hildy_msgs[i], liam_msgs[j]), i < j))\n\n# OPTION CHECKING\noptions = {\n    'A': messages_count[person_idx['Liam']] > 0,\n    'B': messages_count[person_idx['Theodore']] > 0,\n    'C': messages_count[person_idx['Hildy']] > 0,\n    'D': Sum([If(messages_count[i] >= 2, 1, 0) for i in range(len(people))]) == 1,\n    'E': Sum([If(messages_count[i] > 0, 1, 0) for i in range(len(people))]) >= 4,\n}\n\n# The question: Each of the following must be true EXCEPT:\n# So find which option can be false given the constraints.\n\nfor letter, cond in options.items():\n    solver.push()\n    # Add negation of condition to check if it is possibly false\n    solver.add(Not(cond))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "The six messages on an answering machine were each left by one of Fleure, Greta, Hildy, Liam, Pasquale, or Theodore, consistent with the following: At most one person left more than one message. No person left more than three messages. If the first message is Hildy's, the last is Pasquale's. If Greta left any message, Fleure and Pasquale did also. If Fleure left any message, Pasquale and Theodore did also, all of Pasquale's preceding any of Theodore's. If Pasquale left any message, Hildy and Liam did also, all of Hildy's preceding any of Liam's.\n\nIf the only message Pasquale left is the fifth message, then which one of the following could be true?\n\nOptions:\n(A) Hildy left the first message.\n(B) Theodore left exactly two messages.\n(C) Liam left exactly two messages.\n(D) Liam left the second message.\n(E) Fleure left the third and fourth messages.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\npeople = ['Fleure', 'Greta', 'Hildy', 'Liam', 'Pasquale', 'Theodore']\nnum_messages = 6\n\n# Create Int variables for message authors: message[i] = index of person who left message i\n# message indices: 0-based for 6 messages\nmessage = [Int(f'msg_{i}') for i in range(num_messages)]\n\n# Helper function: person index\ndef p(name):\n    return people.index(name)\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each message is left by one of the six people\nfor i in range(num_messages):\n    solver.add(And(message[i] >= 0, message[i] < len(people)))\n\n# Count how many messages each person left\ncounts = [Int(f'count_{person}') for person in people]\nfor i, person in enumerate(people):\n    # counts[i] = number of messages left by person i\n    count_expr = [If(message[j] == i, 1, 0) for j in range(num_messages)]\n    solver.add(counts[i] == Sum(count_expr))\n\n# At most one person left more than one message\n# Count how many people have count > 1\nmore_than_one = [If(counts[i] > 1, 1, 0) for i in range(len(people))]\nsolver.add(Sum(more_than_one) <= 1)\n\n# No person left more than 3 messages\nfor i in range(len(people)):\n    solver.add(counts[i] <= 3)\n\n# If the first message is Hildy's, the last is Pasquale's.\n# This is an implication: (message[0] == Hildy) => (message[5] == Pasquale)\nsolver.add(Implies(message[0] == p('Hildy'), message[5] == p('Pasquale')))\n\n# If Greta left any message, Fleure and Pasquale did also.\n# Meaning: if counts[Greta] > 0 then counts[Fleure] > 0 and counts[Pasquale] > 0\nsolver.add(Implies(counts[p('Greta')] > 0, And(counts[p('Fleure')] > 0, counts[p('Pasquale')] > 0)))\n\n# If Fleure left any message, Pasquale and Theodore did also,\n# and all of Pasquale's messages precede any of Theodore's.\n\n# If counts[Fleure] > 0 then counts[Pasquale] > 0 and counts[Theodore] > 0\nsolver.add(Implies(counts[p('Fleure')] > 0, And(counts[p('Pasquale')] > 0, counts[p('Theodore')] > 0)))\n\n# For all Pasquale's messages and Theodore's messages, Pasquale's messages precede Theodore's\n# Find indices of Pasquale's messages and Theodore's messages\n# For all i,j: if message[i]==Pasquale and message[j]==Theodore then i<j\nfor i in range(num_messages):\n    for j in range(num_messages):\n        cond = And(message[i] == p('Pasquale'), message[j] == p('Theodore'))\n        solver.add(Implies(cond, i < j))\n\n# If Pasquale left any message, Hildy and Liam did also,\n# and all of Hildy's messages precede any of Liam's.\n\nsolver.add(Implies(counts[p('Pasquale')] > 0, And(counts[p('Hildy')] > 0, counts[p('Liam')] > 0)))\n\nfor i in range(num_messages):\n    for j in range(num_messages):\n        cond = And(message[i] == p('Hildy'), message[j] == p('Liam'))\n        solver.add(Implies(cond, i < j))\n\n# Additional condition from the question:\n# The only message Pasquale left is the fifth message (index 4)\n# So Pasquale left exactly one message, and it is message 5 (index 4)\nsolver.add(counts[p('Pasquale')] == 1)\nsolver.add(message[4] == p('Pasquale'))\n\n# OPTION CHECKING\n\n# Options:\n# (A) Hildy left the first message.\n# (B) Theodore left exactly two messages.\n# (C) Liam left exactly two messages.\n# (D) Liam left the second message.\n# (E) Fleure left the third and fourth messages.\n\noptions = [\n    ('A', message[0] == p('Hildy')),\n    ('B', counts[p('Theodore')] == 2),\n    ('C', counts[p('Liam')] == 2),\n    ('D', message[1] == p('Liam')),\n    ('E', And(message[2] == p('Fleure'), message[3] == p('Fleure')))\n]\n\nfor letter, opt_cond in options:\n    solver.push()\n    solver.add(opt_cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly five cars—Frank's, Marquitta's, Orlando's, Taishah's, and Vinquetta's—are washed, each exactly once. The cars are washed one at a time, with each receiving exactly one kind of wash: regular, super, or premium. The following conditions must apply: The first car washed does not receive a super wash, though at least one car does. Exactly one car receives a premium wash. The second and third cars washed receive the same kind of wash as each other. Neither Orlando's nor Taishah's is washed before Vinquetta's. Marquitta's is washed before Frank's, but after Orlando's. Marquitta's and the car washed immediately before Marquitta's receive regular washes.\n\nWhich one of the following could be an accurate list of the cars in the order in which they are washed, matched with type of wash received?\n\nOptions:\n(A) Orlando's: premium; Vinquetta's: regular; Taishah's: regular; Marquitta's: regular; Frank's: super\n(B) Vinquetta's: premium; Orlando's: regular; Taishah's: regular; Marquitta's: regular; Frank's: super\n(C) Vinquetta's: regular; Marquitta's: regular; Taishah's: regular; Orlando's: super; Frank's: super\n(D) Vinquetta's: super; Orlando's: regular; Marquitta's: regular; Frank's: regular; Taishah's: super\n(E) Vinquetta's: premium; Orlando's: regular; Marquitta's: regular; Frank's: regular; Taishah's: regular",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['Frank', 'Marquitta', 'Orlando', 'Taishah', 'Vinquetta']\nwashes = ['regular', 'super', 'premium']\n\n# Create Z3 variables for the position of each car (1 to 5)\npos = {car: Int(car) for car in cars}\n\n# Create Z3 variables for the wash type of each car (0=regular,1=super,2=premium)\nwash = {car: Int(f\"wash_{car}\") for car in cars}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are between 1 and 5\nfor car in cars:\n    solver.add(And(pos[car] >= 1, pos[car] <= 5))\n\n# All positions are distinct\nsolver.add(Distinct([pos[car] for car in cars]))\n\n# Wash types are between 0 and 2\nfor car in cars:\n    solver.add(And(wash[car] >= 0, wash[car] <= 2))\n\n# The first car washed does not receive a super wash (super=1)\nfirst_car = [If(pos[car] == 1, wash[car], -1) for car in cars]\n# Extract the wash of the first car\nfirst_car_wash = Int('first_car_wash')\nsolver.add(first_car_wash == Sum([If(pos[car] == 1, wash[car], 0) for car in cars]))\nsolver.add(first_car_wash != 1)\n\n# At least one car receives a super wash\nsuper_wash_list = [wash[car] == 1 for car in cars]\nsolver.add(Or(super_wash_list))\n\n# Exactly one car receives a premium wash (premium=2)\npremium_wash_list = [wash[car] == 2 for car in cars]\nsolver.add(Sum([If(wash[car] == 2, 1, 0) for car in cars]) == 1)\n\n# The second and third cars washed receive the same kind of wash as each other\n# Find cars in position 2 and 3\ncar_pos_2 = [If(pos[car] == 2, wash[car], -1) for car in cars]\ncar_pos_3 = [If(pos[car] == 3, wash[car], -1) for car in cars]\n\nwash_pos_2 = Int('wash_pos_2')\nwash_pos_3 = Int('wash_pos_3')\n\nsolver.add(wash_pos_2 == Sum([If(pos[car] == 2, wash[car], 0) for car in cars]))\nsolver.add(wash_pos_3 == Sum([If(pos[car] == 3, wash[car], 0) for car in cars]))\nsolver.add(wash_pos_2 == wash_pos_3)\n\n# Neither Orlando's nor Taishah's is washed before Vinquetta's\nsolver.add(pos['Orlando'] > pos['Vinquetta'])\nsolver.add(pos['Taishah'] > pos['Vinquetta'])\n\n# Marquitta's is washed before Frank's, but after Orlando's\nsolver.add(pos['Marquitta'] < pos['Frank'])\nsolver.add(pos['Marquitta'] > pos['Orlando'])\n\n# Marquitta's and the car washed immediately before Marquitta's receive regular washes (regular=0)\n# Find the car washed immediately before Marquitta's\nbefore_marq_pos = Int('before_marq_pos')\nsolver.add(before_marq_pos == pos['Marquitta'] - 1)\n\n# Car washed immediately before Marquitta's\n# We create a variable for the wash of the car before Marquitta's\nwash_before_marq = Int('wash_before_marq')\n\n# Sum over all cars: if pos == before_marq_pos then wash, else 0\nsolver.add(wash_before_marq == Sum([If(pos[car] == before_marq_pos, wash[car], 0) for car in cars]))\n\n# Marquitta's wash is regular (0)\nsolver.add(wash['Marquitta'] == 0)\n\n# The car before Marquitta's wash is regular (0)\nsolver.add(wash_before_marq == 0)\n\n# OPTION CHECKING\n\noptions = [\n    # (car order list, wash types list)\n    (['Orlando', 'Vinquetta', 'Taishah', 'Marquitta', 'Frank'],\n     ['premium', 'regular', 'regular', 'regular', 'super']),\n    (['Vinquetta', 'Orlando', 'Taishah', 'Marquitta', 'Frank'],\n     ['premium', 'regular', 'regular', 'regular', 'super']),\n    (['Vinquetta', 'Marquitta', 'Taishah', 'Orlando', 'Frank'],\n     ['regular', 'regular', 'regular', 'super', 'super']),\n    (['Vinquetta', 'Orlando', 'Marquitta', 'Frank', 'Taishah'],\n     ['super', 'regular', 'regular', 'regular', 'super']),\n    (['Vinquetta', 'Orlando', 'Marquitta', 'Frank', 'Taishah'],\n     ['premium', 'regular', 'regular', 'regular', 'regular']),\n]\n\nwash_map = {w: i for i, w in enumerate(washes)}\n\nfor i, (order_list, wash_list) in enumerate(options):\n    solver.push()\n    # Add constraints for this option's order and wash assignments\n    for pos_i, car in enumerate(order_list, start=1):\n        solver.add(pos[car] == pos_i)\n    for car, w in zip(order_list, wash_list):\n        solver.add(wash[car] == wash_map[w])\n    # Check if the constraints are satisfiable with this option\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly five cars—Frank's, Marquitta's, Orlando's, Taishah's, and Vinquetta's—are washed, each exactly once. The cars are washed one at a time, with each receiving exactly one kind of wash: regular, super, or premium. The following conditions must apply: The first car washed does not receive a super wash, though at least one car does. Exactly one car receives a premium wash. The second and third cars washed receive the same kind of wash as each other. Neither Orlando's nor Taishah's is washed before Vinquetta's. Marquitta's is washed before Frank's, but after Orlando's. Marquitta's and the car washed immediately before Marquitta's receive regular washes.\n\nIf Vinquetta's car does not receive a premium wash, which one of the following must be true?\n\nOptions:\n(A) Orlando's and Vinquetta's cars receive the same kind of wash as each other.\n(B) Marquitta's and Taishah's cars receive the same kind of wash as each other.\n(C) The fourth car washed receives a premium wash.\n(D) Orlando's car is washed third.\n(E) Marquitta's car is washed fourth.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['Frank', 'Marquitta', 'Orlando', 'Taishah', 'Vinquetta']\nwashes = ['regular', 'super', 'premium']\n\n# Positions: 0 to 4 (first to fifth car washed)\npos = {car: Int(car) for car in cars}\n# Wash types for each car: 0=regular,1=super,2=premium\nwash = {car: Int(car + '_wash') for car in cars}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions constraints: all distinct and in range 0..4\nsolver.add(Distinct([pos[c] for c in cars]))\nfor c in cars:\n    solver.add(And(pos[c] >= 0, pos[c] <= 4))\n\n# Wash constraints: wash types in 0..2\nfor c in cars:\n    solver.add(And(wash[c] >= 0, wash[c] <= 2))\n\n# Exactly one car receives a premium wash\npremium_cars = [If(wash[c] == 2, 1, 0) for c in cars]\nsolver.add(Sum(premium_cars) == 1)\n\n# At least one car receives a super wash\nsuper_cars = [If(wash[c] == 1, 1, 0) for c in cars]\nsolver.add(Sum(super_cars) >= 1)\n\n# The first car washed does not receive a super wash\n# Find which car is first (pos == 0)\nfirst_car_conditions = [pos[c] == 0 for c in cars]\nfirst_car_wash_conditions = [And(pos[c] == 0, wash[c] != 1) for c in cars]\nsolver.add(Or(first_car_wash_conditions))\n\n# The second and third cars washed receive the same kind of wash as each other\n# Find cars at positions 1 and 2\nsecond_car_wash = Int('second_car_wash')\nthird_car_wash = Int('third_car_wash')\n# For each car, if pos == 1 then wash == second_car_wash, similarly for pos == 2 and third_car_wash\nsolver.add(Or([And(pos[c] == 1, wash[c] == second_car_wash) for c in cars]))\nsolver.add(Or([And(pos[c] == 2, wash[c] == third_car_wash) for c in cars]))\n# second_car_wash == third_car_wash\nsolver.add(second_car_wash == third_car_wash)\nsolver.add(And(second_car_wash >= 0, second_car_wash <= 2))\nsolver.add(And(third_car_wash >= 0, third_car_wash <= 2))\n\n# Neither Orlando's nor Taishah's is washed before Vinquetta's\nsolver.add(pos['Orlando'] >= pos['Vinquetta'])\nsolver.add(pos['Taishah'] >= pos['Vinquetta'])\n\n# Marquitta's is washed before Frank's, but after Orlando's\nsolver.add(pos['Orlando'] < pos['Marquitta'])\nsolver.add(pos['Marquitta'] < pos['Frank'])\n\n# Marquitta's and the car washed immediately before Marquitta's receive regular washes\n# The car immediately before Marquitta's has position pos['Marquitta'] - 1\n# Find the car with position pos['Marquitta'] - 1 and assert its wash is regular\n# Also Marquitta's wash is regular\nsolver.add(wash['Marquitta'] == 0)\n\n# Define a variable for the position before Marquitta's\npos_before_M = Int('pos_before_M')\nsolver.add(pos_before_M == pos['Marquitta'] - 1)\n# The car before Marquitta's must have position pos_before_M and wash regular (0)\n# We don't know which car it is, so enforce that exactly one car has position pos_before_M and wash 0\nbefore_M_conditions = [And(pos[c] == pos_before_M, wash[c] == 0) for c in cars]\nsolver.add(Or(before_M_conditions))\n\n# Vinquetta's car does not receive a premium wash (wash != 2)\nsolver.add(wash['Vinquetta'] != 2)\n\n# OPTION CHECKING\n\n# Options as functions adding the option constraint and checking satisfiability\n\ndef check_option_A():\n    # Orlando's and Vinquetta's cars receive the same kind of wash as each other.\n    return wash['Orlando'] == wash['Vinquetta']\n\ndef check_option_B():\n    # Marquitta's and Taishah's cars receive the same kind of wash as each other.\n    return wash['Marquitta'] == wash['Taishah']\n\ndef check_option_C():\n    # The fourth car washed receives a premium wash.\n    # Find car with position 3 and wash == premium (2)\n    conds = [And(pos[c] == 3, wash[c] == 2) for c in cars]\n    return Or(conds)\n\ndef check_option_D():\n    # Orlando's car is washed third (position 2)\n    return pos['Orlando'] == 2\n\ndef check_option_E():\n    # Marquitta's car is washed fourth (position 3)\n    return pos['Marquitta'] == 3\n\noptions = [check_option_A, check_option_B, check_option_C, check_option_D, check_option_E]\n\nfor i, option_func in enumerate(options):\n    solver.push()\n    solver.add(Not(option_func()))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly five cars—Frank's, Marquitta's, Orlando's, Taishah's, and Vinquetta's—are washed, each exactly once. The cars are washed one at a time, with each receiving exactly one kind of wash: regular, super, or premium. The following conditions must apply: The first car washed does not receive a super wash, though at least one car does. Exactly one car receives a premium wash. The second and third cars washed receive the same kind of wash as each other. Neither Orlando's nor Taishah's is washed before Vinquetta's. Marquitta's is washed before Frank's, but after Orlando's. Marquitta's and the car washed immediately before Marquitta's receive regular washes.\n\nIf the last two cars washed receive the same kind of wash as each other, then which one of the following could be true?\n\nOptions:\n(A) Orlando's car is washed third.\n(B) Taishah's car is washed fifth.\n(C) Taishah's car is washed before Marquitta's car.\n(D) Vinquetta's car receives a regular wash.\n(E) Exactly one car receives a super wash.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['Frank', 'Marquitta', 'Orlando', 'Taishah', 'Vinquetta']\nwashes = ['regular', 'super', 'premium']\n\n# Map cars to indices for easier handling\ncar_indices = {car: i for i, car in enumerate(cars)}\nwash_indices = {wash: i for i, wash in enumerate(washes)}\n\n# Positions: each car has a position from 1 to 5 (wash order)\npos = {car: Int(f'pos_{car}') for car in cars}\n\n# Wash type for each car: 0=regular,1=super,2=premium\nwash = {car: Int(f'wash_{car}') for car in cars}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are between 1 and 5\nfor car in cars:\n    solver.add(And(pos[car] >= 1, pos[car] <= 5))\n\n# All positions distinct (each car washed exactly once)\nsolver.add(Distinct([pos[car] for car in cars]))\n\n# Wash types are between 0 and 2\nfor car in cars:\n    solver.add(And(wash[car] >= 0, wash[car] <= 2))\n\n# 1) The first car washed does not receive a super wash\nfor car in cars:\n    is_first = pos[car] == 1\n    not_super = wash[car] != wash_indices['super']\n    solver.add(Implies(is_first, not_super))\n\n# 2) At least one car receives a super wash\nsolver.add(Or([wash[car] == wash_indices['super'] for car in cars]))\n\n# 3) Exactly one car receives a premium wash\npremium_count = Sum([If(wash[car] == wash_indices['premium'], 1, 0) for car in cars])\nsolver.add(premium_count == 1)\n\n# 4) The second and third cars washed receive the same kind of wash\n# Find cars at position 2 and 3\n# Define helper variables for washes at position 2 and 3\nwash_at_pos = [Int(f'wash_at_pos_{i}') for i in range(1,6)]\nfor i in range(1,6):\n    # The wash at position i is equal to wash[car] for the car at pos i\n    solver.add(Or([And(pos[car] == i, wash_at_pos[i-1] == wash[car]) for car in cars]))\n\nsolver.add(wash_at_pos[1] == wash_at_pos[2])  # positions 2 and 3 same wash\n\n# 5) Neither Orlando's nor Taishah's is washed before Vinquetta's\nsolver.add(pos['Orlando'] >= pos['Vinquetta'])\nsolver.add(pos['Taishah'] >= pos['Vinquetta'])\n\n# 6) Marquitta's is washed before Frank's, but after Orlando's\nsolver.add(pos['Marquitta'] < pos['Frank'])\nsolver.add(pos['Marquitta'] > pos['Orlando'])\n\n# 7) Marquitta's and the car washed immediately before Marquitta's receive regular washes\n# Find the car washed immediately before Marquitta's: position = pos[Marquitta] - 1\n# That car's wash is regular, and Marquitta's wash is regular\nsolver.add(wash['Marquitta'] == wash_indices['regular'])\n\n# Define a car immediately before Marquitta:\nimmediately_before_M = Int('immediately_before_M')  # index of car washed immediately before Marquitta\n# It must be one of the cars (other than Marquitta)\nsolver.add(Or([immediately_before_M == car_indices[car] for car in cars if car != 'Marquitta']))\n\n# Link immediately_before_M to position pos[Marquitta] -1\nfor car in cars:\n    solver.add(Implies(immediately_before_M == car_indices[car], pos[car] == pos['Marquitta'] - 1))\n\n# The wash of the immediately before car is regular\nfor car in cars:\n    solver.add(Implies(immediately_before_M == car_indices[car], wash[car] == wash_indices['regular']))\n\n# 8) The last two cars washed receive the same kind of wash as each other (given condition)\nsolver.add(wash_at_pos[3] == wash_at_pos[4])  # positions 4 and 5 same wash\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Orlando's car is washed third.\n    pos['Orlando'] == 3,\n    # (B) Taishah's car is washed fifth.\n    pos['Taishah'] == 5,\n    # (C) Taishah's car is washed before Marquitta's car.\n    pos['Taishah'] < pos['Marquitta'],\n    # (D) Vinquetta's car receives a regular wash.\n    wash['Vinquetta'] == wash_indices['regular'],\n    # (E) Exactly one car receives a super wash.\n    Sum([If(wash[car] == wash_indices['super'], 1, 0) for car in cars]) == 1\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly five cars—Frank's, Marquitta's, Orlando's, Taishah's, and Vinquetta's—are washed, each exactly once. The cars are washed one at a time, with each receiving exactly one kind of wash: regular, super, or premium. The following conditions must apply: The first car washed does not receive a super wash, though at least one car does. Exactly one car receives a premium wash. The second and third cars washed receive the same kind of wash as each other. Neither Orlando's nor Taishah's is washed before Vinquetta's. Marquitta's is washed before Frank's, but after Orlando's. Marquitta's and the car washed immediately before Marquitta's receive regular washes.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Vinquetta's car receives a premium wash.\n(B) Exactly two cars receive a super wash.\n(C) The fifth car washed receives a super wash.\n(D) The fourth car washed receives a super wash.\n(E) The second car washed receives a regular wash.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['Frank', 'Marquitta', 'Orlando', 'Taishah', 'Vinquetta']\nwash_types = ['regular', 'super', 'premium']\n\n# Create position variables: position of each car in the wash order (1 to 5)\npos = {c: Int(c) for c in cars}\n\n# Create wash type variables: wash type for each car (0=regular,1=super,2=premium)\nwash = {c: Int(c + '_wash') for c in cars}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are between 1 and 5\nfor c in cars:\n    solver.add(And(pos[c] >= 1, pos[c] <= 5))\n\n# All positions are distinct\nsolver.add(Distinct([pos[c] for c in cars]))\n\n# Wash types are between 0 and 2\nfor c in cars:\n    solver.add(And(wash[c] >= 0, wash[c] <= 2))\n\n# Exactly one car receives a premium wash (wash type 2)\npremium_count = Sum([If(wash[c] == 2, 1, 0) for c in cars])\nsolver.add(premium_count == 1)\n\n# The first car washed does not receive a super wash (wash type 1)\n# Find which car is first (pos == 1)\nfirst_car_cond = [pos[c] == 1 for c in cars]\n# For the first car, wash != super (1)\n# Use Or to find which car is first and add constraint accordingly\n# We'll add a constraint for each car: if pos[c] == 1 then wash[c] != 1\nfor c in cars:\n    solver.add(Implies(pos[c] == 1, wash[c] != 1))\n\n# At least one car receives a super wash (wash type 1)\nsuper_count = Sum([If(wash[c] == 1, 1, 0) for c in cars])\nsolver.add(super_count >= 1)\n\n# The second and third cars washed receive the same kind of wash as each other.\n# Find cars at pos 2 and pos 3\n# For all pairs of cars c1, c2: if pos[c1]==2 and pos[c2]==3 then wash[c1]==wash[c2]\nfor c1 in cars:\n    for c2 in cars:\n        solver.add(Implies(And(pos[c1] == 2, pos[c2] == 3), wash[c1] == wash[c2]))\n\n# Neither Orlando's nor Taishah's is washed before Vinquetta's.\n# pos[Orlando] >= pos[Vinquetta]\nsolver.add(pos['Orlando'] >= pos['Vinquetta'])\n# pos[Taishah] >= pos[Vinquetta]\nsolver.add(pos['Taishah'] >= pos['Vinquetta'])\n\n# Marquitta's is washed before Frank's, but after Orlando's.\nsolver.add(pos['Marquitta'] < pos['Frank'])\nsolver.add(pos['Marquitta'] > pos['Orlando'])\n\n# Marquitta's and the car washed immediately before Marquitta's receive regular washes.\n# Find the car washed immediately before Marquitta's: the car with pos == pos[Marquitta] - 1\n# For all cars c: if pos[c] == pos[Marquitta] - 1 then wash[c] == regular (0)\nfor c in cars:\n    solver.add(Implies(pos[c] == pos['Marquitta'] - 1, wash[c] == 0))\n# Marquitta's wash is regular (0)\nsolver.add(wash['Marquitta'] == 0)\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Vinquetta's car receives a premium wash.\n    wash['Vinquetta'] == 2,\n    # (B) Exactly two cars receive a super wash.\n    super_count == 2,\n    # (C) The fifth car washed receives a super wash.\n    # Find car at pos 5: For all c, if pos[c]==5 then wash[c]==1\n    Or([And(pos[c] == 5, wash[c] == 1) for c in cars]),\n    # (D) The fourth car washed receives a super wash.\n    Or([And(pos[c] == 4, wash[c] == 1) for c in cars]),\n    # (E) The second car washed receives a regular wash.\n    Or([And(pos[c] == 2, wash[c] == 0) for c in cars]),\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(Not(opt))\n    if solver.check() == unsat:\n        # The negation is unsat, so option must be true in all models\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly five cars—Frank's, Marquitta's, Orlando's, Taishah's, and Vinquetta's—are washed, each exactly once. The cars are washed one at a time, with each receiving exactly one kind of wash: regular, super, or premium. The following conditions must apply: The first car washed does not receive a super wash, though at least one car does. Exactly one car receives a premium wash. The second and third cars washed receive the same kind of wash as each other. Neither Orlando's nor Taishah's is washed before Vinquetta's. Marquitta's is washed before Frank's, but after Orlando's. Marquitta's and the car washed immediately before Marquitta's receive regular washes.\n\nWhich one of the following is a complete and accurate list of the cars that must receive a regular wash?\n\nOptions:\n(A) Frank's, Marquitta's\n(B) Marquitta's, Orlando's\n(C) Marquitta's, Orlando's, Taishah's\n(D) Marquitta's, Taishah's\n(E) Marquitta's, Vinquetta's",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['Frank', 'Marquitta', 'Orlando', 'Taishah', 'Vinquetta']\nwashes = ['regular', 'super', 'premium']\n\n# Create Z3 Int variables for the order each car is washed (1 to 5)\norder = {car: Int(car) for car in cars}\n# Create Z3 Int variables for the wash type each car receives (0=regular,1=super,2=premium)\nwash = {car: Int(car + '_wash') for car in cars}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Orders are from 1 to 5\nfor car in cars:\n    solver.add(And(order[car] >= 1, order[car] <= 5))\n\n# 2. All orders distinct\nsolver.add(Distinct([order[car] for car in cars]))\n\n# 3. Wash types are 0 (regular),1 (super),2 (premium)\nfor car in cars:\n    solver.add(And(wash[car] >= 0, wash[car] <= 2))\n\n# 4. The first car washed does NOT receive a super wash (wash != 1)\n# Find which car is first (order == 1)\n# For all cars, if order == 1 then wash != super (1)\nfirst_car_conditions = []\nfor car in cars:\n    first_car_conditions.append(Implies(order[car] == 1, wash[car] != 1))\nsolver.add(And(first_car_conditions))\n\n# 5. At least one car receives a super wash (wash == 1)\nsuper_wash_conditions = [wash[car] == 1 for car in cars]\nsolver.add(Or(super_wash_conditions))\n\n# 6. Exactly one car receives a premium wash (wash == 2)\npremium_wash_conditions = [If(wash[car] == 2, 1, 0) for car in cars]\nsolver.add(Sum(premium_wash_conditions) == 1)\n\n# 7. The second and third cars washed receive the same kind of wash as each other\n# Find cars with order 2 and 3, their washes must be equal\n# For all cars c2 and c3, if order[c2] == 2 and order[c3] == 3 then wash[c2] == wash[c3]\nsecond_third_conditions = []\nfor c2 in cars:\n    for c3 in cars:\n        cond = And(order[c2] == 2, order[c3] == 3)\n        second_third_conditions.append(Implies(cond, wash[c2] == wash[c3]))\nsolver.add(And(second_third_conditions))\n\n# 8. Neither Orlando's nor Taishah's is washed before Vinquetta's\n# order[Orlando] >= order[Vinquetta]\nsolver.add(order['Orlando'] >= order['Vinquetta'])\n# order[Taishah] >= order[Vinquetta]\nsolver.add(order['Taishah'] >= order['Vinquetta'])\n\n# 9. Marquitta's is washed before Frank's, but after Orlando's\nsolver.add(order['Marquitta'] < order['Frank'])\nsolver.add(order['Marquitta'] > order['Orlando'])\n\n# 10. Marquitta's and the car washed immediately before Marquitta's receive regular washes\n# Find the car with order one less than Marquitta's order\n# For all cars c, if order[c] == order[Marquitta] - 1 then wash[c] == regular (0)\nbefore_marquitta_conditions = []\nfor c in cars:\n    cond = order[c] == order['Marquitta'] - 1\n    before_marquitta_conditions.append(Implies(cond, wash[c] == 0))\nsolver.add(And(before_marquitta_conditions))\n# Marquitta's wash is regular\nsolver.add(wash['Marquitta'] == 0)\n\n# OPTION CHECKING\n\noptions = {\n    'A': ['Frank', 'Marquitta'],\n    'B': ['Marquitta', 'Orlando'],\n    'C': ['Marquitta', 'Orlando', 'Taishah'],\n    'D': ['Marquitta', 'Taishah'],\n    'E': ['Marquitta', 'Vinquetta']\n}\n\nfor i, (letter, regular_cars) in enumerate(options.items()):\n    solver.push()\n    # Add constraints that these cars receive regular wash\n    for car in regular_cars:\n        solver.add(wash[car] == 0)\n    # Add constraints that cars not in the list do NOT receive regular wash\n    for car in cars:\n        if car not in regular_cars:\n            solver.add(wash[car] != 0)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.\n\nWhich one of the following is an acceptable assignment of toy-truck models to lines, on order from line 1 through line 7?\n\nOptions:\n(A) F, J, K, S, H, M, G\n(B) F, K, J, S, M, G, H\n(C) F, M, K, S, G, J, H\n(D) H, K, S, M, G, F, J\n(E) H, M, G, S, J, F, K",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmodels = ['F', 'G', 'H', 'J', 'K', 'M', 'S']\nlines = list(range(1, 8))\n\n# Create a dictionary mapping model to its assigned line number (Z3 Int variable)\nline_of = {m: Int(m) for m in models}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each model assigned to a line between 1 and 7\nfor m in models:\n    solver.add(And(line_of[m] >= 1, line_of[m] <= 7))\n\n# All lines assigned to distinct models\nsolver.add(Distinct([line_of[m] for m in models]))\n\n# F is assembled on a lower-numbered line than J\nsolver.add(line_of['F'] < line_of['J'])\n\n# M is assembled on the line numbered one lower than the line on which G is assembled\nsolver.add(line_of['M'] + 1 == line_of['G'])\n\n# H is assembled on line 1 or line 7\nsolver.add(Or(line_of['H'] == 1, line_of['H'] == 7))\n\n# S is assembled on line 4\nsolver.add(line_of['S'] == 4)\n\n# OPTION CHECKING\noptions = [\n    ['F', 'J', 'K', 'S', 'H', 'M', 'G'],  # A\n    ['F', 'K', 'J', 'S', 'M', 'G', 'H'],  # B\n    ['F', 'M', 'K', 'S', 'G', 'J', 'H'],  # C\n    ['H', 'K', 'S', 'M', 'G', 'F', 'J'],  # D\n    ['H', 'M', 'G', 'S', 'J', 'F', 'K'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that model at line n is option[n-1]\n    for line_num, model in enumerate(option, start=1):\n        solver.add(line_of[model] == line_num)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.\n\nIt must be true that the lowest-numbered line on which\n\nOptions:\n(A) F can be assembled is line 2\n(B) G can be assembled is line 3\n(C) J can be assembled is line 2\n(D) K can be assembled is line 3\n(E) M can be assembled is line 2",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmodels = ['F', 'G', 'H', 'J', 'K', 'M', 'S']\nlines = range(1, 8)  # Lines 1 through 7\n\n# Create a dictionary of Int variables for each model's line assignment\nline_vars = {m: Int(m) for m in models}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each model assigned to a line between 1 and 7\nfor m in models:\n    solver.add(And(line_vars[m] >= 1, line_vars[m] <= 7))\n\n# All models assigned to distinct lines\nsolver.add(Distinct([line_vars[m] for m in models]))\n\n# F is assembled on a lower-numbered line than J\nsolver.add(line_vars['F'] < line_vars['J'])\n\n# M is assembled on the line numbered one lower than the line on which G is assembled\nsolver.add(line_vars['M'] + 1 == line_vars['G'])\n\n# H is assembled on line 1 or line 7\nsolver.add(Or(line_vars['H'] == 1, line_vars['H'] == 7))\n\n# S is assembled on line 4\nsolver.add(line_vars['S'] == 4)\n\n# OPTION CHECKING\n\n# Define options with their minimum line constraints\n# We check if the model can be assembled at the stated minimum line or lower\n# To check if the minimum line can be exactly the given line, we try to find a solution where the model is assigned to that line or lower, \n# but not lower than that line (i.e., the model cannot be assigned to any line less than the stated line).\n\noptions = {\n    'A': ('F', 2),\n    'B': ('G', 3),\n    'C': ('J', 2),\n    'D': ('K', 3),\n    'E': ('M', 2),\n}\n\nfor letter, (model, min_line) in options.items():\n    solver.push()\n    # Check if it's possible that the model is assigned to a line lower than min_line\n    solver.add(line_vars[model] < min_line)\n    if solver.check() == sat:\n        # If sat, model can be assembled on a line lower than min_line, so min_line is not the lowest possible\n        solver.pop()\n        continue\n    else:\n        # If unsat, model cannot be on a line lower than min_line, so min_line is the lowest possible line for the model\n        solver.pop()\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.\n\nIf K is assembled on line 5, which one of the following is a pair of models that could be assembled, not necessarily in the order given, on lines whose numbers are consecutive to each other?\n\nOptions:\n(A) G, H\n(B) G, J\n(C) H, J\n(D) J, M\n(E) M, S",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmodels = ['F', 'G', 'H', 'J', 'K', 'M', 'S']\nlines = range(1, 8)  # Lines 1 through 7\n\n# Create a Z3 Int variable for each model representing its line number\nline_vars = {m: Int(m) for m in models}\n\nsolver = Solver()\n\n# Each model assigned to a line between 1 and 7\nfor m in models:\n    solver.add(And(line_vars[m] >= 1, line_vars[m] <= 7))\n\n# All lines assigned to distinct models\nsolver.add(Distinct([line_vars[m] for m in models]))\n\n# CONSTRAINTS\n# F is assembled on a lower-numbered line than J\nsolver.add(line_vars['F'] < line_vars['J'])\n\n# M is assembled on the line numbered one lower than the line on which G is assembled\nsolver.add(line_vars['M'] + 1 == line_vars['G'])\n\n# H is assembled on line 1 or else line 7\nsolver.add(Or(line_vars['H'] == 1, line_vars['H'] == 7))\n\n# S is assembled on line 4\nsolver.add(line_vars['S'] == 4)\n\n# K is assembled on line 5 (given condition)\nsolver.add(line_vars['K'] == 5)\n\n# OPTION CHECKING\n# Each option is a pair of models that could be on consecutive lines (not necessarily in order)\noptions = [\n    ('G', 'H'),  # A\n    ('G', 'J'),  # B\n    ('H', 'J'),  # C\n    ('J', 'M'),  # D\n    ('M', 'S'),  # E\n]\n\nfor i, (m1, m2) in enumerate(options):\n    solver.push()\n    # Add constraint that m1 and m2 are on consecutive lines (either order)\n    cond1 = line_vars[m1] + 1 == line_vars[m2]\n    cond2 = line_vars[m2] + 1 == line_vars[m1]\n    solver.add(Or(cond1, cond2))\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.\n\nIf K is assembled on line 2, which one of the following must be true?\n\nOptions:\n(A) F is assembled on a lower-numbered line than S.\n(B) H is assembled on a lower-numbered line than G.\n(C) J is assembled on a lower-numbered line than H.\n(D) M is assembled on a lower-numbered line than J.\n(E) S is assembled on a lower-numbered line than J.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmodels = ['F', 'G', 'H', 'J', 'K', 'M', 'S']\nlines = range(1, 8)\n\n# Create a dictionary of Int variables for each model's line assignment\nline_of = {m: Int(m) for m in models}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each model is assigned to a line between 1 and 7\nfor m in models:\n    solver.add(And(line_of[m] >= 1, line_of[m] <= 7))\n\n# All models assigned to distinct lines\nsolver.add(Distinct([line_of[m] for m in models]))\n\n# F is assembled on a lower-numbered line than J\nsolver.add(line_of['F'] < line_of['J'])\n\n# M is assembled on the line numbered one lower than G's line\nsolver.add(line_of['M'] + 1 == line_of['G'])\n\n# H is assembled on line 1 or line 7\nsolver.add(Or(line_of['H'] == 1, line_of['H'] == 7))\n\n# S is assembled on line 4\nsolver.add(line_of['S'] == 4)\n\n# K is assembled on line 2 (given condition)\nsolver.add(line_of['K'] == 2)\n\n# OPTION CHECKING\n\noptions = {\n    'A': line_of['F'] < line_of['S'],  # F is lower-numbered than S\n    'B': line_of['H'] < line_of['G'],  # H is lower-numbered than G\n    'C': line_of['J'] < line_of['H'],  # J is lower-numbered than H\n    'D': line_of['M'] < line_of['J'],  # M is lower-numbered than J\n    'E': line_of['S'] < line_of['J'],  # S is lower-numbered than J\n}\n\n# For each option, check if it must be true: \n# That is, add the negation of the option and check if the system is still satisfiable.\n# If negation is unsat, then option must be true.\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.\n\nIf G is assembled on the line numbered one less than the line on which F is assembled, then which one of the following must be true?\n\nOptions:\n(A) F is assembled on line 3.\n(B) G is assembled on line 5.\n(C) H is assembled on line 1.\n(D) K is assembled on line 5.\n(E) M is assembled on line 6.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmodels = ['F', 'G', 'H', 'J', 'K', 'M', 'S']\nlines = range(1, 8)\n\n# Create a dictionary of Z3 Int variables for each model's line number\nline_vars = {m: Int(m) for m in models}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each model must be assigned a line between 1 and 7\nfor m in models:\n    solver.add(And(line_vars[m] >= 1, line_vars[m] <= 7))\n\n# All models must be assigned to distinct lines\nsolver.add(Distinct([line_vars[m] for m in models]))\n\n# Given conditions:\n# F is assembled on a lower-numbered line than J\nsolver.add(line_vars['F'] < line_vars['J'])\n\n# M is assembled on the line numbered one lower than the line on which G is assembled\nsolver.add(line_vars['M'] == line_vars['G'] - 1)\n\n# H is assembled on line 1 or line 7\nsolver.add(Or(line_vars['H'] == 1, line_vars['H'] == 7))\n\n# S is assembled on line 4\nsolver.add(line_vars['S'] == 4)\n\n# OPTION CHECKING\n\noptions = {\n    'A': line_vars['F'] == 3,\n    'B': line_vars['G'] == 5,\n    'C': line_vars['H'] == 1,\n    'D': line_vars['K'] == 5,\n    'E': line_vars['M'] == 6,\n}\n\n# Additional condition for the question:\n# If G is assembled on the line numbered one less than the line on which F is assembled\n# i.e. G = F - 1\ncondition = (line_vars['G'] == line_vars['F'] - 1)\n\n# We want to find which option must be true under this condition.\n# So we check each option by adding the condition and the negation of the option and see if it's unsat.\n# The option that is always true will cause unsat when negated under the condition.\n\nfor letter, opt_constraint in options.items():\n    solver.push()\n    solver.add(condition)\n    solver.add(Not(opt_constraint))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly seven toy-truck models—F, G, H, J, K, M, and S—are assembled on seven assembly lines, exactly one model to a line. The seven lines are arranged side by side and numbered consecutively 1 through 7. Assignment of models to lines must meet the following conditions: F is assembled on a lower-numbered line than J. M is assembled on the line numbered one lower than the line on which G is assembled. H is assembled on line 1 or else line 7. S is assembled on line 4.\n\nIf M is assembled on line 1, which one of the following could be true?\n\nOptions:\n(A) F is assembled on a line numbered one lower than the line on which H is assembled.\n(B) F is assembled on a line numbered one lower than the line on which K is assembled.\n(C) G is assembled on a line numbered one lower than the line on which J is assembled.\n(D) G is assembled on a line numbered one lower than the line on which K is assembled.\n(E) K is assembled on a line numbered one lower than the line on which G is assembled.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmodels = ['F', 'G', 'H', 'J', 'K', 'M', 'S']\nmodel_indices = {m: i for i, m in enumerate(models)}\n\n# Create Z3 Int variables for line assignments of each model\nlines = {}\nfor m in models:\n    lines[m] = Int(m)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each model is assigned to a line from 1 to 7\nfor m in models:\n    solver.add(And(lines[m] >= 1, lines[m] <= 7))\n\n# All lines are distinct (one model per line)\nsolver.add(Distinct([lines[m] for m in models]))\n\n# F is assembled on a lower-numbered line than J\nsolver.add(lines['F'] < lines['J'])\n\n# M is assembled on the line numbered one lower than the line on which G is assembled\nsolver.add(lines['M'] + 1 == lines['G'])\n\n# H is assembled on line 1 or else line 7\nsolver.add(Or(lines['H'] == 1, lines['H'] == 7))\n\n# S is assembled on line 4\nsolver.add(lines['S'] == 4)\n\n# M is assembled on line 1 (given condition)\nsolver.add(lines['M'] == 1)\n\n# OPTION CHECKING\n\noptions = {\n    'A': lines['F'] + 1 == lines['H'],\n    'B': lines['F'] + 1 == lines['K'],\n    'C': lines['G'] + 1 == lines['J'],\n    'D': lines['G'] + 1 == lines['K'],\n    'E': lines['K'] + 1 == lines['G'],\n}\n\nfor option_letter, option_constraint in options.items():\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "At a water carnival, each of the eight lifeguards—J, K, L, M, P, Q, R, and S—will participate in two events, a boat race and a rescue exercise. For each of these events the eight lifeguards are grouped into four two-person teams, subject to the following rules: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise. L and Q are teammates in the boat race. K and L are teammates in the rescue exercise. R and S are not teammates in either event.\n\nIf P and K are teammates in the boat race and P and Q are teammates in the rescue exercise, then each of the following lists a pair of lifeguards who must be teammates in one of the two events EXCEPT:\n\nOptions:\n(A) J and M\n(B) J and R\n(C) J and S\n(D) M and R\n(E) M and S",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlifeguards = ['J', 'K', 'L', 'M', 'P', 'Q', 'R', 'S']\nn = len(lifeguards)\n\n# Create index mapping for lifeguards\nidx = {lg: i for i, lg in enumerate(lifeguards)}\n\n# For each event, create a pairing matrix: 8x8 boolean matrix where pair[i][j] = True if i and j are teammates\n# Since teams are two-person, pair[i][j] == pair[j][i], and pair[i][i] == False\n# We'll represent pairs only for i<j to avoid duplicates\n\n# Variables: boat_pairs[i][j], rescue_pairs[i][j] for i<j\nboat_pairs = {}\nrescue_pairs = {}\n\nfor i in range(n):\n    for j in range(i+1, n):\n        boat_pairs[(i,j)] = Bool(f\"boat_{lifeguards[i]}_{lifeguards[j]}\")\n        rescue_pairs[(i,j)] = Bool(f\"rescue_{lifeguards[i]}_{lifeguards[j]}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each lifeguard participates in exactly one team in each event\n# Each lifeguard is in exactly one pair in boat race\nfor i in range(n):\n    pairs_in_boat = []\n    for j in range(n):\n        if i < j:\n            pairs_in_boat.append(boat_pairs[(i,j)])\n        elif j < i:\n            pairs_in_boat.append(boat_pairs[(j,i)])\n    solver.add(PbEq([(p, 1) for p in pairs_in_boat], 1))\n\n# Each lifeguard is in exactly one pair in rescue exercise\nfor i in range(n):\n    pairs_in_rescue = []\n    for j in range(n):\n        if i < j:\n            pairs_in_rescue.append(rescue_pairs[(i,j)])\n        elif j < i:\n            pairs_in_rescue.append(rescue_pairs[(j,i)])\n    solver.add(PbEq([(p, 1) for p in pairs_in_rescue], 1))\n\n# 2. If two lifeguards are teammates in boat race, they cannot be teammates in rescue exercise\nfor i in range(n):\n    for j in range(i+1, n):\n        solver.add(Or(Not(boat_pairs[(i,j)]), Not(rescue_pairs[(i,j)])))\n\n# 3. L and Q are teammates in boat race\niL = idx['L']\niQ = idx['Q']\nif iL < iQ:\n    solver.add(boat_pairs[(iL, iQ)])\nelse:\n    solver.add(boat_pairs[(iQ, iL)])\n\n# 4. K and L are teammates in rescue exercise\niK = idx['K']\nif iK < iL:\n    solver.add(rescue_pairs[(iK, iL)])\nelse:\n    solver.add(rescue_pairs[(iL, iK)])\n\n# 5. R and S are not teammates in either event\niR = idx['R']\niS = idx['S']\nif iR < iS:\n    solver.add(Not(boat_pairs[(iR, iS)]))\n    solver.add(Not(rescue_pairs[(iR, iS)]))\nelse:\n    solver.add(Not(boat_pairs[(iS, iR)]))\n    solver.add(Not(rescue_pairs[(iS, iR)]))\n\n# 6. P and K are teammates in boat race\niP = idx['P']\nif iK < iP:\n    solver.add(boat_pairs[(iK, iP)])\nelse:\n    solver.add(boat_pairs[(iP, iK)])\n\n# 7. P and Q are teammates in rescue exercise\nif iP < iQ:\n    solver.add(rescue_pairs[(iP, iQ)])\nelse:\n    solver.add(rescue_pairs[(iQ, iP)])\n\n# OPTION CHECKING\n# For each option, check if the pair must be teammates in one of the two events.\n# The question asks: which pair does NOT have to be teammates in one of the two events?\n# So for each pair, we check if the negation is satisfiable: i.e., can they NOT be teammates in either event?\n# If yes, that means the pair does NOT have to be teammates in one of the events.\n\noptions = {\n    'A': ('J', 'M'),\n    'B': ('J', 'R'),\n    'C': ('J', 'S'),\n    'D': ('M', 'R'),\n    'E': ('M', 'S')\n}\n\nfor letter, (a, b) in options.items():\n    solver.push()\n    ia = idx[a]\n    ib = idx[b]\n    if ia < ib:\n        pair_boat = boat_pairs[(ia, ib)]\n        pair_rescue = rescue_pairs[(ia, ib)]\n    else:\n        pair_boat = boat_pairs[(ib, ia)]\n        pair_rescue = rescue_pairs[(ib, ia)]\n    # Add constraint that a and b are NOT teammates in either event\n    solver.add(Not(pair_boat))\n    solver.add(Not(pair_rescue))\n    if solver.check() == sat:\n        # The pair can avoid being teammates in both events\n        # So this pair does NOT have to be teammates in one of the events\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "At a water carnival, each of the eight lifeguards—J, K, L, M, P, Q, R, and S—will participate in two events, a boat race and a rescue exercise. For each of these events the eight lifeguards are grouped into four two-person teams, subject to the following rules: If two lifeguards are teammates in the boat race, they cannot also be teammates in the rescue exercise. L and Q are teammates in the boat race. K and L are teammates in the rescue exercise. R and S are not teammates in either event.\n\nIf J and P are teammates in the boat race, then M could be the teammate of\n\nOptions:\n(A) K in the boat race and S in the rescue exercise\n(B) L in the boat race and S in the rescue exercise\n(C) R in the boat race and L in the rescue exercise\n(D) S in the boat race and K in the rescue exercise\n(E) S in the boat race and P in the rescue exercise",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nlifeguards = ['J', 'K', 'L', 'M', 'P', 'Q', 'R', 'S']\nn = len(lifeguards)\n\n# Map lifeguard names to indices\nindex = {name: i for i, name in enumerate(lifeguards)}\n\n# Variables representing teammate pairs in boat race and rescue exercise\n# Each event is represented as a symmetric adjacency matrix of 0/1 variables\n# team_boat[i][j] = 1 if lifeguard i and j are teammates in boat race, else 0\n# team_rescue[i][j] = 1 if lifeguard i and j are teammates in rescue exercise, else 0\nteam_boat = [[Bool(f\"boat_{i}_{j}\") for j in range(n)] for i in range(n)]\nteam_rescue = [[Bool(f\"rescue_{i}_{j}\") for j in range(n)] for i in range(n)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Teams are pairs: no one teams with themselves\nfor i in range(n):\n    solver.add(Not(team_boat[i][i]))\n    solver.add(Not(team_rescue[i][i]))\n\n# 2. Symmetry: team_boat[i][j] == team_boat[j][i], same for rescue\nfor i in range(n):\n    for j in range(i+1, n):\n        solver.add(team_boat[i][j] == team_boat[j][i])\n        solver.add(team_rescue[i][j] == team_rescue[j][i])\n\n# 3. Each lifeguard is in exactly one team of two in each event:\n# Each lifeguard has exactly one teammate in boat race and one in rescue exercise\nfor i in range(n):\n    # Count number of teammates for lifeguard i in boat race\n    boat_teammates = [team_boat[i][j] for j in range(n) if j != i]\n    solver.add(PbEq([(b, 1) for b in boat_teammates], 1))\n    # Count number of teammates for lifeguard i in rescue exercise\n    rescue_teammates = [team_rescue[i][j] for j in range(n) if j != i]\n    solver.add(PbEq([(r, 1) for r in rescue_teammates], 1))\n\n# 4. If two lifeguards are teammates in boat race, they cannot be teammates in rescue exercise\nfor i in range(n):\n    for j in range(i+1, n):\n        solver.add(Or(Not(team_boat[i][j]), Not(team_rescue[i][j])))\n\n# 5. L and Q are teammates in the boat race\nsolver.add(team_boat[index['L']][index['Q']])\n\n# 6. K and L are teammates in the rescue exercise\nsolver.add(team_rescue[index['K']][index['L']])\n\n# 7. R and S are not teammates in either event\nsolver.add(Not(team_boat[index['R']][index['S']]))\nsolver.add(Not(team_rescue[index['R']][index['S']]))\n\n# 8. J and P are teammates in the boat race (given condition)\nsolver.add(team_boat[index['J']][index['P']])\n\n# OPTION CHECKING\n# For each option, add constraints describing M's teammates in boat race and rescue exercise\n# and check if the model is satisfiable.\n\noptions = [\n    # (boat teammate for M, rescue teammate for M)\n    ('K', 'S'),  # A\n    ('L', 'S'),  # B\n    ('R', 'L'),  # C\n    ('S', 'K'),  # D\n    ('S', 'P')   # E\n]\n\nfor i, (boat_teammate, rescue_teammate) in enumerate(options):\n    solver.push()\n    # M's teammate in boat race is boat_teammate\n    # So team_boat[M][boat_teammate] == True\n    solver.add(team_boat[index['M']][index[boat_teammate]])\n    # M's teammate in rescue exercise is rescue_teammate\n    solver.add(team_rescue[index['M']][index[rescue_teammate]])\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.\n\nWhich one of the following could be an accurate ranking of the restaurants, from highest to lowest?\n\nOptions:\n(A) Tantoko, Medici, Scheherazade's, Pastilla, Vistula, Robusto, Lautrec\n(B) Robusto, Pastilla, Tantoko, Medici, Scheherazade's, Vistula, Lautrec\n(C) Tantoko, Medici, Scheherazade's, Robusto, Vistula, Pastilla, Lautrec\n(D) Tantoko, Robusto, Medici, Vistula, Pastilla, Scheherazade's, Lautrec\n(E) Robusto, Pastilla, Scheherazade's, Medici, Vistula, Tantoko, Lautrec",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nrestaurants = ['Lautrec', 'Medici', 'Pastilla', 'Robusto', 'Scheherazades', 'Tantoko', 'Vistula']\nindices = {r: i for i, r in enumerate(restaurants)}\n\n# Create Z3 Int variables for the rank of each restaurant (0 is highest, 6 is lowest)\nrank = {r: Int(r) for r in restaurants}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank must be between 0 and 6\nfor r in restaurants:\n    solver.add(And(rank[r] >= 0, rank[r] <= 6))\n\n# All ranks must be distinct (no ties)\nsolver.add(Distinct([rank[r] for r in restaurants]))\n\n# Pastilla ranks higher than Lautrec but lower than Robusto\nsolver.add(rank['Pastilla'] < rank['Lautrec'])\nsolver.add(rank['Pastilla'] > rank['Robusto'])\n\n# Medici ranks higher than Vistula but lower than Tantoko\nsolver.add(rank['Medici'] < rank['Vistula'])\nsolver.add(rank['Medici'] > rank['Tantoko'])\n\n# If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's\ncond1 = rank['Scheherazades'] < rank['Pastilla']\nimp1 = Implies(cond1, rank['Medici'] < rank['Scheherazades'])\nsolver.add(imp1)\n\n# If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla\ncond2 = rank['Medici'] < rank['Scheherazades']\nimp2 = Implies(cond2, rank['Scheherazades'] < rank['Pastilla'])\nsolver.add(imp2)\n\n# OPTION CHECKING\n\noptions = [\n    ['Tantoko', 'Medici', 'Scheherazades', 'Pastilla', 'Vistula', 'Robusto', 'Lautrec'],         # A\n    ['Robusto', 'Pastilla', 'Tantoko', 'Medici', 'Scheherazades', 'Vistula', 'Lautrec'],         # B\n    ['Tantoko', 'Medici', 'Scheherazades', 'Robusto', 'Vistula', 'Pastilla', 'Lautrec'],         # C\n    ['Tantoko', 'Robusto', 'Medici', 'Vistula', 'Pastilla', 'Scheherazades', 'Lautrec'],         # D\n    ['Robusto', 'Pastilla', 'Scheherazades', 'Medici', 'Vistula', 'Tantoko', 'Lautrec'],         # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that rank of option[j] == j\n    for pos, r in enumerate(option):\n        solver.add(rank[r] == pos)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.\n\nIf Medici ranks lower than Lautrec, then which one of the following must be true?\n\nOptions:\n(A) Lautrec ranks higher than Tantoko.\n(B) Scheherazade's ranks higher than Vistula.\n(C) Pastilla ranks higher than Tantoko.\n(D) Tantoko ranks higher than Scheherazade's.\n(E) Tantoko ranks higher than Pastilla.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nrestaurants = ['Lautrec', 'Medici', 'Pastilla', 'Robusto', \"Scheherazade's\", 'Tantoko', 'Vistula']\nindices = {r: Int(r) for r in restaurants}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each restaurant rank is between 1 (best) and 7 (worst)\nfor r in restaurants:\n    solver.add(indices[r] >= 1, indices[r] <= 7)\n\n# No ties: all ranks are distinct\nsolver.add(Distinct([indices[r] for r in restaurants]))\n\n# Pastilla ranks higher than Lautrec but lower than Robusto\n# Higher means smaller number (1 is best)\nsolver.add(indices['Pastilla'] < indices['Lautrec'])\nsolver.add(indices['Pastilla'] > indices['Robusto'])\n\n# Medici ranks higher than Vistula but lower than Tantoko\nsolver.add(indices['Medici'] < indices['Vistula'])\nsolver.add(indices['Medici'] > indices['Tantoko'])\n\n# If Scheherazade's ranks higher than Pastilla,\n# then Medici ranks higher than Scheherazade's\ncond1 = indices[\"Scheherazade's\"] < indices['Pastilla']\nsolver.add(Implies(cond1, indices['Medici'] < indices[\"Scheherazade's\"]))\n\n# If Medici ranks higher than Scheherazade's,\n# then Scheherazade's ranks higher than Pastilla\ncond2 = indices['Medici'] < indices[\"Scheherazade's\"]\nsolver.add(Implies(cond2, indices[\"Scheherazade's\"] < indices['Pastilla']))\n\n# The question: If Medici ranks lower than Lautrec\n# i.e. indices['Medici'] > indices['Lautrec']\n\n# We want to find which option must be true under this assumption\n\n# OPTIONS:\n# (A) Lautrec ranks higher than Tantoko: indices['Lautrec'] < indices['Tantoko']\n# (B) Scheherazade's ranks higher than Vistula: indices[\"Scheherazade's\"] < indices['Vistula']\n# (C) Pastilla ranks higher than Tantoko: indices['Pastilla'] < indices['Tantoko']\n# (D) Tantoko ranks higher than Scheherazade's: indices['Tantoko'] < indices[\"Scheherazade's\"]\n# (E) Tantoko ranks higher than Pastilla: indices['Tantoko'] < indices['Pastilla']\n\n# We will check which options must always hold when indices['Medici'] > indices['Lautrec']\n\n# To do so, for each option, we add the assumption indices['Medici'] > indices['Lautrec']\n# and the negation of the option, and check if the model is satisfiable.\n# If unsat, then the option must be true.\n\nsolver.push()\nsolver.add(indices['Medici'] > indices['Lautrec'])\n\n# Option (A)\nsolver.push()\nsolver.add(indices['Lautrec'] >= indices['Tantoko'])  # Negation of (A)\nif solver.check() == unsat:\n    print(\"'A'\")\n    solver.pop()\n    solver.pop()\n    exit()\nsolver.pop()\n\n# Option (B)\nsolver.push()\nsolver.add(indices[\"Scheherazade's\"] >= indices['Vistula'])  # Negation of (B)\nif solver.check() == unsat:\n    print(\"'B'\")\n    solver.pop()\n    solver.pop()\n    exit()\nsolver.pop()\n\n# Option (C)\nsolver.push()\nsolver.add(indices['Pastilla'] >= indices['Tantoko'])  # Negation of (C)\nif solver.check() == unsat:\n    print(\"'C'\")\n    solver.pop()\n    solver.pop()\n    exit()\nsolver.pop()\n\n# Option (D)\nsolver.push()\nsolver.add(indices['Tantoko'] >= indices[\"Scheherazade's\"])  # Negation of (D)\nif solver.check() == unsat:\n    print(\"'D'\")\n    solver.pop()\n    solver.pop()\n    exit()\nsolver.pop()\n\n# Option (E)\nsolver.push()\nsolver.add(indices['Tantoko'] >= indices['Pastilla'])  # Negation of (E)\nif solver.check() == unsat:\n    print(\"'E'\")\n    solver.pop()\n    solver.pop()\n    exit()\nsolver.pop()\n\nsolver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.\n\nWhich one of the following CANNOT be true?\n\nOptions:\n(A) Pastilla ranks second highest.\n(B) Vistula ranks third highest.\n(C) Lautrec ranks third highest.\n(D) Robusto ranks fifth highest.\n(E) Scheherazade's ranks sixth highest.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nrestaurants = ['Lautrec', 'Medici', 'Pastilla', 'Robusto', \"Scheherazade's\", 'Tantoko', 'Vistula']\nranks = {r: Int(r) for r in restaurants}  # rank variables: 1 (highest) to 7 (lowest)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each rank is between 1 and 7\nfor r in restaurants:\n    solver.add(And(ranks[r] >= 1, ranks[r] <= 7))\n\n# All ranks are distinct\nsolver.add(Distinct([ranks[r] for r in restaurants]))\n\n# Pastilla ranks higher than Lautrec but lower than Robusto:\n# higher means smaller rank number\nsolver.add(ranks['Pastilla'] < ranks['Lautrec'])\nsolver.add(ranks['Pastilla'] > ranks['Robusto'])\n\n# Medici ranks higher than Vistula but lower than Tantoko\nsolver.add(ranks['Medici'] < ranks['Vistula'])\nsolver.add(ranks['Medici'] > ranks['Tantoko'])\n\n# If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's\ncond1 = ranks[\"Scheherazade's\"] < ranks['Pastilla']\nsolver.add(Implies(cond1, ranks['Medici'] < ranks[\"Scheherazade's\"]))\n\n# If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla\ncond2 = ranks['Medici'] < ranks[\"Scheherazade's\"]\nsolver.add(Implies(cond2, ranks[\"Scheherazade's\"] < ranks['Pastilla']))\n\n# OPTION CHECKING\noptions = {\n    'A': ranks['Pastilla'] == 2,\n    'B': ranks['Vistula'] == 3,\n    'C': ranks['Lautrec'] == 3,\n    'D': ranks['Robusto'] == 5,\n    'E': ranks[\"Scheherazade's\"] == 6,\n}\n\nfor opt in ['A','B','C','D','E']:\n    solver.push()\n    solver.add(options[opt])\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{opt}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A critic ranks exactly seven restaurants—Lautrec, Medici, Pastilla, Robusto, Scheherazade's, Tantoko, and Vistula—from highest (best) to lowest (worst). The ranking must meet the following conditions: Pastilla ranks higher than Lautrec but lower than Robusto. Medici ranks higher than Vistula but lower than Tantoko. If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's. If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla. There are no ties.\n\nIf Tantoko is ranked third highest, then which one of the following CANNOT be true?\n\nOptions:\n(A) Lautrec ranked fourth highest.\n(B) Pastilla is ranked fifth highest.\n(C) Medici is ranked fifth highest.\n(D) Scheherazade's is ranked fifth highest.\n(E) Medici is ranked sixth highest.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nrestaurants = ['Lautrec', 'Medici', 'Pastilla', 'Robusto', \"Scheherazade's\", 'Tantoko', 'Vistula']\nranks = {r: Int(r) for r in restaurants}  # rank variables, lower number means higher rank\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each rank is between 1 and 7 (1 is highest)\nfor r in restaurants:\n    solver.add(And(ranks[r] >= 1, ranks[r] <= 7))\n\n# All ranks are distinct (no ties)\nsolver.add(Distinct([ranks[r] for r in restaurants]))\n\n# Pastilla ranks higher than Lautrec but lower than Robusto\nsolver.add(ranks['Pastilla'] < ranks['Lautrec'])\nsolver.add(ranks['Pastilla'] > ranks['Robusto'])\n\n# Medici ranks higher than Vistula but lower than Tantoko\nsolver.add(ranks['Medici'] < ranks['Vistula'])\nsolver.add(ranks['Medici'] > ranks['Tantoko'])\n\n# If Scheherazade's ranks higher than Pastilla, Medici ranks higher than Scheherazade's\ncond1 = ranks[\"Scheherazade's\"] < ranks['Pastilla']\nimp1 = Implies(cond1, ranks['Medici'] < ranks[\"Scheherazade's\"])\nsolver.add(imp1)\n\n# If Medici ranks higher than Scheherazade's, Scheherazade's ranks higher than Pastilla\ncond2 = ranks['Medici'] < ranks[\"Scheherazade's\"]\nimp2 = Implies(cond2, ranks[\"Scheherazade's\"] < ranks['Pastilla'])\nsolver.add(imp2)\n\n# Tantoko is ranked third highest\nsolver.add(ranks['Tantoko'] == 3)\n\n# OPTION CHECKING\noptions = {\n    'A': ranks['Lautrec'] == 4,\n    'B': ranks['Pastilla'] == 5,\n    'C': ranks['Medici'] == 5,\n    'D': ranks[\"Scheherazade's\"] == 5,\n    'E': ranks['Medici'] == 6,\n}\n\nfor opt in ['A','B','C','D','E']:\n    solver.push()\n    solver.add(options[opt])\n    if solver.check() == unsat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.\n\nWhich one of the following could be a complete and accurate matching of each park to its attractions?\n\nOptions:\n(A) Jessup: garden, museum; Island: playground; Hilltop: garden, theater\n(B) Jessup: museum, theater; Island: garden; Hilltop: fountain, garden, playground, theater\n(C) Jessup: garden, museum, playground; Island: theater; Hilltop: garden, museum, playground\n(D) Jessup: garden, museum, playground; Island: fountain; Hilltop: garden, theater\n(E) Jessup: museum, playground; Island: fountain, garden; Hilltop: garden, theater",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nparks = ['Jessup', 'Island', 'Hilltop']\ntypes = ['fountain', 'garden', 'museum', 'playground', 'theater']\n\n# Create a dictionary of Bool variables: park x attraction type\nhas_attraction = {}\nfor p in parks:\n    for t in types:\n        has_attraction[(p, t)] = Bool(f\"{p}_{t}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each park has at least one attraction\nfor p in parks:\n    solver.add(Or([has_attraction[(p, t)] for t in types]))\n\n# No two attractions of the same type are included in any park (means no duplicates per park)\n# Since variables are Bool, this is inherently satisfied: a park either has or doesn't have each attraction type\n\n# Among the three parks at least one of each type of attraction is included\nfor t in types:\n    solver.add(Or([has_attraction[(p, t)] for p in parks]))\n\n# Each of exactly two parks has a garden\ngarden_count = Sum([If(has_attraction[(p, 'garden')], 1, 0) for p in parks])\nsolver.add(garden_count == 2)\n\n# Jessup has a museum but not a theater\nsolver.add(has_attraction[('Jessup', 'museum')])\nsolver.add(Not(has_attraction[('Jessup', 'theater')]))\n\n# Island has exactly one attraction\nisland_count = Sum([If(has_attraction[('Island', t)], 1, 0) for t in types])\nsolver.add(island_count == 1)\n\n# No park has both a playground and a fountain\nfor p in parks:\n    solver.add(Not(And(has_attraction[(p, 'playground')], has_attraction[(p, 'fountain')])))\n\n# Each park that has a theater also has a garden\nfor p in parks:\n    solver.add(Implies(has_attraction[(p, 'theater')], has_attraction[(p, 'garden')]))\n\n# Each park that has a museum also has a playground\nfor p in parks:\n    solver.add(Implies(has_attraction[(p, 'museum')], has_attraction[(p, 'playground')]))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Jessup: garden, museum; Island: playground; Hilltop: garden, theater\n    {\n        ('Jessup', 'garden'): True,\n        ('Jessup', 'museum'): True,\n        ('Jessup', 'playground'): False,\n        ('Jessup', 'fountain'): False,\n        ('Jessup', 'theater'): False,\n        ('Island', 'playground'): True,\n        ('Island', 'garden'): False,\n        ('Island', 'museum'): False,\n        ('Island', 'fountain'): False,\n        ('Island', 'theater'): False,\n        ('Hilltop', 'garden'): True,\n        ('Hilltop', 'theater'): True,\n        ('Hilltop', 'museum'): False,\n        ('Hilltop', 'playground'): False,\n        ('Hilltop', 'fountain'): False,\n    },\n    # (B) Jessup: museum, theater; Island: garden; Hilltop: fountain, garden, playground, theater\n    {\n        ('Jessup', 'museum'): True,\n        ('Jessup', 'theater'): True,\n        ('Jessup', 'garden'): False,\n        ('Jessup', 'playground'): False,\n        ('Jessup', 'fountain'): False,\n        ('Island', 'garden'): True,\n        ('Island', 'museum'): False,\n        ('Island', 'playground'): False,\n        ('Island', 'fountain'): False,\n        ('Island', 'theater'): False,\n        ('Hilltop', 'fountain'): True,\n        ('Hilltop', 'garden'): True,\n        ('Hilltop', 'playground'): True,\n        ('Hilltop', 'theater'): True,\n        ('Hilltop', 'museum'): False,\n    },\n    # (C) Jessup: garden, museum, playground; Island: theater; Hilltop: garden, museum, playground\n    {\n        ('Jessup', 'garden'): True,\n        ('Jessup', 'museum'): True,\n        ('Jessup', 'playground'): True,\n        ('Jessup', 'fountain'): False,\n        ('Jessup', 'theater'): False,\n        ('Island', 'theater'): True,\n        ('Island', 'garden'): False,\n        ('Island', 'museum'): False,\n        ('Island', 'playground'): False,\n        ('Island', 'fountain'): False,\n        ('Hilltop', 'garden'): True,\n        ('Hilltop', 'museum'): True,\n        ('Hilltop', 'playground'): True,\n        ('Hilltop', 'fountain'): False,\n        ('Hilltop', 'theater'): False,\n    },\n    # (D) Jessup: garden, museum, playground; Island: fountain; Hilltop: garden, theater\n    {\n        ('Jessup', 'garden'): True,\n        ('Jessup', 'museum'): True,\n        ('Jessup', 'playground'): True,\n        ('Jessup', 'fountain'): False,\n        ('Jessup', 'theater'): False,\n        ('Island', 'fountain'): True,\n        ('Island', 'garden'): False,\n        ('Island', 'museum'): False,\n        ('Island', 'playground'): False,\n        ('Island', 'theater'): False,\n        ('Hilltop', 'garden'): True,\n        ('Hilltop', 'theater'): True,\n        ('Hilltop', 'museum'): False,\n        ('Hilltop', 'playground'): False,\n        ('Hilltop', 'fountain'): False,\n    },\n    # (E) Jessup: museum, playground; Island: fountain, garden; Hilltop: garden, theater\n    {\n        ('Jessup', 'museum'): True,\n        ('Jessup', 'playground'): True,\n        ('Jessup', 'garden'): False,\n        ('Jessup', 'fountain'): False,\n        ('Jessup', 'theater'): False,\n        ('Island', 'fountain'): True,\n        ('Island', 'garden'): True,\n        ('Island', 'museum'): False,\n        ('Island', 'playground'): False,\n        ('Island', 'theater'): False,\n        ('Hilltop', 'garden'): True,\n        ('Hilltop', 'theater'): True,\n        ('Hilltop', 'museum'): False,\n        ('Hilltop', 'playground'): False,\n        ('Hilltop', 'fountain'): False,\n    }\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this option\n    for key, val in option.items():\n        if val:\n            solver.add(has_attraction[key])\n        else:\n            solver.add(Not(has_attraction[key]))\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.\n\nIf each of exactly two of the parks has a fountain, then which one of the following could be true?\n\nOptions:\n(A) Island does not have a fountain.\n(B) Jessup does not have a garden.\n(C) Jessup has exactly two attractions.\n(D) Hilltop has exactly three attractions.\n(E) Hilltop has exactly four attractions.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nparks = ['Jessup', 'Island', 'Hilltop']\ntypes = ['fountain', 'garden', 'museum', 'playground', 'theater']\n\n# Create a dictionary of Bool variables: attraction_presence[park][type]\nattraction_presence = {}\nfor p in parks:\n    attraction_presence[p] = {}\n    for t in types:\n        attraction_presence[p][t] = Bool(f\"{p}_{t}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each park has at least one attraction\nfor p in parks:\n    solver.add(Or([attraction_presence[p][t] for t in types]))\n\n# Each attraction is exactly one of five types - already modeled by Bool variables per type\n\n# No two attractions of the same type are included in any park (each attraction type can appear at most once per park)\n# Already ensured by Bool variables (presence or absence)\n\n# Among the three parks at least one of each type of attraction is included\nfor t in types:\n    solver.add(Or([attraction_presence[p][t] for p in parks]))\n\n# Each of exactly two parks has a garden\ngarden_count = Sum([If(attraction_presence[p]['garden'], 1, 0) for p in parks])\nsolver.add(garden_count == 2)\n\n# Jessup has a museum but not a theater\nsolver.add(attraction_presence['Jessup']['museum'])\nsolver.add(Not(attraction_presence['Jessup']['theater']))\n\n# Island has exactly one attraction\nisland_count = Sum([If(attraction_presence['Island'][t], 1, 0) for t in types])\nsolver.add(island_count == 1)\n\n# No park has both a playground and a fountain\nfor p in parks:\n    solver.add(Not(And(attraction_presence[p]['playground'], attraction_presence[p]['fountain'])))\n\n# Each park that has a theater also has a garden\nfor p in parks:\n    solver.add(Implies(attraction_presence[p]['theater'], attraction_presence[p]['garden']))\n\n# Each park that has a museum also has a playground\nfor p in parks:\n    solver.add(Implies(attraction_presence[p]['museum'], attraction_presence[p]['playground']))\n\n# If each of exactly two of the parks has a fountain\nfountain_count = Sum([If(attraction_presence[p]['fountain'], 1, 0) for p in parks])\nsolver.add(fountain_count == 2)\n\n# OPTION CHECKING\noptions = [\n    # (A) Island does not have a fountain.\n    Not(attraction_presence['Island']['fountain']),\n    # (B) Jessup does not have a garden.\n    Not(attraction_presence['Jessup']['garden']),\n    # (C) Jessup has exactly two attractions.\n    Sum([If(attraction_presence['Jessup'][t], 1, 0) for t in types]) == 2,\n    # (D) Hilltop has exactly three attractions.\n    Sum([If(attraction_presence['Hilltop'][t], 1, 0) for t in types]) == 3,\n    # (E) Hilltop has exactly four attractions.\n    Sum([If(attraction_presence['Hilltop'][t], 1, 0) for t in types]) == 4,\n]\n\nfor i, option_constraint in enumerate(options):\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.\n\nIf Jessup has exactly three attractions, then it is possible to determine the exact set of attractions featured by which of the parks?\n\nOptions:\n(A) Island only\n(B) Jessup only\n(C) Island and Hilltop only\n(D) Island and Jessup only\n(E) Jessup, Island, and Hilltop",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nparks = ['Jessup', 'Island', 'Hilltop']\nattractions = ['fountain', 'garden', 'museum', 'playground', 'theater']\n\n# Create a dictionary of Bool variables: park_has_attraction[park][attraction]\npark_has_attraction = {p: {a: Bool(f\"{p}_{a}\") for a in attractions} for p in parks}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each park has at least one attraction\nfor p in parks:\n    solver.add(Or([park_has_attraction[p][a] for a in attractions]))\n\n# Among the three parks at least one of each type of attraction is included\nfor a in attractions:\n    solver.add(Or([park_has_attraction[p][a] for p in parks]))\n\n# No two attractions of the same type are included in any park (means no duplicates per park)\n# Actually, the problem states \"No two attractions of the same type are included in any park\",\n# which means no duplicate attractions of the same type in the same park (which is obvious since each attraction is unique),\n# so this is already ensured by Bool variables (one per attraction per park).\n# So no constraint needed here.\n\n# Each of exactly two parks has a garden\ngarden_count = Sum([If(park_has_attraction[p]['garden'], 1, 0) for p in parks])\nsolver.add(garden_count == 2)\n\n# Jessup has a museum but not a theater\nsolver.add(park_has_attraction['Jessup']['museum'])\nsolver.add(Not(park_has_attraction['Jessup']['theater']))\n\n# Island has exactly one attraction\nisland_count = Sum([If(park_has_attraction['Island'][a], 1, 0) for a in attractions])\nsolver.add(island_count == 1)\n\n# No park has both a playground and a fountain\nfor p in parks:\n    solver.add(Not(And(park_has_attraction[p]['playground'], park_has_attraction[p]['fountain'])))\n\n# Each park that has a theater also has a garden\nfor p in parks:\n    solver.add(Implies(park_has_attraction[p]['theater'], park_has_attraction[p]['garden']))\n\n# Each park that has a museum also has a playground\nfor p in parks:\n    solver.add(Implies(park_has_attraction[p]['museum'], park_has_attraction[p]['playground']))\n\n# Jessup has exactly three attractions\njessup_count = Sum([If(park_has_attraction['Jessup'][a], 1, 0) for a in attractions])\nsolver.add(jessup_count == 3)\n\n# OPTION CHECKING\noptions = ['A', 'B', 'C', 'D', 'E']\n\n# For each option, add constraints that the parks mentioned have a unique determined set of attractions\n# and the others may have multiple possible sets.\n\n# To check determinability, for each option:\n# 1. Check if there is a solution (should be yes)\n# 2. For each park in the option, check if the attractions set is uniquely determined:\n#    - For each attraction in that park, check if it is always present or always absent in all solutions.\n#    - If any attraction can be both present or absent in different solutions, then that park's attractions are not uniquely determined.\n# 3. If all parks in the option are uniquely determined, and no smaller option containing those parks is uniquely determined,\n#    then print the option letter.\n\n# Function to get the attractions set for a park from a model\ndef get_park_attractions(m, p):\n    return [a for a in attractions if m.eval(park_has_attraction[p][a], model_completion=True)]\n\n# Function to check if a park's attractions are uniquely determined\ndef is_park_unique(p):\n    # For each attraction, check if it can be both True and False in some models\n    for a in attractions:\n        # Check if attraction can be True\n        solver.push()\n        solver.add(park_has_attraction[p][a])\n        if solver.check() == sat:\n            can_be_true = True\n        else:\n            can_be_true = False\n        solver.pop()\n\n        # Check if attraction can be False\n        solver.push()\n        solver.add(Not(park_has_attraction[p][a]))\n        if solver.check() == sat:\n            can_be_false = True\n        else:\n            can_be_false = False\n        solver.pop()\n\n        # If both possible, attraction is not uniquely determined\n        if can_be_true and can_be_false:\n            return False\n    return True\n\n# For each option, check if the listed parks have uniquely determined attractions\nfor i, option in enumerate(options):\n    solver.push()\n    # No additional constraints needed, just check uniqueness for the parks in the option\n    option_parks = []\n    if option == 'A':\n        option_parks = ['Island']\n    elif option == 'B':\n        option_parks = ['Jessup']\n    elif option == 'C':\n        option_parks = ['Island', 'Hilltop']\n    elif option == 'D':\n        option_parks = ['Island', 'Jessup']\n    elif option == 'E':\n        option_parks = ['Jessup', 'Island', 'Hilltop']\n\n    # First check if base constraints are satisfiable\n    if solver.check() == sat:\n        # Check uniqueness for each park in option_parks\n        unique_all = True\n        for p in option_parks:\n            if not is_park_unique(p):\n                unique_all = False\n                break\n        if unique_all:\n            print(f\"'{option}'\")\n            solver.pop()\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.\n\nIf the attraction included in Island is of the same type as an attraction included in Jessup, then which one of the following must be true?\n\nOptions:\n(A) Hilltop has a playground.\n(B) Island has a museum.\n(C) Island has a fountain.\n(D) Island has a garden.\n(E) Jessup has a garden.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nparks = ['Jessup', 'Island', 'Hilltop']\ntypes = ['fountain', 'garden', 'museum', 'playground', 'theater']\nnum_types = len(types)\n\n# Create a dictionary of Bool variables: park x attraction type\n# True means the park has that attraction type\nhas_attr = {}\nfor p in parks:\n    for t in types:\n        has_attr[(p, t)] = Bool(f\"{p}_{t}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each park has at least one attraction\nfor p in parks:\n    solver.add(Or([has_attr[(p, t)] for t in types]))\n\n# Among the three parks at least one of each type of attraction is included\nfor t in types:\n    solver.add(Or([has_attr[(p, t)] for p in parks]))\n\n# No two attractions of the same type are included in any park (means no duplicates in a park)\n# Actually, the problem states: \"No two attractions of the same type are included in any park.\"\n# That means a park cannot have the same type twice (which is trivially true since each variable is Bool)\n# So no constraint needed here beyond each attraction type per park is boolean.\n\n# Each attraction is exactly one of five different types: already modeled\n\n# Each of exactly two parks has a garden\ngardens = [has_attr[(p, 'garden')] for p in parks]\nsolver.add(Sum([If(g, 1, 0) for g in gardens]) == 2)\n\n# Jessup has a museum but not a theater\nsolver.add(has_attr[('Jessup', 'museum')] == True)\nsolver.add(has_attr[('Jessup', 'theater')] == False)\n\n# Island has exactly one attraction\nisland_attrs = [has_attr[('Island', t)] for t in types]\nsolver.add(Sum([If(a, 1, 0) for a in island_attrs]) == 1)\n\n# No park has both a playground and a fountain\nfor p in parks:\n    solver.add(Not(And(has_attr[(p, 'playground')], has_attr[(p, 'fountain')])))\n\n# Each park that has a theater also has a garden\nfor p in parks:\n    solver.add(Implies(has_attr[(p, 'theater')], has_attr[(p, 'garden')]))\n\n# Each park that has a museum also has a playground\nfor p in parks:\n    solver.add(Implies(has_attr[(p, 'museum')], has_attr[(p, 'playground')]))\n\n# OPTION CHECKING\n\n# The question:\n# If the attraction included in Island is of the same type as an attraction included in Jessup,\n# then which one of the following must be true?\n\n# First, define the condition:\n# There exists a type t such that Island has t and Jessup has t\nsame_type_condition = Or([And(has_attr[('Island', t)], has_attr[('Jessup', t)]) for t in types])\n\n# We want to check which option must be true under this condition.\n# That means: For each option, check if the negation of option is possible when same_type_condition is true.\n# If negation is not possible, then option must be true.\n\noptions = {\n    'A': has_attr[('Hilltop', 'playground')],\n    'B': has_attr[('Island', 'museum')],\n    'C': has_attr[('Island', 'fountain')],\n    'D': has_attr[('Island', 'garden')],\n    'E': has_attr[('Jessup', 'garden')],\n}\n\nfor letter, option_expr in options.items():\n    solver.push()\n    # Add same_type_condition\n    solver.add(same_type_condition)\n    # Add negation of the option to see if it can be false under condition\n    solver.add(Not(option_expr))\n    if solver.check() == unsat:\n        # Negation not possible, so option must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of exactly three parks—Jessup, Island, and Hilltop—has at least one attraction. Each attraction is exactly one of five different types: fountain, garden, museum, playground, or theater. Among the three parks at least one of each type of attraction is included. No two attractions of the same type are included in any park. The following conditions must apply: Each of exactly two parks has a garden. Jessup has a museum but not a theater. Island has exactly one attraction. No park has both a playground and a fountain. Each park that has a theater also has a garden. Each park that has a museum also has a playground.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Both Hilltop and Island have a garden.\n(B) Both Hilltop and Island have a playground.\n(C) Both Hilltop and Island have a theater.\n(D) Both Island and Jessup have a fountain.\n(E) Both Island and Jessup have a garden.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nparks = ['Jessup', 'Island', 'Hilltop']\nattractions = ['fountain', 'garden', 'museum', 'playground', 'theater']\n\n# Create a dict of Bool variables: has_attraction[park][attraction]\nhas_attraction = {}\nfor p in parks:\n    has_attraction[p] = {}\n    for a in attractions:\n        has_attraction[p][a] = Bool(f\"{p}_{a}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each park has at least one attraction\nfor p in parks:\n    solver.add(Or([has_attraction[p][a] for a in attractions]))\n\n# Among the three parks at least one of each type of attraction is included\nfor a in attractions:\n    solver.add(Or([has_attraction[p][a] for p in parks]))\n\n# No two attractions of the same type are included in any park (meaning no duplicates in a park)\n# This is automatically true since each attraction is a Bool variable, either present or not.\n# So no need to add constraints here.\n\n# Each of exactly two parks has a garden\ngarden_parks = [has_attraction[p]['garden'] for p in parks]\nsolver.add(Sum([If(g, 1, 0) for g in garden_parks]) == 2)\n\n# Jessup has a museum but not a theater\nsolver.add(has_attraction['Jessup']['museum'])\nsolver.add(Not(has_attraction['Jessup']['theater']))\n\n# Island has exactly one attraction\nisland_attractions = [has_attraction['Island'][a] for a in attractions]\nsolver.add(Sum([If(a, 1, 0) for a in island_attractions]) == 1)\n\n# No park has both a playground and a fountain\nfor p in parks:\n    solver.add(Not(And(has_attraction[p]['playground'], has_attraction[p]['fountain'])))\n\n# Each park that has a theater also has a garden\nfor p in parks:\n    solver.add(Implies(has_attraction[p]['theater'], has_attraction[p]['garden']))\n\n# Each park that has a museum also has a playground\nfor p in parks:\n    solver.add(Implies(has_attraction[p]['museum'], has_attraction[p]['playground']))\n\n# OPTION CHECKING\noptions = [\n    # (A) Both Hilltop and Island have a garden.\n    And(has_attraction['Hilltop']['garden'], has_attraction['Island']['garden']),\n    # (B) Both Hilltop and Island have a playground.\n    And(has_attraction['Hilltop']['playground'], has_attraction['Island']['playground']),\n    # (C) Both Hilltop and Island have a theater.\n    And(has_attraction['Hilltop']['theater'], has_attraction['Island']['theater']),\n    # (D) Both Island and Jessup have a fountain.\n    And(has_attraction['Island']['fountain'], has_attraction['Jessup']['fountain']),\n    # (E) Both Island and Jessup have a garden.\n    And(has_attraction['Island']['garden'], has_attraction['Jessup']['garden']),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each year for the next three years, Dynamic Motors will assemble four new automobile models—the Volante, the Whisper, the Xavier, and the Ziggurat—in exactly five of its factories—F, G, H, I, and K. Each factory will assemble exactly one model in each year. Because of contractual obligations Dynamic will assemble all four models each year according to the following constraints: No model is manufactured in the same factory in consecutive years. Neither Volantes nor Whispers are assembled in any factory in which Xaviers were assembled the previous year. Neither Volantes nor Xaviers are assembled in any factory in which Ziggurats were assembled the previous year. In any year, only one factory assembles Zigurats.\n\nWhich one of the following could be the assembly schedule for factories F and G for the first two years?\n\nOptions:\n(A) year 1: Volantes in F, Ziggurats in G year 2: Xaviers in F, Whispers in G\n(B) year 1: Whispers in F, Xaviers in G year 2: Whispers in F, Ziggurats in G\n(C) year 1: Xaviers in F, Volantes in G year 2: Ziggurats in F, Ziggurats in G\n(D) year 1: Xaviers in F, Xaviers in G year 2: Whispers in F, Ziggurats in G\n(E) year 1: Ziggurats in F, Whispers in G year 2: Volantes in F, Volantes in G",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nfactories = ['F', 'G', 'H', 'I', 'K']\nmodels = ['Volante', 'Whisper', 'Xavier', 'Ziggurat']\nyears = [0, 1, 2]  # Representing three years: 0,1,2\n\n# Create variables: model assembled at each factory in each year\nassembly = {}\nfor f in factories:\n    for y in years:\n        assembly[(f, y)] = Int(f\"{f}_{y}\")\n        # Values 0 to 3 representing models\n        # 0: Volante, 1: Whisper, 2: Xavier, 3: Ziggurat\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each factory assembles exactly one model each year (already by variable domain)\nfor f in factories:\n    for y in years:\n        solver.add(And(assembly[(f, y)] >= 0, assembly[(f, y)] < len(models)))\n\n# Each year, all four models are assembled exactly once among the five factories\n# Since there are 5 factories and 4 models, one model will be assembled twice or one factory assembles a model twice?\n# The problem says: \"Each year for the next three years, Dynamic Motors will assemble four new automobile models... in exactly five factories.\"\n# \"Each factory will assemble exactly one model in each year.\"\n# \"Because of contractual obligations Dynamic will assemble all four models each year\"\n# So all four models must be assembled each year.\n# Since there are 5 factories and 4 models, one model must be assembled twice each year.\n# But the problem does not say which model is assembled twice.\n# So for each year, the set of models assembled in factories includes all four models at least once.\n\n# The constraints do not forbid models being assembled in multiple factories in the same year except for Ziggurat:\n# \"In any year, only one factory assembles Ziggurats.\"\n# So only one factory assembles Ziggurat each year.\n\nfor y in years:\n    # Ziggurat only once per year\n    ziggurat_count = Sum([If(assembly[(f, y)] == 3, 1, 0) for f in factories])\n    solver.add(ziggurat_count == 1)\n    # All four models assembled at least once in the year\n    # For each model except Ziggurat, at least one factory assembles it\n    for m in [0,1,2]:  # Volante, Whisper, Xavier\n        count_m = Sum([If(assembly[(f, y)] == m, 1, 0) for f in factories])\n        solver.add(count_m >= 1)\n\n# Constraint 1: No model is manufactured in the same factory in consecutive years.\nfor f in factories:\n    for y in [0,1]:\n        solver.add(assembly[(f, y)] != assembly[(f, y+1)])\n\n# Constraint 2:\n# Neither Volantes nor Whispers are assembled in any factory in which Xaviers were assembled the previous year.\n# For each factory f and year y in 1 and 2:\n# If previous year assembly was Xavier (2), then current year assembly cannot be Volante (0) or Whisper (1)\nfor f in factories:\n    for y in [1,2]:\n        prev_xavier = assembly[(f, y-1)] == 2\n        curr_volante_or_whisper = Or(assembly[(f, y)] == 0, assembly[(f, y)] == 1)\n        solver.add(Implies(prev_xavier, Not(curr_volante_or_whisper)))\n\n# Constraint 3:\n# Neither Volantes nor Xaviers are assembled in any factory in which Ziggurats were assembled the previous year.\n# For each factory f and year y in 1 and 2:\n# If previous year assembly was Ziggurat (3), then current year assembly cannot be Volante (0) or Xavier (2)\nfor f in factories:\n    for y in [1,2]:\n        prev_ziggurat = assembly[(f, y-1)] == 3\n        curr_volante_or_xavier = Or(assembly[(f, y)] == 0, assembly[(f, y)] == 2)\n        solver.add(Implies(prev_ziggurat, Not(curr_volante_or_xavier)))\n\n# OPTION CHECKING\n\n# Each option specifies models for factories F and G for years 1 and 2 (index 0 and 1)\n# We will check each option by adding the specified constraints and checking satisfiability.\n\noption_data = [\n    # Format: (F_year1, G_year1, F_year2, G_year2)\n    # Models are strings, map to indices: Volante=0, Whisper=1, Xavier=2, Ziggurat=3\n    (0, 3, 2, 1),  # (A) year1: F=Volante(0), G=Ziggurat(3); year2: F=Xavier(2), G=Whisper(1)\n    (1, 2, 1, 3),  # (B) year1: F=Whisper(1), G=Xavier(2); year2: F=Whisper(1), G=Ziggurat(3)\n    (2, 0, 3, 3),  # (C) year1: F=Xavier(2), G=Volante(0); year2: F=Ziggurat(3), G=Ziggurat(3)\n    (2, 2, 1, 3),  # (D) year1: F=Xavier(2), G=Xavier(2); year2: F=Whisper(1), G=Ziggurat(3)\n    (3, 1, 0, 0),  # (E) year1: F=Ziggurat(3), G=Whisper(1); year2: F=Volante(0), G=Volante(0)\n]\n\nfor i, (F_y1, G_y1, F_y2, G_y2) in enumerate(option_data):\n    solver.push()\n    solver.add(assembly[('F',0)] == F_y1)\n    solver.add(assembly[('G',0)] == G_y1)\n    solver.add(assembly[('F',1)] == F_y2)\n    solver.add(assembly[('G',1)] == G_y2)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each year for the next three years, Dynamic Motors will assemble four new automobile models—the Volante, the Whisper, the Xavier, and the Ziggurat—in exactly five of its factories—F, G, H, I, and K. Each factory will assemble exactly one model in each year. Because of contractual obligations Dynamic will assemble all four models each year according to the following constraints: No model is manufactured in the same factory in consecutive years. Neither Volantes nor Whispers are assembled in any factory in which Xaviers were assembled the previous year. Neither Volantes nor Xaviers are assembled in any factory in which Ziggurats were assembled the previous year. In any year, only one factory assembles Zigurats.\n\nIf in the first year Volantes and Whispers are assembled in F and G, respectively, the models that are assembled in the second year in F and G, respectively, could be\n\nOptions:\n(A) Volantes and Whispers\n(B) Whispers and Volantes\n(C) Whispers and Ziggurats\n(D) Ziggurats and Whispers\n(E) Ziggurats and Ziggurats",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfactories = ['F', 'G', 'H', 'I', 'K']\nmodels = ['Volante', 'Whisper', 'Xavier', 'Ziggurat']\nyears = [1, 2, 3]\n\n# Create variables: model assembled at each factory in each year\n# model_vars[(factory, year)] = Int variable representing model index\nmodel_vars = {}\nfor f in factories:\n    for y in years:\n        model_vars[(f, y)] = Int(f\"{f}_{y}\")\n\n# Create solver\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Models indices range\nfor f in factories:\n    for y in years:\n        solver.add(And(model_vars[(f, y)] >= 0, model_vars[(f, y)] < len(models)))\n\n# Each year all four models are assembled exactly once (except Ziggurat which is assembled only once per year)\n# Since there are 5 factories and 4 models, one model will be repeated in each year except Ziggurat which is only in one factory\n# But the problem states: \"Because of contractual obligations Dynamic will assemble all four models each year\"\n# So in each year, all four models appear at least once. Ziggurat appears exactly once per year.\n# So in each year:\n# - Ziggurat appears exactly once\n# - The other three models appear in the other four factories, so one of them appears twice.\n\nfor y in years:\n    # Count Ziggurat = 3 index\n    ziggurat_count = Sum([If(model_vars[(f, y)] == models.index('Ziggurat'), 1, 0) for f in factories])\n    solver.add(ziggurat_count == 1)\n\n    # For other models, each appears at least once, total factories=5\n    # So sum of counts of Volante, Whisper, Xavier = 4 (since Ziggurat=1)\n    # And each of Volante, Whisper, Xavier appears at least once\n    for m in ['Volante', 'Whisper', 'Xavier']:\n        count_m = Sum([If(model_vars[(f, y)] == models.index(m), 1, 0) for f in factories])\n        solver.add(count_m >= 1)\n\n    # Total factories = 5\n    # sum of counts of all models = 5\n    total_count = Sum([If(Or([model_vars[(f, y)] == models.index(m) for m in models]), 1, 0) for f in factories])\n    solver.add(total_count == 5)\n\n# No model is manufactured in the same factory in consecutive years\nfor f in factories:\n    for y in [1, 2]:\n        solver.add(model_vars[(f, y)] != model_vars[(f, y + 1)])\n\n# Neither Volantes nor Whispers are assembled in any factory in which Xaviers were assembled the previous year\nfor f in factories:\n    for y in [1, 2]:\n        prev_model = model_vars[(f, y)]\n        next_model = model_vars[(f, y + 1)]\n        # If previous year is Xavier (2), then next year cannot be Volante(0) or Whisper(1)\n        cond = Implies(prev_model == models.index('Xavier'),\n                       And(next_model != models.index('Volante'), next_model != models.index('Whisper')))\n        solver.add(cond)\n\n# Neither Volantes nor Xaviers are assembled in any factory in which Ziggurats were assembled the previous year\nfor f in factories:\n    for y in [1, 2]:\n        prev_model = model_vars[(f, y)]\n        next_model = model_vars[(f, y + 1)]\n        # If previous year is Ziggurat(3), then next year cannot be Volante(0) or Xavier(2)\n        cond = Implies(prev_model == models.index('Ziggurat'),\n                       And(next_model != models.index('Volante'), next_model != models.index('Xavier')))\n        solver.add(cond)\n\n# Given: In the first year, Volantes and Whispers are assembled in F and G respectively\nsolver.add(model_vars[('F', 1)] == models.index('Volante'))\nsolver.add(model_vars[('G', 1)] == models.index('Whisper'))\n\n# OPTION CHECKING\n# Options for second year for F and G respectively:\noptions = [\n    ('Volante', 'Whisper'),   # A\n    ('Whisper', 'Volante'),   # B\n    ('Whisper', 'Ziggurat'),  # C\n    ('Ziggurat', 'Whisper'),  # D\n    ('Ziggurat', 'Ziggurat')  # E\n]\n\nfor i, (f_model, g_model) in enumerate(options):\n    solver.push()\n    solver.add(model_vars[('F', 2)] == models.index(f_model))\n    solver.add(model_vars[('G', 2)] == models.index(g_model))\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each year for the next three years, Dynamic Motors will assemble four new automobile models—the Volante, the Whisper, the Xavier, and the Ziggurat—in exactly five of its factories—F, G, H, I, and K. Each factory will assemble exactly one model in each year. Because of contractual obligations Dynamic will assemble all four models each year according to the following constraints: No model is manufactured in the same factory in consecutive years. Neither Volantes nor Whispers are assembled in any factory in which Xaviers were assembled the previous year. Neither Volantes nor Xaviers are assembled in any factory in which Ziggurats were assembled the previous year. In any year, only one factory assembles Zigurats.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Xaviers are assembled in exactly two of the factories in the first year.\n(B) Xaviers are assembled in exactly one of the factories in the second year.\n(C) Xaviers are assembled in exactly two of the factories in the second year.\n(D) Xaviers are assembled in exactly one of the factories in the third year.\n(E) Xaviers are assembled in exactly two of the factories in the third year.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfactories = ['F', 'G', 'H', 'I', 'K']\nmodels = ['Volante', 'Whisper', 'Xavier', 'Ziggurat', 'Other']  # 'Other' is a dummy to fill 5 factories\nyears = [0, 1, 2]  # 3 years\n\nnum_factories = len(factories)\nnum_models = len(models)\n\n# We have 4 models per year, but 5 factories, so one factory each year assembles a model not in the four named?\n# The problem states exactly four models each year, so the fifth factory must assemble one of the four models as well?\n# Re-examining: \"four new automobile models... in exactly five factories... each factory assembles exactly one model in each year\"\n# \"Because of contractual obligations Dynamic will assemble all four models each year\"\n# So each year, all four models must be assembled (at least once), but there are five factories, so one model must be assembled twice.\n# The problem does not say anything about duplication of models in a year.\n# So the problem is that all four models are assembled each year, but there are 5 factories, so one model is assembled twice.\n\n# Let's model the factory-year assignments as a 3x5 matrix of variables, each variable is an int representing a model index (0-3)\n# We will assign:\n# 0 - Volante\n# 1 - Whisper\n# 2 - Xavier\n# 3 - Ziggurat\n\n# So models = ['Volante', 'Whisper', 'Xavier', 'Ziggurat']\n\nmodels = ['Volante', 'Whisper', 'Xavier', 'Ziggurat']\nmodel_index = {m: i for i, m in enumerate(models)}\n\n# Variables: model assigned to each factory in each year\n# assignments[year][factory] = model index\nassignments = [[Int(f\"a_{y}_{f}\") for f in range(num_factories)] for y in years]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each assignment is a valid model index (0 to 3)\nfor y in years:\n    for f in range(num_factories):\n        solver.add(And(assignments[y][f] >= 0, assignments[y][f] < len(models)))\n\n# Each year, all four models must be assembled (at least once)\n# So for each year, the set of models assigned must include all four models at least once\nfor y in years:\n    # For each model, at least one factory assigned that model in year y\n    for m in range(len(models)):\n        solver.add(Or([assignments[y][f] == m for f in range(num_factories)]))\n\n# Each factory assembles exactly one model in each year (already ensured by assignments[y][f])\n\n# No model is manufactured in the same factory in consecutive years\nfor y in [0,1]:\n    for f in range(num_factories):\n        solver.add(assignments[y][f] != assignments[y+1][f])\n\n# Neither Volantes nor Whispers are assembled in any factory in which Xaviers were assembled the previous year.\n# For each factory f and year y in [1,2]:\n# if previous year assigned Xavier then current year cannot be Volante or Whisper\nfor y in [1,2]:\n    for f in range(num_factories):\n        prev_xavier = assignments[y-1][f] == model_index['Xavier']\n        curr_volante_or_whisper = Or(assignments[y][f] == model_index['Volante'], assignments[y][f] == model_index['Whisper'])\n        solver.add(Implies(prev_xavier, Not(curr_volante_or_whisper)))\n\n# Neither Volantes nor Xaviers are assembled in any factory in which Ziggurats were assembled the previous year.\n# For each factory f and year y in [1,2]:\n# if previous year assigned Ziggurat then current year cannot be Volante or Xavier\nfor y in [1,2]:\n    for f in range(num_factories):\n        prev_ziggurat = assignments[y-1][f] == model_index['Ziggurat']\n        curr_volante_or_xavier = Or(assignments[y][f] == model_index['Volante'], assignments[y][f] == model_index['Xavier'])\n        solver.add(Implies(prev_ziggurat, Not(curr_volante_or_xavier)))\n\n# In any year, only one factory assembles Ziggurats.\n# For each year, count number of factories assigned Ziggurat == 1\nfor y in years:\n    ziggurat_count = Sum([If(assignments[y][f] == model_index['Ziggurat'], 1, 0) for f in range(num_factories)])\n    solver.add(ziggurat_count == 1)\n\n# OPTION CHECKING\n\n# Options:\n# (A) Xaviers are assembled in exactly two of the factories in the first year.\n# (B) Xaviers are assembled in exactly one of the factories in the second year.\n# (C) Xaviers are assembled in exactly two of the factories in the second year.\n# (D) Xaviers are assembled in exactly one of the factories in the third year.\n# (E) Xaviers are assembled in exactly two of the factories in the third year.\n\noptions = [\n    ('A', 0, 2),  # year 0, exactly 2 Xaviers\n    ('B', 1, 1),  # year 1, exactly 1 Xavier\n    ('C', 1, 2),  # year 1, exactly 2 Xaviers\n    ('D', 2, 1),  # year 2, exactly 1 Xavier\n    ('E', 2, 2)   # year 2, exactly 2 Xaviers\n]\n\nfor letter, year, count in options:\n    solver.push()\n    # Add constraint that number of factories assembling Xavier in year is NOT count (to test if option must be true)\n    xavier_count = Sum([If(assignments[year][f] == model_index['Xavier'], 1, 0) for f in range(num_factories)])\n    # We check if the negation of the option is satisfiable\n    solver.add(xavier_count != count)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each year for the next three years, Dynamic Motors will assemble four new automobile models—the Volante, the Whisper, the Xavier, and the Ziggurat—in exactly five of its factories—F, G, H, I, and K. Each factory will assemble exactly one model in each year. Because of contractual obligations Dynamic will assemble all four models each year according to the following constraints: No model is manufactured in the same factory in consecutive years. Neither Volantes nor Whispers are assembled in any factory in which Xaviers were assembled the previous year. Neither Volantes nor Xaviers are assembled in any factory in which Ziggurats were assembled the previous year. In any year, only one factory assembles Zigurats.\n\nIf in the second year Ziggurats are assembled in F, which one of the following must be true?\n\nOptions:\n(A) Volantes are assembled in exactly one of the factories in the third year.\n(B) Whispers are assembled in exactly one of the factories in the third year.\n(C) Volantes are assembled in F in the first year.\n(D) Whispers are assembled in F in the first year.\n(E) Xaviers are assembled in F in the first year.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfactories = ['F', 'G', 'H', 'I', 'K']\nmodels = ['Volante', 'Whisper', 'Xavier', 'Ziggurat']\nyears = [1, 2, 3]\n\n# Create variables: assembly[year][factory] = model index\nassembly = dict()\nfor y in years:\n    assembly[y] = dict()\n    for f in factories:\n        assembly[y][f] = Int(f\"{f}_{y}\")\n        \n# Model indices\nVOLANTE = models.index('Volante')\nWHISPER = models.index('Whisper')\nXAVIER = models.index('Xavier')\nZIGGURAT = models.index('Ziggurat')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each factory assembles exactly one model each year (model index in range)\nfor y in years:\n    for f in factories:\n        solver.add(And(assembly[y][f] >= 0, assembly[y][f] < len(models)))\n\n# 2. Each year, all four models are assembled (implies that for each year, all four models appear in factories, and since there are 5 factories, one model appears twice)\n# So for each year, the models assembled in factories include all four models at least once.\nfor y in years:\n    # For each model, there is at least one factory assembling it\n    for m in range(len(models)):\n        solver.add(Or([assembly[y][f] == m for f in factories]))\n        \n# 3. No model is manufactured in the same factory in consecutive years\nfor f in factories:\n    for y in [1, 2]:\n        solver.add(assembly[y][f] != assembly[y+1][f])\n\n# 4. Neither Volantes nor Whispers are assembled in any factory in which Xaviers were assembled the previous year\nfor f in factories:\n    for y in [2, 3]:\n        # If previous year assembly is Xavier, then current year assembly is not Volante or Whisper\n        prev_xavier = assembly[y-1][f] == XAVIER\n        curr_volante_or_whisper = Or(assembly[y][f] == VOLANTE, assembly[y][f] == WHISPER)\n        solver.add(Implies(prev_xavier, Not(curr_volante_or_whisper)))\n\n# 5. Neither Volantes nor Xaviers are assembled in any factory in which Ziggurats were assembled the previous year\nfor f in factories:\n    for y in [2, 3]:\n        prev_ziggurat = assembly[y-1][f] == ZIGGURAT\n        curr_volante_or_xavier = Or(assembly[y][f] == VOLANTE, assembly[y][f] == XAVIER)\n        solver.add(Implies(prev_ziggurat, Not(curr_volante_or_xavier)))\n\n# 6. In any year, only one factory assembles Ziggurats\nfor y in years:\n    ziggurat_factories = [assembly[y][f] == ZIGGURAT for f in factories]\n    solver.add(Sum([If(cond, 1, 0) for cond in ziggurat_factories]) == 1)\n\n# 7. Given: In the second year, Ziggurats are assembled in F\nsolver.add(assembly[2]['F'] == ZIGGURAT)\n\n# OPTION CHECKING\n\n# We will check each option by adding its negation and checking if the model is still satisfiable.\n# If negation is unsat, option must be true.\n\noptions = dict()\n# (A) Volantes are assembled in exactly one of the factories in the third year.\nvolante_in_third = [assembly[3][f] == VOLANTE for f in factories]\noptions['A'] = Sum([If(cond, 1, 0) for cond in volante_in_third]) == 1\n\n# (B) Whispers are assembled in exactly one of the factories in the third year.\nwhisper_in_third = [assembly[3][f] == WHISPER for f in factories]\noptions['B'] = Sum([If(cond, 1, 0) for cond in whisper_in_third]) == 1\n\n# (C) Volantes are assembled in F in the first year.\noptions['C'] = assembly[1]['F'] == VOLANTE\n\n# (D) Whispers are assembled in F in the first year.\noptions['D'] = assembly[1]['F'] == WHISPER\n\n# (E) Xaviers are assembled in F in the first year.\noptions['E'] = assembly[1]['F'] == XAVIER\n\nfor option_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add negation of the option\n    solver.add(Not(options[option_letter]))\n    if solver.check() == unsat:\n        print(f\"'{option_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each year for the next three years, Dynamic Motors will assemble four new automobile models—the Volante, the Whisper, the Xavier, and the Ziggurat—in exactly five of its factories—F, G, H, I, and K. Each factory will assemble exactly one model in each year. Because of contractual obligations Dynamic will assemble all four models each year according to the following constraints: No model is manufactured in the same factory in consecutive years. Neither Volantes nor Whispers are assembled in any factory in which Xaviers were assembled the previous year. Neither Volantes nor Xaviers are assembled in any factory in which Ziggurats were assembled the previous year. In any year, only one factory assembles Zigurats.\n\nIf in the second year Volantes and Whispers are assembled in F and G, respectively, the models that are assembled in the first year in F and G, respectively, could be\n\nOptions:\n(A) Whispers and Volantes\n(B) Whispers and Xaviers\n(C) Xaviers and Volantes\n(D) Xaviers and Ziggurats\n(E) Ziggurats and Volantes",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfactories = ['F', 'G', 'H', 'I', 'K']\nmodels = ['Volante', 'Whisper', 'Xavier', 'Ziggurat']\nyears = [0, 1, 2]  # 0: first year, 1: second year, 2: third year\n\n# Create variables: model assembled at each factory in each year\nassembly = {}\nfor y in years:\n    for f in factories:\n        assembly[(y, f)] = Int(f\"{y}_{f}\")\n        \n# Map models to indices\nV = models.index('Volante')\nW = models.index('Whisper')\nX = models.index('Xavier')\nZ = models.index('Ziggurat')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each factory assembles exactly one model each year, model index in range\nfor y in years:\n    for f in factories:\n        solver.add(And(assembly[(y, f)] >= 0, assembly[(y, f)] < len(models)))\n\n# Each year all four models are assembled (so exactly one of each model per year)\n# Since there are 5 factories and 4 models, one model must appear twice or one model appears once and one factory assembles nothing?\n# The problem states: \"Dynamic Motors will assemble four new automobile models ... in exactly five factories each year\"\n# \"Each factory will assemble exactly one model in each year\"\n# \"Because of contractual obligations Dynamic will assemble all four models each year\"\n# So all four models appear each year, and one model appears twice? The problem doesn't say explicitly,\n# but since there are 5 factories and 4 models, one model must be assembled in two factories each year.\n# But the problem states \"all four models each year\" (so all four must appear), so one model appears twice.\n# But the problem states constraints about Ziggurat: \"In any year, only one factory assembles Ziggurats.\"\n# So Ziggurat appears exactly once per year.\n# So the model that appears twice must be Volante, Whisper or Xavier.\n# The problem does not specify which model appears twice.\n# So the only restriction is that Ziggurat appears once per year.\n# We'll enforce that.\n\nfor y in years:\n    ziggurat_count = Sum([If(assembly[(y, f)] == Z, 1, 0) for f in factories])\n    solver.add(ziggurat_count == 1)\n\n# No model is manufactured in the same factory in consecutive years.\nfor f in factories:\n    for y in [0,1]:\n        solver.add(assembly[(y, f)] != assembly[(y+1, f)])\n\n# Neither Volantes nor Whispers are assembled in any factory in which Xaviers were assembled the previous year.\nfor f in factories:\n    for y in [0,1]:\n        x_prev = assembly[(y, f)] == X\n        v_curr = assembly[(y+1, f)] == V\n        w_curr = assembly[(y+1, f)] == W\n        solver.add(Implies(x_prev, And(Not(v_curr), Not(w_curr))))\n\n# Neither Volantes nor Xaviers are assembled in any factory in which Ziggurats were assembled the previous year.\nfor f in factories:\n    for y in [0,1]:\n        z_prev = assembly[(y, f)] == Z\n        v_curr = assembly[(y+1, f)] == V\n        x_curr = assembly[(y+1, f)] == X\n        solver.add(Implies(z_prev, And(Not(v_curr), Not(x_curr))))\n\n# Given: in the second year Volantes and Whispers are assembled in F and G, respectively.\nsolver.add(assembly[(1, 'F')] == V)\nsolver.add(assembly[(1, 'G')] == W)\n\n# OPTION CHECKING\n\n# Options for first year models in F and G:\noption_models = [\n    (W, V),  # (A) Whispers and Volantes\n    (W, X),  # (B) Whispers and Xaviers\n    (X, V),  # (C) Xaviers and Volantes\n    (X, Z),  # (D) Xaviers and Ziggurats\n    (Z, V)   # (E) Ziggurats and Volantes\n]\n\nfor i, (f_model, g_model) in enumerate(option_models):\n    solver.push()\n    solver.add(assembly[(0, 'F')] == f_model)\n    solver.add(assembly[(0, 'G')] == g_model)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of seven television programs—H, J, L, P, Q, S, V—is assigned a different rank: from first through seventh (from most popular to least popular). The ranking is consistent with the following conditions: J and L are each less popular than H. J is more popular than Q. S and V are each less popular than L. P and S are each less popular than Q. S is not seventh.\n\nWhich one of the following could be the order of the programs, from most popular to least popular?\n\nOptions:\n(A) J, H, L, Q, V, S, P\n(B) H, L, Q, J, S, P, V\n(C) H, J, Q, L, S, V, P\n(D) H, J, V, L, Q, S, P\n(E) H, L, V, J, Q, P, S",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nprograms = ['H', 'J', 'L', 'P', 'Q', 'S', 'V']\nranks = {p: Int(p) for p in programs}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each program has a rank from 1 (most popular) to 7 (least popular)\nfor p in programs:\n    solver.add(And(ranks[p] >= 1, ranks[p] <= 7))\n\n# All ranks are distinct\nsolver.add(Distinct([ranks[p] for p in programs]))\n\n# J and L are each less popular than H: rank(J) > rank(H), rank(L) > rank(H)\nsolver.add(ranks['J'] > ranks['H'])\nsolver.add(ranks['L'] > ranks['H'])\n\n# J is more popular than Q: rank(J) < rank(Q)\nsolver.add(ranks['J'] < ranks['Q'])\n\n# S and V are each less popular than L: rank(S) > rank(L), rank(V) > rank(L)\nsolver.add(ranks['S'] > ranks['L'])\nsolver.add(ranks['V'] > ranks['L'])\n\n# P and S are each less popular than Q: rank(P) > rank(Q), rank(S) > ranks(Q)\nsolver.add(ranks['P'] > ranks['Q'])\nsolver.add(ranks['S'] > ranks['Q'])\n\n# S is not seventh: rank(S) != 7\nsolver.add(ranks['S'] != 7)\n\n# OPTION CHECKING\noptions = [\n    ['J', 'H', 'L', 'Q', 'V', 'S', 'P'],  # A\n    ['H', 'L', 'Q', 'J', 'S', 'P', 'V'],  # B\n    ['H', 'J', 'Q', 'L', 'S', 'V', 'P'],  # C\n    ['H', 'J', 'V', 'L', 'Q', 'S', 'P'],  # D\n    ['H', 'L', 'V', 'J', 'Q', 'P', 'S']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this specific order: rank of program at position j is j+1\n    for pos, prog in enumerate(option):\n        solver.add(ranks[prog] == pos + 1)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of seven television programs—H, J, L, P, Q, S, V—is assigned a different rank: from first through seventh (from most popular to least popular). The ranking is consistent with the following conditions: J and L are each less popular than H. J is more popular than Q. S and V are each less popular than L. P and S are each less popular than Q. S is not seventh.\n\nIf J is more popular than L, and S is more popular than P, then which one of the following must be true of the ranking?\n\nOptions:\n(A) J is second.\n(B) J is third.\n(C) L is third.\n(D) Q is third.\n(E) P is seventh.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nprograms = ['H', 'J', 'L', 'P', 'Q', 'S', 'V']\nranks = {p: Int(p) for p in programs}  # rank variables: 1 (most popular) to 7 (least popular)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each rank is between 1 and 7\nfor p in programs:\n    solver.add(And(ranks[p] >= 1, ranks[p] <= 7))\n\n# All ranks are distinct\nsolver.add(Distinct([ranks[p] for p in programs]))\n\n# Given conditions:\n# J and L are each less popular than H: rank(J) > rank(H), rank(L) > rank(H)\nsolver.add(ranks['J'] > ranks['H'])\nsolver.add(ranks['L'] > ranks['H'])\n\n# J is more popular than Q: rank(J) < rank(Q)\nsolver.add(ranks['J'] < ranks['Q'])\n\n# S and V are each less popular than L: rank(S) > rank(L), rank(V) > rank(L)\nsolver.add(ranks['S'] > ranks['L'])\nsolver.add(ranks['V'] > ranks['L'])\n\n# P and S are each less popular than Q: rank(P) > rank(Q), rank(S) > rank(Q)\nsolver.add(ranks['P'] > ranks['Q'])\nsolver.add(ranks['S'] > ranks['Q'])\n\n# S is not seventh: rank(S) != 7\nsolver.add(ranks['S'] != 7)\n\n# Additional conditions given in the question to test options:\n# J is more popular than L: rank(J) < rank(L)\nsolver.add(ranks['J'] < ranks['L'])\n\n# S is more popular than P: rank(S) < rank(P)\nsolver.add(ranks['S'] < ranks['P'])\n\n# OPTION CHECKING\n# Options:\n# (A) J is second: rank(J) == 2\n# (B) J is third: rank(J) == 3\n# (C) L is third: rank(L) == 3\n# (D) Q is third: rank(Q) == 3\n# (E) P is seventh: rank(P) == 7\n\noptions = [\n    ranks['J'] == 2,\n    ranks['J'] == 3,\n    ranks['L'] == 3,\n    ranks['Q'] == 3,\n    ranks['P'] == 7\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(Not(opt))  # Check if option can be false\n    if solver.check() == unsat:\n        # If adding Not(opt) makes it unsat, then opt must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of seven television programs—H, J, L, P, Q, S, V—is assigned a different rank: from first through seventh (from most popular to least popular). The ranking is consistent with the following conditions: J and L are each less popular than H. J is more popular than Q. S and V are each less popular than L. P and S are each less popular than Q. S is not seventh.\n\nIf V is more popular than Q and J is less popular than L, then which one of the following could be true of the ranking?\n\nOptions:\n(A) P is more popular than S.\n(B) S is more popular than V.\n(C) P is more popular than L.\n(D) J is more popular than V.\n(E) Q is more popular than V.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nprograms = ['H', 'J', 'L', 'P', 'Q', 'S', 'V']\n\n# Create Z3 Int variables for ranks (1 = most popular, 7 = least popular)\nrank = {p: Int(p) for p in programs}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank is between 1 and 7\nfor p in programs:\n    solver.add(And(rank[p] >= 1, rank[p] <= 7))\n\n# All ranks are distinct\nsolver.add(Distinct([rank[p] for p in programs]))\n\n# J and L are each less popular than H (rank higher number)\nsolver.add(rank['J'] > rank['H'])\nsolver.add(rank['L'] > rank['H'])\n\n# J is more popular than Q\nsolver.add(rank['J'] < rank['Q'])\n\n# S and V are each less popular than L\nsolver.add(rank['S'] > rank['L'])\nsolver.add(rank['V'] > rank['L'])\n\n# P and S are each less popular than Q\nsolver.add(rank['P'] > rank['Q'])\nsolver.add(rank['S'] > rank['Q'])\n\n# S is not seventh\nsolver.add(rank['S'] != 7)\n\n# Additional conditions from the \"If\" clause:\n# V is more popular than Q and J is less popular than L\nsolver.add(rank['V'] < rank['Q'])\nsolver.add(rank['J'] > rank['L'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': rank['P'] < rank['S'],  # P more popular than S\n    'B': rank['S'] < rank['V'],  # S more popular than V\n    'C': rank['P'] < rank['L'],  # P more popular than L\n    'D': rank['J'] < rank['V'],  # J more popular than V\n    'E': rank['Q'] < rank['V'],  # Q more popular than V\n}\n\nfor opt_letter, opt_cond in options.items():\n    solver.push()\n    solver.add(opt_cond)\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Each of seven television programs—H, J, L, P, Q, S, V—is assigned a different rank: from first through seventh (from most popular to least popular). The ranking is consistent with the following conditions: J and L are each less popular than H. J is more popular than Q. S and V are each less popular than L. P and S are each less popular than Q. S is not seventh.\n\nIf Q is more popular than L, then each of the following must be true of the ranking EXCEPT:\n\nOptions:\n(A) H is first.\n(B) L is fourth.\n(C) V is not fourth.\n(D) J is not third.\n(E) Q is third.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nprograms = ['H', 'J', 'L', 'P', 'Q', 'S', 'V']\nranks = {p: Int(p) for p in programs}  # rank: 1 (most popular) to 7 (least popular)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank is between 1 and 7\nfor p in programs:\n    solver.add(And(ranks[p] >= 1, ranks[p] <= 7))\n\n# All ranks are distinct\nsolver.add(Distinct([ranks[p] for p in programs]))\n\n# Given conditions:\n# J and L are each less popular than H -> rank(J) > rank(H), rank(L) > rank(H)\nsolver.add(ranks['J'] > ranks['H'])\nsolver.add(ranks['L'] > ranks['H'])\n\n# J is more popular than Q -> rank(J) < rank(Q)\nsolver.add(ranks['J'] < ranks['Q'])\n\n# S and V are each less popular than L -> rank(S) > rank(L), rank(V) > rank(L)\nsolver.add(ranks['S'] > ranks['L'])\nsolver.add(ranks['V'] > ranks['L'])\n\n# P and S are each less popular than Q -> rank(P) > rank(Q), rank(S) > rank(Q)\nsolver.add(ranks['P'] > ranks['Q'])\nsolver.add(ranks['S'] > ranks['Q'])\n\n# S is not seventh -> rank(S) != 7\nsolver.add(ranks['S'] != 7)\n\n# Additional condition for this problem:\n# Q is more popular than L -> rank(Q) < rank(L)\nsolver.add(ranks['Q'] < ranks['L'])\n\n# OPTION CHECKING\n# We test each option by adding its condition and checking for satisfiability.\n# The correct answer is the one that can be false (i.e., adding the option's negation is satisfiable).\n\noptions = {\n    'A': ranks['H'] == 1,\n    'B': ranks['L'] == 4,\n    'C': ranks['V'] != 4,\n    'D': ranks['J'] != 3,\n    'E': ranks['Q'] == 3,\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    # Add negation of the option's condition: if the negation is satisfiable, option is NOT necessarily true\n    solver.add(Not(cond))\n    if solver.check() == sat:\n        # This option's negation is satisfiable, so this option is the EXCEPTION (not necessarily true)\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.\n\nWhich one of the following could be a complete and accurate list of the birds NOT in the forest?\n\nOptions:\n(A) jays, shrikes\n(B) harriers, grosbeaks\n(C) grosbeaks, jays, martins\n(D) grosbeaks, martins, shrikes, wrens\n(E) martins, shrikes",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbirds = ['grosbeak', 'harrier', 'jay', 'martin', 'shrike', 'wren']\nbird_vars = {b: Bool(b) for b in birds}  # True if bird is in the forest, False otherwise\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1. If harriers are in the forest, then grosbeaks are not.\nharrier_in = bird_vars['harrier']\ngrosbeak_in = bird_vars['grosbeak']\nsolver.add(Implies(harrier_in, Not(grosbeak_in)))\n\n# 2. If jays, martins, or both are in the forest, then so are harriers.\njay_in = bird_vars['jay']\nmartin_in = bird_vars['martin']\nsolver.add(Implies(Or([jay_in, martin_in]), harrier_in))\n\n# 3. If wrens are in the forest, then so are grosbeaks.\nwren_in = bird_vars['wren']\nsolver.add(Implies(wren_in, grosbeak_in))\n\n# 4. If jays are not in the forest, then shrikes are.\nshrike_in = bird_vars['shrike']\nsolver.add(Implies(Not(jay_in), shrike_in))\n\n# OPTION CHECKING\noptions = [\n    ['jay', 'shrike'],                   # A\n    ['harrier', 'grosbeak'],            # B\n    ['grosbeak', 'jay', 'martin'],      # C\n    ['grosbeak', 'martin', 'shrike', 'wren'],  # D\n    ['martin', 'shrike']                 # E\n]\n\nfor i, absent_birds in enumerate(options):\n    solver.push()\n    # Add constraints that the birds in absent_birds are NOT in the forest\n    for b in absent_birds:\n        solver.add(bird_vars[b] == False)\n    # And birds not in absent_birds are in the forest\n    for b in birds:\n        if b not in absent_birds:\n            solver.add(bird_vars[b] == True)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.\n\nIf both martins and harriers are in the forest, then which one of the following must be true?\n\nOptions:\n(A) Shrikes are the only other birds in the forest.\n(B) Jays are the only other birds in the forest.\n(C) The forest contains neither jays nor shrikes.\n(D) There are at least two other kinds of birds in the forest.\n(E) There are at most two other kinds of birds in the forest.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbirds = ['grosbeak', 'harrier', 'jay', 'martin', 'shrike', 'wren']\nbird_vars = {b: Bool(b) for b in birds}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1. If harriers are in the forest, then grosbeaks are not.\nsolver.add(Implies(bird_vars['harrier'], Not(bird_vars['grosbeak'])))\n\n# 2. If jays, martins, or both are in the forest, then so are harriers.\nsolver.add(Implies(Or(bird_vars['jay'], bird_vars['martin']), bird_vars['harrier']))\n\n# 3. If wrens are in the forest, then so are grosbeaks.\nsolver.add(Implies(bird_vars['wren'], bird_vars['grosbeak']))\n\n# 4. If jays are not in the forest, then shrikes are.\nsolver.add(Implies(Not(bird_vars['jay']), bird_vars['shrike']))\n\n# Add condition: both martins and harriers are in the forest\nsolver.add(bird_vars['martin'])\nsolver.add(bird_vars['harrier'])\n\n# OPTION CHECKING\noptions = {\n    'A': And(bird_vars['shrike'],\n             Not(bird_vars['jay']),\n             Not(bird_vars['wren']),\n             Not(bird_vars['grosbeak'])),\n    'B': And(bird_vars['jay'],\n             Not(bird_vars['shrike']),\n             Not(bird_vars['wren']),\n             Not(bird_vars['grosbeak'])),\n    'C': And(Not(bird_vars['jay']),\n             Not(bird_vars['shrike'])),\n    'D': Sum([If(bird_vars[b], 1, 0) for b in birds if b not in ['martin', 'harrier']]) >= 2,\n    'E': Sum([If(bird_vars[b], 1, 0) for b in birds if b not in ['martin', 'harrier']]) <= 2,\n}\n\nfor letter, option_constraint in options.items():\n    solver.push()\n    solver.add(Not(option_constraint))  # Try to find a counterexample to the option\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.\n\nIf jays are not in the forest, then which one of the following must be false?\n\nOptions:\n(A) Martins are in the forest.\n(B) Harriers are in the forest.\n(C) Neither martins nor harriers are in the forest.\n(D) Neither martins nor shrikes are in the forest.\n(E) Harriers and shrikes are the only birds in the forest.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbirds = ['grosbeak', 'harrier', 'jay', 'martin', 'shrike', 'wren']\nbird_vars = {b: Bool(b) for b in birds}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# If harriers are in the forest, then grosbeaks are not.\nsolver.add(Implies(bird_vars['harrier'], Not(bird_vars['grosbeak'])))\n\n# If jays, martins, or both are in the forest, then so are harriers.\nsolver.add(Implies(Or([bird_vars['jay'], bird_vars['martin']]), bird_vars['harrier']))\n\n# If wrens are in the forest, then so are grosbeaks.\nsolver.add(Implies(bird_vars['wren'], bird_vars['grosbeak']))\n\n# If jays are not in the forest, then shrikes are.\nsolver.add(Implies(Not(bird_vars['jay']), bird_vars['shrike']))\n\n# Given: jays are not in the forest\nsolver.add(Not(bird_vars['jay']))\n\n# OPTION CHECKING\n# Each option is tested by adding its statement and checking for satisfiability\n\noptions = {\n    'A': bird_vars['martin'],\n    'B': bird_vars['harrier'],\n    'C': And(Not(bird_vars['martin']), Not(bird_vars['harrier'])),\n    'D': And(Not(bird_vars['martin']), Not(bird_vars['shrike'])),\n    'E': And(bird_vars['harrier'], bird_vars['shrike'],\n             Not(bird_vars['grosbeak']), Not(bird_vars['jay']),\n             Not(bird_vars['martin']), Not(bird_vars['wren']))\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.\n\nWhich one of the following pairs of birds CANNOT be among those birds contained in the forest?\n\nOptions:\n(A) jays, wrens\n(B) jays, shrikes\n(C) shrikes, wrens\n(D) jays, martins\n(E) shrikes, martins",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbirds = ['grosbeak', 'harrier', 'jay', 'martin', 'shrike', 'wren']\nbird_vars = {b: Bool(b) for b in birds}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# If harriers are in the forest, then grosbeaks are not.\nsolver.add(Implies(bird_vars['harrier'], Not(bird_vars['grosbeak'])))\n\n# If jays, martins, or both are in the forest, then so are harriers.\nsolver.add(Implies(Or([bird_vars['jay'], bird_vars['martin']]), bird_vars['harrier']))\n\n# If wrens are in the forest, then so are grosbeaks.\nsolver.add(Implies(bird_vars['wren'], bird_vars['grosbeak']))\n\n# If jays are not in the forest, then shrikes are.\nsolver.add(Implies(Not(bird_vars['jay']), bird_vars['shrike']))\n\n# OPTION CHECKING\noptions = {\n    'A': ['jay', 'wren'],\n    'B': ['jay', 'shrike'],\n    'C': ['shrike', 'wren'],\n    'D': ['jay', 'martin'],\n    'E': ['shrike', 'martin']\n}\n\nfor letter, pair in options.items():\n    solver.push()\n    # Add constraints that both birds in the pair are in the forest\n    solver.add(And([bird_vars[b] for b in pair]))\n    # Check if the constraints are satisfiable with these birds present\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.\n\nIf grosbeaks are in the forest, then which one of the following must be true?\n\nOptions:\n(A) Shrikes are in the forest.\n(B) Wrens are in the forest.\n(C) The forest contains both wrens and shrikes.\n(D) At most two kinds of birds are in the forest.\n(E) At least three kinds of birds are in the forest.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbirds = ['grosbeak', 'harrier', 'jay', 'martin', 'shrike', 'wren']\n\n# Create Bool variables for each bird indicating presence in the forest\npresence = {b: Bool(b) for b in birds}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1. If harriers are in the forest, then grosbeaks are not.\nconstraint1 = Implies(presence['harrier'], Not(presence['grosbeak']))\nsolver.add(constraint1)\n\n# 2. If jays, martins, or both are in the forest, then so are harriers.\njay_or_martin = Or(presence['jay'], presence['martin'])\nconstraint2 = Implies(jay_or_martin, presence['harrier'])\nsolver.add(constraint2)\n\n# 3. If wrens are in the forest, then so are grosbeaks.\nconstraint3 = Implies(presence['wren'], presence['grosbeak'])\nsolver.add(constraint3)\n\n# 4. If jays are not in the forest, then shrikes are.\nconstraint4 = Implies(Not(presence['jay']), presence['shrike'])\nsolver.add(constraint4)\n\n# OPTION CHECKING\n# We assume grosbeaks are in the forest and test each option to see which must be true.\n\n# Fix grosbeak presence to True\nsolver.add(presence['grosbeak'] == True)\n\noptions_constraints = []\n\n# (A) Shrikes are in the forest.\noptions_constraints.append(presence['shrike'] == True)\n\n# (B) Wrens are in the forest.\noptions_constraints.append(presence['wren'] == True)\n\n# (C) The forest contains both wrens and shrikes.\noptions_constraints.append(And(presence['wren'] == True, presence['shrike'] == True))\n\n# (D) At most two kinds of birds are in the forest.\nnum_birds = Sum([If(presence[b], 1, 0) for b in birds])\noptions_constraints.append(num_birds <= 2)\n\n# (E) At least three kinds of birds are in the forest.\noptions_constraints.append(num_birds >= 3)\n\nfor i, opt_constraint in enumerate(options_constraints):\n    solver.push()\n    # Add negation of option constraint to test if option must be true\n    solver.add(Not(opt_constraint))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Bird-watchers explore a forest to see which of the following six kinds of birds—grosbeak, harrier, jay, martin, shrike, wren—it contains. The findings are consistent with the following conditions: If harriers are in the forest, then grosbeaks are not. If jays, martins, or both are in the forest, then so are harriers. If wrens are in the forest, then so are grosbeaks. If jays are not in the forest, then shrikes are.\n\nSuppose the condition is added that if shrikes are in the forest, then harriers are not. If all other conditions remain in effect, then which one of the following could be true?\n\nOptions:\n(A) The forest contains both jays and shrikes.\n(B) The forest contains both wrens and shrikes.\n(C) The forest contains both martins and shrikes.\n(D) Jays are not in the forest, whereas martins are.\n(E) Only two of the six kinds of birds are not in the forest.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbirds = ['grosbeak', 'harrier', 'jay', 'martin', 'shrike', 'wren']\nbird_vars = {b: Bool(b) for b in birds}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# If harriers are in the forest, then grosbeaks are not.\nsolver.add(Implies(bird_vars['harrier'], Not(bird_vars['grosbeak'])))\n\n# If jays, martins, or both are in the forest, then so are harriers.\nsolver.add(Implies(Or(bird_vars['jay'], bird_vars['martin']), bird_vars['harrier']))\n\n# If wrens are in the forest, then so are grosbeaks.\nsolver.add(Implies(bird_vars['wren'], bird_vars['grosbeak']))\n\n# If jays are not in the forest, then shrikes are.\nsolver.add(Implies(Not(bird_vars['jay']), bird_vars['shrike']))\n\n# Added condition: If shrikes are in the forest, then harriers are not.\nsolver.add(Implies(bird_vars['shrike'], Not(bird_vars['harrier'])))\n\n# OPTION CHECKING\noptions = [\n    # (A) The forest contains both jays and shrikes.\n    And(bird_vars['jay'], bird_vars['shrike']),\n    \n    # (B) The forest contains both wrens and shrikes.\n    And(bird_vars['wren'], bird_vars['shrike']),\n    \n    # (C) The forest contains both martins and shrikes.\n    And(bird_vars['martin'], bird_vars['shrike']),\n    \n    # (D) Jays are not in the forest, whereas martins are.\n    And(Not(bird_vars['jay']), bird_vars['martin']),\n    \n    # (E) Only two of the six kinds of birds are not in the forest.\n    Sum([If(bird_vars[b], 0, 1) for b in birds]) == 2\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.\n\nWhich one of the following could be the selection of stones?\n\nOptions:\n(A) F, G, H, M, X, Y\n(B) F, G, J, K, M, W\n(C) F, G, J, K, W, X\n(D) G, H, J, X, Y, Z\n(E) G, H, K, W, X, Z",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstones = ['F', 'G', 'H', 'J', 'K', 'M', 'W', 'X', 'Y', 'Z']\nrubies = ['F', 'G', 'H']\nsapphires = ['J', 'K', 'M']\ntopazes = ['W', 'X', 'Y', 'Z']\n\n# Create a Bool variable for each stone indicating if it is selected\nselected = {s: Bool(s) for s in stones}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly six stones selected\nsolver.add(Sum([If(selected[s], 1, 0) for s in stones]) == 6)\n\n# At least two topazes selected\nsolver.add(Sum([If(selected[s], 1, 0) for s in topazes]) >= 2)\n\n# If exactly two sapphires selected, exactly one ruby is selected\nnum_sapphires = Sum([If(selected[s], 1, 0) for s in sapphires])\nnum_rubies = Sum([If(selected[s], 1, 0) for s in rubies])\ncond_sapp_two = num_sapphires == 2\ncond_ruby_one = num_rubies == 1\nsolver.add(Implies(cond_sapp_two, cond_ruby_one))\n\n# If W is selected, neither H nor Z is selected\nsolver.add(Implies(selected['W'], And(Not(selected['H']), Not(selected['Z']))))\n\n# If M is selected, W is also selected\nsolver.add(Implies(selected['M'], selected['W']))\n\n# OPTION CHECKING\noptions = [\n    ['F', 'G', 'H', 'M', 'X', 'Y'],  # A\n    ['F', 'G', 'J', 'K', 'M', 'W'],  # B\n    ['F', 'G', 'J', 'K', 'W', 'X'],  # C\n    ['G', 'H', 'J', 'X', 'Y', 'Z'],  # D\n    ['G', 'H', 'K', 'W', 'X', 'Z'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that exactly these stones are selected\n    for s in stones:\n        if s in option:\n            solver.add(selected[s] == True)\n        else:\n            solver.add(selected[s] == False)\n    check_result = solver.check()\n    if check_result == sat:\n        print(f\"'{chr(65+i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.\n\nWhich one of the following most be true?\n\nOptions:\n(A) G is selected.\n(B) J is selected.\n(C) X is selected.\n(D) Of at least one of the three types of stones, exactly one stone is selected.\n(E) Of at least one of the three types of stones, exactly three stones are selected.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstones = ['F', 'G', 'H', 'J', 'K', 'M', 'W', 'X', 'Y', 'Z']\nrubies = ['F', 'G', 'H']\nsapphires = ['J', 'K', 'M']\ntopazes = ['W', 'X', 'Y', 'Z']\n\n# Create selection variables: 1 if selected, 0 if not\nselection = {s: Int(s) for s in stones}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each selection variable is 0 or 1\nfor s in stones:\n    solver.add(Or(selection[s] == 0, selection[s] == 1))\n\n# Exactly six stones selected\nsolver.add(Sum([selection[s] for s in stones]) == 6)\n\n# At least two topazes selected\nsolver.add(Sum([selection[s] for s in topazes]) >= 2)\n\n# If exactly two sapphires selected, then exactly one ruby selected\nnum_sapphires = Sum([selection[s] for s in sapphires])\nnum_rubies = Sum([selection[s] for s in rubies])\nsolver.add(Implies(num_sapphires == 2, num_rubies == 1))\n\n# If W selected, then neither H nor Z selected\nsolver.add(Implies(selection['W'] == 1, And(selection['H'] == 0, selection['Z'] == 0)))\n\n# If M selected, then W also selected\nsolver.add(Implies(selection['M'] == 1, selection['W'] == 1))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) G is selected\n    selection['G'] == 1,\n    # (B) J is selected\n    selection['J'] == 1,\n    # (C) X is selected\n    selection['X'] == 1,\n    # (D) Of at least one of the three types of stones, exactly one stone is selected\n    Or([\n        num_rubies == 1,\n        num_sapphires == 1,\n        Sum([selection[s] for s in topazes]) == 1\n    ]),\n    # (E) Of at least one of the three types of stones, exactly three stones are selected\n    Or([\n        num_rubies == 3,\n        num_sapphires == 3,\n        Sum([selection[s] for s in topazes]) == 3\n    ])\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(Not(option))  # Add negation of the option to check if it's necessarily true\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.\n\nIf Z is selected, which one of the following could be true?\n\nOptions:\n(A) All three of the sapphires are selected.\n(B) Both J and M are selected.\n(C) Both K and M are selected.\n(D) None of the rubies is selected.\n(E) None of the sapphires is selected.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstones = ['F', 'G', 'H', 'J', 'K', 'M', 'W', 'X', 'Y', 'Z']\nrubies = ['F', 'G', 'H']\nsapphires = ['J', 'K', 'M']\ntopazes = ['W', 'X', 'Y', 'Z']\n\n# Create a Bool variable for each stone indicating whether it is selected (True) or not (False)\nselected = {s: Bool(s) for s in stones}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly six stones are selected\nsolver.add(Sum([If(selected[s], 1, 0) for s in stones]) == 6)\n\n# At least two of the topazes are selected\nsolver.add(Sum([If(selected[s], 1, 0) for s in topazes]) >= 2)\n\n# If exactly two sapphires are selected, exactly one ruby is selected\nnum_sapphires = Sum([If(selected[s], 1, 0) for s in sapphires])\nnum_rubies = Sum([If(selected[s], 1, 0) for s in rubies])\nsolver.add(Implies(num_sapphires == 2, num_rubies == 1))\n\n# If W is selected, neither H nor Z is selected\nsolver.add(Implies(selected['W'], And(Not(selected['H']), Not(selected['Z']))))\n\n# If M is selected, W is also selected\nsolver.add(Implies(selected['M'], selected['W']))\n\n# Z is selected (given condition)\nsolver.add(selected['Z'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': And(num_sapphires == 3),\n    'B': And(selected['J'], selected['M']),\n    'C': And(selected['K'], selected['M']),\n    'D': num_rubies == 0,\n    'E': num_sapphires == 0,\n}\n\nfor letter, option_constraint in options.items():\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.\n\nIf exactly two rubies are selected, which one of the following must be true?\n\nOptions:\n(A) H is selected.\n(B) J is selected.\n(C) Z is selected.\n(D) Exactly one sapphire is selected.\n(E) Exactly two topazes are selected.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nstones = ['F', 'G', 'H', 'J', 'K', 'M', 'W', 'X', 'Y', 'Z']\nrubies = ['F', 'G', 'H']\nsapphires = ['J', 'K', 'M']\ntopazes = ['W', 'X', 'Y', 'Z']\n\n# Create a Bool variable for each stone indicating if it is selected\nselected = {s: Bool(s) for s in stones}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly 6 stones selected\nsolver.add(Sum([If(selected[s], 1, 0) for s in stones]) == 6)\n\n# At least two topazes selected\nsolver.add(Sum([If(selected[s], 1, 0) for s in topazes]) >= 2)\n\n# If exactly two sapphires selected, then exactly one ruby selected\nnum_sapphires = Sum([If(selected[s], 1, 0) for s in sapphires])\nnum_rubies = Sum([If(selected[s], 1, 0) for s in rubies])\ncond1 = num_sapphires == 2\ncond2 = num_rubies == 1\nsolver.add(Implies(cond1, cond2))\n\n# If W is selected, then neither H nor Z is selected\nsolver.add(Implies(selected['W'], And(Not(selected['H']), Not(selected['Z']))))\n\n# If M is selected, W is also selected\nsolver.add(Implies(selected['M'], selected['W']))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) H is selected.\n    selected['H'],\n    # (B) J is selected.\n    selected['J'],\n    # (C) Z is selected.\n    selected['Z'],\n    # (D) Exactly one sapphire is selected.\n    num_sapphires == 1,\n    # (E) Exactly two topazes are selected.\n    Sum([If(selected[s], 1, 0) for s in topazes]) == 2\n]\n\n# We add the condition: exactly two rubies selected\nsolver.add(num_rubies == 2)\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add negation of the option to test if option must be true\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.\n\nWhich one of the following must be true?\n\nOptions:\n(A) The selection of stones includes at least one ruby.\n(B) The selection of stones includes at most two rubies.\n(C) The selection of stones includes either F or Z, or both.\n(D) The selection of stones includes either X or Y, or both.\n(E) The selection of stones includes either X or Z, or both.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstones = ['F', 'G', 'H', 'J', 'K', 'M', 'W', 'X', 'Y', 'Z']\nrubies = ['F', 'G', 'H']\nsapphires = ['J', 'K', 'M']\ntopazes = ['W', 'X', 'Y', 'Z']\n\n# Create a Bool variable for each stone indicating if it is selected\nselected = {s: Bool(s) for s in stones}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly six stones are selected\nsolver.add(Sum([If(selected[s], 1, 0) for s in stones]) == 6)\n\n# At least two topazes are selected\nsolver.add(Sum([If(selected[s], 1, 0) for s in topazes]) >= 2)\n\n# If exactly two sapphires are selected, exactly one ruby is selected\nnum_sapphires = Sum([If(selected[s], 1, 0) for s in sapphires])\nnum_rubies = Sum([If(selected[s], 1, 0) for s in rubies])\nexactly_two_sapphires = num_sapphires == 2\nexactly_one_ruby = num_rubies == 1\nsolver.add(Implies(exactly_two_sapphires, exactly_one_ruby))\n\n# If W is selected, neither H nor Z is selected\nsolver.add(Implies(selected['W'], And(Not(selected['H']), Not(selected['Z']))))\n\n# If M is selected, W is also selected\nsolver.add(Implies(selected['M'], selected['W']))\n\n# OPTION CHECKING\noptions = [\n    # (A) The selection of stones includes at least one ruby.\n    Sum([If(selected[s], 1, 0) for s in rubies]) >= 1,\n    # (B) The selection of stones includes at most two rubies.\n    Sum([If(selected[s], 1, 0) for s in rubies]) <= 2,\n    # (C) The selection of stones includes either F or Z, or both.\n    Or(selected['F'], selected['Z']),\n    # (D) The selection of stones includes either X or Y, or both.\n    Or(selected['X'], selected['Y']),\n    # (E) The selection of stones includes either X or Z, or both.\n    Or(selected['X'], selected['Z']),\n]\n\nfor i, option_constraint in enumerate(options):\n    solver.push()\n    # Add negation of option to check if it can be false\n    solver.add(Not(option_constraint))\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "From among ten stones, a jeweler will select six, one for each of six rings. Of the stones, three—F, G, and H—are rubies; three—J, K, and M—are sapphires; and four—W, X, Y, and Z—are topazes. The selection of stones must meet the following restrictions: At least two of the topazes are selected. If exactly two of the sapphires are selected, exactly one of the rubies is selected. If W is selected, neither H nor Z is selected. If M is selected, W is also selected.\n\nIf J and M are the only sapphires selected, which one of the following could be true?\n\nOptions:\n(A) F and G are both selected.\n(B) F and X are both selected.\n(C) G and H are both selected.\n(D) G and K are both selected.\n(E) Y and Z are both selected.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstones = ['F', 'G', 'H', 'J', 'K', 'M', 'W', 'X', 'Y', 'Z']\nrubies = ['F', 'G', 'H']\nsapphires = ['J', 'K', 'M']\ntopazes = ['W', 'X', 'Y', 'Z']\n\n# Create a Bool variable for each stone indicating if it is selected\nselected = {s: Bool(s) for s in stones}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Exactly six stones are selected\nsolver.add(Sum([If(selected[s], 1, 0) for s in stones]) == 6)\n\n# At least two of the topazes are selected\nsolver.add(Sum([If(selected[t], 1, 0) for t in topazes]) >= 2)\n\n# If exactly two of the sapphires are selected, exactly one of the rubies is selected\nnum_sapphires_selected = Sum([If(selected[s], 1, 0) for s in sapphires])\nnum_rubies_selected = Sum([If(selected[r], 1, 0) for r in rubies])\ncond_sapp_two = (num_sapphires_selected == 2)\ncond_rub_one = (num_rubies_selected == 1)\nsolver.add(Implies(cond_sapp_two, cond_rub_one))\n\n# If W is selected, neither H nor Z is selected\nsolver.add(Implies(selected['W'], And(Not(selected['H']), Not(selected['Z']))))\n\n# If M is selected, W is also selected\nsolver.add(Implies(selected['M'], selected['W']))\n\n# The condition given in the question: J and M are the only sapphires selected\n# So J and M selected, K not selected\nsolver.add(selected['J'])\nsolver.add(selected['M'])\nsolver.add(Not(selected['K']))\n\n# OPTION CHECKING\noptions = {\n    'A': And(selected['F'], selected['G']),\n    'B': And(selected['F'], selected['X']),\n    'C': And(selected['G'], selected['H']),\n    'D': And(selected['G'], selected['K']),\n    'E': And(selected['Y'], selected['Z']),\n}\n\nfor letter, option_cond in options.items():\n    solver.push()\n    solver.add(option_cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "There are exactly ten stores and no other buildings on Oak Street. On the north side of the street, from west to east, are stores 1, 3, 5, 7, and 9; on the south side of the street, also from west to east, are stores 2, 4, 6, 8, and 10. The stores on the north side are located directly across the street from those on the south side, facing each other in pairs, as follows: 1 and 2; 3 and 4; 5 and 6; 7 and 8; 9 and 10. Each store is decorated with lights in exactly one of the following colors: green, red, and yellow. The stores have been decorated with lights according to the following conditions: No store is decorated with lights of the same color as those of any store adjacent to it. No store is decorated with lights of the same color as those of the store directly across the street from it. Yellow lights decorate exactly one store on each side of the street. Red lights decorate store 4. Yellow lights decorate store 5.\n\nWhich one of the following could be an accurate list of the colors of the lights that decorate stores 2, 4, 6, 8, and 10, respectively?\n\nOptions:\n(A) green, red, green, red, green\n(B) green, red, green, yellow, red\n(C) green, red, yellow, red, green\n(D) yellow, green, red, green, red\n(E) yellow, red, green, red, yellow",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstores = list(range(1, 11))\nnorth_stores = [1, 3, 5, 7, 9]\nsouth_stores = [2, 4, 6, 8, 10]\n\ncolors = ['green', 'red', 'yellow']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Create Z3 Int variables for each store's color\nstore_colors = {s: Int(f'store_{s}') for s in stores}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each store color must be one of the color indices\nfor s in stores:\n    solver.add(And(store_colors[s] >= 0, store_colors[s] < len(colors)))\n\n# No store has the same color as any adjacent store\n# Adjacent stores on north side (west to east)\nfor i in range(len(north_stores) - 1):\n    s1 = north_stores[i]\n    s2 = north_stores[i + 1]\n    solver.add(store_colors[s1] != store_colors[s2])\n\n# Adjacent stores on south side (west to east)\nfor i in range(len(south_stores) - 1):\n    s1 = south_stores[i]\n    s2 = south_stores[i + 1]\n    solver.add(store_colors[s1] != store_colors[s2])\n\n# Stores directly across the street do not have the same color\nfor i in range(len(north_stores)):\n    n = north_stores[i]\n    s = south_stores[i]\n    solver.add(store_colors[n] != store_colors[s])\n\n# Yellow lights decorate exactly one store on each side\nnorth_yellow_count = Sum([If(store_colors[s] == color_indices['yellow'], 1, 0) for s in north_stores])\nsouth_yellow_count = Sum([If(store_colors[s] == color_indices['yellow'], 1, 0) for s in south_stores])\nsolver.add(north_yellow_count == 1)\nsolver.add(south_yellow_count == 1)\n\n# Red lights decorate store 4\nsolver.add(store_colors[4] == color_indices['red'])\n\n# Yellow lights decorate store 5\nsolver.add(store_colors[5] == color_indices['yellow'])\n\n# OPTION CHECKING\noptions = [\n    ['green', 'red', 'green', 'red', 'green'],   # A\n    ['green', 'red', 'green', 'yellow', 'red'],  # B\n    ['green', 'red', 'yellow', 'red', 'green'],  # C\n    ['yellow', 'green', 'red', 'green', 'red'],  # D\n    ['yellow', 'red', 'green', 'red', 'yellow']  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for stores 2,4,6,8,10 colors according to option\n    for idx, s in enumerate(south_stores):\n        solver.add(store_colors[s] == color_indices[option[idx]])\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "There are exactly ten stores and no other buildings on Oak Street. On the north side of the street, from west to east, are stores 1, 3, 5, 7, and 9; on the south side of the street, also from west to east, are stores 2, 4, 6, 8, and 10. The stores on the north side are located directly across the street from those on the south side, facing each other in pairs, as follows: 1 and 2; 3 and 4; 5 and 6; 7 and 8; 9 and 10. Each store is decorated with lights in exactly one of the following colors: green, red, and yellow. The stores have been decorated with lights according to the following conditions: No store is decorated with lights of the same color as those of any store adjacent to it. No store is decorated with lights of the same color as those of the store directly across the street from it. Yellow lights decorate exactly one store on each side of the street. Red lights decorate store 4. Yellow lights decorate store 5.\n\nWhich one of the following statements must be true?\n\nOptions:\n(A) Green lights decorate store 10.\n(B) Red lights decorate store 1.\n(C) Red lights decorate store 8.\n(D) Yellow lights decorate store 8.\n(E) Yellow lights decorate store 10.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstores = list(range(1, 11))\ncolors = ['green', 'red', 'yellow']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Create Z3 Int variables for each store's color\nstore_color = {s: Int(f'store_{s}_color') for s in stores}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each store's color is one of the three colors\nfor s in stores:\n    solver.add(And(store_color[s] >= 0, store_color[s] < len(colors)))\n\n# Stores on the north side: 1,3,5,7,9\nnorth = [1,3,5,7,9]\n# Stores on the south side: 2,4,6,8,10\nsouth = [2,4,6,8,10]\n\n# Adjacent stores on north side (west to east): pairs (1,3), (3,5), (5,7), (7,9)\nfor i in range(len(north)-1):\n    s1 = north[i]\n    s2 = north[i+1]\n    # No same color adjacent\n    solver.add(store_color[s1] != store_color[s2])\n\n# Adjacent stores on south side (west to east): pairs (2,4), (4,6), (6,8), (8,10)\nfor i in range(len(south)-1):\n    s1 = south[i]\n    s2 = south[i+1]\n    # No same color adjacent\n    solver.add(store_color[s1] != store_color[s2])\n\n# Stores directly across the street must have different colors:\n# pairs: (1,2), (3,4), (5,6), (7,8), (9,10)\nacross_pairs = [(1,2), (3,4), (5,6), (7,8), (9,10)]\nfor s1, s2 in across_pairs:\n    solver.add(store_color[s1] != store_color[s2])\n\n# Exactly one yellow on each side\nyellow_idx = color_indices['yellow']\nnorth_yellow_count = Sum([If(store_color[s] == yellow_idx, 1, 0) for s in north])\nsouth_yellow_count = Sum([If(store_color[s] == yellow_idx, 1, 0) for s in south])\nsolver.add(north_yellow_count == 1)\nsolver.add(south_yellow_count == 1)\n\n# Red lights decorate store 4\nred_idx = color_indices['red']\nsolver.add(store_color[4] == red_idx)\n\n# Yellow lights decorate store 5\nsolver.add(store_color[5] == yellow_idx)\n\n# OPTION CHECKING\n\noptions = [\n    ('A', store_color[10] == color_indices['green']),\n    ('B', store_color[1] == red_idx),\n    ('C', store_color[8] == red_idx),\n    ('D', store_color[8] == yellow_idx),\n    ('E', store_color[10] == yellow_idx)\n]\n\nfor letter, condition in options:\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        model = solver.model()\n        # Now check if the negation is possible (to confirm must be true)\n        solver.pop()\n        solver.push()\n        solver.add(Not(condition))\n        if solver.check() == unsat:\n            print(f\"'{letter}'\")\n            break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "There are exactly ten stores and no other buildings on Oak Street. On the north side of the street, from west to east, are stores 1, 3, 5, 7, and 9; on the south side of the street, also from west to east, are stores 2, 4, 6, 8, and 10. The stores on the north side are located directly across the street from those on the south side, facing each other in pairs, as follows: 1 and 2; 3 and 4; 5 and 6; 7 and 8; 9 and 10. Each store is decorated with lights in exactly one of the following colors: green, red, and yellow. The stores have been decorated with lights according to the following conditions: No store is decorated with lights of the same color as those of any store adjacent to it. No store is decorated with lights of the same color as those of the store directly across the street from it. Yellow lights decorate exactly one store on each side of the street. Red lights decorate store 4. Yellow lights decorate store 5.\n\nIf green lights decorate five stores on the street, then which one of the following statements must be true?\n\nOptions:\n(A) Green lights decorate store 9.\n(B) Red lights decorate store 2.\n(C) Red lights decorate store 7.\n(D) Red lights decorate store 10.\n(E) Yellow lights decorate store 8.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstores = list(range(1, 11))\ncolors = ['green', 'red', 'yellow']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Create Z3 Int variables for each store's color\nstore_color = {s: Int(f'store_{s}_color') for s in stores}\n\n# Sides of the street\nnorth_side = [1, 3, 5, 7, 9]\nsouth_side = [2, 4, 6, 8, 10]\n\n# Adjacent stores on the same side (west to east)\nadjacent_north = [(1,3), (3,5), (5,7), (7,9)]\nadjacent_south = [(2,4), (4,6), (6,8), (8,10)]\n\n# Across the street pairs\nacross_pairs = [(1,2), (3,4), (5,6), (7,8), (9,10)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each store's color is one of green(0), red(1), yellow(2)\nfor s in stores:\n    solver.add(And(store_color[s] >= 0, store_color[s] < len(colors)))\n\n# No store has the same color as any adjacent store on the same side\nfor (a,b) in adjacent_north:\n    solver.add(store_color[a] != store_color[b])\nfor (a,b) in adjacent_south:\n    solver.add(store_color[a] != store_color[b])\n\n# No store has the same color as the store directly across the street\nfor (a,b) in across_pairs:\n    solver.add(store_color[a] != store_color[b])\n\n# Yellow lights decorate exactly one store on each side\nyellow = color_indices['yellow']\nsolver.add(Sum([If(store_color[s] == yellow, 1, 0) for s in north_side]) == 1)\nsolver.add(Sum([If(store_color[s] == yellow, 1, 0) for s in south_side]) == 1)\n\n# Red lights decorate store 4\nred = color_indices['red']\nsolver.add(store_color[4] == red)\n\n# Yellow lights decorate store 5\nsolver.add(store_color[5] == yellow)\n\n# Green lights decorate five stores total\ngreen = color_indices['green']\nsolver.add(Sum([If(store_color[s] == green, 1, 0) for s in stores]) == 5)\n\n# OPTION CHECKING\noptions = [\n    ('A', store_color[9] == green),  # Green lights decorate store 9\n    ('B', store_color[2] == red),    # Red lights decorate store 2\n    ('C', store_color[7] == red),    # Red lights decorate store 7\n    ('D', store_color[10] == red),   # Red lights decorate store 10\n    ('E', store_color[8] == yellow)  # Yellow lights decorate store 8\n]\n\nfor letter, condition in options:\n    solver.push()\n    solver.add(Not(condition))  # Check if condition can be false\n    if solver.check() == unsat:\n        # Condition must be true in all solutions\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "There are exactly ten stores and no other buildings on Oak Street. On the north side of the street, from west to east, are stores 1, 3, 5, 7, and 9; on the south side of the street, also from west to east, are stores 2, 4, 6, 8, and 10. The stores on the north side are located directly across the street from those on the south side, facing each other in pairs, as follows: 1 and 2; 3 and 4; 5 and 6; 7 and 8; 9 and 10. Each store is decorated with lights in exactly one of the following colors: green, red, and yellow. The stores have been decorated with lights according to the following conditions: No store is decorated with lights of the same color as those of any store adjacent to it. No store is decorated with lights of the same color as those of the store directly across the street from it. Yellow lights decorate exactly one store on each side of the street. Red lights decorate store 4. Yellow lights decorate store 5.\n\nSuppose that yellow lights decorate exactly two stores, not just one, on the south side of the street and decorate exactly one store on the north side. If all of the other conditions remain the same, then which one of the following statements must be true?\n\nOptions:\n(A) Green lights decorate store 1.\n(B) Red lights decorate store 7.\n(C) Red lights decorate store 10.\n(D) Yellow lights decorate store 2.\n(E) Yellow lights decorate store 8.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nstores = list(range(1, 11))\ncolors = ['green', 'red', 'yellow']\ncolor_indices = {c: i for i, c in enumerate(colors)}\n\n# Create Z3 Int variables for each store's color\nstore_color = {}\nfor s in stores:\n    store_color[s] = Int(f'store_{s}_color')\n\nsolver = Solver()\n\n# Each store's color is one of green(0), red(1), yellow(2)\nfor s in stores:\n    solver.add(And(store_color[s] >= 0, store_color[s] < len(colors)))\n\n# Define adjacency for north side stores (1,3,5,7,9)\nnorth_stores = [1, 3, 5, 7, 9]\nnorth_adjacent_pairs = [(1,3), (3,5), (5,7), (7,9)]\n\n# Define adjacency for south side stores (2,4,6,8,10)\nsouth_stores = [2, 4, 6, 8, 10]\nsouth_adjacent_pairs = [(2,4), (4,6), (6,8), (8,10)]\n\n# Pairs across the street\nacross_pairs = [(1,2), (3,4), (5,6), (7,8), (9,10)]\n\n# CONSTRAINTS\n\n# No store has the same color as any adjacent store (north side adjacency)\nfor (a, b) in north_adjacent_pairs:\n    solver.add(store_color[a] != store_color[b])\n\n# No store has the same color as any adjacent store (south side adjacency)\nfor (a, b) in south_adjacent_pairs:\n    solver.add(store_color[a] != store_color[b])\n\n# No store has the same color as the store directly across the street\nfor (a, b) in across_pairs:\n    solver.add(store_color[a] != store_color[b])\n\n# Red lights decorate store 4\nsolver.add(store_color[4] == color_indices['red'])\n\n# Yellow lights decorate store 5\nsolver.add(store_color[5] == color_indices['yellow'])\n\n# Original condition: Yellow lights decorate exactly one store on each side\n# New condition: Yellow lights decorate exactly two stores on south side and exactly one on north side\n# So yellow count on north side = 1\nnorth_yellow = [store_color[s] == color_indices['yellow'] for s in north_stores]\nsolver.add(Sum([If(cond, 1, 0) for cond in north_yellow]) == 1)\n\n# yellow count on south side = 2\nsouth_yellow = [store_color[s] == color_indices['yellow'] for s in south_stores]\nsolver.add(Sum([If(cond, 1, 0) for cond in south_yellow]) == 2)\n\n# OPTION CHECKING\n\noptions = {\n    'A': store_color[1] == color_indices['green'],\n    'B': store_color[7] == color_indices['red'],\n    'C': store_color[10] == color_indices['red'],\n    'D': store_color[2] == color_indices['yellow'],\n    'E': store_color[8] == color_indices['yellow'],\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Jill, Kurt, Larisa, Manny, and Olga are the clerks in a supermarket. The supermarket has exactly nine parallel aisles, numbered consecutively 1 through 9 from one end of the store to the other. Each aisle is stocked by exactly one clerk and no clerk stocks more than two aisles. Stocking assignments must meet the following conditions: Olga stocks exactly one aisle. Kurt stocks aisle 2. Manny does not stock aisle 1. Jill does not stock consecutive aisles. Kurt stocks the only aisle between the two aisles Manny stocks. Exactly one of Larisa's aisles is an end aisle. Olga's aisle is numbered higher than either of Kurt's aisles, and lower than at least one of Larisa's.\n\nIf Jill stocks aisle 3, then which one of the following CANNOT be true?\n\nOptions:\n(A) Jill stocks aisle 9.\n(B) Kurt stocks aisle 6.\n(C) Larisa stocks aisle 4.\n(D) Manny stocks aisle 4.\n(E) Olga stocks aisle 6.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclerks = ['Jill', 'Kurt', 'Larisa', 'Manny', 'Olga']\naisles = list(range(1, 10))  # aisles 1 through 9\n\n# Each clerk stocks either 1 or 2 aisles, except Olga who stocks exactly 1 aisle\n# Represent aisles stocked by each clerk as sorted lists of Int variables (length 2 for all except Olga length 1)\n# For uniformity, represent all as length 2 lists; for Olga second aisle is 0 (invalid)\naisle_vars = {}\nfor c in clerks:\n    if c == 'Olga':\n        aisle_vars[c] = [Int(f'{c}_a1')]\n    else:\n        aisle_vars[c] = [Int(f'{c}_a1'), Int(f'{c}_a2')]\n\nsolver = Solver()\n\n# Constraints: aisle numbers must be valid\nfor c in clerks:\n    for i in range(len(aisle_vars[c])):\n        solver.add(aisle_vars[c][i] >= 1, aisle_vars[c][i] <= 9)\n\n# Olga stocks exactly one aisle\n# Already modeled as only one variable for Olga\n\n# No clerk stocks more than two aisles (already enforced by model)\n\n# Aisles stocked by each clerk are distinct (if length 2)\nfor c in clerks:\n    if c != 'Olga':\n        solver.add(aisle_vars[c][0] != aisle_vars[c][1])\n\n# No aisle is stocked by more than one clerk\n# Collect all aisle variables (including Olga's single aisle)\nall_aisles = []\nfor c in clerks:\n    all_aisles.extend(aisle_vars[c])\n# Remove zeros (Olga has only one aisle, no zeros here)\nsolver.add(Distinct(all_aisles))\n\n# Constraints from the problem:\n\n# Kurt stocks aisle 2\n# Kurt has two aisles, one must be 2\nkurt_a1 = aisle_vars['Kurt'][0]\nkurt_a2 = aisle_vars['Kurt'][1]\nkurt_has_2 = Or(kurt_a1 == 2, kurt_a2 == 2)\nsolver.add(kurt_has_2)\n\n# Olga stocks exactly one aisle (already done, only one variable)\n\n# Manny does not stock aisle 1\nfor a in aisle_vars['Manny']:\n    solver.add(a != 1)\n\n# Jill does not stock consecutive aisles\njill_a1 = aisle_vars['Jill'][0]\njill_a2 = aisle_vars['Jill'][1]\n# If Jill stocks two aisles, they are not consecutive\nsolver.add(Or(jill_a1 == jill_a2, Abs(jill_a1 - jill_a2) > 1))\n\n# Kurt stocks the only aisle between the two aisles Manny stocks\n# Manny has two aisles: m1, m2\nmanny_a1 = aisle_vars['Manny'][0]\nmanny_a2 = aisle_vars['Manny'][1]\n# Sort Manny's aisles for clarity\nmanny_min = If(manny_a1 < manny_a2, manny_a1, manny_a2)\nmanny_max = If(manny_a1 > manny_a2, manny_a1, manny_a2)\n\n# The aisle between Manny's aisles is Kurt's aisle (the one that is not 2)\n# Kurt's aisles: kurt_a1, kurt_a2\n# One is 2 (already constrained), the other is between Manny's aisles and is unique between them\nkurt_other = If(kurt_a1 == 2, kurt_a2, kurt_a1)\n\n# The aisle between Manny's aisles is kurt_other\n# The aisles between Manny's aisles are those strictly between manny_min and manny_max\n# There must be exactly one aisle between Manny's aisles and it equals kurt_other\n# So kurt_other is > manny_min and < manny_max\nsolver.add(kurt_other > manny_min)\nsolver.add(kurt_other < manny_max)\n\n# Also, there is no other aisle between Manny's aisles except kurt_other\n# So manny_max - manny_min == 2 (aisle numbers consecutive with exactly one aisle between)\nsolver.add(manny_max - manny_min == 2)\n\n# Exactly one of Larisa's aisles is an end aisle (1 or 9)\nlarisa_a1 = aisle_vars['Larisa'][0]\nlarisa_a2 = aisle_vars['Larisa'][1]\n\nlarisa_end1 = Or(larisa_a1 == 1, larisa_a1 == 9)\nlarisa_end2 = Or(larisa_a2 == 1, larisa_a2 == 9)\n# Exactly one is an end aisle\nsolver.add(Xor(larisa_end1, larisa_end2))\n\n# Olga's aisle is numbered higher than either of Kurt's aisles,\n# and lower than at least one of Larisa's aisles\n\nolga_a1 = aisle_vars['Olga'][0]\n\n# Olga's aisle > both Kurt's aisles\nolga_gt_kurt = And(olga_a1 > kurt_a1, olga_a1 > kurt_a2)\n\n# Olga's aisle < at least one of Larisa's aisles\nolga_lt_larisa = Or(olga_a1 < larisa_a1, olga_a1 < larisa_a2)\n\nsolver.add(olga_gt_kurt)\nsolver.add(olga_lt_larisa)\n\n# Jill stocks aisle 3 (given condition)\n# Jill has two aisles, one must be 3\njill_has_3 = Or(jill_a1 == 3, jill_a2 == 3)\nsolver.add(jill_has_3)\n\n# OPTIONS:\n# (A) Jill stocks aisle 9.\n# (B) Kurt stocks aisle 6.\n# (C) Larisa stocks aisle 4.\n# (D) Manny stocks aisle 4.\n# (E) Olga stocks aisle 6.\n\noptions = {\n    'A': Or(jill_a1 == 9, jill_a2 == 9),\n    'B': Or(kurt_a1 == 6, kurt_a2 == 6),\n    'C': Or(larisa_a1 == 4, larisa_a2 == 4),\n    'D': Or(manny_a1 == 4, manny_a2 == 4),\n    'E': olga_a1 == 6,\n}\n\n# OPTION CHECKING\nfor letter in ['A','B','C','D','E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A five-week adult education course consists of exactly five lectures with a different lecture given each week. No lecture is given more than once. Each lecture is delivered by a different speaker. The following conditions are true about the speakers and their lectures: Each speaker lectures on a philosopher in whom he or she specializes. No two speakers lecture on the same philosopher. The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers. The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers. The third week's and fourth week's speakers each specialize in Mill and Nietzsche, and no other philosophers. The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) The first speaker lectures on Mill.\n(B) The second speaker lectures on Mill.\n(C) The second speaker lectures on Nietzsche.\n(D) The fifth speaker lectures on Nietzsche.\n(E) The fifth speaker lectures on Ockham.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Philosophers\nphilosophers = ['Kant', 'Locke', 'Mill', 'Nietzsche', 'Ockham', 'Plato']\nphilo_idx = {p: i for i, p in enumerate(philosophers)}\n\n# Weeks 1 to 5\nweeks = [1, 2, 3, 4, 5]\n\n# Each week's speaker lectures on exactly one philosopher\n# Variables: lecture[w] = index of philosopher for week w\nlecture = {}\nfor w in weeks:\n    lecture[w] = Int(f'lecture_{w}')\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each lecture is a valid philosopher index\nfor w in weeks:\n    solver.add(And(lecture[w] >= 0, lecture[w] < len(philosophers)))\n\n# All lectures are different philosophers (no repeats)\nsolver.add(Distinct([lecture[w] for w in weeks]))\n\n# Specialization constraints per week:\n# Week 1 speaker specializes in Kant, Locke, Mill only\nweek1_special = [philo_idx['Kant'], philo_idx['Locke'], philo_idx['Mill']]\nsolver.add(Or([lecture[1] == p for p in week1_special]))\n\n# Week 2 speaker specializes in Kant, Locke, Mill, Nietzsche only\nweek2_special = [philo_idx['Kant'], philo_idx['Locke'], philo_idx['Mill'], philo_idx['Nietzsche']]\nsolver.add(Or([lecture[2] == p for p in week2_special]))\n\n# Week 3 speaker specializes in Mill, Nietzsche only\nweek3_special = [philo_idx['Mill'], philo_idx['Nietzsche']]\nsolver.add(Or([lecture[3] == p for p in week3_special]))\n\n# Week 4 speaker specializes in Mill, Nietzsche only\nweek4_special = [philo_idx['Mill'], philo_idx['Nietzsche']]\nsolver.add(Or([lecture[4] == p for p in week4_special]))\n\n# Week 5 speaker specializes in Nietzsche, Ockham, Plato only\nweek5_special = [philo_idx['Nietzsche'], philo_idx['Ockham'], philo_idx['Plato']]\nsolver.add(Or([lecture[5] == p for p in week5_special]))\n\n# OPTION CHECKING\n# Options:\n# (A) The first speaker lectures on Mill.\n# (B) The second speaker lectures on Mill.\n# (C) The second speaker lectures on Nietzsche.\n# (D) The fifth speaker lectures on Nietzsche.\n# (E) The fifth speaker lectures on Ockham.\n\noptions = [\n    lecture[1] == philo_idx['Mill'],       # A\n    lecture[2] == philo_idx['Mill'],       # B\n    lecture[2] == philo_idx['Nietzsche'],  # C\n    lecture[5] == philo_idx['Nietzsche'],  # D\n    lecture[5] == philo_idx['Ockham']      # E\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A five-week adult education course consists of exactly five lectures with a different lecture given each week. No lecture is given more than once. Each lecture is delivered by a different speaker. The following conditions are true about the speakers and their lectures: Each speaker lectures on a philosopher in whom he or she specializes. No two speakers lecture on the same philosopher. The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers. The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers. The third week's and fourth week's speakers each specialize in Mill and Nietzsche, and no other philosophers. The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers.\n\nWhat is the maximum possible number of different schedules for the five lectures in which those philosophers who are discussed are discussed in alphabetical order?\n\nOptions:\n(A) 2\n(B) 3\n(C) 4\n(D) 5\n(E) 6",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Philosophers in alphabetical order\nphilosophers = ['Kant', 'Locke', 'Mill', 'Nietzsche', 'Ockham', 'Plato']\nphilo_idx = {p: i for i, p in enumerate(philosophers)}\n\n# Weeks 1 to 5\nweeks = [1, 2, 3, 4, 5]\n\n# Each week has a speaker who specializes in certain philosophers\n# Variables: which philosopher is lectured each week (index in philosophers)\nlecture = {w: Int(f\"lecture_{w}\") for w in weeks}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each lecture must be one of the philosophers the speaker specializes in:\n# Week 1 speaker specializes in Kant, Locke, Mill only\nsolver.add(Or(lecture[1] == philo_idx['Kant'],\n              lecture[1] == philo_idx['Locke'],\n              lecture[1] == philo_idx['Mill']))\n\n# Week 2 speaker: Kant, Locke, Mill, Nietzsche\nsolver.add(Or(lecture[2] == philo_idx['Kant'],\n              lecture[2] == philo_idx['Locke'],\n              lecture[2] == philo_idx['Mill'],\n              lecture[2] == philo_idx['Nietzsche']))\n\n# Week 3 speaker: Mill, Nietzsche\nsolver.add(Or(lecture[3] == philo_idx['Mill'],\n              lecture[3] == philo_idx['Nietzsche']))\n\n# Week 4 speaker: Mill, Nietzsche\nsolver.add(Or(lecture[4] == philo_idx['Mill'],\n              lecture[4] == philo_idx['Nietzsche']))\n\n# Week 5 speaker: Nietzsche, Ockham, Plato\nsolver.add(Or(lecture[5] == philo_idx['Nietzsche'],\n              lecture[5] == philo_idx['Ockham'],\n              lecture[5] == philo_idx['Plato']))\n\n# No lecture is given more than once (all lectures distinct)\nsolver.add(Distinct([lecture[w] for w in weeks]))\n\n# Philosophers discussed are in alphabetical order\n# That means the sequence lecture[1], lecture[2], ..., lecture[5] is strictly increasing\nfor i in range(1, 5):\n    solver.add(lecture[i] < lecture[i+1])\n\n# OPTION CHECKING\noptions = [2, 3, 4, 5, 6]  # Corresponding to (A) to (E)\n\n# Count number of solutions satisfying constraints\n# Use a loop to enumerate all solutions and count them\ncount = 0\nsolutions = []\nwhile solver.check() == sat:\n    m = solver.model()\n    sol = tuple(m.evaluate(lecture[w]).as_long() for w in weeks)\n    solutions.append(sol)\n    count += 1\n\n    # Add blocking clause to find different solution\n    solver.add(Or([lecture[w] != sol[i] for i, w in enumerate(weeks)]))\n\n# Check which option matches count\nfor i, val in enumerate(options):\n    if count == val:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A five-week adult education course consists of exactly five lectures with a different lecture given each week. No lecture is given more than once. Each lecture is delivered by a different speaker. The following conditions are true about the speakers and their lectures: Each speaker lectures on a philosopher in whom he or she specializes. No two speakers lecture on the same philosopher. The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers. The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers. The third week's and fourth week's speakers each specialize in Mill and Nietzsche, and no other philosophers. The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers.\n\nAssume that, of the six philosophers, Kant and Nietzsche are the only German philosophers, and Locke, Mill, and Ockham are the only British philosophers. Each of the following statements could be true EXCEPT:\n\nOptions:\n(A) The first and fourth speakers lecture on British philosophers.\n(B) The first and fourth speakers lecture on German philosophers.\n(C) The second and third speakers lecture on British philosophers.\n(D) The third and fourth speakers lecture on German philosophers.\n(E) The fourth and fifth speakers lecture on British philosophers.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Philosophers indices\nphilosophers = ['Kant', 'Locke', 'Mill', 'Nietzsche', 'Ockham', 'Plato']\nphilo_idx = {p: i for i, p in enumerate(philosophers)}\n\n# Nationalities\n# German: Kant, Nietzsche\n# British: Locke, Mill, Ockham\n# Plato is neither German nor British\n\ndef is_german(p):\n    return p in ['Kant', 'Nietzsche']\n\ndef is_british(p):\n    return p in ['Locke', 'Mill', 'Ockham']\n\n# Weeks 1 to 5\nweeks = [1, 2, 3, 4, 5]\n\n# Variables: lecture philosopher for each week (integer index)\nlecture = {w: Int(f'lecture_{w}') for w in weeks}\n\n# Variables: speaker specialization set for each week (set of philosophers)\n# We model speaker specialization by constraints on possible philosophers for that speaker\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each lecture must be a valid philosopher index\nfor w in weeks:\n    solver.add(And(lecture[w] >= 0, lecture[w] < len(philosophers)))\n\n# All lectures are different philosophers (no repeats)\nsolver.add(Distinct([lecture[w] for w in weeks]))\n\n# Speaker specializations per week (only philosophers they specialize in)\n# Week 1 speaker specializes in Kant, Locke, Mill only\nweek1_specialization = [philo_idx[p] for p in ['Kant', 'Locke', 'Mill']]\nsolver.add(Or([lecture[1] == p for p in week1_specialization]))\n\n# Week 2 speaker specializes in Kant, Locke, Mill, Nietzsche only\nweek2_specialization = [philo_idx[p] for p in ['Kant', 'Locke', 'Mill', 'Nietzsche']]\nsolver.add(Or([lecture[2] == p for p in week2_specialization]))\n\n# Week 3 speaker specializes in Mill, Nietzsche only\nweek3_specialization = [philo_idx[p] for p in ['Mill', 'Nietzsche']]\nsolver.add(Or([lecture[3] == p for p in week3_specialization]))\n\n# Week 4 speaker specializes in Mill, Nietzsche only\nweek4_specialization = [philo_idx[p] for p in ['Mill', 'Nietzsche']]\nsolver.add(Or([lecture[4] == p for p in week4_specialization]))\n\n# Week 5 speaker specializes in Nietzsche, Ockham, Plato only\nweek5_specialization = [philo_idx[p] for p in ['Nietzsche', 'Ockham', 'Plato']]\nsolver.add(Or([lecture[5] == p for p in week5_specialization]))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) The first and fourth speakers lecture on British philosophers.\n    And(\n        Or([lecture[1] == philo_idx[p] for p in ['Locke', 'Mill', 'Ockham']]),\n        Or([lecture[4] == philo_idx[p] for p in ['Locke', 'Mill', 'Ockham']])\n    ),\n    # (B) The first and fourth speakers lecture on German philosophers.\n    And(\n        Or([lecture[1] == philo_idx[p] for p in ['Kant', 'Nietzsche']]),\n        Or([lecture[4] == philo_idx[p] for p in ['Kant', 'Nietzsche']])\n    ),\n    # (C) The second and third speakers lecture on British philosophers.\n    And(\n        Or([lecture[2] == philo_idx[p] for p in ['Locke', 'Mill', 'Ockham']]),\n        Or([lecture[3] == philo_idx[p] for p in ['Locke', 'Mill', 'Ockham']])\n    ),\n    # (D) The third and fourth speakers lecture on German philosophers.\n    And(\n        Or([lecture[3] == philo_idx[p] for p in ['Kant', 'Nietzsche']]),\n        Or([lecture[4] == philo_idx[p] for p in ['Kant', 'Nietzsche']])\n    ),\n    # (E) The fourth and fifth speakers lecture on British philosophers.\n    And(\n        Or([lecture[4] == philo_idx[p] for p in ['Locke', 'Mill', 'Ockham']]),\n        Or([lecture[5] == philo_idx[p] for p in ['Locke', 'Mill', 'Ockham']])\n    )\n]\n\n# Check each option for satisfiability with the base constraints\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        solver.pop()\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A five-week adult education course consists of exactly five lectures with a different lecture given each week. No lecture is given more than once. Each lecture is delivered by a different speaker. The following conditions are true about the speakers and their lectures: Each speaker lectures on a philosopher in whom he or she specializes. No two speakers lecture on the same philosopher. The first week's speaker specializes in Kant, Locke, and Mill, and no other philosophers. The second week's speaker specializes in Kant, Locke, Mill, and Nietzsche, and no other philosophers. The third week's and fourth week's speakers each specialize in Mill and Nietzsche, and no other philosophers. The fifth week's speaker specializes in Nietzsche, Ockham, and Plato, and no other philosophers.\n\nSuppose the third speaker were a specialist not only in Mill and Nietzsche, but also in Sartre. If all of the other conditions remained the same, then each of the following could be true EXCEPT:\n\nOptions:\n(A) Mill is lectured on in the first lecture and Nietzsche in the fourth.\n(B) Mill is lectured on in the second lecture and Nietzsche in the third.\n(C) Mill is lectured on in the second lecture and Nietzsche in the fourth.\n(D) Mill is lectured on in the fourth lecture and Nietzsche in the fifth.\n(E) Nietzsche is lectured on in the second lecture and Mill in the fourth.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Weeks\nweeks = [0,1,2,3,4]  # 0-based indexing for weeks 1 to 5\n\n# Philosophers\nphilosophers = ['Kant', 'Locke', 'Mill', 'Nietzsche', 'Ockham', 'Plato', 'Sartre']\nphilo_idx = {p:i for i,p in enumerate(philosophers)}\n\n# Speakers: one per week\n# Each speaker lectures on exactly one philosopher that they specialize in.\n# Variables: philosopher lectured in each week (integer index)\nlecture = [Int(f'lecture_{w}') for w in weeks]\n\n# Specializations per week (speaker):\n# Week 1 (index 0): Kant, Locke, Mill only\nspec_0 = [philo_idx['Kant'], philo_idx['Locke'], philo_idx['Mill']]\n# Week 2 (index 1): Kant, Locke, Mill, Nietzsche only\nspec_1 = [philo_idx['Kant'], philo_idx['Locke'], philo_idx['Mill'], philo_idx['Nietzsche']]\n# Week 3 (index 2): Mill, Nietzsche, Sartre (modified)\nspec_2 = [philo_idx['Mill'], philo_idx['Nietzsche'], philo_idx['Sartre']]\n# Week 4 (index 3): Mill, Nietzsche only\nspec_3 = [philo_idx['Mill'], philo_idx['Nietzsche']]\n# Week 5 (index 4): Nietzsche, Ockham, Plato only\nspec_4 = [philo_idx['Nietzsche'], philo_idx['Ockham'], philo_idx['Plato']]\n\nspecs = [spec_0, spec_1, spec_2, spec_3, spec_4]\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each lecture must be a philosopher the speaker specializes in\nfor w in weeks:\n    solver.add(Or([lecture[w] == p for p in specs[w]]))\n\n# All lectures are different philosophers (no repeats)\nsolver.add(Distinct(lecture))\n\n# OPTION CHECKING\n\n# Options dictionary with constraints for Mill and Nietzsche lectures placement\n# Each option is a tuple: (Mill_week, Nietzsche_week)\n# Weeks are zero-based indexes\noptions = {\n    'A': (0, 3),  # Mill in week 1, Nietzsche in week 4\n    'B': (1, 2),  # Mill in week 2, Nietzsche in week 3\n    'C': (1, 3),  # Mill in week 2, Nietzsche in week 4\n    'D': (3, 4),  # Mill in week 4, Nietzsche in week 5\n    'E': (1, 3),  # Nietzsche in week 2, Mill in week 4 (Note: reversed Mill/Nietzsche positions)\n}\n\n# For option E, Nietzsche is in week 2 and Mill in week 4 (so Mill_week=3, Nietzsche_week=1)\n# We will handle E separately due to reversed order.\n\nfor opt in ['A','B','C','D','E']:\n    solver.push()\n    if opt != 'E':\n        mill_wk, nietzsche_wk = options[opt]\n        # Add constraints: lecture[mill_wk] == Mill, lecture[nietzsche_wk] == Nietzsche\n        solver.add(lecture[mill_wk] == philo_idx['Mill'])\n        solver.add(lecture[nietzsche_wk] == philo_idx['Nietzsche'])\n    else:\n        # For E: Nietzsche in week 2 (index 1), Mill in week 4 (index 3)\n        solver.add(lecture[1] == philo_idx['Nietzsche'])\n        solver.add(lecture[3] == philo_idx['Mill'])\n    # Check if satisfiable\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{opt}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.\n\nWhich one of the following could be the order in which the trains arrive, from first to last?\n\nOptions:\n(A) Rockville, Tilbury, Victoria, Wooster, Sunnydale, York, Quigley\n(B) Rockville, Wooster, Quigley, York, Tilbury, Sunnydale, Victoria\n(C) Rockville, Tilbury, Quigley, Wooster, Sunnydale, York, Victoria\n(D) Quigley, Rockville, Wooster, Sunnydale, Victoria, York, Tilbury\n(E) Tilbury, Rockville, Quigley, Wooster, Sunnydale, York, Victoria",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrains = ['Quigley', 'Rockville', 'Sunnydale', 'Tilbury', 'Victoria', 'Wooster', 'York']\nn = len(trains)\n\n# Create a dictionary of Int variables representing the arrival order (1 to 7)\narrival = {train: Int(train) for train in trains}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each train arrives at a unique position from 1 to 7\nfor train in trains:\n    solver.add(And(arrival[train] >= 1, arrival[train] <= n))\nsolver.add(Distinct([arrival[train] for train in trains]))\n\n# Either York or Wooster arrives fourth\nsolver.add(Or(arrival['York'] == 4, arrival['Wooster'] == 4))\n\n# Sunnydale arrives after Wooster but before York\nsolver.add(arrival['Sunnydale'] > arrival['Wooster'])\nsolver.add(arrival['Sunnydale'] < arrival['York'])\n\n# Tilbury and Victoria arrive after Rockville\nsolver.add(arrival['Tilbury'] > arrival['Rockville'])\nsolver.add(arrival['Victoria'] > arrival['Rockville'])\n\n# Tilbury does not arrive immediately after Victoria\nsolver.add(arrival['Tilbury'] != arrival['Victoria'] + 1)\n\n# Victoria does not arrive immediately after Tilbury\nsolver.add(arrival['Victoria'] != arrival['Tilbury'] + 1)\n\n# OPTION CHECKING\noptions = [\n    ['Rockville', 'Tilbury', 'Victoria', 'Wooster', 'Sunnydale', 'York', 'Quigley'],\n    ['Rockville', 'Wooster', 'Quigley', 'York', 'Tilbury', 'Sunnydale', 'Victoria'],\n    ['Rockville', 'Tilbury', 'Quigley', 'Wooster', 'Sunnydale', 'York', 'Victoria'],\n    ['Quigley', 'Rockville', 'Wooster', 'Sunnydale', 'Victoria', 'York', 'Tilbury'],\n    ['Tilbury', 'Rockville', 'Quigley', 'Wooster', 'Sunnydale', 'York', 'Victoria']\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints to fix the order according to the option\n    for pos, train in enumerate(option, start=1):\n        solver.add(arrival[train] == pos)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.\n\nIf the Wooster arrives at some time before the Rockville, then exactly how many different orders are there in which the seven trains could arrive?\n\nOptions:\n(A) four\n(B) five\n(C) six\n(D) seven\n(E) eight",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrains = ['Quigley', 'Rockville', 'Sunnydale', 'Tilbury', 'Victoria', 'Wooster', 'York']\nn = len(trains)\n\n# Create integer variables for arrival positions (1 to 7)\npos = {t: Int(t) for t in trains}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each train arrives at a unique position from 1 to 7\nfor t in trains:\n    solver.add(And(pos[t] >= 1, pos[t] <= n))\nsolver.add(Distinct([pos[t] for t in trains]))\n\n# Either York or Wooster arrives fourth\nsolver.add(Or(pos['York'] == 4, pos['Wooster'] == 4))\n\n# Sunnydale arrives after Wooster but before York\nsolver.add(pos['Sunnydale'] > pos['Wooster'])\nsolver.add(pos['Sunnydale'] < pos['York'])\n\n# Both Tilbury and Victoria arrive after Rockville\nsolver.add(pos['Tilbury'] > pos['Rockville'])\nsolver.add(pos['Victoria'] > pos['Rockville'])\n\n# Tilbury does not arrive immediately after Victoria, and Victoria does not arrive immediately after Tilbury\nsolver.add(pos['Tilbury'] != pos['Victoria'] + 1)\nsolver.add(pos['Victoria'] != pos['Tilbury'] + 1)\n\n# Additional condition: Wooster arrives before Rockville\nsolver.add(pos['Wooster'] < pos['Rockville'])\n\n# OPTION CHECKING\n# We want to count how many different orders satisfy all constraints including Wooster before Rockville\n\ncount = 0\nmodels = []\n\nwhile solver.check() == sat:\n    m = solver.model()\n    # Extract positions for all trains as a tuple\n    order = tuple(m.evaluate(pos[t]).as_long() for t in trains)\n    models.append(order)\n    count += 1\n\n    # Add constraint to block this exact order to find new ones\n    solver.add(Or([pos[t] != m.evaluate(pos[t]) for t in trains]))\n\n# Map option letters to counts\noptions = {'A':4, 'B':5, 'C':6, 'D':7, 'E':8}\n\n# Find which option matches count\nfor letter, val in options.items():\n    if val == count:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.\n\nWhich one of the following must be true?\n\nOptions:\n(A) The first train to arrive is the Rockville.\n(B) The Quigley arrives at some time before the Sunnydale.\n(C) The Rockville arrives at some time before the Wooster.\n(D) The Victoria arrives at some time before the York.\n(E) The Wooster arrives at some time before the York.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrains = ['Quigley', 'Rockville', 'Sunnydale', 'Tilbury', 'Victoria', 'Wooster', 'York']\npositions = {train: Int(train) for train in trains}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each train arrives at a unique position from 1 to 7\nfor train in trains:\n    solver.add(And(positions[train] >= 1, positions[train] <= 7))\nsolver.add(Distinct([positions[train] for train in trains]))\n\n# Either York or Wooster arrives fourth\nsolver.add(Or(positions['York'] == 4, positions['Wooster'] == 4))\n\n# Sunnydale arrives after Wooster but before York\nsolver.add(positions['Sunnydale'] > positions['Wooster'])\nsolver.add(positions['Sunnydale'] < positions['York'])\n\n# Tilbury and Victoria arrive after Rockville\nsolver.add(positions['Tilbury'] > positions['Rockville'])\nsolver.add(positions['Victoria'] > positions['Rockville'])\n\n# Tilbury does not arrive immediately after Victoria\nsolver.add(positions['Tilbury'] != positions['Victoria'] + 1)\n\n# Victoria does not arrive immediately after Tilbury\nsolver.add(positions['Victoria'] != positions['Tilbury'] + 1)\n\n# OPTION CHECKING\noptions = [\n    positions['Rockville'] == 1,                 # (A) The first train to arrive is the Rockville.\n    positions['Quigley'] < positions['Sunnydale'], # (B) Quigley arrives before Sunnydale.\n    positions['Rockville'] < positions['Wooster'], # (C) Rockville arrives before Wooster.\n    positions['Victoria'] < positions['York'],     # (D) Victoria arrives before York.\n    positions['Wooster'] < positions['York']        # (E) Wooster arrives before York.\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add negation of the option to check if it must be true\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.\n\nWhich one of the following could be true?\n\nOptions:\n(A) The Sunnydale is the next train to arrive after the Quigley.\n(B) The Rockville is the next train to arrive after the Sunnydale.\n(C) The Rockville is the next train to arrive after the Tilbury.\n(D) The Quigley is the next train to arrive after the Sunnydale.\n(E) The Quigley is the next train to arrive after the Wooster.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrains = ['Quigley', 'Rockville', 'Sunnydale', 'Tilbury', 'Victoria', 'Wooster', 'York']\nn = len(trains)\n\n# Create an Int variable for each train representing its arrival position (1 to 7)\npositions = {train: Int(train) for train in trains}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each train arrives at a unique position between 1 and 7\nfor train in trains:\n    solver.add(And(positions[train] >= 1, positions[train] <= n))\nsolver.add(Distinct([positions[train] for train in trains]))\n\n# Either York or Wooster arrives fourth\nsolver.add(Or(positions['York'] == 4, positions['Wooster'] == 4))\n\n# Sunnydale arrives after Wooster but before York\nsolver.add(positions['Sunnydale'] > positions['Wooster'])\nsolver.add(positions['Sunnydale'] < positions['York'])\n\n# Tilbury and Victoria arrive after Rockville\nsolver.add(positions['Tilbury'] > positions['Rockville'])\nsolver.add(positions['Victoria'] > positions['Rockville'])\n\n# Tilbury does not arrive immediately after Victoria\nsolver.add(positions['Tilbury'] != positions['Victoria'] + 1)\n\n# Victoria does not arrive immediately after Tilbury\nsolver.add(positions['Victoria'] != positions['Tilbury'] + 1)\n\n# OPTION CHECKING\noptions = {\n    'A': ('Quigley', 'Sunnydale'),\n    'B': ('Sunnydale', 'Rockville'),\n    'C': ('Tilbury', 'Rockville'),\n    'D': ('Sunnydale', 'Quigley'),\n    'E': ('Wooster', 'Quigley')\n}\n\nfor letter, (first_train, second_train) in options.items():\n    solver.push()\n    # Add constraint that second_train arrives immediately after first_train\n    solver.add(positions[second_train] == positions[first_train] + 1)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly seven different trains—Quigley, Rockville, Sunnydale, Tilbury, Victoria, Wooster, and York—arrive at Middlebrook Station on Saturday. The following conditions govern their arrivals: The trains arrive one at a time. Either the York or the Wooster arrives fourth. The Sunnydale arrives at some time after the Wooster but at some time before the York. Both the Tilbury and the Victoria arrive at some time after the Rockville. The Tilbury does not arrive next after the Victoria; nor does the Victoria arrive next after the Tilbury.\n\nIf exactly one of the trains arrives after the Wooster but before the York, then which one of the following could be true?\n\nOptions:\n(A) The sixth train to arrive is the Sunnydale.\n(B) The sixth train to arrive is the Tilbury.\n(C) The third train to arrive is the Rockville.\n(D) The second train to arrive is the Sunnydale.\n(E) The first train to arrive is the Rockville.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrains = ['Quigley', 'Rockville', 'Sunnydale', 'Tilbury', 'Victoria', 'Wooster', 'York']\nn = len(trains)\n\n# Create a variable for each train representing its arrival position (1 to 7)\narrival = {t: Int(t) for t in trains}\n\nsolver = Solver()\n\n# Each train arrives exactly once at a position between 1 and 7\nfor t in trains:\n    solver.add(And(arrival[t] >= 1, arrival[t] <= n))\nsolver.add(Distinct([arrival[t] for t in trains]))\n\n# CONSTRAINTS\n\n# Either York or Wooster arrives fourth\nsolver.add(Or(arrival['York'] == 4, arrival['Wooster'] == 4))\n\n# Sunnydale arrives after Wooster but before York\nsolver.add(arrival['Sunnydale'] > arrival['Wooster'])\nsolver.add(arrival['Sunnydale'] < arrival['York'])\n\n# Both Tilbury and Victoria arrive after Rockville\nsolver.add(arrival['Tilbury'] > arrival['Rockville'])\nsolver.add(arrival['Victoria'] > arrival['Rockville'])\n\n# Tilbury does not arrive immediately after Victoria, and Victoria does not arrive immediately after Tilbury\nsolver.add(arrival['Tilbury'] != arrival['Victoria'] + 1)\nsolver.add(arrival['Victoria'] != arrival['Tilbury'] + 1)\n\n# Exactly one train arrives after Wooster but before York\n# Define a helper function to count how many trains arrive between Wooster and York (exclusive)\n# Count trains t where arrival[Wooster] < arrival[t] < arrival[York]\n# We know arrival[Wooster] < arrival[York] because Sunnydale must be between them and Sunnydale > Wooster and < York\n# But we do not have explicit that Wooster < York, so enforce it:\nsolver.add(arrival['Wooster'] < arrival['York'])\n\n# For each train t, define a Bool indicating if it arrives after Wooster but before York\nin_between = {t: Bool(f\"in_between_{t}\") for t in trains}\n\nfor t in trains:\n    cond = And(arrival[t] > arrival['Wooster'], arrival[t] < arrival['York'])\n    solver.add(in_between[t] == cond)\n\n# Exactly one train (other than Wooster and York) arrives after Wooster but before York\n# Note: Wooster and York cannot be counted since arrival[t] > arrival[Wooster] and < arrival[York] excludes them\n# So count how many trains satisfy in_between and are not Wooster or York\nin_between_trains = [in_between[t] for t in trains if t not in ['Wooster', 'York']]\nsolver.add(Sum([If(b, 1, 0) for b in in_between_trains]) == 1)\n\n# OPTION CHECKING\n# Options:\n# (A) The sixth train to arrive is the Sunnydale.\n# (B) The sixth train to arrive is the Tilbury.\n# (C) The third train to arrive is the Rockville.\n# (D) The second train to arrive is the Sunnydale.\n# (E) The first train to arrive is the Rockville.\n\noptions = [\n    arrival['Sunnydale'] == 6,\n    arrival['Tilbury'] == 6,\n    arrival['Rockville'] == 3,\n    arrival['Sunnydale'] == 2,\n    arrival['Rockville'] == 1\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.\n\nWhich one of the following could be a complete and accurate list of the doctors that are at Souderton?\n\nOptions:\n(A) Juarez, Kudrow, Onawa\n(B) Juarez, Nance, Onawa, Palermo\n(C) Kudrow, Longtree, Onawa\n(D) Nance, Onawa\n(E) Nance, Palermo",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndoctors = ['Juarez', 'Kudrow', 'Longtree', 'Nance', 'Onawa', 'Palermo']\nclinics = ['Souderton', 'Randsborough']\n\n# Create a Bool variable for each doctor: True if at Souderton, False if at Randsborough\nat_souderton = {d: Bool(d) for d in doctors}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# 1. Kudrow is at Randsborough if Juarez is at Souderton.\n# Juarez at Souderton => Kudrow at Randsborough\n# Juarez_Souderton => Not Kudrow_Souderton\nconstraint1 = Implies(at_souderton['Juarez'], Not(at_souderton['Kudrow']))\nsolver.add(constraint1)\n\n# 2. Onawa is at Souderton if Juarez is at Randsborough.\n# Juarez at Randsborough => Onawa at Souderton\n# Not Juarez_Souderton => Onawa_Souderton\nconstraint2 = Implies(Not(at_souderton['Juarez']), at_souderton['Onawa'])\nsolver.add(constraint2)\n\n# 3. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough.\n# Longtree_Souderton => Not Nance_Souderton and Not Palermo_Souderton\nconstraint3a = Implies(at_souderton['Longtree'], Not(at_souderton['Nance']))\nconstraint3b = Implies(at_souderton['Longtree'], Not(at_souderton['Palermo']))\nsolver.add(constraint3a)\nsolver.add(constraint3b)\n\n# 4. If Nance is at Randsborough, then so is Onawa.\n# Not Nance_Souderton => Not Onawa_Souderton\nconstraint4 = Implies(Not(at_souderton['Nance']), Not(at_souderton['Onawa']))\nsolver.add(constraint4)\n\n# 5. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.\n# Not Palermo_Souderton => Kudrow_Souderton and Onawa_Souderton\nconstraint5a = Implies(Not(at_souderton['Palermo']), at_souderton['Kudrow'])\nconstraint5b = Implies(Not(at_souderton['Palermo']), at_souderton['Onawa'])\nsolver.add(constraint5a)\nsolver.add(constraint5b)\n\n# OPTION CHECKING\noptions = {\n    'A': ['Juarez', 'Kudrow', 'Onawa'],\n    'B': ['Juarez', 'Nance', 'Onawa', 'Palermo'],\n    'C': ['Kudrow', 'Longtree', 'Onawa'],\n    'D': ['Nance', 'Onawa'],\n    'E': ['Nance', 'Palermo']\n}\n\nfor letter, souderton_list in options.items():\n    solver.push()\n    # Add constraints for this option: doctors in list are at Souderton, others at Randsborough\n    for d in doctors:\n        if d in souderton_list:\n            solver.add(at_souderton[d] == True)\n        else:\n            solver.add(at_souderton[d] == False)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.\n\nIf Palermo is at Randsborough, then which one of the following must be true?\n\nOptions:\n(A) Juarez is at Randsborough.\n(B) Kudrow is at Randsborough.\n(C) Longtree is at Souderton.\n(D) Nance is at Randsborough.\n(E) Onawa is at Randsborough.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndoctors = ['Juarez', 'Kudrow', 'Longtree', 'Nance', 'Onawa', 'Palermo']\nclinics = ['Souderton', 'Randsborough']\n\n# Create Z3 variables for each doctor: 0 for Souderton, 1 for Randsborough\nlocation = {d: Int(d) for d in doctors}\n\nsolver = Solver()\n\n# Each doctor is at exactly one clinic: 0 or 1\nfor d in doctors:\n    solver.add(Or(location[d] == 0, location[d] == 1))\n\n# CONSTRAINTS\n# Kudrow is at Randsborough if Juarez is at Souderton\ncond1 = Implies(location['Juarez'] == 0, location['Kudrow'] == 1)\nsolver.add(cond1)\n\n# Onawa is at Souderton if Juarez is at Randsborough\ncond2 = Implies(location['Juarez'] == 1, location['Onawa'] == 0)\nsolver.add(cond2)\n\n# If Longtree is at Souderton, then both Nance and Palermo are at Randsborough\ncond3 = Implies(location['Longtree'] == 0, And(location['Nance'] == 1, location['Palermo'] == 1))\nsolver.add(cond3)\n\n# If Nance is at Randsborough, then so is Onawa\ncond4 = Implies(location['Nance'] == 1, location['Onawa'] == 1)\nsolver.add(cond4)\n\n# If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton\ncond5 = Implies(location['Palermo'] == 1, And(location['Kudrow'] == 0, location['Onawa'] == 0))\nsolver.add(cond5)\n\n# OPTION CHECKING\noptions = [\n    ('A', location['Juarez'] == 1),\n    ('B', location['Kudrow'] == 1),\n    ('C', location['Longtree'] == 0),\n    ('D', location['Nance'] == 1),\n    ('E', location['Onawa'] == 1)\n]\n\n# Since the question is \"If Palermo is at Randsborough, then which must be true?\"\n# We add the condition that Palermo is at Randsborough and check which option must hold in all models\n\n# Add Palermo at Randsborough\nsolver.push()\nsolver.add(location['Palermo'] == 1)\n\ncorrect_option = None\nfor letter, condition in options:\n    # Check if condition must be true under current constraints\n    solver.push()\n    # Check if condition can be false\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        # condition must be true in all models\n        correct_option = letter\n        solver.pop()\n        break\n    solver.pop()\n\nsolver.pop()\n\nprint(f\"'{correct_option}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.\n\nWhat is the minimum number of doctors that could be at Souderton?\n\nOptions:\n(A) zero\n(B) one\n(C) two\n(D) three\n(E) four",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndoctors = ['Juarez', 'Kudrow', 'Longtree', 'Nance', 'Onawa', 'Palermo']\nclinics = ['Souderton', 'Randsborough']\n\n# Create variables: 0 for Souderton, 1 for Randsborough\nlocation = {d: Int(d) for d in doctors}\nfor d in doctors:\n    # Each doctor is assigned to one of the two clinics (0 or 1)\n    pass\n\n# CONSTRAINTS\nsolver = Solver()\n\nfor d in doctors:\n    solver.add(Or(location[d] == 0, location[d] == 1))\n\n# Kudrow is at Randsborough if Juarez is at Souderton.\n# Juarez at Souderton => Kudrow at Randsborough\nsolver.add(Implies(location['Juarez'] == 0, location['Kudrow'] == 1))\n\n# Onawa is at Souderton if Juarez is at Randsborough.\n# Juarez at Randsborough => Onawa at Souderton\nsolver.add(Implies(location['Juarez'] == 1, location['Onawa'] == 0))\n\n# If Longtree is at Souderton, then both Nance and Palermo are at Randsborough.\nsolver.add(Implies(location['Longtree'] == 0, And(location['Nance'] == 1, location['Palermo'] == 1)))\n\n# If Nance is at Randsborough, then so is Onawa.\nsolver.add(Implies(location['Nance'] == 1, location['Onawa'] == 1))\n\n# If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.\nsolver.add(Implies(location['Palermo'] == 1, And(location['Kudrow'] == 0, location['Onawa'] == 0)))\n\n# OPTION CHECKING\n# We want to check the minimum number of doctors at Souderton.\n# For each option, add a constraint that the number of doctors at Souderton equals that option,\n# and check if the constraints are satisfiable.\n\n# Count how many doctors are at Souderton (location == 0)\nsou_count = Sum([If(location[d] == 0, 1, 0) for d in doctors])\n\noptions = [0, 1, 2, 3, 4]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(sou_count == opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.\n\nIf Nance and Onawa are at different clinics, which one of the following must be true?\n\nOptions:\n(A) Juarez is at Souderton.\n(B) Kudrow is at Souderton.\n(C) Palermo is at Randsborough.\n(D) Four doctors are at Souderton.\n(E) Four doctors are at Randsborough.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndoctors = ['Juarez', 'Kudrow', 'Longtree', 'Nance', 'Onawa', 'Palermo']\nclinics = ['Souderton', 'Randsborough']\n\n# Create Int variables for each doctor: 0 for Souderton, 1 for Randsborough\nlocation = {d: Int(d) for d in doctors}\n\nsolver = Solver()\n\n# Each doctor is at exactly one clinic: 0 or 1\nfor d in doctors:\n    solver.add(Or(location[d] == 0, location[d] == 1))\n\n# CONSTRAINTS\n# Kudrow is at Randsborough if Juarez is at Souderton.\ncond1 = Implies(location['Juarez'] == 0, location['Kudrow'] == 1)\nsolver.add(cond1)\n\n# Onawa is at Souderton if Juarez is at Randsborough.\ncond2 = Implies(location['Juarez'] == 1, location['Onawa'] == 0)\nsolver.add(cond2)\n\n# If Longtree is at Souderton, then both Nance and Palermo are at Randsborough.\ncond3 = Implies(location['Longtree'] == 0, And(location['Nance'] == 1, location['Palermo'] == 1))\nsolver.add(cond3)\n\n# If Nance is at Randsborough, then so is Onawa.\ncond4 = Implies(location['Nance'] == 1, location['Onawa'] == 1)\nsolver.add(cond4)\n\n# If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.\ncond5 = Implies(location['Palermo'] == 1, And(location['Kudrow'] == 0, location['Onawa'] == 0))\nsolver.add(cond5)\n\n# Nance and Onawa are at different clinics\nsolver.add(location['Nance'] != location['Onawa'])\n\noptions = {\n    'A': location['Juarez'] == 0,\n    'B': location['Kudrow'] == 0,\n    'C': location['Palermo'] == 1,\n    'D': Sum([If(location[d] == 0, 1, 0) for d in doctors]) == 4,\n    'E': Sum([If(location[d] == 1, 1, 0) for d in doctors]) == 4,\n}\n\n# OPTION CHECKING\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(Not(options[opt]))\n    if solver.check() == unsat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each of exactly six doctors—Juarez, Kudrow, Longtree, Nance, Onawa, and Palermo—is at exactly one of two clinics: Souderton or Randsborough. The following conditions must be satisfied: Kudrow is at Randsborough if Juarez is at Souderton. Onawa is at Souderton if Juarez is at Randsborough. If Longtree is at Souderton, then both Nance and Palermo are at Randsborough. If Nance is at Randsborough, then so is Onawa. If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.\n\nIf Kudrow is at Souderton, then which one of the following must be true?\n\nOptions:\n(A) Juarez is at Souderton.\n(B) Nance is at Souderton.\n(C) Onawa is at Randsborough.\n(D) Palermo is at Souderton.\n(E) Palermo is at Randsborough.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndoctors = ['Juarez', 'Kudrow', 'Longtree', 'Nance', 'Onawa', 'Palermo']\nclinics = ['Souderton', 'Randsborough']\n\n# Map clinics to integers\nclinic_map = {clinics[i]: i for i in range(len(clinics))}\n\n# Create Z3 Int variables for each doctor representing their clinic (0: Souderton, 1: Randsborough)\ndoctor_clinic = {d: Int(d) for d in doctors}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each doctor is at exactly one clinic: 0 or 1\nfor d in doctors:\n    solver.add(And(doctor_clinic[d] >= 0, doctor_clinic[d] <= 1))\n\n# Kudrow is at Randsborough if Juarez is at Souderton.\njuarez_souderton = doctor_clinic['Juarez'] == clinic_map['Souderton']\nkudrow_randsborough = doctor_clinic['Kudrow'] == clinic_map['Randsborough']\nsolver.add(Implies(juarez_souderton, kudrow_randsborough))\n\n# Onawa is at Souderton if Juarez is at Randsborough.\njuarez_randsborough = doctor_clinic['Juarez'] == clinic_map['Randsborough']\nonawa_souderton = doctor_clinic['Onawa'] == clinic_map['Souderton']\nsolver.add(Implies(juarez_randsborough, onawa_souderton))\n\n# If Longtree is at Souderton, then both Nance and Palermo are at Randsborough.\nlongtree_souderton = doctor_clinic['Longtree'] == clinic_map['Souderton']\nnance_randsborough = doctor_clinic['Nance'] == clinic_map['Randsborough']\npalermo_randsborough = doctor_clinic['Palermo'] == clinic_map['Randsborough']\nsolver.add(Implies(longtree_souderton, And(nance_randsborough, palermo_randsborough)))\n\n# If Nance is at Randsborough, then so is Onawa.\nonawa_randsborough = doctor_clinic['Onawa'] == clinic_map['Randsborough']\nsolver.add(Implies(nance_randsborough, onawa_randsborough))\n\n# If Palermo is at Randsborough, then both Kudrow and Onawa are at Souderton.\nkudrow_souderton = doctor_clinic['Kudrow'] == clinic_map['Souderton']\nsolver.add(Implies(palermo_randsborough, And(kudrow_souderton, onawa_souderton)))\n\n# OPTION CHECKING\noptions = {\n    'A': doctor_clinic['Juarez'] == clinic_map['Souderton'],\n    'B': doctor_clinic['Nance'] == clinic_map['Souderton'],\n    'C': doctor_clinic['Onawa'] == clinic_map['Randsborough'],\n    'D': doctor_clinic['Palermo'] == clinic_map['Souderton'],\n    'E': doctor_clinic['Palermo'] == clinic_map['Randsborough'],\n}\n\n# Add the given condition: Kudrow is at Souderton\nsolver.add(kudrow_souderton)\n\n# We want to find which option must be true given the constraints and Kudrow at Souderton.\n# So for each option, check if its negation is satisfiable with the constraints.\n# The one whose negation is UNSAT must be true in all models.\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(Not(condition))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "From among eight candidates, four astronauts will be selected for a space flight. Four of the candidates—F, J, K, and L—are experienced astronauts and four—M, N, P, and T—are inexperienced astronauts. F, M, P, and T are geologists whereas J, K, L, and N are radiobiologists. The astronauts must be selected according to the following conditions: Exactly two experienced astronauts and two inexperienced astronauts are selected. Exactly two geologists and two radiobiologists are selected. Either P or L or both are selected.\n\nWhich one of the following is an acceptable selection of astronauts for the space flight?\n\nOptions:\n(A) F, J, N, and T\n(B) F, L, M, and P\n(C) F, M, N, and P\n(D) J, L, M, and T\n(E) K, L, N, and T",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncandidates = ['F', 'J', 'K', 'L', 'M', 'N', 'P', 'T']\n\n# Experienced and Inexperienced sets\nexperienced = ['F', 'J', 'K', 'L']\ninexperienced = ['M', 'N', 'P', 'T']\n\n# Geologists and Radiobiologists sets\ngeologists = ['F', 'M', 'P', 'T']\nradiobiologists = ['J', 'K', 'L', 'N']\n\n# Create a Bool variable for each candidate indicating selection (True if selected)\nselection = {c: Bool(c) for c in candidates}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly 4 astronauts are selected\nsolver.add(Sum([If(selection[c], 1, 0) for c in candidates]) == 4)\n\n# Exactly 2 experienced astronauts selected\nsolver.add(Sum([If(selection[c], 1, 0) for c in experienced]) == 2)\n\n# Exactly 2 inexperienced astronauts selected\nsolver.add(Sum([If(selection[c], 1, 0) for c in inexperienced]) == 2)\n\n# Exactly 2 geologists selected\nsolver.add(Sum([If(selection[c], 1, 0) for c in geologists]) == 2)\n\n# Exactly 2 radiobiologists selected\nsolver.add(Sum([If(selection[c], 1, 0) for c in radiobiologists]) == 2)\n\n# Either P or L or both selected\nsolver.add(Or(selection['P'], selection['L']))\n\n# OPTION CHECKING\noptions = [\n    ['F', 'J', 'N', 'T'],  # A\n    ['F', 'L', 'M', 'P'],  # B\n    ['F', 'M', 'N', 'P'],  # C\n    ['J', 'L', 'M', 'T'],  # D\n    ['K', 'L', 'N', 'T'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that exactly these candidates are selected\n    # For each candidate, if in option then selection must be True, else False\n    for c in candidates:\n        if c in option:\n            solver.add(selection[c] == True)\n        else:\n            solver.add(selection[c] == False)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "From among eight candidates, four astronauts will be selected for a space flight. Four of the candidates—F, J, K, and L—are experienced astronauts and four—M, N, P, and T—are inexperienced astronauts. F, M, P, and T are geologists whereas J, K, L, and N are radiobiologists. The astronauts must be selected according to the following conditions: Exactly two experienced astronauts and two inexperienced astronauts are selected. Exactly two geologists and two radiobiologists are selected. Either P or L or both are selected.\n\nIf F and P are selected for the space flight, the other two astronauts selected must be\n\nOptions:\n(A) a radiobiologist who is an experienced astronaut and a radiobiologist who is an inexperienced astronaut\n(B) a radiobiologist who is an experienced astronaut and a geologist who is an inexperienced astronaut\n(C) a radiobiologist and a geologist, both of whom are experienced astronauts\n(D) two radiobiologists, both of whom are experienced astronauts\n(E) two radiobiologists, both of whom are inexperienced astronauts",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncandidates = ['F', 'J', 'K', 'L', 'M', 'N', 'P', 'T']\n\n# Index mapping for candidates\nidx = {c: i for i, c in enumerate(candidates)}\n\n# Attributes of candidates\nexperienced = ['F', 'J', 'K', 'L']\ninexperienced = ['M', 'N', 'P', 'T']\n\ngeologists = ['F', 'M', 'P', 'T']\nradiobiologists = ['J', 'K', 'L', 'N']\n\n# Create Bool variables for selection of each candidate\nselected = {c: Bool(c) for c in candidates}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly 4 astronauts selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in candidates]) == 4)\n\n# Exactly 2 experienced astronauts selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in experienced]) == 2)\n\n# Exactly 2 inexperienced astronauts selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in inexperienced]) == 2)\n\n# Exactly 2 geologists selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in geologists]) == 2)\n\n# Exactly 2 radiobiologists selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in radiobiologists]) == 2)\n\n# Either P or L or both are selected\nsolver.add(Or(selected['P'], selected['L']))\n\n# Additional condition: F and P are selected\nsolver.add(selected['F'])\nsolver.add(selected['P'])\n\n# We want to find the other two astronauts selected, and check which option matches\n\n# The other two astronauts selected (excluding F and P)\nothers = [c for c in candidates if c not in ['F', 'P']]\n\n# For each option, we check if the other two astronauts satisfy the conditions\n\noptions = {\n    'A': And(\n        # a radiobiologist who is experienced AND a radiobiologist who is inexperienced\n        Sum([If(And(selected[c], c in radiobiologists, c in experienced), 1, 0) for c in others]) == 1,\n        Sum([If(And(selected[c], c in radiobiologists, c in inexperienced), 1, 0) for c in others]) == 1,\n        Sum([If(selected[c], 1, 0) for c in others]) == 2\n    ),\n    'B': And(\n        # a radiobiologist who is experienced AND a geologist who is inexperienced\n        Sum([If(And(selected[c], c in radiobiologists, c in experienced), 1, 0) for c in others]) == 1,\n        Sum([If(And(selected[c], c in geologists, c in inexperienced), 1, 0) for c in others]) == 1,\n        Sum([If(selected[c], 1, 0) for c in others]) == 2\n    ),\n    'C': And(\n        # a radiobiologist and a geologist, both experienced\n        Sum([If(And(selected[c], c in radiobiologists, c in experienced), 1, 0) for c in others]) == 1,\n        Sum([If(And(selected[c], c in geologists, c in experienced), 1, 0) for c in others]) == 1,\n        Sum([If(selected[c], 1, 0) for c in others]) == 2\n    ),\n    'D': And(\n        # two radiobiologists, both experienced\n        Sum([If(And(selected[c], c in radiobiologists, c in experienced), 1, 0) for c in others]) == 2,\n        Sum([If(selected[c], 1, 0) for c in others]) == 2\n    ),\n    'E': And(\n        # two radiobiologists, both inexperienced\n        Sum([If(And(selected[c], c in radiobiologists, c in inexperienced), 1, 0) for c in others]) == 2,\n        Sum([If(selected[c], 1, 0) for c in others]) == 2\n    )\n}\n\n# OPTION CHECKING\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "From among eight candidates, four astronauts will be selected for a space flight. Four of the candidates—F, J, K, and L—are experienced astronauts and four—M, N, P, and T—are inexperienced astronauts. F, M, P, and T are geologists whereas J, K, L, and N are radiobiologists. The astronauts must be selected according to the following conditions: Exactly two experienced astronauts and two inexperienced astronauts are selected. Exactly two geologists and two radiobiologists are selected. Either P or L or both are selected.\n\nIf M and T are selected for the space flight, which one of the following could be, but need not be, selected for the flight?\n\nOptions:\n(A) F\n(B) J\n(C) L\n(D) N\n(E) P",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncandidates = ['F', 'J', 'K', 'L', 'M', 'N', 'P', 'T']\nexperienced = ['F', 'J', 'K', 'L']\ninexperienced = ['M', 'N', 'P', 'T']\ngeologists = ['F', 'M', 'P', 'T']\nradiobiologists = ['J', 'K', 'L', 'N']\n\n# Create a Bool variable for each candidate indicating selection (True if selected)\nselected = {c: Bool(c) for c in candidates}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly 4 astronauts selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in candidates]) == 4)\n\n# Exactly 2 experienced selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in experienced]) == 2)\n\n# Exactly 2 inexperienced selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in inexperienced]) == 2)\n\n# Exactly 2 geologists selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in geologists]) == 2)\n\n# Exactly 2 radiobiologists selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in radiobiologists]) == 2)\n\n# Either P or L or both are selected\nsolver.add(Or(selected['P'], selected['L']))\n\n# M and T are selected\nsolver.add(selected['M'] == True)\nsolver.add(selected['T'] == True)\n\n# OPTION CHECKING\noptions = ['F', 'J', 'L', 'N', 'P']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Check if there exists a selection with M and T selected, and opt selected\n    solver.add(selected[opt] == True)\n    if solver.check() == sat:\n        model_with_opt = True\n    else:\n        model_with_opt = False\n    solver.pop()\n\n    solver.push()\n    # Check if there exists a selection with M and T selected, and opt NOT selected\n    solver.add(selected[opt] == False)\n    if solver.check() == sat:\n        model_without_opt = True\n    else:\n        model_without_opt = False\n    solver.pop()\n\n    # The candidate could be but need not be selected if both are True\n    if model_with_opt and model_without_opt:\n        print(f\"'{chr(65 + i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "From among eight candidates, four astronauts will be selected for a space flight. Four of the candidates—F, J, K, and L—are experienced astronauts and four—M, N, P, and T—are inexperienced astronauts. F, M, P, and T are geologists whereas J, K, L, and N are radiobiologists. The astronauts must be selected according to the following conditions: Exactly two experienced astronauts and two inexperienced astronauts are selected. Exactly two geologists and two radiobiologists are selected. Either P or L or both are selected.\n\nIf N is selected for the space flight, which one of the following must also be selected?\n\nOptions:\n(A) F\n(B) J\n(C) L\n(D) M\n(E) T",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncandidates = ['F', 'J', 'K', 'L', 'M', 'N', 'P', 'T']\n\n# Indices for categories\nexperienced = ['F', 'J', 'K', 'L']\ninexperienced = ['M', 'N', 'P', 'T']\n\ngeologists = ['F', 'M', 'P', 'T']\nradiobiologists = ['J', 'K', 'L', 'N']\n\n# Create a Bool variable for each candidate: True if selected, False otherwise\nselected = {c: Bool(c) for c in candidates}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly 4 astronauts selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in candidates]) == 4)\n\n# Exactly 2 experienced astronauts selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in experienced]) == 2)\n\n# Exactly 2 inexperienced astronauts selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in inexperienced]) == 2)\n\n# Exactly 2 geologists selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in geologists]) == 2)\n\n# Exactly 2 radiobiologists selected\nsolver.add(Sum([If(selected[c], 1, 0) for c in radiobiologists]) == 2)\n\n# Either P or L or both are selected\nsolver.add(Or(selected['P'], selected['L']))\n\n# N is selected\nsolver.add(selected['N'])\n\n# OPTION CHECKING\noptions = ['F', 'J', 'L', 'M', 'T']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that the option candidate is NOT selected\n    solver.add(Not(selected[opt]))\n    check_result = solver.check()\n    if check_result == unsat:\n        # If unsat, then opt must be selected when N is selected\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A showroom contains exactly six new cars—T, V, W, X, Y, and Z—each equipped with at least one of the following three options: power windows, leather interior, and sunroof. No car has any other options. The following conditions must apply: V has power windows and a sunroof. W has power windows and a leather interior. W and Y have no options in common. X has more options than W. V and Z have exactly one option in common. T has fewer options than Z.\n\nFor exactly how many of the six cars is it possible to determine exactly which options each one has?\n\nOptions:\n(A) two\n(B) three\n(C) four\n(D) five\n(E) six",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['T', 'V', 'W', 'X', 'Y', 'Z']\noptions = ['power_windows', 'leather_interior', 'sunroof']\nnum_options = len(options)\n\n# Create a dictionary of Int variables for each car and each option (0 or 1)\ncar_opts = {}\nfor c in cars:\n    car_opts[c] = [Int(f\"{c}_{opt}\") for opt in options]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each option variable is either 0 or 1\nfor c in cars:\n    for opt_var in car_opts[c]:\n        solver.add(Or(opt_var == 0, opt_var == 1))\n\n# Each car has at least one option\nfor c in cars:\n    solver.add(Sum(car_opts[c]) >= 1)\n\n# No car has any other options (already enforced by only these three options)\n\n# V has power windows and a sunroof\nsolver.add(car_opts['V'][options.index('power_windows')] == 1)\nsolver.add(car_opts['V'][options.index('sunroof')] == 1)\n\n# W has power windows and a leather interior\nsolver.add(car_opts['W'][options.index('power_windows')] == 1)\nsolver.add(car_opts['W'][options.index('leather_interior')] == 1)\n\n# W and Y have no options in common\n# For each option, W_opt + Y_opt <= 1 (no overlap)\nfor i in range(num_options):\n    solver.add(car_opts['W'][i] + car_opts['Y'][i] <= 1)\n\n# X has more options than W\nsolver.add(Sum(car_opts['X']) > Sum(car_opts['W']))\n\n# V and Z have exactly one option in common\ncommon_VZ = []\nfor i in range(num_options):\n    # common if both have option i\n    common_i = And(car_opts['V'][i] == 1, car_opts['Z'][i] == 1)\n    common_VZ.append(If(common_i, 1, 0))\nsolver.add(Sum(common_VZ) == 1)\n\n# T has fewer options than Z\nsolver.add(Sum(car_opts['T']) < Sum(car_opts['Z']))\n\n# OPTION CHECKING\n\n# We want to find for how many cars their options are uniquely determined.\n# For each car, check if there is exactly one option assignment possible.\n\ndef is_car_unique(car):\n    # Check if there is exactly one model for car's options given the constraints\n    # Strategy:\n    # 1. Find one solution\n    # 2. Add a constraint excluding that solution for this car's options\n    # 3. Check if another solution exists with different options for this car\n    # If no other solution exists, car's options are unique\n\n    # Save current solver state\n    solver.push()\n    if solver.check() != sat:\n        # No solution at all\n        solver.pop()\n        return False\n    model = solver.model()\n\n    # Extract option values for this car in the model\n    opt_vals = []\n    for opt_var in car_opts[car]:\n        val = model.eval(opt_var, model_completion=True)\n        opt_vals.append(val.as_long())\n\n    # Add constraint excluding this exact option combination for this car\n    diff_constraint = Or([car_opts[car][i] != opt_vals[i] for i in range(num_options)])\n    solver.add(diff_constraint)\n\n    # Check if another solution exists with different options for this car\n    res = solver.check()\n    solver.pop()\n    return res == unsat\n\nunique_count = 0\nfor c in cars:\n    if is_car_unique(c):\n        unique_count += 1\n\n# Map counts to options letters\noption_map = {\n    2: 'A',\n    3: 'B',\n    4: 'C',\n    5: 'D',\n    6: 'E'\n}\n\nprint(f\"'{option_map[unique_count]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A showroom contains exactly six new cars—T, V, W, X, Y, and Z—each equipped with at least one of the following three options: power windows, leather interior, and sunroof. No car has any other options. The following conditions must apply: V has power windows and a sunroof. W has power windows and a leather interior. W and Y have no options in common. X has more options than W. V and Z have exactly one option in common. T has fewer options than Z.\n\nWhich one of the following must be false?\n\nOptions:\n(A) Exactly five of the six cars have leather interiors.\n(B) Exactly five of the six cars have sunroofs.\n(C) Exactly four of the six cars have leather interiors.\n(D) Exactly four of the six cars have power windows.\n(E) Exactly four of the six cars have sunroofs.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['T', 'V', 'W', 'X', 'Y', 'Z']\noptions = ['power_windows', 'leather_interior', 'sunroof']\n\n# Create variables: for each car and option, a Bool indicating presence of that option\ncar_option = dict()\nfor car in cars:\n    for opt in options:\n        car_option[(car, opt)] = Bool(f\"{car}_{opt}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each car has at least one option and no other options (only these three)\nfor car in cars:\n    opts = [car_option[(car, opt)] for opt in options]\n    # At least one option\n    solver.add(Or(opts))\n    # No other options - implicitly satisfied since only these options are modeled\n\n# V has power windows and a sunroof\nsolver.add(car_option[('V', 'power_windows')] == True)\nsolver.add(car_option[('V', 'sunroof')] == True)\n\n# W has power windows and a leather interior\nsolver.add(car_option[('W', 'power_windows')] == True)\nsolver.add(car_option[('W', 'leather_interior')] == True)\n\n# W and Y have no options in common\nfor opt in options:\n    solver.add(Or(car_option[('W', opt)] != car_option[('Y', opt)]))\n\n# X has more options than W\ndef count_options(car):\n    return Sum([If(car_option[(car, opt)], 1, 0) for opt in options])\n\nsolver.add(count_options('X') > count_options('W'))\n\n# V and Z have exactly one option in common\ncommon_VZ = [And(car_option[('V', opt)], car_option[('Z', opt)]) for opt in options]\nsolver.add(Sum([If(c, 1, 0) for c in common_VZ]) == 1)\n\n# T has fewer options than Z\nsolver.add(count_options('T') < count_options('Z'))\n\n# OPTION CHECKING\n# For each option (A-E), check if it can be true. The one that must be false will make the model unsat.\n\noption_exprs = {\n    'A': Sum([If(car_option[(car, 'leather_interior')], 1, 0) for car in cars]) == 5,\n    'B': Sum([If(car_option[(car, 'sunroof')], 1, 0) for car in cars]) == 5,\n    'C': Sum([If(car_option[(car, 'leather_interior')], 1, 0) for car in cars]) == 4,\n    'D': Sum([If(car_option[(car, 'power_windows')], 1, 0) for car in cars]) == 4,\n    'E': Sum([If(car_option[(car, 'sunroof')], 1, 0) for car in cars]) == 4,\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(option_exprs[letter])\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        solver.pop()\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A showroom contains exactly six new cars—T, V, W, X, Y, and Z—each equipped with at least one of the following three options: power windows, leather interior, and sunroof. No car has any other options. The following conditions must apply: V has power windows and a sunroof. W has power windows and a leather interior. W and Y have no options in common. X has more options than W. V and Z have exactly one option in common. T has fewer options than Z.\n\nIf all the cars that have leather interiors also have power windows, which one of the following must be false?\n\nOptions:\n(A) T has power windows.\n(B) T has a sunroof.\n(C) V has power windows.\n(D) Z has power windows.\n(E) Z has a sunroof.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['T', 'V', 'W', 'X', 'Y', 'Z']\noptions = ['power_windows', 'leather_interior', 'sunroof']\nnum_options = len(options)\n\n# Create a dictionary of Bool variables: car_option[car][option]\ncar_option = dict()\nfor c in cars:\n    car_option[c] = dict()\n    for o in options:\n        car_option[c][o] = Bool(f\"{c}_{o}\")\n\n# Helper function: count number of options for a car\ndef count_options(car):\n    return Sum([If(car_option[car][o], 1, 0) for o in options])\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each car has at least one option and no other options (only these three)\nfor c in cars:\n    # At least one option\n    solver.add(Or([car_option[c][o] for o in options]))\n\n# Given conditions:\n\n# 1) V has power windows and a sunroof.\nsolver.add(car_option['V']['power_windows'])\nsolver.add(car_option['V']['sunroof'])\n\n# 2) W has power windows and a leather interior.\nsolver.add(car_option['W']['power_windows'])\nsolver.add(car_option['W']['leather_interior'])\n\n# 3) W and Y have no options in common.\n# For each option, W[o] and Y[o] cannot both be True\nfor o in options:\n    solver.add(Or(Not(car_option['W'][o]), Not(car_option['Y'][o])))\n\n# 4) X has more options than W.\nsolver.add(count_options('X') > count_options('W'))\n\n# 5) V and Z have exactly one option in common.\ncommon_VZ = []\nfor o in options:\n    common_VZ.append(And(car_option['V'][o], car_option['Z'][o]))\nsolver.add(Sum([If(c,1,0) for c in common_VZ]) == 1)\n\n# 6) T has fewer options than Z.\nsolver.add(count_options('T') < count_options('Z'))\n\n# Additional condition: All cars that have leather interiors also have power windows.\nfor c in cars:\n    solver.add(Implies(car_option[c]['leather_interior'], car_option[c]['power_windows']))\n\n# OPTION CHECKING\n# We want to check which option must be false.\n# That is, for each option, add the assumption that it is true and check if the model is satisfiable.\n# If it is unsat, then that option must be false.\n\noption_vars = {\n    'A': car_option['T']['power_windows'],\n    'B': car_option['T']['sunroof'],\n    'C': car_option['V']['power_windows'],\n    'D': car_option['Z']['power_windows'],\n    'E': car_option['Z']['sunroof'],\n}\n\nfor letter in ['A','B','C','D','E']:\n    solver.push()\n    # Assume the option is true\n    solver.add(option_vars[letter] == True)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A showroom contains exactly six new cars—T, V, W, X, Y, and Z—each equipped with at least one of the following three options: power windows, leather interior, and sunroof. No car has any other options. The following conditions must apply: V has power windows and a sunroof. W has power windows and a leather interior. W and Y have no options in common. X has more options than W. V and Z have exactly one option in common. T has fewer options than Z.\n\nIf Z has no options in common with T but has at least one option in common with every other car, then which one of the following must be false?\n\nOptions:\n(A) T has power windows.\n(B) Z has a sunroof.\n(C) Exactly four of the six cars have power windows.\n(D) Exactly four of the six cars have leather interiors.\n(E) Exactly four of the six cars have sunroofs.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['T', 'V', 'W', 'X', 'Y', 'Z']\noptions = ['power_windows', 'leather_interior', 'sunroof']\nnum_options = len(options)\n\n# Create a dictionary of Bool variables: car -> option -> Bool variable\ncar_options = {}\nfor c in cars:\n    car_options[c] = {}\n    for o in options:\n        car_options[c][o] = Bool(f\"{c}_{o}\")\n\nsolver = Solver()\n\n# Each car has at least one option\nfor c in cars:\n    opts = [car_options[c][o] for o in options]\n    solver.add(Or(opts))\n\n# No car has any other options (only these three options) - implicit by design\n\n# CONSTRAINTS\n\n# V has power windows and a sunroof\nsolver.add(car_options['V']['power_windows'])\nsolver.add(car_options['V']['sunroof'])\n\n# W has power windows and a leather interior\nsolver.add(car_options['W']['power_windows'])\nsolver.add(car_options['W']['leather_interior'])\n\n# W and Y have no options in common\n# For each option, not both have it\nfor o in options:\n    solver.add(Or(Not(car_options['W'][o]), Not(car_options['Y'][o])))\n\n# X has more options than W\n# Count options for W and X\ndef count_options(car):\n    return Sum([If(car_options[car][o], 1, 0) for o in options])\nsolver.add(count_options('X') > count_options('W'))\n\n# V and Z have exactly one option in common\ncommon_VZ = []\nfor o in options:\n    common_VZ.append(And(car_options['V'][o], car_options['Z'][o]))\nsolver.add(Sum([If(c, 1, 0) for c in common_VZ]) == 1)\n\n# T has fewer options than Z\nsolver.add(count_options('T') < count_options('Z'))\n\n# Additional condition in the question:\n# Z has no options in common with T but has at least one option in common with every other car\n# i.e. intersection(Z,T) = 0\n# and for every other car c in {V,W,X,Y}, intersection(Z,c) >= 1\nfor o in options:\n    solver.add(Or(Not(car_options['Z'][o]), Not(car_options['T'][o])))  # no common option between Z and T\n\nfor c in ['V', 'W', 'X', 'Y']:\n    common_Zc = []\n    for o in options:\n        common_Zc.append(And(car_options['Z'][o], car_options[c][o]))\n    solver.add(Sum([If(c_, 1, 0) for c_ in common_Zc]) >= 1)\n\n# OPTION CHECKING\n\n# Define helper function to count how many cars have a given option\ndef count_cars_with_option(option):\n    return Sum([If(car_options[c][option], 1, 0) for c in cars])\n\noptions_checks = {\n    'A': car_options['T']['power_windows'],              # T has power windows\n    'B': car_options['Z']['sunroof'],                     # Z has a sunroof\n    'C': count_cars_with_option('power_windows') == 4,   # Exactly four cars have power windows\n    'D': count_cars_with_option('leather_interior') == 4,# Exactly four cars have leather interiors\n    'E': count_cars_with_option('sunroof') == 4          # Exactly four cars have sunroofs\n}\n\n# We want to know which option must be false.\n# For each option, check if it can be true. If it cannot be true, that option must be false.\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options_checks[letter])\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A showroom contains exactly six new cars—T, V, W, X, Y, and Z—each equipped with at least one of the following three options: power windows, leather interior, and sunroof. No car has any other options. The following conditions must apply: V has power windows and a sunroof. W has power windows and a leather interior. W and Y have no options in common. X has more options than W. V and Z have exactly one option in common. T has fewer options than Z.\n\nSuppose that no two cars have exactly the same options as one another. In that case, each of the following could be true EXCEPT:\n\nOptions:\n(A) Exactly three of the six cars have power windows.\n(B) Exactly four of the six cars have power windows.\n(C) Exactly three of the six cars have sunroofs.\n(D) Exactly four of the six cars have sunroofs.\n(E) Exactly four of the six cars have leather interiors.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['T', 'V', 'W', 'X', 'Y', 'Z']\noptions = ['power_windows', 'leather_interior', 'sunroof']\nnum_options = len(options)\n\n# Create a dictionary of Bool variables: car -> option -> Bool\ncar_opts = {}\nfor c in cars:\n    car_opts[c] = {}\n    for o in options:\n        car_opts[c][o] = Bool(f\"{c}_{o}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each car has at least one option and no other options (only these three)\nfor c in cars:\n    opts_list = [car_opts[c][o] for o in options]\n    solver.add(Or(opts_list))  # at least one option\n\n# V has power windows and sunroof\nsolver.add(car_opts['V']['power_windows'])\nsolver.add(car_opts['V']['sunroof'])\n\n# W has power windows and leather interior\nsolver.add(car_opts['W']['power_windows'])\nsolver.add(car_opts['W']['leather_interior'])\n\n# W and Y have no options in common\nno_common_opts = []\nfor o in options:\n    no_common_opts.append(Or(Not(car_opts['W'][o]), Not(car_opts['Y'][o])))\nsolver.add(And(no_common_opts))\n\n# X has more options than W\n# Count options for W and X\ndef count_opts(car):\n    return Sum([If(car_opts[car][o], 1, 0) for o in options])\nsolver.add(count_opts('X') > count_opts('W'))\n\n# V and Z have exactly one option in common\ncommon_VZ = []\nfor o in options:\n    common_VZ.append(And(car_opts['V'][o], car_opts['Z'][o]))\nsolver.add(Sum([If(c, 1, 0) for c in common_VZ]) == 1)\n\n# T has fewer options than Z\nsolver.add(count_opts('T') < count_opts('Z'))\n\n# No two cars have exactly the same options\nfor i in range(len(cars)):\n    for j in range(i+1, len(cars)):\n        c1 = cars[i]\n        c2 = cars[j]\n        equal_opts = []\n        for o in options:\n            equal_opts.append(car_opts[c1][o] == car_opts[c2][o])\n        solver.add(Not(And(equal_opts)))\n\n# OPTION CHECKING\n# We need to check which option is NOT possible given the above constraints.\n# Each option states a count of cars with a certain option.\n# We'll add the constraint for that option and check satisfiability.\n\n# Define a helper to count how many cars have a given option\ndef count_cars_with_option(option):\n    return Sum([If(car_opts[c][option], 1, 0) for c in cars])\n\noptions_to_check = [\n    ('A', 'power_windows', 3),\n    ('B', 'power_windows', 4),\n    ('C', 'sunroof', 3),\n    ('D', 'sunroof', 4),\n    ('E', 'leather_interior', 4)\n]\n\nfor letter, opt_name, count_val in options_to_check:\n    solver.push()\n    solver.add(count_cars_with_option(opt_name) == count_val)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        # This option cannot be true\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A showroom contains exactly six new cars—T, V, W, X, Y, and Z—each equipped with at least one of the following three options: power windows, leather interior, and sunroof. No car has any other options. The following conditions must apply: V has power windows and a sunroof. W has power windows and a leather interior. W and Y have no options in common. X has more options than W. V and Z have exactly one option in common. T has fewer options than Z.\n\nIf exactly four of the six cars have leather interiors, and exactly four of the six cars have power windows, then each of the following must be true EXCEPT:\n\nOptions:\n(A) T and V have no options in common.\n(B) T and Y have no options in common.\n(C) T and Z have exactly one option in common.\n(D) W and Z have exactly one option in common.\n(E) Y and Z have no options in common.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['T', 'V', 'W', 'X', 'Y', 'Z']\noptions = ['power_windows', 'leather_interior', 'sunroof']\noption_indices = {opt: i for i, opt in enumerate(options)}\n\n# Create variables: For each car and each option, a Bool indicating if the car has that option\ncar_options = {}\nfor c in cars:\n    for o in options:\n        car_options[(c, o)] = Bool(f\"{c}_{o}\")\n\n# Helper to count how many options a car has\ndef num_options(car):\n    return Sum([If(car_options[(car, o)], 1, 0) for o in options])\n\n# Helper to count how many cars have a given option\ndef num_cars_with_option(opt):\n    return Sum([If(car_options[(c, opt)], 1, 0) for c in cars])\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each car has at least one option (given)\nfor c in cars:\n    solver.add(num_options(c) >= 1)\n\n# No car has options other than the three listed (implicitly ensured by model)\n\n# V has power windows and a sunroof.\nsolver.add(car_options[('V', 'power_windows')] == True)\nsolver.add(car_options[('V', 'sunroof')] == True)\n\n# W has power windows and a leather interior.\nsolver.add(car_options[('W', 'power_windows')] == True)\nsolver.add(car_options[('W', 'leather_interior')] == True)\n\n# W and Y have no options in common.\n# For each option, not both W and Y have it\nfor o in options:\n    solver.add(Or(Not(car_options[('W', o)]), Not(car_options[('Y', o)])))\n\n# X has more options than W.\nsolver.add(num_options('X') > num_options('W'))\n\n# V and Z have exactly one option in common.\ncommon_VZ = [And(car_options[('V', o)], car_options[('Z', o)]) for o in options]\nsolver.add(Sum([If(c, 1, 0) for c in common_VZ]) == 1)\n\n# T has fewer options than Z.\nsolver.add(num_options('T') < num_options('Z'))\n\n# Exactly four of the six cars have leather interiors.\nsolver.add(num_cars_with_option('leather_interior') == 4)\n\n# Exactly four of the six cars have power windows.\nsolver.add(num_cars_with_option('power_windows') == 4)\n\n# OPTION CHECKING\noptions_statements = {\n    'A': \"T and V have no options in common.\",\n    'B': \"T and Y have no options in common.\",\n    'C': \"T and Z have exactly one option in common.\",\n    'D': \"W and Z have exactly one option in common.\",\n    'E': \"Y and Z have no options in common.\"\n}\n\ndef no_options_in_common(c1, c2):\n    return And([Or(Not(car_options[(c1, o)]), Not(car_options[(c2, o)])) for o in options])\n\ndef exactly_one_option_in_common(c1, c2):\n    common = [And(car_options[(c1, o)], car_options[(c2, o)]) for o in options]\n    return Sum([If(c, 1, 0) for c in common]) == 1\n\n# Check which option is NOT necessarily true\nfor letter in ['A','B','C','D','E']:\n    solver.push()\n    # Add the negation of the statement to see if it is possible\n    if letter == 'A':\n        # Negate: T and V have no options in common -> there is at least one common option\n        solver.add(Not(no_options_in_common('T', 'V')))\n    elif letter == 'B':\n        # Negate: T and Y have no options in common -> there is at least one common option\n        solver.add(Not(no_options_in_common('T', 'Y')))\n    elif letter == 'C':\n        # Negate: T and Z have exactly one option in common -> common options != 1\n        common = [And(car_options[('T', o)], car_options[('Z', o)]) for o in options]\n        sum_common = Sum([If(c, 1, 0) for c in common])\n        solver.add(Or(sum_common != 1))\n    elif letter == 'D':\n        # Negate: W and Z have exactly one option in common -> common options != 1\n        common = [And(car_options[('W', o)], car_options[('Z', o)]) for o in options]\n        sum_common = Sum([If(c, 1, 0) for c in common])\n        solver.add(Or(sum_common != 1))\n    elif letter == 'E':\n        # Negate: Y and Z have no options in common -> there is at least one common option\n        solver.add(Not(no_options_in_common('Y', 'Z')))\n    else:\n        solver.pop()\n        continue\n\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A showroom contains exactly six new cars—T, V, W, X, Y, and Z—each equipped with at least one of the following three options: power windows, leather interior, and sunroof. No car has any other options. The following conditions must apply: V has power windows and a sunroof. W has power windows and a leather interior. W and Y have no options in common. X has more options than W. V and Z have exactly one option in common. T has fewer options than Z.\n\nSuppose that the condition requiring that X has more options than W is replaced by a new condition requiring that X and W have exactly two options in common. If all of the other original conditions remain in effect, which one of the following must be false?\n\nOptions:\n(A) T and X have no options in common.\n(B) V and X have exactly one option in common.\n(C) V and X have exactly two options in common.\n(D) X and Z have no options in common.\n(E) X and Z have exactly two options in common.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncars = ['T', 'V', 'W', 'X', 'Y', 'Z']\noptions = ['power_windows', 'leather_interior', 'sunroof']\nnum_options = len(options)\n\n# Create a dictionary to hold option variables for each car\n# Each car has a list of 3 Bool variables indicating presence of each option\ncar_opts = {}\nfor c in cars:\n    car_opts[c] = [Bool(f\"{c}_{opt}\") for opt in options]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each car has at least one option and no other options\nfor c in cars:\n    solver.add(Or(car_opts[c]))  # at least one option\n\n# V has power windows and a sunroof\nsolver.add(car_opts['V'][options.index('power_windows')])\nsolver.add(car_opts['V'][options.index('sunroof')])\n\n# W has power windows and a leather interior\nsolver.add(car_opts['W'][options.index('power_windows')])\nsolver.add(car_opts['W'][options.index('leather_interior')])\n\n# W and Y have no options in common\nfor i in range(num_options):\n    solver.add(Or(Not(car_opts['W'][i]), Not(car_opts['Y'][i])))\n\n# V and Z have exactly one option in common\nVZ_common = []\nfor i in range(num_options):\n    VZ_common.append(And(car_opts['V'][i], car_opts['Z'][i]))\nsolver.add(Sum([If(cond, 1, 0) for cond in VZ_common]) == 1)\n\n# T has fewer options than Z\nT_count = Sum([If(car_opts['T'][i], 1, 0) for i in range(num_options)])\nZ_count = Sum([If(car_opts['Z'][i], 1, 0) for i in range(num_options)])\nsolver.add(T_count < Z_count)\n\n# REPLACED CONDITION:\n# X and W have exactly two options in common (replaces: X has more options than W)\nXW_common = []\nfor i in range(num_options):\n    XW_common.append(And(car_opts['X'][i], car_opts['W'][i]))\nsolver.add(Sum([If(cond, 1, 0) for cond in XW_common]) == 2)\n\n# Now define helper functions to count common options between two cars\ndef common_options(c1, c2):\n    return Sum([If(And(car_opts[c1][i], car_opts[c2][i]), 1, 0) for i in range(num_options)])\n\n# OPTION CHECKING\n\n# We will check which option must be false by adding the negation of each option and checking satisfiability\n# If negation of option is unsat, then option must be true; if option itself is unsat, then option must be false\n\n# (A) T and X have no options in common.\n# Translate: common_options(T,X) == 0\noptA = common_options('T', 'X') == 0\n\n# (B) V and X have exactly one option in common.\noptB = common_options('V', 'X') == 1\n\n# (C) V and X have exactly two options in common.\noptC = common_options('V', 'X') == 2\n\n# (D) X and Z have no options in common.\noptD = common_options('X', 'Z') == 0\n\n# (E) X and Z have exactly two options in common.\noptE = common_options('X', 'Z') == 2\n\noptions_list = [optA, optB, optC, optD, optE]\n\nfor i, opt in enumerate(options_list):\n    solver.push()\n    # Add negation of option to test if option can be false\n    solver.add(Not(opt))\n    if solver.check() == unsat:\n        # Negation unsat means option must be true, so option cannot be false\n        solver.pop()\n        continue\n    else:\n        # Option can be false, so it is not necessarily true\n        # Now check if option itself is unsat (must be false)\n        solver.pop()\n        solver.push()\n        solver.add(opt)\n        if solver.check() == unsat:\n            # Option itself unsat means option must be false\n            print(f\"'{chr(65+i)}'\")\n            break\n        else:\n            solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Quentin, Robert, Shiro, Tony, and Umeko are the only members of the Kim family who attend an opera. Each of them sits in a separate seat in either row G or row H, and each sits in a seat numbered 1, 2, or 3. Consecutively numbered seats within each row are adjacent. Each member of the Kim family sits in a seat adjacent to, and in the same row as, at least one other member of the family. Tony and Umeko sit in row H. Shiro and Umeko sit in lower numbered seats than does Tony. Robert sits in the same row as Quentin or Shiro or both. Robert sits in a seat numbered 2.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) Seat G3 is empty.\n(B) Seat H2 is empty.\n(C) Shiro sits in a seat numbered 3.\n(D) Tony sits in a seat numbered 1.\n(E) Umeko sits in a seat numbered 3.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['Quentin', 'Robert', 'Shiro', 'Tony', 'Umeko']\nrows = ['G', 'H']\nseat_numbers = [1, 2, 3]\n\n# Map rows to indices for Z3\nrow_indices = {r: i for i, r in enumerate(rows)}\n\n# Variables for each member: row (0 for G, 1 for H), seat number (1,2,3)\nrow_vars = {m: Int(f'row_{m}') for m in members}\nseat_vars = {m: Int(f'seat_{m}') for m in members}\n\n# Helper: seat index within a row (0-based)\ndef seat_index(seat_num):\n    return seat_num - 1\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each member sits in a valid row and seat number\nfor m in members:\n    solver.add(Or(row_vars[m] == row_indices['G'], row_vars[m] == row_indices['H']))\n    solver.add(And(seat_vars[m] >= 1, seat_vars[m] <= 3))\n\n# All members sit in distinct seats (row and seat number)\nfor i in range(len(members)):\n    for j in range(i + 1, len(members)):\n        m1 = members[i]\n        m2 = members[j]\n        diff_row = row_vars[m1] != row_vars[m2]\n        diff_seat = seat_vars[m1] != seat_vars[m2]\n        solver.add(Or(diff_row, diff_seat))\n\n# Each member sits adjacent to at least one other member in the same row\n# Adjacent means same row and seat numbers differ by 1\nfor m in members:\n    adjacents = []\n    for other in members:\n        if other == m:\n            continue\n        same_row = row_vars[m] == row_vars[other]\n        seat_diff_1 = Or(seat_vars[m] == seat_vars[other] + 1, seat_vars[m] == seat_vars[other] - 1)\n        adjacents.append(And(same_row, seat_diff_1))\n    solver.add(Or(adjacents))\n\n# Tony and Umeko sit in row H\nsolver.add(row_vars['Tony'] == row_indices['H'])\nsolver.add(row_vars['Umeko'] == row_indices['H'])\n\n# Shiro and Umeko sit in lower numbered seats than Tony\nsolver.add(seat_vars['Shiro'] < seat_vars['Tony'])\nsolver.add(seat_vars['Umeko'] < seat_vars['Tony'])\n\n# Robert sits in the same row as Quentin or Shiro or both\nsame_row_Q = row_vars['Robert'] == row_vars['Quentin']\nsame_row_S = row_vars['Robert'] == row_vars['Shiro']\nsolver.add(Or(same_row_Q, same_row_S))\n\n# Robert sits in seat number 2\nsolver.add(seat_vars['Robert'] == 2)\n\n# OPTION CHECKING\noptions = {\n    'A': And(row_indices['G'] == row_indices['G'],  # seat G3 empty means no one sits at row G seat 3\n             Not(And(row_vars['Quentin'] == row_indices['G'], seat_vars['Quentin'] == 3)),\n             Not(And(row_vars['Robert'] == row_indices['G'], seat_vars['Robert'] == 3)),\n             Not(And(row_vars['Shiro'] == row_indices['G'], seat_vars['Shiro'] == 3)),\n             Not(And(row_vars['Tony'] == row_indices['G'], seat_vars['Tony'] == 3)),\n             Not(And(row_vars['Umeko'] == row_indices['G'], seat_vars['Umeko'] == 3))),\n    'B': And(row_indices['H'] == row_indices['H'],  # seat H2 empty means no one sits at row H seat 2\n             Not(And(row_vars['Quentin'] == row_indices['H'], seat_vars['Quentin'] == 2)),\n             Not(And(row_vars['Robert'] == row_indices['H'], seat_vars['Robert'] == 2)),\n             Not(And(row_vars['Shiro'] == row_indices['H'], seat_vars['Shiro'] == 2)),\n             Not(And(row_vars['Tony'] == row_indices['H'], seat_vars['Tony'] == 2)),\n             Not(And(row_vars['Umeko'] == row_indices['H'], seat_vars['Umeko'] == 2))),\n    'C': seat_vars['Shiro'] == 3,\n    'D': seat_vars['Tony'] == 1,\n    'E': seat_vars['Umeko'] == 3,\n}\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[opt])\n    if solver.check() == sat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Quentin, Robert, Shiro, Tony, and Umeko are the only members of the Kim family who attend an opera. Each of them sits in a separate seat in either row G or row H, and each sits in a seat numbered 1, 2, or 3. Consecutively numbered seats within each row are adjacent. Each member of the Kim family sits in a seat adjacent to, and in the same row as, at least one other member of the family. Tony and Umeko sit in row H. Shiro and Umeko sit in lower numbered seats than does Tony. Robert sits in the same row as Quentin or Shiro or both. Robert sits in a seat numbered 2.\n\nWhich one of the following statements could be true?\n\nOptions:\n(A) Robert sits in row H.\n(B) Shiro sits in row H.\n(C) Quentin sits in the same row as, and in a seat adjacent to, Shiro.\n(D) Robert sits in the same row as, and in a seat adjacent to, Tony.\n(E) Robert sits in the same row as, and in a seat adjacent to, Umeko.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['Quentin', 'Robert', 'Shiro', 'Tony', 'Umeko']\nrows = ['G', 'H']\nrow_indices = {r: i for i, r in enumerate(rows)}\nseats = [1, 2, 3]\n\n# Variables: row and seat for each member\nrow_vars = {m: Int(f\"row_{m}\") for m in members}\nseat_vars = {m: Int(f\"seat_{m}\") for m in members}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each member sits in a valid row (0 for G, 1 for H)\nfor m in members:\n    solver.add(Or([row_vars[m] == row_indices[r] for r in rows]))\n\n# Each member sits in a valid seat number (1, 2, or 3)\nfor m in members:\n    solver.add(Or([seat_vars[m] == s for s in seats]))\n\n# Each member sits in a unique seat (row and seat combination)\npositions = [ (row_vars[m], seat_vars[m]) for m in members ]\nfor i in range(len(members)):\n    for j in range(i+1, len(members)):\n        solver.add(Or(row_vars[members[i]] != row_vars[members[j]],\n                      seat_vars[members[i]] != seat_vars[members[j]]))\n\n# Tony and Umeko sit in row H (row index 1)\nsolver.add(row_vars['Tony'] == row_indices['H'])\nsolver.add(row_vars['Umeko'] == row_indices['H'])\n\n# Shiro and Umeko sit in lower numbered seats than Tony\nsolver.add(seat_vars['Shiro'] < seat_vars['Tony'])\nsolver.add(seat_vars['Umeko'] < seat_vars['Tony'])\n\n# Robert sits in seat number 2\nsolver.add(seat_vars['Robert'] == 2)\n\n# Robert sits in the same row as Quentin or Shiro or both\nrobert_row = row_vars['Robert']\nquentin_row = row_vars['Quentin']\nshiro_row = row_vars['Shiro']\nsolver.add(Or(robert_row == quentin_row, robert_row == shiro_row))\n\n# Each member sits adjacent to at least one other member in the same row\n# Adjacent seats are seats with consecutive numbers in the same row\nfor m in members:\n    same_row = []\n    for other in members:\n        if other != m:\n            same_row.append(And(row_vars[m] == row_vars[other],\n                                Abs(seat_vars[m] - seat_vars[other]) == 1))\n    solver.add(Or(same_row))\n\n# OPTION CHECKING\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\n# Define helper function to add option-specific constraints\ndef check_option(option):\n    solver.push()\n    if option == 'A':\n        # Robert sits in row H\n        solver.add(row_vars['Robert'] == row_indices['H'])\n    elif option == 'B':\n        # Shiro sits in row H\n        solver.add(row_vars['Shiro'] == row_indices['H'])\n    elif option == 'C':\n        # Quentin sits in the same row as, and in a seat adjacent to, Shiro\n        solver.add(row_vars['Quentin'] == row_vars['Shiro'])\n        solver.add(Abs(seat_vars['Quentin'] - seat_vars['Shiro']) == 1)\n    elif option == 'D':\n        # Robert sits in the same row as, and in a seat adjacent to, Tony\n        solver.add(row_vars['Robert'] == row_vars['Tony'])\n        solver.add(Abs(seat_vars['Robert'] - seat_vars['Tony']) == 1)\n    elif option == 'E':\n        # Robert sits in the same row as, and in a seat adjacent to, Umeko\n        solver.add(row_vars['Robert'] == row_vars['Umeko'])\n        solver.add(Abs(seat_vars['Robert'] - seat_vars['Umeko']) == 1)\n    else:\n        solver.pop()\n        return False\n\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\nfor opt in options:\n    if check_option(opt):\n        print(f\"'{opt}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Quentin, Robert, Shiro, Tony, and Umeko are the only members of the Kim family who attend an opera. Each of them sits in a separate seat in either row G or row H, and each sits in a seat numbered 1, 2, or 3. Consecutively numbered seats within each row are adjacent. Each member of the Kim family sits in a seat adjacent to, and in the same row as, at least one other member of the family. Tony and Umeko sit in row H. Shiro and Umeko sit in lower numbered seats than does Tony. Robert sits in the same row as Quentin or Shiro or both. Robert sits in a seat numbered 2.\n\nIf Tony sits in a seat numbered 2, then which one of the following statements could be false?\n\nOptions:\n(A) Quentin sits in a seat numbered 3.\n(B) Umeko sits in a seat numbered 1.\n(C) Quentin sits in the same row as, and in a seat adjacent to, Robert.\n(D) Robert sits in the same row as, and in a seat adjacent to, Shiro.\n(E) Tony sits in the same row as, and in a seat adjacent to, Umeko.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['Quentin', 'Robert', 'Shiro', 'Tony', 'Umeko']\nrows = ['G', 'H']\nrow_indices = {r: i for i, r in enumerate(rows)}\nseat_numbers = [1, 2, 3]\n\n# Create Z3 variables for each member's row and seat number\nrow_vars = {m: Int(f'row_{m}') for m in members}   # 0 for G, 1 for H\nseat_vars = {m: Int(f'seat_{m}') for m in members} # seat number 1,2,3\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each member sits in a valid row and seat\nfor m in members:\n    solver.add(And(row_vars[m] >= 0, row_vars[m] < len(rows)))\n    solver.add(And(seat_vars[m] >= 1, seat_vars[m] <= 3))\n\n# All members sit in separate seats (no two members share same row and seat)\nfor i in range(len(members)):\n    for j in range(i+1, len(members)):\n        m1 = members[i]\n        m2 = members[j]\n        # Not same row and seat\n        solver.add(Or(row_vars[m1] != row_vars[m2], seat_vars[m1] != seat_vars[m2]))\n\n# Each member sits adjacent to at least one other member in the same row\nfor m in members:\n    adjacents = []\n    for other in members:\n        if other == m:\n            continue\n        same_row = row_vars[m] == row_vars[other]\n        adjacent_seat = Or(seat_vars[m] == seat_vars[other] + 1,\n                           seat_vars[m] == seat_vars[other] - 1)\n        adjacents.append(And(same_row, adjacent_seat))\n    solver.add(Or(adjacents))\n\n# Tony and Umeko sit in row H (index 1)\nsolver.add(row_vars['Tony'] == row_indices['H'])\nsolver.add(row_vars['Umeko'] == row_indices['H'])\n\n# Shiro and Umeko sit in lower numbered seats than Tony\nsolver.add(seat_vars['Shiro'] < seat_vars['Tony'])\nsolver.add(seat_vars['Umeko'] < seat_vars['Tony'])\n\n# Robert sits in the same row as Quentin or Shiro or both\nsame_row_robert_quentin = row_vars['Robert'] == row_vars['Quentin']\nsame_row_robert_shiro = row_vars['Robert'] == row_vars['Shiro']\nsolver.add(Or(same_row_robert_quentin, same_row_robert_shiro))\n\n# Robert sits in seat numbered 2\nsolver.add(seat_vars['Robert'] == 2)\n\n# Additional condition for the question:\n# Tony sits in seat numbered 2\nsolver.add(seat_vars['Tony'] == 2)\n\n# OPTION CHECKING\n# We want to find which option could be FALSE\n# So for each option, we add the negation of the option and check if still satisfiable\n\n# (A) Quentin sits in a seat numbered 3.\n# Negation: Quentin does NOT sit in seat 3 (seat != 3)\noption_A = seat_vars['Quentin'] == 3\nneg_A = seat_vars['Quentin'] != 3\n\n# (B) Umeko sits in a seat numbered 1.\n# Negation: Umeko does NOT sit in seat 1\noption_B = seat_vars['Umeko'] == 1\nneg_B = seat_vars['Umeko'] != 1\n\n# (C) Quentin sits in the same row as, and in a seat adjacent to, Robert.\n# Negation: Quentin NOT in same row or NOT adjacent seat to Robert\nsame_row_QR = row_vars['Quentin'] == row_vars['Robert']\nadjacent_QR = Or(seat_vars['Quentin'] == seat_vars['Robert'] + 1,\n                 seat_vars['Quentin'] == seat_vars['Robert'] - 1)\noption_C = And(same_row_QR, adjacent_QR)\nneg_C = Or(row_vars['Quentin'] != row_vars['Robert'], Not(adjacent_QR))\n\n# (D) Robert sits in the same row as, and in a seat adjacent to, Shiro.\n# Negation: Robert NOT in same row or NOT adjacent seat to Shiro\nsame_row_RS = row_vars['Robert'] == row_vars['Shiro']\nadjacent_RS = Or(seat_vars['Robert'] == seat_vars['Shiro'] + 1,\n                 seat_vars['Robert'] == seat_vars['Shiro'] - 1)\noption_D = And(same_row_RS, adjacent_RS)\nneg_D = Or(row_vars['Robert'] != row_vars['Shiro'], Not(adjacent_RS))\n\n# (E) Tony sits in the same row as, and in a seat adjacent to, Umeko.\n# Negation: Tony NOT in same row or NOT adjacent seat to Umeko\nsame_row_TU = row_vars['Tony'] == row_vars['Umeko']\nadjacent_TU = Or(seat_vars['Tony'] == seat_vars['Umeko'] + 1,\n                 seat_vars['Tony'] == seat_vars['Umeko'] - 1)\noption_E = And(same_row_TU, adjacent_TU)\nneg_E = Or(row_vars['Tony'] != row_vars['Umeko'], Not(adjacent_TU))\n\noptions_neg = [neg_A, neg_B, neg_C, neg_D, neg_E]\n\nfor i, neg_option in enumerate(options_neg):\n    solver.push()\n    solver.add(neg_option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Quentin, Robert, Shiro, Tony, and Umeko are the only members of the Kim family who attend an opera. Each of them sits in a separate seat in either row G or row H, and each sits in a seat numbered 1, 2, or 3. Consecutively numbered seats within each row are adjacent. Each member of the Kim family sits in a seat adjacent to, and in the same row as, at least one other member of the family. Tony and Umeko sit in row H. Shiro and Umeko sit in lower numbered seats than does Tony. Robert sits in the same row as Quentin or Shiro or both. Robert sits in a seat numbered 2.\n\nConsidering only the six seats in which members of the Kim family could sit, which one of the following is a complete and accurate list of those seats any one of which could be empty?\n\nOptions:\n(A) G1, G3\n(B) G3, H1\n(C) H1, H3\n(D) G1, G3, H1\n(E) G1, G3, H1, H3",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmembers = ['Quentin', 'Robert', 'Shiro', 'Tony', 'Umeko']\nrows = ['G', 'H']\nseats = [1, 2, 3]\n\n# Map rows to indices\nrow_idx = {r: i for i, r in enumerate(rows)}\n\n# Create variables for each member's row and seat\nmember_row = {m: Int(f'{m}_row') for m in members}\nmember_seat = {m: Int(f'{m}_seat') for m in members}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each member sits in a valid row and seat\nfor m in members:\n    solver.add(And(member_row[m] >= 0, member_row[m] < len(rows)))\n    solver.add(And(member_seat[m] >= 1, member_seat[m] <= 3))\n\n# Tony and Umeko sit in row H (row index 1)\nsolver.add(member_row['Tony'] == row_idx['H'])\nsolver.add(member_row['Umeko'] == row_idx['H'])\n\n# Shiro and Umeko sit in lower numbered seats than Tony\nsolver.add(member_seat['Shiro'] < member_seat['Tony'])\nsolver.add(member_seat['Umeko'] < member_seat['Tony'])\n\n# Robert sits in seat number 2\nsolver.add(member_seat['Robert'] == 2)\n\n# Robert sits in the same row as Quentin or Shiro or both\nsame_row_Quentin = member_row['Robert'] == member_row['Quentin']\nsame_row_Shiro = member_row['Robert'] == member_row['Shiro']\nsolver.add(Or([same_row_Quentin, same_row_Shiro]))\n\n# All members sit in distinct seats (row and seat)\nfor i in range(len(members)):\n    for j in range(i+1, len(members)):\n        m1 = members[i]\n        m2 = members[j]\n        # Not same row and same seat\n        solver.add(Or(member_row[m1] != member_row[m2], member_seat[m1] != member_seat[m2]))\n\n# Each member sits adjacent to at least one other member in the same row\nfor m in members:\n    # For each other member, check if adjacent in same row\n    adjacents = []\n    for other in members:\n        if other == m:\n            continue\n        same_row = member_row[m] == member_row[other]\n        seat_diff_1 = Abs(member_seat[m] - member_seat[other]) == 1\n        adjacents.append(And(same_row, seat_diff_1))\n    solver.add(Or(adjacents))\n\n# The six seats in which members could sit are the seats assigned to the five members plus one more seat\n# The problem states \"Considering only the six seats in which members of the Kim family could sit\"\n# Since there are 5 members and 6 seats, one seat might be empty.\n# We must find which seats could possibly be empty.\n\n# Collect all possible seats occupied by members (row, seat)\n# The six seats are the union of the seats occupied by members plus one seat that might be empty.\n# Since each member has a seat, and there are 6 seats total, the 6 seats are the ones occupied plus one.\n\n# We'll test each option to see if it matches the set of possible empty seats.\n\n# List of options with sets of seats that could be empty\noptions = [\n    [('G',1), ('G',3)],                  # A\n    [('G',3), ('H',1)],                  # B\n    [('H',1), ('H',3)],                  # C\n    [('G',1), ('G',3), ('H',1)],         # D\n    [('G',1), ('G',3), ('H',1), ('H',3)] # E\n]\n\n# We want to check for each option if the seats listed could be the empty seats among the 6 possible seats.\n\n# The 6 seats are the seats occupied by the 5 members plus one other seat that is empty.\n# So the 6 seats are the union of the 5 occupied seats plus one empty seat.\n\n# We will find all possible sets of 6 seats consistent with the constraints, and check which option matches.\n\n# To do that, we will:\n# - Enumerate all possible seats in rows G and H, seats 1 to 3\n# - For each solution, get the set of seats occupied by members\n# - Find which seat is not occupied among the 6 seats (the 6 seats are the seats occupied plus one empty seat)\n# - Check if the empty seat(s) match the option's seats\n\n# Since the problem asks which seats any one of which could be empty, the options list seats that could be empty.\n\n# So for each option, we check if for all solutions, the empty seat is always in the option's list,\n# and if the option's list is complete (no seats outside it could be empty).\n\n# We'll do this by:\n# - For each option:\n#   - Add constraint that the empty seat is NOT in the option's list (i.e., there exists an empty seat outside the option)\n#   - If solver finds a solution, then the option is incomplete (some empty seat outside it possible)\n#   - Otherwise, the option is complete and accurate.\n\n# To implement this, we need to model the empty seat explicitly.\n\n# DECLARE empty seat variables\nempty_row = Int('empty_row')\nempty_seat = Int('empty_seat')\n\nsolver.add(And(empty_row >= 0, empty_row < len(rows)))\nsolver.add(And(empty_seat >= 1, empty_seat <= 3))\n\n# The empty seat is not occupied by any member\nfor m in members:\n    not_same_seat = Or(empty_row != member_row[m], empty_seat != member_seat[m])\n    solver.add(not_same_seat)\n\n# The 6 seats are the 5 occupied seats plus the empty seat\n\n# OPTION CHECKING\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraint that empty seat is NOT in option's seats\n    not_in_option = []\n    for (r, s) in option:\n        not_in_option.append(Or(empty_row != row_idx[r], empty_seat != s))\n    # If empty seat NOT in option, then empty seat is outside option\n    # So add constraint that empty seat is outside option\n    solver.add(And(not_in_option))\n    if solver.check() == sat:\n        # There is a solution with empty seat outside option, so option is incomplete\n        solver.pop()\n        continue\n    else:\n        # No solution with empty seat outside option, so option is complete and accurate\n        solver.pop()\n        print(f\"'{chr(65 + i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly seven professors—Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, and Togo—were hired in the years 1989 through 1995. Each professor has one or more specialities, and any two professors hired in the same year or in consecutive years do not have a specialty in common. The professors were hired according to the following conditions: Madison was hired in 1993, Robinson in 1991. There is at least one specialty that Madison, Orozco, and Togo have in common. Nilsson shares a specialty with Robinson. Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson. Orozco, who shares a specialty with Sarkis, was hired in 1990.\n\nIf exactly one professor was hired in 1991, then which one of the following could be true?\n\nOptions:\n(A) Madison and Paton share a specialty.\n(B) Robinson and Sarkis share a specialty.\n(C) Paton was hired exactly one year after Orozco.\n(D) Exactly one professor was hired in 1994.\n(E) Exactly two professors were hired in 1993.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Professors\nprofessors = ['Madison', 'Nilsson', 'Orozco', 'Paton', 'Robinson', 'Sarkis', 'Togo']\n\n# Years from 1989 to 1995 mapped to indices 0..6 for convenience\nyears = list(range(1989, 1996))\nyear_to_idx = {y: i for i, y in enumerate(years)}\n\n# Variables: hire year for each professor (integer from 0 to 6)\nhire_year = {p: Int(p) for p in professors}\n\n# Specialties: represent specialties by integers, each professor can have multiple specialties\n# To model specialties intersection constraints, assign for each professor a set of specialties represented by a list of Bool variables indicating presence of specialty i.\n# Since specialties are not enumerated, we only need to model the intersection constraints and non-overlap constraints.\n# We'll create a fixed number of specialties (say 4) to allow for shared specialties.\nnum_specialties = 4\nspecialty = {p: [Bool(f\"{p}_spec_{i}\") for i in range(num_specialties)] for p in professors}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each professor hired in years 1989..1995\nfor p in professors:\n    solver.add(And(hire_year[p] >= 0, hire_year[p] <= 6))\n\n# 2. Madison hired in 1993 (index 4), Robinson in 1991 (index 2), Orozco in 1990 (index 1)\nsolver.add(hire_year['Madison'] == year_to_idx[1993])  # 4\nsolver.add(hire_year['Robinson'] == year_to_idx[1991])  # 2\nsolver.add(hire_year['Orozco'] == year_to_idx[1990])  # 1\n\n# 3. Any two professors hired in the same year or consecutive years do not share any specialty in common\n# For every pair of professors p1, p2 (p1 != p2):\n# if abs(hire_year[p1] - hire_year[p2]) <= 1 then no specialty in common\nfor i1 in range(len(professors)):\n    for i2 in range(i1+1, len(professors)):\n        p1 = professors[i1]\n        p2 = professors[i2]\n        year_diff = Abs(hire_year[p1] - hire_year[p2])\n        # If year_diff <=1 then specialties disjoint\n        # specialties disjoint means for all i: Not (specialty[p1][i] and specialty[p2][i])\n        no_common_specialty = And([Not(And(specialty[p1][i], specialty[p2][i])) for i in range(num_specialties)])\n        cond = Implies(year_diff <= 1, no_common_specialty)\n        solver.add(cond)\n\n# 4. There is at least one specialty that Madison, Orozco, and Togo have in common\ncommon_spec_MOT = [And(specialty['Madison'][i], specialty['Orozco'][i], specialty['Togo'][i]) for i in range(num_specialties)]\nsolver.add(Or(common_spec_MOT))\n\n# 5. Nilsson shares a specialty with Robinson\ncommon_spec_NR = [And(specialty['Nilsson'][i], specialty['Robinson'][i]) for i in range(num_specialties)]\nsolver.add(Or(common_spec_NR))\n\n# 6. Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson\n# Paton < Madison - 1 or Paton <= Madison - 1 (at least one year before Madison means Paton <= Madison - 1)\n# Paton > Nilsson (at least one year after Nilsson means Paton >= Nilsson + 1)\nsolver.add(hire_year['Paton'] <= hire_year['Madison'] - 1)\nsolver.add(hire_year['Paton'] >= hire_year['Nilsson'] + 1)\n\nsolver.add(hire_year['Sarkis'] <= hire_year['Madison'] - 1)\nsolver.add(hire_year['Sarkis'] >= hire_year['Nilsson'] + 1)\n\n# 7. Orozco shares a specialty with Sarkis\ncommon_spec_OS = [And(specialty['Orozco'][i], specialty['Sarkis'][i]) for i in range(num_specialties)]\nsolver.add(Or(common_spec_OS))\n\n# 8. Exactly one professor was hired in 1991 (year index 2)\n# We will check options under this assumption in OPTION CHECKING by adding this constraint\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Madison and Paton share a specialty.\n    lambda: solver.add(Or([And(specialty['Madison'][i], specialty['Paton'][i]) for i in range(num_specialties)])),\n    # (B) Robinson and Sarkis share a specialty.\n    lambda: solver.add(Or([And(specialty['Robinson'][i], specialty['Sarkis'][i]) for i in range(num_specialties)])),\n    # (C) Paton was hired exactly one year after Orozco.\n    lambda: solver.add(hire_year['Paton'] == hire_year['Orozco'] + 1),\n    # (D) Exactly one professor was hired in 1994 (year index 5).\n    lambda: solver.add(Sum([If(hire_year[p] == year_to_idx[1994], 1, 0) for p in professors]) == 1),\n    # (E) Exactly two professors were hired in 1993 (year index 4).\n    lambda: solver.add(Sum([If(hire_year[p] == year_to_idx[1993], 1, 0) for p in professors]) == 2),\n]\n\n# Add the constraint: Exactly one professor hired in 1991 (year index 2)\none_prof_1991 = Sum([If(hire_year[p] == year_to_idx[1991], 1, 0) for p in professors]) == 1\n\n# Check each option\nfor i, option_add in enumerate(options):\n    solver.push()\n    solver.add(one_prof_1991)\n    option_add()\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly seven professors—Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, and Togo—were hired in the years 1989 through 1995. Each professor has one or more specialities, and any two professors hired in the same year or in consecutive years do not have a specialty in common. The professors were hired according to the following conditions: Madison was hired in 1993, Robinson in 1991. There is at least one specialty that Madison, Orozco, and Togo have in common. Nilsson shares a specialty with Robinson. Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson. Orozco, who shares a specialty with Sarkis, was hired in 1990.\n\nWhich one of the following must be false?\n\nOptions:\n(A) Nilsson was hired in 1989.\n(B) Paton was hired in 1990.\n(C) Paton was hired in 1991.\n(D) Sarkis was hired in 1992.\n(E) Togo was hired in 1994.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\nprofessors = ['Madison', 'Nilsson', 'Orozco', 'Paton', 'Robinson', 'Sarkis', 'Togo']\nyears = list(range(1989, 1996))  # 1989 to 1995 inclusive\nyear_indices = {y: i for i, y in enumerate(years)}\n\n# Mapping professor names to indices for convenience\nprof_idx = {p: i for i, p in enumerate(professors)}\n\n# We will represent hire years as integers in [0..6] corresponding to years 1989..1995\n# Variables: hire year index for each professor\nhire_year = {p: Int(p) for p in professors}\n\n# Specialties:\n# Because specialties are not explicitly listed, model specialties as sets of integers.\n# We will assign each professor a set of specialties represented by a bit-vector of length S.\n# But since the problem only involves sharing or not sharing specialties,\n# we can model specialties as sets of integers.\n# For simplicity, assign each professor a set of specialties represented by a set of integers.\n# To keep it simple, assign specialties as sets of integers from 0 to max_specialties-1.\nmax_specialties = 10  # arbitrary upper bound for number of specialties\n\n# For each professor, we create a BitVec of length max_specialties, where 1 means has specialty.\n# However, Z3 BitVec operations on bits are complex, so better to use Bool arrays.\n# So for each professor and specialty, create a Bool variable indicating if professor has that specialty.\n\nspecialties = []\nfor s in range(max_specialties):\n    specialties.append(s)\n\n# specialties_vars[p][s] = Bool indicating if professor p has specialty s\nspecialties_vars = {p: [Bool(f\"{p}_spec_{s}\") for s in specialties] for p in professors}\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# 1) Each professor is hired in one of the years 1989..1995 (indices 0..6)\nfor p in professors:\n    solver.add(And(hire_year[p] >= 0, hire_year[p] <= 6))\n\n# 2) Given years 1989..1995, so 7 professors and 7 years.\n# But multiple professors can be hired same year? No explicit restriction on unique years.\n# So no distinctness constraint on hire years.\n\n# 3) Madison hired in 1993 -> hire_year['Madison'] == 1993-1989 = 4\nsolver.add(hire_year['Madison'] == year_indices[1993])\n\n# 4) Robinson hired in 1991 -> hire_year['Robinson'] == 1991-1989 = 2\nsolver.add(hire_year['Robinson'] == year_indices[1991])\n\n# 5) Orozco hired in 1990 -> hire_year['Orozco'] == 1990-1989 = 1\nsolver.add(hire_year['Orozco'] == year_indices[1990])\n\n# 6) Any two professors hired in the same year or in consecutive years do NOT share any specialty.\n# For every pair of professors p1, p2:\n# if abs(hire_year[p1] - hire_year[p2]) <= 1 then specialties_vars[p1] and specialties_vars[p2] have no intersection\n\nfor i in range(len(professors)):\n    for j in range(i+1, len(professors)):\n        p1 = professors[i]\n        p2 = professors[j]\n\n        diff = Int(f\"diff_{p1}_{p2}\")\n        solver.add(diff == hire_year[p1] - hire_year[p2])\n        abs_diff = Int(f\"abs_diff_{p1}_{p2}\")\n        solver.add(abs_diff == If(diff >= 0, diff, -diff))\n\n        # If abs_diff <= 1 then no common specialty\n        # no common specialty means for all s: not (p1 has s and p2 has s)\n        # i.e. for all s: Not(And(specialties_vars[p1][s], specialties_vars[p2][s]))\n        # Which is equivalent to: For all s, Or(Not(p1_s), Not(p2_s))\n        # So we add an implication:\n        # abs_diff <= 1 => For all s, Or(Not(p1_s), Not(p2_s))\n\n        no_common_specialty = And([Or(Not(specialties_vars[p1][s]), Not(specialties_vars[p2][s])) for s in specialties])\n        solver.add(Implies(abs_diff <= 1, no_common_specialty))\n\n# 7) There is at least one specialty that Madison, Orozco, and Togo have in common.\ncommon_MOT = []\nfor s in specialties:\n    common_MOT.append(And(specialties_vars['Madison'][s], specialties_vars['Orozco'][s], specialties_vars['Togo'][s]))\nsolver.add(Or(common_MOT))\n\n# 8) Nilsson shares a specialty with Robinson.\ncommon_NR = []\nfor s in specialties:\n    common_NR.append(And(specialties_vars['Nilsson'][s], specialties_vars['Robinson'][s]))\nsolver.add(Or(common_NR))\n\n# 9) Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson.\n# i.e. Nilsson < Paton < Madison and Nilsson < Sarkis < Madison in hire years\nsolver.add(hire_year['Paton'] < hire_year['Madison'])\nsolver.add(hire_year['Paton'] > hire_year['Nilsson'])\nsolver.add(hire_year['Sarkis'] < hire_year['Madison'])\nsolver.add(hire_year['Sarkis'] > hire_year['Nilsson'])\n\n# 10) Orozco, who shares a specialty with Sarkis, was hired in 1990 (already set)\n# So Orozco and Sarkis share at least one specialty\ncommon_OS = []\nfor s in specialties:\n    common_OS.append(And(specialties_vars['Orozco'][s], specialties_vars['Sarkis'][s]))\nsolver.add(Or(common_OS))\n\n# OPTION CHECKING\n\n# We want to find which option must be false:\n# Options:\n# (A) Nilsson was hired in 1989. -> hire_year['Nilsson'] == 0\n# (B) Paton was hired in 1990. -> hire_year['Paton'] == 1\n# (C) Paton was hired in 1991. -> hire_year['Paton'] == 2\n# (D) Sarkis was hired in 1992. -> hire_year['Sarkis'] == 3\n# (E) Togo was hired in 1994. -> hire_year['Togo'] == 5\n\noptions = [\n    ('A', hire_year['Nilsson'] == year_indices[1989]),\n    ('B', hire_year['Paton'] == year_indices[1990]),\n    ('C', hire_year['Paton'] == year_indices[1991]),\n    ('D', hire_year['Sarkis'] == year_indices[1992]),\n    ('E', hire_year['Togo'] == year_indices[1994]),\n]\n\n# For each option, check if it can be true.\n# The one that must be false is the one for which adding that constraint makes the problem unsat.\n\nfor letter, cond in options:\n    solver.push()\n    solver.add(cond)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly seven professors—Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, and Togo—were hired in the years 1989 through 1995. Each professor has one or more specialities, and any two professors hired in the same year or in consecutive years do not have a specialty in common. The professors were hired according to the following conditions: Madison was hired in 1993, Robinson in 1991. There is at least one specialty that Madison, Orozco, and Togo have in common. Nilsson shares a specialty with Robinson. Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson. Orozco, who shares a specialty with Sarkis, was hired in 1990.\n\nIf exactly two professors were hired in 1992, then which one of the following could be true?\n\nOptions:\n(A) Orozco, Paton, and Togo share a specialty.\n(B) Madison, Paton, and Togo share a specialty.\n(C) Exactly two professors were hired in 1991.\n(D) Exactly two professors were hired in 1993.\n(E) Paton was hired in 1991.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nprofessors = ['Madison', 'Nilsson', 'Orozco', 'Paton', 'Robinson', 'Sarkis', 'Togo']\nyears = list(range(1989, 1996))  # 1989-1995\n\n# Map professors to variables representing their hiring years\nhire_year = {p: Int(p) for p in professors}\n\n# Specialties are abstract; model sharing specialties by Bool variables for each pair\n# We'll create Bool variables indicating if two professors share a specialty\n# Because specialties can be multiple and shared among groups, model sharing specialty relations directly\n\n# For each pair of professors, create a Bool variable indicating if they share a specialty\nshared_specialty = {}\nfor i in range(len(professors)):\n    for j in range(i+1, len(professors)):\n        p1 = professors[i]\n        p2 = professors[j]\n        shared_specialty[(p1, p2)] = Bool(f\"shared_{p1}_{p2}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each professor's hire year is between 1989 and 1995\nfor p in professors:\n    solver.add(And(hire_year[p] >= 1989, hire_year[p] <= 1995))\n\n# Madison was hired in 1993, Robinson in 1991, Orozco in 1990\nsolver.add(hire_year['Madison'] == 1993)\nsolver.add(hire_year['Robinson'] == 1991)\nsolver.add(hire_year['Orozco'] == 1990)\n\n# Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson\n# That is: Nilsson < Paton < Madison and Nilsson < Sarkis < Madison\nsolver.add(hire_year['Paton'] < hire_year['Madison'])\nsolver.add(hire_year['Paton'] > hire_year['Nilsson'])\nsolver.add(hire_year['Sarkis'] < hire_year['Madison'])\nsolver.add(hire_year['Sarkis'] > hire_year['Nilsson'])\n\n# There is at least one specialty that Madison, Orozco, and Togo have in common\n# Model as: Madison-Orozco share specialty AND Madison-Togo share specialty AND Orozco-Togo share specialty\n# Because specialty is shared among all three, all three pairs share specialty\nsolver.add(shared_specialty[('Madison', 'Orozco')] == True)\nsolver.add(shared_specialty[('Madison', 'Togo')] == True)\n# Orozco < Togo in alphabetical order? Orozco < Togo, yes, so key is ('Orozco', 'Togo')\nsolver.add(shared_specialty[('Orozco', 'Togo')] == True)\n\n# Nilsson shares a specialty with Robinson\n# Nilsson < Robinson alphabetically? Nilsson < Robinson, yes\nsolver.add(shared_specialty[('Nilsson', 'Robinson')] == True)\n\n# Orozco shares a specialty with Sarkis\n# Orozco < Sarkis? Orozco < Sarkis, yes\nsolver.add(shared_specialty[('Orozco', 'Sarkis')] == True)\n\n# Any two professors hired in the same year or in consecutive years do not have a specialty in common\n# For all pairs (p1, p2), if abs(hire_year[p1] - hire_year[p2]) <= 1, then shared_specialty[(p1,p2)] == False\nfor i in range(len(professors)):\n    for j in range(i+1, len(professors)):\n        p1 = professors[i]\n        p2 = professors[j]\n        diff = Int(f\"diff_{p1}_{p2}\")\n        solver.add(diff == Abs(hire_year[p1] - hire_year[p2]))\n        # If diff <= 1 then no shared specialty\n        solver.add(Implies(diff <= 1, Not(shared_specialty[(p1, p2)])))\n\n# Exactly two professors were hired in 1992\n# Count number of professors hired in 1992 == 2\ncount_1992 = []\nfor p in professors:\n    count_1992.append(hire_year[p] == 1992)\nsolver.add(Sum([If(c, 1, 0) for c in count_1992]) == 2)\n\n# OPTION CHECKING\n# We will test each option by adding the option's condition to the solver and checking satisfiability\n\noptions = {\n    'A': # Orozco, Paton, and Togo share a specialty\n         # Model as all pairs share specialty among these three\n         And(shared_specialty[('Orozco', 'Paton')] if ('Orozco', 'Paton') in shared_specialty else shared_specialty[('Paton', 'Orozco')],\n             shared_specialty[('Orozco', 'Togo')],\n             shared_specialty[('Paton', 'Togo')] if ('Paton', 'Togo') in shared_specialty else shared_specialty[('Togo', 'Paton')]),\n\n    'B': # Madison, Paton, and Togo share a specialty\n         # All pairs among Madison, Paton, Togo share specialty\n         And(shared_specialty[('Madison', 'Paton')] if ('Madison', 'Paton') in shared_specialty else shared_specialty[('Paton', 'Madison')],\n             shared_specialty[('Madison', 'Togo')],\n             shared_specialty[('Paton', 'Togo')] if ('Paton', 'Togo') in shared_specialty else shared_specialty[('Togo', 'Paton')]),\n\n    'C': # Exactly two professors were hired in 1991\n         Sum([If(hire_year[p] == 1991, 1, 0) for p in professors]) == 2,\n\n    'D': # Exactly two professors were hired in 1993\n         Sum([If(hire_year[p] == 1993, 1, 0) for p in professors]) == 2,\n\n    'E': # Paton was hired in 1991\n         hire_year['Paton'] == 1991\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Exactly seven professors—Madison, Nilsson, Orozco, Paton, Robinson, Sarkis, and Togo—were hired in the years 1989 through 1995. Each professor has one or more specialities, and any two professors hired in the same year or in consecutive years do not have a specialty in common. The professors were hired according to the following conditions: Madison was hired in 1993, Robinson in 1991. There is at least one specialty that Madison, Orozco, and Togo have in common. Nilsson shares a specialty with Robinson. Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson. Orozco, who shares a specialty with Sarkis, was hired in 1990.\n\nIf Paton and Madison have a specialty in common, then which one of the following must be true?\n\nOptions:\n(A) Nilsson does not share a specialty with Paton.\n(B) Exactly one professor was hired in 1990.\n(C) Exactly one professor was hired in 1991.\n(D) Exactly two professors were hired in each of two years.\n(E) Paton was hired at least one year before Sarkis.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Professors\nprofessors = ['Madison', 'Nilsson', 'Orozco', 'Paton', 'Robinson', 'Sarkis', 'Togo']\nnum_profs = len(professors)\n\n# Years from 1989 to 1995\nyears = list(range(1989, 1996))\nnum_years = len(years)\nyear_index = {y: i for i, y in enumerate(years)}\n\n# Specialties - we do not know exact specialties, but we model specialty sets as boolean variables:\n# For each professor and each specialty index, a boolean indicates if that professor has that specialty.\n# Since specialties are not explicitly named or counted, we will represent specialties abstractly.\n# To model \"have a specialty in common\" we will create boolean variables for each pair of professors indicating if they share at least one specialty.\n# We also need to enforce that any two professors hired in the same or consecutive years do NOT share any specialty.\n\n# Variables:\n\n# hire_year[p]: Int variable for the hire year index (0..6) for professor p\nhire_year = {p: Int(p) for p in professors}\n\n# For each pair of professors (p1, p2) with p1 < p2, define a Bool variable indicating if they share any specialty\n# We'll store in a dict with sorted tuple keys\nshare_specialty = dict()\nfor i in range(num_profs):\n    for j in range(i+1, num_profs):\n        p1 = professors[i]\n        p2 = professors[j]\n        share_specialty[(p1, p2)] = Bool(f\"share_{p1}_{p2}\")\n\n# Helper function to get shared specialty variable for unordered pair\ndef shared(p1, p2):\n    if p1 == p2:\n        return True\n    key = tuple(sorted([p1, p2]))\n    return share_specialty[key]\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each professor hired in one of the years 1989-1995 (indices 0..6)\nfor p in professors:\n    solver.add(hire_year[p] >= 0)\n    solver.add(hire_year[p] < num_years)\n\n# Given hires:\n# Madison hired in 1993 -> index of 1993 is years.index(1993) = 4\nsolver.add(hire_year['Madison'] == year_index[1993])\n\n# Robinson hired in 1991 -> index of 1991 is 2\nsolver.add(hire_year['Robinson'] == year_index[1991])\n\n# Orozco hired in 1990 -> index of 1990 is 1\nsolver.add(hire_year['Orozco'] == year_index[1990])\n\n# Any two professors hired in the same year or consecutive years do NOT share any specialty\n# So if abs(year1 - year2) <= 1 then share_specialty[(p1,p2)] == False\nfor i in range(num_profs):\n    for j in range(i+1, num_profs):\n        p1 = professors[i]\n        p2 = professors[j]\n        diff = Int(f\"diff_{p1}_{p2}\")\n        solver.add(diff == Abs(hire_year[p1] - hire_year[p2]))\n        # If diff <= 1 then no shared specialty\n        solver.add(Implies(diff <= 1, Not(shared(p1, p2))))\n\n# There is at least one specialty that Madison, Orozco, and Togo have in common.\n# This means that Madison shares a specialty with Orozco and with Togo, and Orozco shares with Togo.\nsolver.add(shared('Madison', 'Orozco'))\nsolver.add(shared('Madison', 'Togo'))\nsolver.add(shared('Orozco', 'Togo'))\n\n# Nilsson shares a specialty with Robinson.\nsolver.add(shared('Nilsson', 'Robinson'))\n\n# Paton and Sarkis were each hired at least one year before Madison and at least one year after Nilsson.\n# Paton < Madison, Paton > Nilsson\nsolver.add(hire_year['Paton'] < hire_year['Madison'])\nsolver.add(hire_year['Paton'] > hire_year['Nilsson'])\n# Sarkis < Madison, Sarkis > Nilsson\nsolver.add(hire_year['Sarkis'] < hire_year['Madison'])\nsolver.add(hire_year['Sarkis'] > hire_year['Nilsson'])\n\n# Orozco shares a specialty with Sarkis.\nsolver.add(shared('Orozco', 'Sarkis'))\n\n# OPTION CHECKING\n\n# We want to check which option must be true IF Paton and Madison have a specialty in common.\n\n# So add that Paton and Madison share a specialty\nsolver.add(shared('Paton', 'Madison'))\n\n# The options to check:\n\n# (A) Nilsson does not share a specialty with Paton.\n# (B) Exactly one professor was hired in 1990.\n# (C) Exactly one professor was hired in 1991.\n# (D) Exactly two professors were hired in each of two years.\n# (E) Paton was hired at least one year before Sarkis.\n\n# We'll check which of these must be true by trying to add the negation of each and seeing if the model is still satisfiable.\n# The one whose negation is unsat is the correct answer.\n\n# Helper: count how many professors hired in a given year index\ndef count_hired_in_year(year_idx):\n    return Sum([If(hire_year[p] == year_idx, 1, 0) for p in professors])\n\n# (A) Negation: Nilsson shares a specialty with Paton\nsolver.push()\nsolver.add(shared('Nilsson', 'Paton'))\nres_A = solver.check()\nsolver.pop()\n\n# (B) Negation: Not exactly one professor hired in 1990 (year_index 1)\nsolver.push()\ncount_1990 = count_hired_in_year(year_index[1990])\nsolver.add(Or(count_1990 != 1))\nres_B = solver.check()\nsolver.pop()\n\n# (C) Negation: Not exactly one professor hired in 1991 (year_index 2)\nsolver.push()\ncount_1991 = count_hired_in_year(year_index[1991])\nsolver.add(Or(count_1991 != 1))\nres_C = solver.check()\nsolver.pop()\n\n# (D) Negation: It is NOT true that exactly two professors were hired in each of two years.\n# So negation: For every pair of distinct years, not (count_year1 == 2 and count_year2 == 2)\n# So negation is: For all pairs of years, NOT (count_year1 == 2 and count_year2 == 2)\n# So negation is: For all pairs of years, (count_year1 != 2 or count_year2 != 2)\n# To negate the option, we add: For all pairs of years, (count_year1 != 2 or count_year2 != 2)\n# But this is a universal quantifier, hard to encode directly.\n# Instead, to check negation, we try to find a model that violates it: i.e. no two years have exactly two professors.\n# So negation means: For all pairs of distinct years, at least one year does not have exactly two professors.\n# So to check negation, add constraint: For all pairs (y1,y2), count_y1 != 2 or count_y2 != 2.\n# To encode, add constraints for all pairs (y1,y2) that count_y1 != 2 or count_y2 != 2\n# So negation is conjunction over all pairs (count_y1 != 2 or count_y2 != 2)\n\nsolver.push()\npairs = []\nfor i in range(num_years):\n    for j in range(i+1, num_years):\n        c1 = count_hired_in_year(i) != 2\n        c2 = count_hired_in_year(j) != 2\n        pairs.append(Or(c1, c2))\nsolver.add(And(pairs))\nres_D = solver.check()\nsolver.pop()\n\n# (E) Negation: Paton was NOT hired at least one year before Sarkis\n# Negation: Paton hired same year or after Sarkis\nsolver.push()\nsolver.add(hire_year['Paton'] >= hire_year['Sarkis'])\nres_E = solver.check()\nsolver.pop()\n\n# Print the letter of the option whose negation is unsat (i.e. must be true)\nif res_A == unsat:\n    print(\"'A'\")\nelif res_B == unsat:\n    print(\"'B'\")\nelif res_C == unsat:\n    print(\"'C'\")\nelif res_D == unsat:\n    print(\"'D'\")\nelif res_E == unsat:\n    print(\"'E'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.\n\nWhich one of the following could be a complete and accurate list of the kinds of fruit the stand carries?\n\nOptions:\n(A) oranges, pears\n(B) pears, tangerines\n(C) oranges, pears, watermelons\n(D) oranges, tangerines, watermelons\n(E) kiwis, oranges, pears, watermelons",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfruits = ['figs', 'kiwis', 'oranges', 'pears', 'tangerines', 'watermelons']\nfruit_vars = {f: Bool(f) for f in fruits}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# The stand carries at least one kind of fruit\nsolver.add(Or([fruit_vars[f] for f in fruits]))\n\n# The stand does not carry any other kind of fruit (only these six)\n# This is implicit since only these fruits are modeled\n\n# If the stand carries kiwis, then it does not carry pears\nsolver.add(Implies(fruit_vars['kiwis'], Not(fruit_vars['pears'])))\n\n# If the stand does not carry tangerines, then it carries kiwis\nsolver.add(Implies(Not(fruit_vars['tangerines']), fruit_vars['kiwis']))\n\n# If the stand carries oranges, then it carries both pears and watermelons\nsolver.add(Implies(fruit_vars['oranges'], And(fruit_vars['pears'], fruit_vars['watermelons'])))\n\n# If the stand carries watermelons, then it carries figs or tangerines or both\nsolver.add(Implies(fruit_vars['watermelons'], Or(fruit_vars['figs'], fruit_vars['tangerines'])))\n\n# OPTION CHECKING\noptions = [\n    ['oranges', 'pears'],                     # A\n    ['pears', 'tangerines'],                  # B\n    ['oranges', 'pears', 'watermelons'],     # C\n    ['oranges', 'tangerines', 'watermelons'],# D\n    ['kiwis', 'oranges', 'pears', 'watermelons']  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # The stand carries exactly the fruits in the option\n    # So for each fruit, if in option then True else False\n    for f in fruits:\n        if f in option:\n            solver.add(fruit_vars[f] == True)\n        else:\n            solver.add(fruit_vars[f] == False)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.\n\nWhich one of the following could be the only kind of fruit the stand carries?\n\nOptions:\n(A) figs\n(B) oranges\n(C) pears\n(D) tangerines\n(E) watermelons",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfruits = ['figs', 'kiwis', 'oranges', 'pears', 'tangerines', 'watermelons']\nfruit_vars = {f: Bool(f) for f in fruits}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# At least one kind of fruit is carried\nsolver.add(Or([fruit_vars[f] for f in fruits]))\n\n# The stand does not carry any other kind of fruit (only these six)\n# (No need to add constraints for other fruits since only these variables exist)\n\n# If the stand carries kiwis, then it does not carry pears\nsolver.add(Implies(fruit_vars['kiwis'], Not(fruit_vars['pears'])))\n\n# If the stand does not carry tangerines, then it carries kiwis\nsolver.add(Implies(Not(fruit_vars['tangerines']), fruit_vars['kiwis']))\n\n# If the stand carries oranges, then it carries both pears and watermelons\nsolver.add(Implies(fruit_vars['oranges'], And(fruit_vars['pears'], fruit_vars['watermelons'])))\n\n# If the stand carries watermelons, then it carries figs or tangerines or both\nsolver.add(Implies(fruit_vars['watermelons'], Or(fruit_vars['figs'], fruit_vars['tangerines'])))\n\n# OPTION CHECKING\noptions = ['figs', 'oranges', 'pears', 'tangerines', 'watermelons']\n\nfor i, option in enumerate(options):\n    solver.push()\n    # The stand carries only this fruit (exactly one fruit)\n    only_this = [fruit_vars[f] if f == option else Not(fruit_vars[f]) for f in fruits]\n    solver.add(And(only_this))\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.\n\nWhich one of the following CANNOT be a complete and accurate list of the kinds of fruit the stand carries?\n\nOptions:\n(A) kiwis, tangerines\n(B) tangerines, watermelons\n(C) figs, kiwis, watermelons\n(D) oranges, pears, tangerines, watermelons\n(E) figs, kiwis, oranges, pears, watermelons",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfruits = ['figs', 'kiwis', 'oranges', 'pears', 'tangerines', 'watermelons']\nfruit_vars = dict()\nfor f in fruits:\n    fruit_vars[f] = Bool(f)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# The stand carries at least one kind of fruit\nsolver.add(Or([fruit_vars[f] for f in fruits]))\n\n# The stand does not carry any other kind of fruit (already implicit since only these fruits exist)\n\n# If the stand carries kiwis, then it does not carry pears\nsolver.add(Implies(fruit_vars['kiwis'], Not(fruit_vars['pears'])))\n\n# If the stand does not carry tangerines, then it carries kiwis\nsolver.add(Implies(Not(fruit_vars['tangerines']), fruit_vars['kiwis']))\n\n# If the stand carries oranges, then it carries both pears and watermelons\nsolver.add(Implies(fruit_vars['oranges'], And(fruit_vars['pears'], fruit_vars['watermelons'])))\n\n# If the stand carries watermelons, then it carries figs or tangerines or both\nsolver.add(Implies(fruit_vars['watermelons'], Or(fruit_vars['figs'], fruit_vars['tangerines'])))\n\n# OPTION CHECKING\noptions = [\n    ['kiwis', 'tangerines'],                               # A\n    ['tangerines', 'watermelons'],                         # B\n    ['figs', 'kiwis', 'watermelons'],                      # C\n    ['oranges', 'pears', 'tangerines', 'watermelons'],    # D\n    ['figs', 'kiwis', 'oranges', 'pears', 'watermelons']  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # The stand carries exactly the fruits in option\n    # So for each fruit, if in option then True else False\n    for f in fruits:\n        if f in option:\n            solver.add(fruit_vars[f] == True)\n        else:\n            solver.add(fruit_vars[f] == False)\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.\n\nIf the stand carries no watermelons, then which one of the following must be true?\n\nOptions:\n(A) The stand carries kiwis.\n(B) The stand carries at least two kinds of fruit.\n(C) The stand carries at most three kinds of fruit.\n(D) The stand carries neither oranges nor pears.\n(E) The stand carries neither oranges nor kiwis.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfruits = ['figs', 'kiwis', 'oranges', 'pears', 'tangerines', 'watermelons']\n# Create a Bool variable for each fruit indicating whether the stand carries it\ncarry = {f: Bool(f) for f in fruits}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# The stand carries at least one kind of fruit\nsolver.add(Or([carry[f] for f in fruits]))\n\n# The stand does not carry any other kind of fruit (only these six kinds)\n# Implicit by only these six variables\n\n# If the stand carries kiwis, then it does not carry pears\nsolver.add(Implies(carry['kiwis'], Not(carry['pears'])))\n\n# If the stand does not carry tangerines, then it carries kiwis\nsolver.add(Implies(Not(carry['tangerines']), carry['kiwis']))\n\n# If the stand carries oranges, then it carries both pears and watermelons\nsolver.add(Implies(carry['oranges'], And(carry['pears'], carry['watermelons'])))\n\n# If the stand carries watermelons, then it carries figs or tangerines or both\nsolver.add(Implies(carry['watermelons'], Or(carry['figs'], carry['tangerines'])))\n\n# Given condition: The stand carries no watermelons\nsolver.add(Not(carry['watermelons']))\n\n# OPTION CHECKING\noptions = [\n    carry['kiwis'],  # (A) The stand carries kiwis\n    Sum([If(carry[f], 1, 0) for f in fruits]) >= 2,  # (B) The stand carries at least two kinds of fruit\n    Sum([If(carry[f], 1, 0) for f in fruits]) <= 3,  # (C) The stand carries at most three kinds of fruit\n    And(Not(carry['oranges']), Not(carry['pears'])),  # (D) The stand carries neither oranges nor pears\n    And(Not(carry['oranges']), Not(carry['kiwis'])),  # (E) The stand carries neither oranges nor kiwis\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Check if the negation of the option is satisfiable with all constraints\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        # The option must be true (its negation is unsatisfiable)\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.\n\nIf the stand carries watermelons, then which one of the following must be false?\n\nOptions:\n(A) The stand does not carry figs.\n(B) The stand does not carry tangerines.\n(C) The stand does not carry pears.\n(D) The stand carries pears but not oranges.\n(E) The stand carries pears but not tangerines.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfruits = ['figs', 'kiwis', 'oranges', 'pears', 'tangerines', 'watermelons']\nF = {f: Bool(f) for f in fruits}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# The stand carries at least one kind of fruit\nsolver.add(Or([F[f] for f in fruits]))\n\n# The stand does not carry any other kinds of fruit (only these 6)\n# (No variable needed for this since only these fruits are considered)\n\n# If the stand carries kiwis, then it does not carry pears\nsolver.add(Implies(F['kiwis'], Not(F['pears'])))\n\n# If the stand does not carry tangerines, then it carries kiwis\nsolver.add(Implies(Not(F['tangerines']), F['kiwis']))\n\n# If the stand carries oranges, then it carries both pears and watermelons\nsolver.add(Implies(F['oranges'], And(F['pears'], F['watermelons'])))\n\n# If the stand carries watermelons, then it carries figs or tangerines or both\nsolver.add(Implies(F['watermelons'], Or(F['figs'], F['tangerines'])))\n\n# The question: If the stand carries watermelons, then which one of the following must be false?\n# So we add the condition that watermelons are carried\nsolver.add(F['watermelons'])\n\n# OPTION CHECKING\noptions = [\n    # (A) The stand does not carry figs.\n    Not(F['figs']),\n    # (B) The stand does not carry tangerines.\n    Not(F['tangerines']),\n    # (C) The stand does not carry pears.\n    Not(F['pears']),\n    # (D) The stand carries pears but not oranges.\n    And(F['pears'], Not(F['oranges'])),\n    # (E) The stand carries pears but not tangerines.\n    And(F['pears'], Not(F['tangerines']))\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A fruit stand carries at least one kind of the following kinds of fruit: figs, kiwis, oranges, pears, tangerines, and watermelons. The stand does not carry any other kind of fruit. The selection of fruits the stand carries is consistent with the following conditions: If the stand carries kiwis, then it does not carry pears. If the stand does not carry tangerines, then it carries kiwis. If the stand carries oranges, then it carries both pears and watermelons. If the stand carries watermelons, then it carries figs or tangerines or both.\n\nIf the condition that if the fruit stand does not carry tangerines then it does carry kiwis is suspended, and all other conditions remain in effect, then which one of the following CANNOT be a complete and accurate list of the kinds of fruit the stand carries?\n\nOptions:\n(A) pears\n(B) figs, pears\n(C) oranges, pears, watermelons\n(D) figs, pears, watermelons\n(E) figs, oranges, pears, watermelons",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfruits = ['figs', 'kiwis', 'oranges', 'pears', 'tangerines', 'watermelons']\nfruit_vars = {f: Bool(f) for f in fruits}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# The stand carries at least one kind of fruit\nsolver.add(Or([fruit_vars[f] for f in fruits]))\n\n# The stand does not carry any fruit not in the list (already ensured by vars)\n\n# Conditions (except the suspended one):\n# 1) If the stand carries kiwis, then it does not carry pears.\nsolver.add(Implies(fruit_vars['kiwis'], Not(fruit_vars['pears'])))\n\n# 2) The condition \"If the stand does not carry tangerines, then it carries kiwis\" is suspended\n# So we do NOT add this constraint.\n\n# 3) If the stand carries oranges, then it carries both pears and watermelons.\nsolver.add(Implies(fruit_vars['oranges'], And(fruit_vars['pears'], fruit_vars['watermelons'])))\n\n# 4) If the stand carries watermelons, then it carries figs or tangerines or both.\nsolver.add(Implies(fruit_vars['watermelons'], Or(fruit_vars['figs'], fruit_vars['tangerines'])))\n\n# OPTION CHECKING\noptions = {\n    'A': ['pears'],\n    'B': ['figs', 'pears'],\n    'C': ['oranges', 'pears', 'watermelons'],\n    'D': ['figs', 'pears', 'watermelons'],\n    'E': ['figs', 'oranges', 'pears', 'watermelons']\n}\n\nfor letter, option_fruits in options.items():\n    solver.push()\n    # Add constraints that the stand carries exactly the fruits in option_fruits\n    # i.e., carry these fruits and do not carry the others\n    for f in fruits:\n        if f in option_fruits:\n            solver.add(fruit_vars[f] == True)\n        else:\n            solver.add(fruit_vars[f] == False)\n    # Check if the constraints are satisfiable\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A radio talk show host airs five telephone calls sequentially. The calls, one from each of Felicia, Gwen, Henry, Isaac, and Mel, are each either live or taped (but not both). Two calls are from Vancouver, two are from Seattle, and one is from Kelowna. The following conditions must apply: Isaac's and Mel's calls are the first two calls aired, but not necessarily in that order. The third call aired, from Kelowna, is taped. Both Seattle calls are live. Both Gwen's and Felicia's calls air after Henry's. Neither Mel nor Felicia calls from Seattle.\n\nWhich one of the following could be an accurate list of the calls, listed in the order in which they are aired?\n\nOptions:\n(A) Isaac's, Henry's, Felicia's, Mel's, Gwen's\n(B) Isaac's, Mel's, Gwen's, Henry's, Felicia's\n(C) Mel's, Gwen's, Henry's, Isaac's, Felicia's\n(D) Mel's, Isaac's, Gwen's, Henry's, Felicia's\n(E) Mel's, Isaac's, Henry's, Felicia's, Gwen's",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Callers\ncallers = ['Felicia', 'Gwen', 'Henry', 'Isaac', 'Mel']\n\n# Locations\nlocations = ['Vancouver', 'Seattle', 'Kelowna']\nloc_idx = {loc: i for i, loc in enumerate(locations)}\n\n# Types\ntypes = ['live', 'taped']\ntype_idx = {t: i for i, t in enumerate(types)}\n\n# Positions: 5 calls, positions 0 to 4\npositions = range(5)\n\nsolver = Solver()\n\n# Variables\n# caller_pos[c] = position of caller c in the call order (0-based)\ncaller_pos = {c: Int(c + '_pos') for c in callers}\nfor c in callers:\n    solver.add(And(caller_pos[c] >= 0, caller_pos[c] < 5))\n\n# caller_loc[c] = location index of caller c\ncaller_loc = {c: Int(c + '_loc') for c in callers}\nfor c in callers:\n    solver.add(And(caller_loc[c] >= 0, caller_loc[c] < len(locations)))\n\n# caller_type[c] = type index of caller c (live or taped)\ncaller_type = {c: Int(c + '_type') for c in callers}\nfor c in callers:\n    solver.add(And(caller_type[c] >= 0, caller_type[c] < len(types)))\n\n# Distinct positions: Each caller has unique position\nsolver.add(Distinct([caller_pos[c] for c in callers]))\n\n# Distinct callers per position: not needed as positions are unique\n\n# CONSTRAINTS\n\n# 1) Isaac's and Mel's calls are the first two calls aired, but not necessarily in that order.\npos_isaac = caller_pos['Isaac']\npos_mel = caller_pos['Mel']\nfirst_two_positions = [0,1]\nsolver.add(Or(pos_isaac == 0, pos_isaac == 1))\nsolver.add(Or(pos_mel == 0, pos_mel == 1))\nsolver.add(pos_isaac != pos_mel)  # distinct positions\n\n# 2) The third call aired, from Kelowna, is taped.\n# Find the caller at position 2\n# We need to link position to caller\n# Create an array pos_to_caller to map position to caller index\n\n# We'll create an array of 5 Int variables pos_to_caller_idx, each from 0 to 4 representing callers\n# But we don't need to create separate variables, we can use conditions to relate position 2 to a caller\n\n# For each caller, if caller_pos[c] == 2 then:\n# caller_loc[c] == Kelowna (2)\n# caller_type[c] == taped (1)\n\nkelowna_idx = loc_idx['Kelowna']\ntaped_idx = type_idx['taped']\n\nfor c in callers:\n    cond = caller_pos[c] == 2\n    solver.add(Implies(cond, caller_loc[c] == kelowna_idx))\n    solver.add(Implies(cond, caller_type[c] == taped_idx))\n\n# 3) Two calls are from Vancouver, two are from Seattle, and one is from Kelowna.\n# Count of each location equals specified count\n\n# Count how many callers have each location\n# We create boolean variables for each caller and location\nvancouver_idx = loc_idx['Vancouver']\nseattle_idx = loc_idx['Seattle']\n\nvancouver_count = []\nseattle_count = []\nkelowna_count = []\n\nfor c in callers:\n    vancouver_count.append(caller_loc[c] == vancouver_idx)\n    seattle_count.append(caller_loc[c] == seattle_idx)\n    kelowna_count.append(caller_loc[c] == kelowna_idx)\n\nsolver.add(Sum([If(b,1,0) for b in vancouver_count]) == 2)\nsolver.add(Sum([If(b,1,0) for b in seattle_count]) == 2)\nsolver.add(Sum([If(b,1,0) for b in kelowna_count]) == 1)\n\n# 4) Both Seattle calls are live.\n# For each caller, if location is Seattle then type is live\n\nlive_idx = type_idx['live']\nfor c in callers:\n    solver.add(Implies(caller_loc[c] == seattle_idx, caller_type[c] == live_idx))\n\n# 5) Both Gwen's and Felicia's calls air after Henry's.\n# So Henry's position < Gwen's position and Henry's position < Felicia's position\n\nsolver.add(caller_pos['Henry'] < caller_pos['Gwen'])\nsolver.add(caller_pos['Henry'] < caller_pos['Felicia'])\n\n# 6) Neither Mel nor Felicia calls from Seattle.\n\nsolver.add(caller_loc['Mel'] != seattle_idx)\nsolver.add(caller_loc['Felicia'] != seattle_idx)\n\n# 7) Each call is either live or taped (already enforced by domain constraints)\n\n# OPTION CHECKING\n\noptions = [\n    ['Isaac', 'Henry', 'Felicia', 'Mel', 'Gwen'],  # A\n    ['Isaac', 'Mel', 'Gwen', 'Henry', 'Felicia'],  # B\n    ['Mel', 'Gwen', 'Henry', 'Isaac', 'Felicia'],  # C\n    ['Mel', 'Isaac', 'Gwen', 'Henry', 'Felicia'],  # D\n    ['Mel', 'Isaac', 'Henry', 'Felicia', 'Gwen']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that positions match the option order\n    # For each position p, caller_pos[option[p]] == p\n    for p, c in enumerate(option):\n        solver.add(caller_pos[c] == p)\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A radio talk show host airs five telephone calls sequentially. The calls, one from each of Felicia, Gwen, Henry, Isaac, and Mel, are each either live or taped (but not both). Two calls are from Vancouver, two are from Seattle, and one is from Kelowna. The following conditions must apply: Isaac's and Mel's calls are the first two calls aired, but not necessarily in that order. The third call aired, from Kelowna, is taped. Both Seattle calls are live. Both Gwen's and Felicia's calls air after Henry's. Neither Mel nor Felicia calls from Seattle.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Felicia's call airs fifth.\n(B) Gwen's call airs first.\n(C) Henry's call airs second.\n(D) Isaac's call airs third.\n(E) Mel's call airs fifth.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Felicia', 'Gwen', 'Henry', 'Isaac', 'Mel']\ncities = ['Vancouver', 'Seattle', 'Kelowna']\ncall_types = ['live', 'taped']\npositions = range(1, 6)\n\n# Create Z3 variables for each person\n# position: integer 1-5 representing the order of the call\npos = {p: Int(p + '_pos') for p in people}\n# city: integer index 0-2 representing Vancouver, Seattle, Kelowna\ncity = {p: Int(p + '_city') for p in people}\n# call_type: integer index 0-1 representing live=0, taped=1\nctype = {p: Int(p + '_type') for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions between 1 and 5 and all distinct\nfor p in people:\n    solver.add(And(pos[p] >= 1, pos[p] <= 5))\nsolver.add(Distinct([pos[p] for p in people]))\n\n# Cities: 0=Vancouver,1=Seattle,2=Kelowna\nfor p in people:\n    solver.add(And(city[p] >= 0, city[p] <= 2))\n# Exactly two Vancouver calls\nsolver.add(Sum([If(city[p] == 0, 1, 0) for p in people]) == 2)\n# Exactly two Seattle calls\nsolver.add(Sum([If(city[p] == 1, 1, 0) for p in people]) == 2)\n# Exactly one Kelowna call\nsolver.add(Sum([If(city[p] == 2, 1, 0) for p in people]) == 1)\n\n# Call types: 0=live,1=taped\nfor p in people:\n    solver.add(Or(ctype[p] == 0, ctype[p] == 1))\n\n# Isaac's and Mel's calls are the first two calls aired, in any order\nsolver.add(Or(\n    And(pos['Isaac'] == 1, pos['Mel'] == 2),\n    And(pos['Isaac'] == 2, pos['Mel'] == 1)\n))\n\n# The third call aired is from Kelowna and is taped\nfor p in people:\n    solver.add(Implies(pos[p] == 3, And(city[p] == 2, ctype[p] == 1)))\n\n# Both Seattle calls are live\nfor p in people:\n    solver.add(Implies(city[p] == 1, ctype[p] == 0))\n\n# Both Gwen's and Felicia's calls air after Henry's\nsolver.add(pos['Gwen'] > pos['Henry'])\nsolver.add(pos['Felicia'] > pos['Henry'])\n\n# Neither Mel nor Felicia calls from Seattle\nsolver.add(city['Mel'] != 1)\nsolver.add(city['Felicia'] != 1)\n\n# OPTION CHECKING\n\n# Options:\n# (A) Felicia's call airs fifth.\n# (B) Gwen's call airs first.\n# (C) Henry's call airs second.\n# (D) Isaac's call airs third.\n# (E) Mel's call airs fifth.\n\noptions = [\n    pos['Felicia'] == 5,\n    pos['Gwen'] == 1,\n    pos['Henry'] == 2,\n    pos['Isaac'] == 3,\n    pos['Mel'] == 5,\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A radio talk show host airs five telephone calls sequentially. The calls, one from each of Felicia, Gwen, Henry, Isaac, and Mel, are each either live or taped (but not both). Two calls are from Vancouver, two are from Seattle, and one is from Kelowna. The following conditions must apply: Isaac's and Mel's calls are the first two calls aired, but not necessarily in that order. The third call aired, from Kelowna, is taped. Both Seattle calls are live. Both Gwen's and Felicia's calls air after Henry's. Neither Mel nor Felicia calls from Seattle.\n\nWhich one of the following must be true?\n\nOptions:\n(A) Gwen's call is live.\n(B) Henry's call is live.\n(C) Mel's call is live.\n(D) Felicia's call is taped.\n(E) Isaac's call is taped.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncallers = ['Felicia', 'Gwen', 'Henry', 'Isaac', 'Mel']\ncities = ['Vancouver', 'Seattle', 'Kelowna']\nstatuses = ['Live', 'Taped']\npositions = range(5)  # Calls 0 to 4 aired in sequence\n\n# Create variables for each caller:\n# position: integer 0..4 indicating call order\n# city: integer index into cities\n# status: integer index into statuses\npos = {c: Int(f'pos_{c}') for c in callers}\ncity = {c: Int(f'city_{c}') for c in callers}\nstatus = {c: Int(f'status_{c}') for c in callers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are distinct and in range 0..4\nfor c in callers:\n    solver.add(And(pos[c] >= 0, pos[c] < 5))\nsolver.add(Distinct([pos[c] for c in callers]))\n\n# Cities constraints: exactly 2 Vancouver, 2 Seattle, 1 Kelowna\n# Count how many callers assigned to each city\n# We'll use helper variables for counts\nvancouver_count = Sum([If(city[c] == cities.index('Vancouver'), 1, 0) for c in callers])\nseattle_count = Sum([If(city[c] == cities.index('Seattle'), 1, 0) for c in callers])\nkelowna_count = Sum([If(city[c] == cities.index('Kelowna'), 1, 0) for c in callers])\n\nsolver.add(vancouver_count == 2)\nsolver.add(seattle_count == 2)\nsolver.add(kelowna_count == 1)\n\n# Status constraints: 0=Live,1=Taped\nfor c in callers:\n    solver.add(And(status[c] >= 0, status[c] < 2))\n\n# Isaac's and Mel's calls are the first two calls aired, but not necessarily in that order.\n# So pos[Isaac] and pos[Mel] are 0 and 1 in some order\nsolver.add(Or(And(pos['Isaac'] == 0, pos['Mel'] == 1), And(pos['Isaac'] == 1, pos['Mel'] == 0)))\n\n# The third call aired (position 2), from Kelowna, is taped.\n# So the caller with position 2 has city Kelowna and status Taped\nfor c in callers:\n    solver.add(Implies(pos[c] == 2, city[c] == cities.index('Kelowna')))\n    solver.add(Implies(pos[c] == 2, status[c] == statuses.index('Taped')))\n\n# Both Seattle calls are live\n# So for any caller with city Seattle, status is Live\nfor c in callers:\n    solver.add(Implies(city[c] == cities.index('Seattle'), status[c] == statuses.index('Live')))\n\n# Both Gwen's and Felicia's calls air after Henry's.\nsolver.add(pos['Gwen'] > pos['Henry'])\nsolver.add(pos['Felicia'] > pos['Henry'])\n\n# Neither Mel nor Felicia calls from Seattle.\nsolver.add(city['Mel'] != cities.index('Seattle'))\nsolver.add(city['Felicia'] != cities.index('Seattle'))\n\n# OPTION CHECKING\n# Options:\n# (A) Gwen's call is live.\n# (B) Henry's call is live.\n# (C) Mel's call is live.\n# (D) Felicia's call is taped.\n# (E) Isaac's call is taped.\n\noptions = [\n    status['Gwen'] == statuses.index('Live'),\n    status['Henry'] == statuses.index('Live'),\n    status['Mel'] == statuses.index('Live'),\n    status['Felicia'] == statuses.index('Taped'),\n    status['Isaac'] == statuses.index('Taped'),\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add the negation of the option and check if puzzle still satisfiable\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true in all models\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Gutierrez, Hoffman, Imamura, Kelly, Lapas, and Moore ride a bus together. Each sits facing forward in a different one of the six seats on the left side of the bus. The seats are in consecutive rows that are numbered 1, 2, and 3 from front to back. Each row has exactly two seats: a window seat and an aisle seat. The following conditions must apply: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat. If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas. If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat. If Kelly occupies a window seat, Moore sits in row 3. If Kelly sits in row 3, Imamura sits in row 1.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Imamura sits in row 2, whereas Kelly sits in row 3.\n(B) Gutierrez sits in the same row as Kelly, immediately and directly behind Moore.\n(C) Gutierrez occupies a window seat in the same row as Lapas.\n(D) Moore occupies an aisle seat in the same row as Lapas.\n(E) Kelly and Moore both sit in row 3.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Persons\npersons = ['Gutierrez', 'Hoffman', 'Imamura', 'Kelly', 'Lapas', 'Moore']\n\n# Rows: 1,2,3\nrows = [1, 2, 3]\n\n# Seats: 0 = window, 1 = aisle\nseats = [0, 1]\n\n# Create variables for each person: row and seat\nrow_vars = {p: Int(f'row_{p}') for p in persons}\nseat_vars = {p: Int(f'seat_{p}') for p in persons}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person must be assigned a valid row and seat\nfor p in persons:\n    solver.add(And(row_vars[p] >= 1, row_vars[p] <= 3))\n    solver.add(Or(seat_vars[p] == 0, seat_vars[p] == 1))\n\n# All persons sit in different seats (row + seat combinations must be distinct)\n# We create tuples (row, seat) and enforce distinctness\npositions = []\nfor p in persons:\n    positions.append(row_vars[p]*10 + seat_vars[p])  # Unique int per seat\n\nsolver.add(Distinct(positions))\n\n# Condition 1:\n# Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat.\n# So Hoffman.seat == 1 (aisle), Gutierrez.seat == 1 (aisle)\n# Hoffman.row == Gutierrez.row + 1\nsolver.add(seat_vars['Hoffman'] == 1)\nsolver.add(seat_vars['Gutierrez'] == 1)\nsolver.add(row_vars['Hoffman'] == row_vars['Gutierrez'] + 1)\n\n# Condition 2:\n# If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas.\nmoore_aisle = seat_vars['Moore'] == 1\nhoffman_lapas_same_row = row_vars['Hoffman'] == row_vars['Lapas']\nsolver.add(Implies(moore_aisle, hoffman_lapas_same_row))\n\n# Condition 3:\n# If Gutierrez sits in the same row as Kelly,\n# Moore occupies the seat immediately and directly behind Imamura's seat.\n# That means:\n# If row_Gutierrez == row_Kelly,\n# then row_Moore == row_Imamura + 1 and seat_Moore == seat_Imamura\nsame_row_gk = row_vars['Gutierrez'] == row_vars['Kelly']\nmoore_behind_imamura = And(row_vars['Moore'] == row_vars['Imamura'] + 1,\n                          seat_vars['Moore'] == seat_vars['Imamura'])\nsolver.add(Implies(same_row_gk, moore_behind_imamura))\n\n# Condition 4:\n# If Kelly occupies a window seat, Moore sits in row 3.\nkelly_window = seat_vars['Kelly'] == 0\nmoore_row3 = row_vars['Moore'] == 3\nsolver.add(Implies(kelly_window, moore_row3))\n\n# Condition 5:\n# If Kelly sits in row 3, Imamura sits in row 1.\nkelly_row3 = row_vars['Kelly'] == 3\nimamura_row1 = row_vars['Imamura'] == 1\nsolver.add(Implies(kelly_row3, imamura_row1))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Imamura sits in row 2, whereas Kelly sits in row 3.\n    And(row_vars['Imamura'] == 2, row_vars['Kelly'] == 3),\n\n    # (B) Gutierrez sits in the same row as Kelly, immediately and directly behind Moore.\n    # Gutierrez.row == Kelly.row\n    # Gutierrez.row == Moore.row + 1\n    # Gutierrez.seat == Moore.seat\n    And(row_vars['Gutierrez'] == row_vars['Kelly'],\n        row_vars['Gutierrez'] == row_vars['Moore'] + 1,\n        seat_vars['Gutierrez'] == seat_vars['Moore']),\n\n    # (C) Gutierrez occupies a window seat in the same row as Lapas.\n    And(seat_vars['Gutierrez'] == 0,\n        row_vars['Gutierrez'] == row_vars['Lapas']),\n\n    # (D) Moore occupies an aisle seat in the same row as Lapas.\n    And(seat_vars['Moore'] == 1,\n        row_vars['Moore'] == row_vars['Lapas']),\n\n    # (E) Kelly and Moore both sit in row 3.\n    And(row_vars['Kelly'] == 3,\n        row_vars['Moore'] == 3)\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Gutierrez, Hoffman, Imamura, Kelly, Lapas, and Moore ride a bus together. Each sits facing forward in a different one of the six seats on the left side of the bus. The seats are in consecutive rows that are numbered 1, 2, and 3 from front to back. Each row has exactly two seats: a window seat and an aisle seat. The following conditions must apply: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat. If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas. If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat. If Kelly occupies a window seat, Moore sits in row 3. If Kelly sits in row 3, Imamura sits in row 1.\n\nIf Lapas and Kelly each occupy a window seat, then which one of the following could be true?\n\nOptions:\n(A) Moore occupies the aisle seat in row 3.\n(B) Imamura occupies the window seat in row 3.\n(C) Gutierrez sits in the same row as Kelly.\n(D) Gutierrez sits in the same row as Moore.\n(E) Moore sits in the same row as Lapas.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# People\npeople = ['Gutierrez', 'Hoffman', 'Imamura', 'Kelly', 'Lapas', 'Moore']\n\n# Rows and seats\nrows = [1, 2, 3]\nseat_types = ['window', 'aisle']\n\n# Map seat types to indices for convenience\nseat_type_idx = {'window': 0, 'aisle': 1}\n\n# Create variables for each person: row and seat_type\nrow_vars = {p: Int(f'row_{p}') for p in people}\nseat_vars = {p: Int(f'seat_{p}') for p in people}  # 0 for window, 1 for aisle\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person sits in a valid row and seat type\nfor p in people:\n    solver.add(And(row_vars[p] >= 1, row_vars[p] <= 3))\n    solver.add(Or(seat_vars[p] == 0, seat_vars[p] == 1))  # 0=window,1=aisle\n\n# All persons occupy different seats (row and seat combination unique)\n# So for any two different people, their (row, seat) pairs differ\nfor i in range(len(people)):\n    for j in range(i+1, len(people)):\n        p1 = people[i]\n        p2 = people[j]\n        diff_row = row_vars[p1] != row_vars[p2]\n        diff_seat = seat_vars[p1] != seat_vars[p2]\n        # They differ in row or seat (so not same seat)\n        solver.add(Or(diff_row, diff_seat))\n\n# 1. Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat.\n# That means:\n# - Hoffman seat type is aisle (1)\n# - Gutierrez seat type is aisle (1)\n# - Hoffman's row is Gutierrez's row + 1 (immediately behind)\nsolver.add(seat_vars['Hoffman'] == 1)\nsolver.add(seat_vars['Gutierrez'] == 1)\nsolver.add(row_vars['Hoffman'] == row_vars['Gutierrez'] + 1)\n\n# 2. If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas.\n# This is an implication:\n# (Moore aisle) => (Hoffman row == Lapas row)\nsolver.add(Implies(seat_vars['Moore'] == 1, row_vars['Hoffman'] == row_vars['Lapas']))\n\n# 3. If Gutierrez sits in the same row as Kelly,\n# Moore occupies the seat immediately and directly behind Imamura's seat.\n# \"Immediately and directly behind\" means:\n# - Moore's row = Imamura's row + 1\n# - Moore's seat type = Imamura's seat type\ngk_same_row = row_vars['Gutierrez'] == row_vars['Kelly']\nmoore_behind_imamura = And(row_vars['Moore'] == row_vars['Imamura'] + 1,\n                           seat_vars['Moore'] == seat_vars['Imamura'])\nsolver.add(Implies(gk_same_row, moore_behind_imamura))\n\n# 4. If Kelly occupies a window seat, Moore sits in row 3.\nsolver.add(Implies(seat_vars['Kelly'] == 0, row_vars['Moore'] == 3))\n\n# 5. If Kelly sits in row 3, Imamura sits in row 1.\nsolver.add(Implies(row_vars['Kelly'] == 3, row_vars['Imamura'] == 1))\n\n# GIVEN CONDITION FOR THE QUESTION:\n# If Lapas and Kelly each occupy a window seat\nsolver.add(seat_vars['Lapas'] == 0)\nsolver.add(seat_vars['Kelly'] == 0)\n\n# OPTION CHECKING\n\noptions = {\n    'A': seat_vars['Moore'] == 1,  # Moore aisle seat in row 3\n    'B': And(seat_vars['Imamura'] == 0, row_vars['Imamura'] == 3),  # Imamura window seat in row 3\n    'C': row_vars['Gutierrez'] == row_vars['Kelly'],  # Gutierrez same row as Kelly\n    'D': row_vars['Gutierrez'] == row_vars['Moore'],  # Gutierrez same row as Moore\n    'E': row_vars['Moore'] == row_vars['Lapas'],      # Moore same row as Lapas\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Gutierrez, Hoffman, Imamura, Kelly, Lapas, and Moore ride a bus together. Each sits facing forward in a different one of the six seats on the left side of the bus. The seats are in consecutive rows that are numbered 1, 2, and 3 from front to back. Each row has exactly two seats: a window seat and an aisle seat. The following conditions must apply: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat. If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas. If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat. If Kelly occupies a window seat, Moore sits in row 3. If Kelly sits in row 3, Imamura sits in row 1.\n\nIf Moore sits in row 1, then which one of the following must be true?\n\nOptions:\n(A) Hoffman sits in row 2.\n(B) Imamura sits in row 2.\n(C) Imamura sits in row 3.\n(D) Kelly sits in row 1.\n(E) Lapas sits in row 3.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['Gutierrez', 'Hoffman', 'Imamura', 'Kelly', 'Lapas', 'Moore']\nrows = [1, 2, 3]\nseat_types = ['window', 'aisle']\n\n# Create Z3 Int variables for each person: row (1-3) and seat_type (0=window,1=aisle)\nrow_vars = {p: Int(f'row_{p}') for p in persons}\nseat_vars = {p: Int(f'seat_{p}') for p in persons}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person sits in a valid row and seat type\nfor p in persons:\n    solver.add(And(row_vars[p] >= 1, row_vars[p] <= 3))\n    solver.add(Or(seat_vars[p] == 0, seat_vars[p] == 1))  # 0=window,1=aisle\n\n# Each seat (row + seat_type) is occupied by exactly one person\n# So all (row, seat) pairs are distinct\noccupied_seats = [ (row_vars[p], seat_vars[p]) for p in persons]\n\n# To enforce distinctness on pairs, we add pairwise constraints:\nfor i in range(len(persons)):\n    for j in range(i+1, len(persons)):\n        p1 = persons[i]\n        p2 = persons[j]\n        cond = Or(row_vars[p1] != row_vars[p2], seat_vars[p1] != seat_vars[p2])\n        solver.add(cond)\n\n# Condition 1:\n# Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat.\n# That means: Hoffman.seat == aisle (1)\n# Gutierrez.seat == aisle (1)\n# Hoffman.row == Gutierrez.row + 1\n\nsolver.add(seat_vars['Hoffman'] == 1)\nsolver.add(seat_vars['Gutierrez'] == 1)\nsolver.add(row_vars['Hoffman'] == row_vars['Gutierrez'] + 1)\n\n# Condition 2:\n# If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas.\n# (Moore.seat == aisle) => (Hoffman.row == Lapas.row)\nmoore_aisle = seat_vars['Moore'] == 1\nhoff_lapas_same_row = row_vars['Hoffman'] == row_vars['Lapas']\nsolver.add(Implies(moore_aisle, hoff_lapas_same_row))\n\n# Condition 3:\n# If Gutierrez sits in the same row as Kelly,\n# then Moore occupies the seat immediately and directly behind Imamura's seat.\n# \"Immediately and directly behind\" means:\n# Moore.row == Imamura.row + 1 and Moore.seat == Imamura.seat\ngut_kelly_same_row = row_vars['Gutierrez'] == row_vars['Kelly']\nmoore_behind_imamura = And(row_vars['Moore'] == row_vars['Imamura'] + 1,\n                          seat_vars['Moore'] == seat_vars['Imamura'])\nsolver.add(Implies(gut_kelly_same_row, moore_behind_imamura))\n\n# Condition 4:\n# If Kelly occupies a window seat, Moore sits in row 3.\nsolver.add(Implies(seat_vars['Kelly'] == 0, row_vars['Moore'] == 3))\n\n# Condition 5:\n# If Kelly sits in row 3, Imamura sits in row 1.\nsolver.add(Implies(row_vars['Kelly'] == 3, row_vars['Imamura'] == 1))\n\n# Additional constraints: all persons sit in different seats (already done)\n# No other constraints given.\n\n# OPTION CHECKING\n# Given: Moore sits in row 1\nsolver.add(row_vars['Moore'] == 1)\n\noptions = {\n    'A': row_vars['Hoffman'] == 2,\n    'B': row_vars['Imamura'] == 2,\n    'C': row_vars['Imamura'] == 3,\n    'D': row_vars['Kelly'] == 1,\n    'E': row_vars['Lapas'] == 3\n}\n\n# For each option, check if it must be true:\n# That is, check if the negation is UNSAT with all constraints.\n\nfor opt in ['A','B','C','D','E']:\n    solver.push()\n    # Add negation of option\n    solver.add(Not(options[opt]))\n    if solver.check() == unsat:\n        print(f\"'{opt}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Gutierrez, Hoffman, Imamura, Kelly, Lapas, and Moore ride a bus together. Each sits facing forward in a different one of the six seats on the left side of the bus. The seats are in consecutive rows that are numbered 1, 2, and 3 from front to back. Each row has exactly two seats: a window seat and an aisle seat. The following conditions must apply: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat. If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas. If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat. If Kelly occupies a window seat, Moore sits in row 3. If Kelly sits in row 3, Imamura sits in row 1.\n\nIf Kelly occupies the aisle seat in row 3, then each of the following must be true EXCEPT:\n\nOptions:\n(A) Gutierrez sits in the same row as Imamura.\n(B) Hoffman sits in the same row as Lapas.\n(C) Lapas occupies a window seat.\n(D) Moore occupies a window seat.\n(E) Gutierrez sits in row 1.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npeople = ['Gutierrez', 'Hoffman', 'Imamura', 'Kelly', 'Lapas', 'Moore']\nrows = [1, 2, 3]\nseats = ['window', 'aisle']\n\n# Map seat positions to indices for easier handling\nrow_indices = {1: 0, 2: 1, 3: 2}\nseat_indices = {'window': 0, 'aisle': 1}\n\n# Create variables for each person: row and seat (0 for window, 1 for aisle)\nrow_vars = {p: Int(f'row_{p}') for p in people}\nseat_vars = {p: Int(f'seat_{p}') for p in people}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person must be in a valid row and seat\nfor p in people:\n    solver.add(And(row_vars[p] >= 1, row_vars[p] <= 3))\n    solver.add(Or(seat_vars[p] == 0, seat_vars[p] == 1))  # 0=window, 1=aisle\n\n# All six people occupy different seats (row, seat pairs)\noccupied_seats = [row_vars[p] * 2 + seat_vars[p] for p in people]\nsolver.add(Distinct(occupied_seats))\n\n# Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat.\n# So Hoffman seat is aisle (1), Gutierrez seat is aisle (1)\n# and Hoffman's row = Gutierrez's row + 1\nsolver.add(seat_vars['Hoffman'] == 1)\nsolver.add(seat_vars['Gutierrez'] == 1)\nsolver.add(row_vars['Hoffman'] == row_vars['Gutierrez'] + 1)\n\n# If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas.\nmoore_is_aisle = seat_vars['Moore'] == 1\nhoffman_lapas_same_row = row_vars['Hoffman'] == row_vars['Lapas']\nsolver.add(Implies(moore_is_aisle, hoffman_lapas_same_row))\n\n# If Gutierrez sits in the same row as Kelly,\n# Moore occupies the seat immediately and directly behind Imamura's seat.\ngutierrez_kelly_same_row = row_vars['Gutierrez'] == row_vars['Kelly']\n# Moore is immediately behind Imamura: Moore.row = Imamura.row + 1\n# Moore.seat == Imamura.seat\nmoore_behind_imamura = And(row_vars['Moore'] == row_vars['Imamura'] + 1,\n                          seat_vars['Moore'] == seat_vars['Imamura'])\nsolver.add(Implies(gutierrez_kelly_same_row, moore_behind_imamura))\n\n# If Kelly occupies a window seat, Moore sits in row 3.\nkelly_is_window = seat_vars['Kelly'] == 0\nsolver.add(Implies(kelly_is_window, row_vars['Moore'] == 3))\n\n# If Kelly sits in row 3, Imamura sits in row 1.\nkelly_row_3 = row_vars['Kelly'] == 3\nsolver.add(Implies(kelly_row_3, row_vars['Imamura'] == 1))\n\n# OPTION CHECKING\n# We are told: If Kelly occupies the aisle seat in row 3, then each of the following must be true EXCEPT:\n# So first add Kelly in aisle seat in row 3\nsolver.push()\nsolver.add(row_vars['Kelly'] == 3)\nsolver.add(seat_vars['Kelly'] == 1)  # aisle seat\n\noptions = {\n    'A': row_vars['Gutierrez'] == row_vars['Imamura'],\n    'B': row_vars['Hoffman'] == row_vars['Lapas'],\n    'C': seat_vars['Lapas'] == 0,  # window seat\n    'D': seat_vars['Moore'] == 0,  # window seat\n    'E': row_vars['Gutierrez'] == 1\n}\n\n# Check which options must be true under the above conditions\n# The EXCEPT means one of these is not necessarily true\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Check if the negation of the option is possible (i.e. option does NOT hold)\n    solver.add(Not(options[letter]))\n    if solver.check() == sat:\n        # If negation is satisfiable, option is not necessarily true, so this is the EXCEPT\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()\n\nsolver.pop()  # remove Kelly aisle row 3 condition to clean up solver state",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Gutierrez, Hoffman, Imamura, Kelly, Lapas, and Moore ride a bus together. Each sits facing forward in a different one of the six seats on the left side of the bus. The seats are in consecutive rows that are numbered 1, 2, and 3 from front to back. Each row has exactly two seats: a window seat and an aisle seat. The following conditions must apply: Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat. If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas. If Gutierrez sits in the same row as Kelly, Moore occupies the seat immediately and directly behind Imamura's seat. If Kelly occupies a window seat, Moore sits in row 3. If Kelly sits in row 3, Imamura sits in row 1.\n\nIf neither Gutierrez nor Imamura sits in row 1, then which one of the following could be true?\n\nOptions:\n(A) Hoffman sits in row 2.\n(B) Kelly sits in row 2.\n(C) Moore sits in row 2.\n(D) Imamura occupies an aisle seat.\n(E) Moore occupies an aisle seat.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npersons = ['Gutierrez', 'Hoffman', 'Imamura', 'Kelly', 'Lapas', 'Moore']\nrows = [1, 2, 3]\nseats = ['window', 'aisle']\n\n# Create variables for each person: row (1-3) and seat (0 for window, 1 for aisle)\nrow_vars = {p: Int(f'row_{p}') for p in persons}\nseat_vars = {p: Int(f'seat_{p}') for p in persons}  # 0=window,1=aisle\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each person sits in a valid row and seat\nfor p in persons:\n    solver.add(And(row_vars[p] >= 1, row_vars[p] <= 3))\n    solver.add(Or(seat_vars[p] == 0, seat_vars[p] == 1))\n\n# All seats are different: no two persons have same row and seat\nfor i in range(len(persons)):\n    for j in range(i+1, len(persons)):\n        p1 = persons[i]\n        p2 = persons[j]\n        diff_row = row_vars[p1] != row_vars[p2]\n        diff_seat = seat_vars[p1] != seat_vars[p2]\n        # They differ in row or seat (can't be same seat)\n        solver.add(Or(diff_row, diff_seat))\n\n# Condition 1:\n# Hoffman occupies the aisle seat immediately behind Gutierrez's aisle seat.\n# Means: Hoffman seat=aisle (1), Gutierrez seat=aisle (1)\n# Hoffman row = Gutierrez row +1\nsolver.add(seat_vars['Hoffman'] == 1)\nsolver.add(seat_vars['Gutierrez'] == 1)\nsolver.add(row_vars['Hoffman'] == row_vars['Gutierrez'] + 1)\n\n# Condition 2:\n# If Moore occupies an aisle seat, Hoffman sits in the same row as Lapas.\n# (Moore seat=1) => (row Hoffman == row Lapas)\nmoore_aisle = seat_vars['Moore'] == 1\nhoffman_lapas_same_row = row_vars['Hoffman'] == row_vars['Lapas']\nsolver.add(Implies(moore_aisle, hoffman_lapas_same_row))\n\n# Condition 3:\n# If Gutierrez sits in the same row as Kelly,\n# then Moore occupies the seat immediately and directly behind Imamura's seat.\n# \"Immediately and directly behind\" means:\n# Moore row = Imamura row +1\n# Moore seat = Imamura seat\ngut_kelly_same_row = row_vars['Gutierrez'] == row_vars['Kelly']\nmoore_behind_imamura = And(row_vars['Moore'] == row_vars['Imamura'] + 1,\n                          seat_vars['Moore'] == seat_vars['Imamura'])\nsolver.add(Implies(gut_kelly_same_row, moore_behind_imamura))\n\n# Condition 4:\n# If Kelly occupies a window seat, Moore sits in row 3.\nkelly_window = seat_vars['Kelly'] == 0\nmoore_row3 = row_vars['Moore'] == 3\nsolver.add(Implies(kelly_window, moore_row3))\n\n# Condition 5:\n# If Kelly sits in row 3, Imamura sits in row 1.\nkelly_row3 = row_vars['Kelly'] == 3\nimamura_row1 = row_vars['Imamura'] == 1\nsolver.add(Implies(kelly_row3, imamura_row1))\n\n# Additional given condition for the question:\n# Neither Gutierrez nor Imamura sits in row 1\nsolver.add(row_vars['Gutierrez'] != 1)\nsolver.add(row_vars['Imamura'] != 1)\n\n# OPTION CHECKING\noptions = [\n    ('A', row_vars['Hoffman'] == 2),\n    ('B', row_vars['Kelly'] == 2),\n    ('C', row_vars['Moore'] == 2),\n    ('D', seat_vars['Imamura'] == 1),\n    ('E', seat_vars['Moore'] == 1)\n]\n\nfor letter, cond in options:\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "An airline has four flights from New York to Sarasota—flights 1, 2, 3, and 4. On each flight there is exactly one pilot and exactly one co-pilot. The pilots are Fazio, Germond, Kyle, and Lopez; the co-pilots are Reich, Simon, Taylor, and Umlas. Each pilot and co-pilot is assigned to exactly one flight. The flights take off in numerical order. Fazio's flight takes off before Germond's, and at least one other flight takes off between their flights. Kyle is assigned to flight 2. Lopez is assigned to the same flight as Umlas.\n\nWhich one of the following pilot and co-pilot teams could be assigned to flight 1?\n\nOptions:\n(A) Fazio and Reich\n(B) Fazio and Umlas\n(C) Germond and Reich\n(D) Germond and Umlas\n(E) Lopez and Taylor",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npilots = ['Fazio', 'Germond', 'Kyle', 'Lopez']\ncopilots = ['Reich', 'Simon', 'Taylor', 'Umlas']\nflights = [1, 2, 3, 4]\n\n# Create Z3 Int variables for pilot flight assignments\npilot_flight = {p: Int(p) for p in pilots}\n# Create Z3 Int variables for co-pilot flight assignments\ncopilot_flight = {c: Int(c) for c in copilots}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each pilot is assigned to exactly one flight number 1-4\nfor p in pilots:\n    solver.add(And(pilot_flight[p] >= 1, pilot_flight[p] <= 4))\n\n# Each co-pilot is assigned to exactly one flight number 1-4\nfor c in copilots:\n    solver.add(And(copilot_flight[c] >= 1, copilot_flight[c] <= 4))\n\n# All pilots assigned to distinct flights\nsolver.add(Distinct([pilot_flight[p] for p in pilots]))\n\n# All co-pilots assigned to distinct flights\nsolver.add(Distinct([copilot_flight[c] for c in copilots]))\n\n# Each flight has exactly one pilot and one co-pilot (already ensured by distinctness and domains)\n\n# Kyle is assigned to flight 2\nsolver.add(pilot_flight['Kyle'] == 2)\n\n# Lopez is assigned to the same flight as Umlas\nsolver.add(pilot_flight['Lopez'] == copilot_flight['Umlas'])\n\n# Fazio's flight takes off before Germond's, and at least one other flight takes off between their flights\n# That means Germond's flight number minus Fazio's flight number >= 2\ndiff_fg = pilot_flight['Germond'] - pilot_flight['Fazio']\nsolver.add(diff_fg >= 2)\n\n# OPTION CHECKING\noptions = [\n    ('Fazio', 'Reich'),\n    ('Fazio', 'Umlas'),\n    ('Germond', 'Reich'),\n    ('Germond', 'Umlas'),\n    ('Lopez', 'Taylor'),\n]\n\nfor i, (opt_pilot, opt_copilot) in enumerate(options):\n    solver.push()\n    # Add constraint that flight 1 has this pilot and co-pilot\n    solver.add(pilot_flight[opt_pilot] == 1)\n    solver.add(copilot_flight[opt_copilot] == 1)\n    # Check if satisfiable\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "An airline has four flights from New York to Sarasota—flights 1, 2, 3, and 4. On each flight there is exactly one pilot and exactly one co-pilot. The pilots are Fazio, Germond, Kyle, and Lopez; the co-pilots are Reich, Simon, Taylor, and Umlas. Each pilot and co-pilot is assigned to exactly one flight. The flights take off in numerical order. Fazio's flight takes off before Germond's, and at least one other flight takes off between their flights. Kyle is assigned to flight 2. Lopez is assigned to the same flight as Umlas.\n\nIf Reich's flight is later than Umlas's, which one of the following statements cannot be true?\n\nOptions:\n(A) Fazio's flight is earlier than Simon's.\n(B) Kyle's flight is earlier than Reich's.\n(C) Kyle's flight is earlier than Taylor's.\n(D) Simon's flight is earlier than Reich's.\n(E) Taylor's flight is earlier than Kyle's.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Flights numbered 1 to 4\nflights = [1, 2, 3, 4]\n\n# Pilots and Co-pilots\npilots = ['Fazio', 'Germond', 'Kyle', 'Lopez']\ncopilots = ['Reich', 'Simon', 'Taylor', 'Umlas']\n\n# Create Z3 Int variables for each pilot and co-pilot representing their flight number\npilot_flight = {p: Int(p) for p in pilots}\ncopilot_flight = {c: Int(c) for c in copilots}\n\n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each pilot's flight is between 1 and 4\nfor p in pilots:\n    solver.add(And(pilot_flight[p] >= 1, pilot_flight[p] <= 4))\n\n# Each co-pilot's flight is between 1 and 4\nfor c in copilots:\n    solver.add(And(copilot_flight[c] >= 1, copilot_flight[c] <= 4))\n\n# All pilots assigned to different flights\nsolver.add(Distinct([pilot_flight[p] for p in pilots]))\n\n# All co-pilots assigned to different flights\nsolver.add(Distinct([copilot_flight[c] for c in copilots]))\n\n# Each flight has exactly one pilot and one co-pilot\n# Since pilots and co-pilots are distinct sets and each assigned to unique flights,\n# no two pilots share a flight and no two co-pilots share a flight.\n# We must ensure that the sets of pilot flights and co-pilot flights match (one pilot and one co-pilot per flight)\n# So the multiset of pilot flights equals the multiset of co-pilot flights.\n# Since both sets are distinct and cover the same 4 flights, the sets of flights must be equal.\n# Enforce that the sets of pilot flights and co-pilot flights are equal as sets:\npilot_flights_list = [pilot_flight[p] for p in pilots]\ncopilot_flights_list = [copilot_flight[c] for c in copilots]\n# Enforce that for each flight number, it appears exactly once in pilots and exactly once in copilots\n# Because they are distinct and cover all four flights, this is equivalent to:\nfor fl in flights:\n    # Exactly one pilot assigned to flight fl\n    pilot_on_fl = [pilot_flight[p] == fl for p in pilots]\n    solver.add(Sum([If(cond, 1, 0) for cond in pilot_on_fl]) == 1)\n    # Exactly one co-pilot assigned to flight fl\n    copilot_on_fl = [copilot_flight[c] == fl for c in copilots]\n    solver.add(Sum([If(cond, 1, 0) for cond in copilot_on_fl]) == 1)\n\n# Fazio's flight takes off before Germond's, and at least one other flight takes off between their flights\nsolver.add(pilot_flight['Fazio'] < pilot_flight['Germond'])\nsolver.add(pilot_flight['Germond'] - pilot_flight['Fazio'] >= 2)\n\n# Kyle is assigned to flight 2\nsolver.add(pilot_flight['Kyle'] == 2)\n\n# Lopez is assigned to the same flight as Umlas\nsolver.add(pilot_flight['Lopez'] == copilot_flight['Umlas'])\n\n# Reich's flight is later than Umlas's\nsolver.add(copilot_flight['Reich'] > copilot_flight['Umlas'])\n\n# OPTION CHECKING\n\n# For each option, check if it can be true (i.e., if the model is satisfiable with the option added)\n# The question: which one CANNOT be true? So we want the option that makes the model UNSAT\n\noptions = {\n    'A': pilot_flight['Fazio'] < copilot_flight['Simon'],\n    'B': pilot_flight['Kyle'] < copilot_flight['Reich'],\n    'C': pilot_flight['Kyle'] < copilot_flight['Taylor'],\n    'D': copilot_flight['Simon'] < copilot_flight['Reich'],\n    'E': copilot_flight['Taylor'] < pilot_flight['Kyle'],\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "An airline has four flights from New York to Sarasota—flights 1, 2, 3, and 4. On each flight there is exactly one pilot and exactly one co-pilot. The pilots are Fazio, Germond, Kyle, and Lopez; the co-pilots are Reich, Simon, Taylor, and Umlas. Each pilot and co-pilot is assigned to exactly one flight. The flights take off in numerical order. Fazio's flight takes off before Germond's, and at least one other flight takes off between their flights. Kyle is assigned to flight 2. Lopez is assigned to the same flight as Umlas.\n\nIf Lopez's flight is earlier than Germond's, which one of the following statements could be false?\n\nOptions:\n(A) Fazio's flight is earlier than Umlas's.\n(B) Germond is assigned to flight 4.\n(C) Either Reich's or Taylor's flight is earlier than Umlas's.\n(D) Simon's flight is earlier than Umlas's.\n(E) Umlas is assigned to flight 3.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflights = [1, 2, 3, 4]\npilots = ['Fazio', 'Germond', 'Kyle', 'Lopez']\ncopilots = ['Reich', 'Simon', 'Taylor', 'Umlas']\n\n# Create Z3 Int variables for pilot flight assignments\npilot_flights = {p: Int(p) for p in pilots}\n# Create Z3 Int variables for copilot flight assignments\ncopilot_flights = {c: Int(c) for c in copilots}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each pilot assigned to exactly one flight between 1 and 4\nfor p in pilots:\n    solver.add(And(pilot_flights[p] >= 1, pilot_flights[p] <= 4))\n\n# Each copilot assigned to exactly one flight between 1 and 4\nfor c in copilots:\n    solver.add(And(copilot_flights[c] >= 1, copilot_flights[c] <= 4))\n\n# All pilots have distinct flights\nsolver.add(Distinct([pilot_flights[p] for p in pilots]))\n\n# All copilots have distinct flights\nsolver.add(Distinct([copilot_flights[c] for c in copilots]))\n\n# Each flight has exactly one pilot and one copilot\n# Since all pilots and copilots have distinct flights, and there are 4 flights,\n# and each flight has one pilot and one copilot, the sets of pilot flights and copilot flights are equal sets.\n# So the set of pilot flights equals the set of copilot flights (order may differ).\n# We enforce that the multiset of pilot flights equals the multiset of copilot flights.\n# To do this, we check that for each flight number, the count of pilots assigned equals the count of copilots assigned.\nfor f in flights:\n    pilot_assigned = Sum([If(pilot_flights[p] == f, 1, 0) for p in pilots])\n    copilot_assigned = Sum([If(copilot_flights[c] == f, 1, 0) for c in copilots])\n    solver.add(pilot_assigned == 1)\n    solver.add(copilot_assigned == 1)\n\n# Fazio's flight takes off before Germond's, and at least one other flight takes off between their flights.\n# Means: pilot_flights[Fazio] < pilot_flights[Germond] - 1\nsolver.add(pilot_flights['Fazio'] < pilot_flights['Germond'] - 1)\n\n# Kyle is assigned to flight 2\nsolver.add(pilot_flights['Kyle'] == 2)\n\n# Lopez is assigned to the same flight as Umlas\nsolver.add(pilot_flights['Lopez'] == copilot_flights['Umlas'])\n\n# Additional assumption from the question stem for option checking:\n# Lopez's flight is earlier than Germond's\nsolver.add(pilot_flights['Lopez'] < pilot_flights['Germond'])\n\n# OPTION CHECKING\n\noptions = {\n    'A': pilot_flights['Fazio'] < copilot_flights['Umlas'],  # Fazio's flight earlier than Umlas's\n    'B': pilot_flights['Germond'] == 4,                      # Germond is assigned to flight 4\n    'C': Or([copilot_flights[c] < copilot_flights['Umlas'] for c in ['Reich', 'Taylor']]), # Reich's or Taylor's flight earlier than Umlas's\n    'D': copilot_flights['Simon'] < copilot_flights['Umlas'], # Simon's flight earlier than Umlas's\n    'E': copilot_flights['Umlas'] == 3                        # Umlas is assigned to flight 3\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    # Check if the negation of the option condition is satisfiable with all other constraints\n    # Because the question asks: which one could be false?\n    # So we check if the option can be false, i.e., condition can be false.\n    solver.add(Not(condition))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "An airline has four flights from New York to Sarasota—flights 1, 2, 3, and 4. On each flight there is exactly one pilot and exactly one co-pilot. The pilots are Fazio, Germond, Kyle, and Lopez; the co-pilots are Reich, Simon, Taylor, and Umlas. Each pilot and co-pilot is assigned to exactly one flight. The flights take off in numerical order. Fazio's flight takes off before Germond's, and at least one other flight takes off between their flights. Kyle is assigned to flight 2. Lopez is assigned to the same flight as Umlas.\n\nWhat is the maximum possible number of different pilot and co-pilot teams, any one of which could be assigned to flight 4?\n\nOptions:\n(A) 2\n(B) 3\n(C) 4\n(D) 5\n(E) 6",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflights = [1, 2, 3, 4]\n\npilots = ['Fazio', 'Germond', 'Kyle', 'Lopez']\ncopilots = ['Reich', 'Simon', 'Taylor', 'Umlas']\n\n# Create Z3 Int variables for pilot assignments: pilot_to_flight[pilot] = flight number (1-4)\npilot_to_flight = {p: Int(p) for p in pilots}\n\n# Create Z3 Int variables for co-pilot assignments: copilot_to_flight[copilot] = flight number (1-4)\ncopilot_to_flight = {c: Int(c) for c in copilots}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each pilot assigned to exactly one flight in 1..4\nfor p in pilots:\n    solver.add(And(pilot_to_flight[p] >= 1, pilot_to_flight[p] <= 4))\n\n# All pilots assigned to distinct flights\nsolver.add(Distinct([pilot_to_flight[p] for p in pilots]))\n\n# Each co-pilot assigned to exactly one flight in 1..4\nfor c in copilots:\n    solver.add(And(copilot_to_flight[c] >= 1, copilot_to_flight[c] <= 4))\n\n# All co-pilots assigned to distinct flights\nsolver.add(Distinct([copilot_to_flight[c] for c in copilots]))\n\n# Lopez is assigned to the same flight as Umlas\nsolver.add(pilot_to_flight['Lopez'] == copilot_to_flight['Umlas'])\n\n# Kyle is assigned to flight 2\nsolver.add(pilot_to_flight['Kyle'] == 2)\n\n# Fazio's flight takes off before Germond's, and at least one other flight takes off between their flights\n# So Germond's flight number - Fazio's flight number >= 2\nsolver.add(pilot_to_flight['Fazio'] < pilot_to_flight['Germond'])\nsolver.add(pilot_to_flight['Germond'] - pilot_to_flight['Fazio'] >= 2)\n\n# Additional constraint: each flight has exactly one pilot and one co-pilot\n# So for each flight, there is exactly one pilot and one co-pilot assigned\n# This is ensured by Distinct and domain constraints above\n\n# OPTION CHECKING\n# We want to find the maximum possible number of different pilot and co-pilot teams\n# that could be assigned to flight 4.\n\n# So for each possible pilot and co-pilot pair, check if there exists a solution where\n# pilot_to_flight[p] == 4 and copilot_to_flight[c] == 4.\n\n# Count how many such pairs are possible.\n\npossible_pairs = []\n\nfor p in pilots:\n    for c in copilots:\n        solver.push()\n        solver.add(pilot_to_flight[p] == 4)\n        solver.add(copilot_to_flight[c] == 4)\n        if solver.check() == sat:\n            possible_pairs.append((p, c))\n        solver.pop()\n\nmax_possible_teams = len(possible_pairs)\n\n# Map max_possible_teams to options\n# Options:\n# (A) 2\n# (B) 3\n# (C) 4\n# (D) 5\n# (E) 6\n\noptions_map = {2: 'A', 3: 'B', 4: 'C', 5: 'D', 6: 'E'}\n\nprint(f\"'{options_map[max_possible_teams]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "An airline has four flights from New York to Sarasota—flights 1, 2, 3, and 4. On each flight there is exactly one pilot and exactly one co-pilot. The pilots are Fazio, Germond, Kyle, and Lopez; the co-pilots are Reich, Simon, Taylor, and Umlas. Each pilot and co-pilot is assigned to exactly one flight. The flights take off in numerical order. Fazio's flight takes off before Germond's, and at least one other flight takes off between their flights. Kyle is assigned to flight 2. Lopez is assigned to the same flight as Umlas.\n\nIf Simon's flight is later than Lopez's, then which one of the following statements could be false?\n\nOptions:\n(A) Germond's flight is later than Reich's.\n(B) Germond's flight is later than Taylor's.\n(C) Lopez's flight is later than Taylor's.\n(D) Taylor's flight is later than Reich's.\n(E) Umlas's flight is later than Reich's.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nflights = [1, 2, 3, 4]\n\npilots = ['Fazio', 'Germond', 'Kyle', 'Lopez']\ncopilots = ['Reich', 'Simon', 'Taylor', 'Umlas']\n\n# Create Z3 Int variables for pilot flights and copilot flights\npilot_flight = {p: Int(p) for p in pilots}\ncopilot_flight = {c: Int(c) for c in copilots}\n\nsolver = Solver()\n\n# Each pilot assigned to exactly one flight (1-4)\nfor p in pilots:\n    solver.add(And(pilot_flight[p] >= 1, pilot_flight[p] <= 4))\n\n# Each co-pilot assigned to exactly one flight (1-4)\nfor c in copilots:\n    solver.add(And(copilot_flight[c] >= 1, copilot_flight[c] <= 4))\n\n# All pilots assigned to different flights\nsolver.add(Distinct([pilot_flight[p] for p in pilots]))\n\n# All copilots assigned to different flights\nsolver.add(Distinct([copilot_flight[c] for c in copilots]))\n\n# Each flight has exactly one pilot and one copilot\n# This is implicit in distinctness and assignments\n\n# Kyle is assigned to flight 2\nsolver.add(pilot_flight['Kyle'] == 2)\n\n# Lopez is assigned to the same flight as Umlas\nsolver.add(pilot_flight['Lopez'] == copilot_flight['Umlas'])\n\n# Fazio's flight takes off before Germond's flight\nsolver.add(pilot_flight['Fazio'] < pilot_flight['Germond'])\n\n# At least one other flight takes off between Fazio's and Germond's flights\ndiff_fazio_germond = pilot_flight['Germond'] - pilot_flight['Fazio']\nsolver.add(diff_fazio_germond >= 2)\n\n# If Simon's flight is later than Lopez's\n# We will add this condition when checking options\n\n# OPTION CHECKING\noptions = {\n    'A': pilot_flight['Germond'] > copilot_flight['Reich'],\n    'B': pilot_flight['Germond'] > copilot_flight['Taylor'],\n    'C': pilot_flight['Lopez'] > copilot_flight['Taylor'],\n    'D': copilot_flight['Taylor'] > copilot_flight['Reich'],\n    'E': copilot_flight['Umlas'] > copilot_flight['Reich'],\n}\n\n# We want to find which option could be false,\n# i.e., under the condition Simon's flight > Lopez's flight,\n# the negation of the option is satisfiable with all constraints.\n\nfor opt_letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add condition: Simon's flight is later than Lopez's\n    solver.add(copilot_flight['Simon'] > pilot_flight['Lopez'])\n    # Add negation of option\n    solver.add(Not(options[opt_letter]))\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A school has exactly four dormitories that are to be fully occupied—Richards, Tuscarora, Veblen, and Wisteria—each consisting entirely of a North wing and a South wing. The following rules govern assignment of students to dormitory wings: Each wing is assigned only male students or only female students. Exactly three wings have males assigned to them. Richards North and Tuscarora North are assigned females. If a dormitory has males assigned to one of its wings, then its other wing is assigned females. If males are assigned to Veblen South, then Wisteria North is assigned males.\n\nIf females are assigned to Veblen South and Veblen North, then which one of the following could be two other wings that are also assigned females?\n\nOptions:\n(A) Richards North and Tuscarora South\n(B) Richards South and Wisteria South\n(C) Richards South and Tuscarora North\n(D) Tuscarora North and Wisteria South\n(E) Tuscarora South and Wisteria South",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndorms = ['Richards', 'Tuscarora', 'Veblen', 'Wisteria']\nwings = ['North', 'South']\n\n# Create variables for each wing: 0 = female, 1 = male\nassignments = {}\nfor d in dorms:\n    for w in wings:\n        assignments[(d, w)] = Int(f\"{d}_{w}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each wing assigned either male (1) or female (0)\nfor d in dorms:\n    for w in wings:\n        solver.add(Or(assignments[(d, w)] == 0, assignments[(d, w)] == 1))\n\n# Exactly three wings have males assigned\nsolver.add(Sum([assignments[(d, w)] for d in dorms for w in wings]) == 3)\n\n# Richards North and Tuscarora North are females\nsolver.add(assignments[('Richards', 'North')] == 0)\nsolver.add(assignments[('Tuscarora', 'North')] == 0)\n\n# If a dormitory has males assigned to one wing, the other wing is females\nfor d in dorms:\n    north = assignments[(d, 'North')]\n    south = assignments[(d, 'South')]\n    # If North is male, South is female\n    solver.add(Implies(north == 1, south == 0))\n    # If South is male, North is female\n    solver.add(Implies(south == 1, north == 0))\n\n# If males assigned to Veblen South, then Wisteria North is males\nsolver.add(Implies(assignments[('Veblen', 'South')] == 1, assignments[('Wisteria', 'North')] == 1))\n\n# Females assigned to Veblen South and Veblen North (given)\nsolver.add(assignments[('Veblen', 'North')] == 0)\nsolver.add(assignments[('Veblen', 'South')] == 0)\n\n# OPTION CHECKING\noptions = {\n    'A': [('Richards', 'North'), ('Tuscarora', 'South')],\n    'B': [('Richards', 'South'), ('Wisteria', 'South')],\n    'C': [('Richards', 'South'), ('Tuscarora', 'North')],\n    'D': [('Tuscarora', 'North'), ('Wisteria', 'South')],\n    'E': [('Tuscarora', 'South'), ('Wisteria', 'South')]\n}\n\nfor letter, wings_female in options.items():\n    solver.push()\n    # Add constraints that these two wings are female\n    for wing in wings_female:\n        solver.add(assignments[wing] == 0)\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A school has exactly four dormitories that are to be fully occupied—Richards, Tuscarora, Veblen, and Wisteria—each consisting entirely of a North wing and a South wing. The following rules govern assignment of students to dormitory wings: Each wing is assigned only male students or only female students. Exactly three wings have males assigned to them. Richards North and Tuscarora North are assigned females. If a dormitory has males assigned to one of its wings, then its other wing is assigned females. If males are assigned to Veblen South, then Wisteria North is assigned males.\n\nIt CANNOT be true that females are assigned to both\n\nOptions:\n(A) Richards South and Wisteria South\n(B) Richards South and Tuscarora South\n(C) Richards South and Veblen North\n(D) Tuscarora South and Wisteria South\n(E) Veblen North and Wisteria South",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndorms = ['Richards', 'Tuscarora', 'Veblen', 'Wisteria']\nwings = ['North', 'South']\n\n# Create variables: 1 for male, 0 for female\nassign = {}\nfor d in dorms:\n    for w in wings:\n        assign[(d, w)] = Int(f'{d}_{w}')\n\nsolver = Solver()\n\n# Each wing assigned 0 (female) or 1 (male)\nfor d in dorms:\n    for w in wings:\n        solver.add(Or(assign[(d, w)] == 0, assign[(d, w)] == 1))\n\n# Exactly three wings have males assigned\nsolver.add(Sum([assign[(d, w)] for d in dorms for w in wings]) == 3)\n\n# Richards North and Tuscarora North are assigned females\nsolver.add(assign[('Richards', 'North')] == 0)\nsolver.add(assign[('Tuscarora', 'North')] == 0)\n\n# If a dorm has males on one wing, other wing is female\nfor d in dorms:\n    male_n = assign[(d, 'North')] == 1\n    male_s = assign[(d, 'South')] == 1\n    # If North is male then South is female\n    solver.add(Implies(male_n, assign[(d, 'South')] == 0))\n    # If South is male then North is female\n    solver.add(Implies(male_s, assign[(d, 'North')] == 0))\n\n# If males assigned to Veblen South, then Wisteria North is males\nsolver.add(Implies(assign[('Veblen', 'South')] == 1, assign[('Wisteria', 'North')] == 1))\n\n# OPTION CHECKING\noptions = {\n    'A': [('Richards', 'South'), ('Wisteria', 'South')],\n    'B': [('Richards', 'South'), ('Tuscarora', 'South')],\n    'C': [('Richards', 'South'), ('Veblen', 'North')],\n    'D': [('Tuscarora', 'South'), ('Wisteria', 'South')],\n    'E': [('Veblen', 'North'), ('Wisteria', 'South')],\n}\n\nfor letter, pairs in options.items():\n    solver.push()\n    # Add constraint that females assigned to both wings in pairs\n    fem_constraints = [assign[pair] == 0 for pair in pairs]\n    solver.add(And(fem_constraints))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A school has exactly four dormitories that are to be fully occupied—Richards, Tuscarora, Veblen, and Wisteria—each consisting entirely of a North wing and a South wing. The following rules govern assignment of students to dormitory wings: Each wing is assigned only male students or only female students. Exactly three wings have males assigned to them. Richards North and Tuscarora North are assigned females. If a dormitory has males assigned to one of its wings, then its other wing is assigned females. If males are assigned to Veblen South, then Wisteria North is assigned males.\n\nIf Wisteria North is assigned females, then females must also be assigned to which one of the following?\n\nOptions:\n(A) Richards South\n(B) Wisteria South\n(C) Tuscarora South\n(D) Veblen South\n(E) Veblen North",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndorms = ['Richards', 'Tuscarora', 'Veblen', 'Wisteria']\nwings = ['North', 'South']\n\n# Map dorm and wing to a variable representing gender assignment:\n# 1 for male, 0 for female\nassign = {}\nfor d in dorms:\n    for w in wings:\n        assign[(d, w)] = Int(f'{d}_{w}')\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each wing assigned only male (1) or female (0)\nfor d in dorms:\n    for w in wings:\n        solver.add(Or(assign[(d, w)] == 0, assign[(d, w)] == 1))\n\n# Exactly three wings have males assigned\nsolver.add(Sum([assign[(d, w)] for d in dorms for w in wings]) == 3)\n\n# Richards North and Tuscarora North are assigned females\nsolver.add(assign[('Richards', 'North')] == 0)\nsolver.add(assign[('Tuscarora', 'North')] == 0)\n\n# If a dorm has males assigned to one wing, then the other wing is females\nfor d in dorms:\n    male_north = assign[(d, 'North')] == 1\n    male_south = assign[(d, 'South')] == 1\n    # If North is male, South is female\n    solver.add(Implies(male_north, assign[(d, 'South')] == 0))\n    # If South is male, North is female\n    solver.add(Implies(male_south, assign[(d, 'North')] == 0))\n\n# If males are assigned to Veblen South, then Wisteria North is assigned males\nsolver.add(Implies(assign[('Veblen', 'South')] == 1, assign[('Wisteria', 'North')] == 1))\n\n# OPTION CHECKING\n# We want to find which option must be female if Wisteria North is female\n\noptions = [\n    ('Richards', 'South'),\n    ('Wisteria', 'South'),\n    ('Tuscarora', 'South'),\n    ('Veblen', 'South'),\n    ('Veblen', 'North'),\n]\n\nfor i, (d_opt, w_opt) in enumerate(options):\n    solver.push()\n    # Add the condition that Wisteria North is female\n    solver.add(assign[('Wisteria', 'North')] == 0)\n    # Check if it's possible that the option wing is male (not female)\n    solver.add(assign[(d_opt, w_opt)] == 1)\n    if solver.check() == unsat:\n        # If unsat, then that wing must be female\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A school has exactly four dormitories that are to be fully occupied—Richards, Tuscarora, Veblen, and Wisteria—each consisting entirely of a North wing and a South wing. The following rules govern assignment of students to dormitory wings: Each wing is assigned only male students or only female students. Exactly three wings have males assigned to them. Richards North and Tuscarora North are assigned females. If a dormitory has males assigned to one of its wings, then its other wing is assigned females. If males are assigned to Veblen South, then Wisteria North is assigned males.\n\nIf males are assigned to Veblen South, which one of the following is a complete and accurate list of the wings that CANNOT be assigned males?\n\nOptions:\n(A) Richards North, Tuscarora North\n(B) Richards North, Tuscarora North, Veblen North\n(C) Richards North, Tuscarora North, Wisteria South\n(D) Richards North, Tuscarora North, Veblen North, Wisteria South\n(E) Richards North, Richards South, Tuscarora North, Veblen North, Wisteria South",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndormitories = ['Richards', 'Tuscarora', 'Veblen', 'Wisteria']\nwings = ['North', 'South']\n\n# Create variables for each wing: 1 if males assigned, 0 if females assigned\nassign = {}\nfor dorm in dormitories:\n    for wing in wings:\n        assign[(dorm, wing)] = Int(f'{dorm}_{wing}')\n        \nsolver = Solver()\n\n# Each wing assigned only males (1) or females (0)\nfor dorm in dormitories:\n    for wing in wings:\n        solver.add(Or(assign[(dorm, wing)] == 0, assign[(dorm, wing)] == 1))\n\n# Exactly three wings have males assigned\nsolver.add(Sum([assign[(dorm, wing)] for dorm in dormitories for wing in wings]) == 3)\n\n# Richards North and Tuscarora North are assigned females\nsolver.add(assign[('Richards', 'North')] == 0)\nsolver.add(assign[('Tuscarora', 'North')] == 0)\n\n# If a dormitory has males assigned to one wing, then its other wing is assigned females\nfor dorm in dormitories:\n    north = assign[(dorm, 'North')]\n    south = assign[(dorm, 'South')]\n    # If north is males, south is females: north == 1 -> south == 0\n    solver.add(Implies(north == 1, south == 0))\n    # If south is males, north is females: south == 1 -> north == 0\n    solver.add(Implies(south == 1, north == 0))\n\n# If males assigned to Veblen South, then Wisteria North is males\nsolver.add(Implies(assign[('Veblen', 'South')] == 1, assign[('Wisteria', 'North')] == 1))\n\n# We want to check which wings CANNOT be assigned males if Veblen South is males\n# So add constraint Veblen South = 1\nsolver.add(assign[('Veblen', 'South')] == 1)\n\n# List of wings to check for male assignment possibility\n# Wings that CANNOT be assigned males are those that cannot be 1 in any model satisfying constraints\nwings_to_check = [\n    ('Richards', 'North'),\n    ('Richards', 'South'),\n    ('Tuscarora', 'North'),\n    ('Tuscarora', 'South'),\n    ('Veblen', 'North'),\n    ('Veblen', 'South'),\n    ('Wisteria', 'North'),\n    ('Wisteria', 'South')\n]\n\n# We know Veblen South is males, so it can be males; skip checking it\nwings_to_check.remove(('Veblen', 'South'))\n\ncannot_be_males = []\n\nfor dorm, wing in wings_to_check:\n    solver.push()\n    # Check if this wing can be males (1)\n    solver.add(assign[(dorm, wing)] == 1)\n    if solver.check() == sat:\n        # It can be males, so it is not in cannot_be_males\n        pass\n    else:\n        # Cannot be males\n        cannot_be_males.append(f'{dorm} {wing}')\n    solver.pop()\n\n# Now match cannot_be_males to options\n# Options:\n# (A) Richards North, Tuscarora North\n# (B) Richards North, Tuscarora North, Veblen North\n# (C) Richards North, Tuscarora North, Wisteria South\n# (D) Richards North, Tuscarora North, Veblen North, Wisteria South\n# (E) Richards North, Richards South, Tuscarora North, Veblen North, Wisteria South\n\noptions = {\n    'A': ['Richards North', 'Tuscarora North'],\n    'B': ['Richards North', 'Tuscarora North', 'Veblen North'],\n    'C': ['Richards North', 'Tuscarora North', 'Wisteria South'],\n    'D': ['Richards North', 'Tuscarora North', 'Veblen North', 'Wisteria South'],\n    'E': ['Richards North', 'Richards South', 'Tuscarora North', 'Veblen North', 'Wisteria South']\n}\n\nfor letter, wings_list in options.items():\n    # Check if cannot_be_males matches exactly the wings_list (order doesn't matter)\n    if sorted(cannot_be_males) == sorted(wings_list):\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A school has exactly four dormitories that are to be fully occupied—Richards, Tuscarora, Veblen, and Wisteria—each consisting entirely of a North wing and a South wing. The following rules govern assignment of students to dormitory wings: Each wing is assigned only male students or only female students. Exactly three wings have males assigned to them. Richards North and Tuscarora North are assigned females. If a dormitory has males assigned to one of its wings, then its other wing is assigned females. If males are assigned to Veblen South, then Wisteria North is assigned males.\n\nIf Tuscarora South is assigned females, then it could be true that females are assigned to both\n\nOptions:\n(A) Richards South and Wisteria North\n(B) Richards South and Wisteria South\n(C) Veblen North and Wisteria North\n(D) Veblen South and Wisteria South\n(E) Veblen South and Veblen North",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ndorms = ['Richards', 'Tuscarora', 'Veblen', 'Wisteria']\nwings = ['North', 'South']\n\n# Create variables: 1 for male, 0 for female\nassign = {}\nfor d in dorms:\n    for w in wings:\n        assign[(d, w)] = Int(f\"{d}_{w}\")\n\nsolver = Solver()\n\n# Each wing assigned 0 (female) or 1 (male)\nfor d in dorms:\n    for w in wings:\n        solver.add(Or(assign[(d, w)] == 0, assign[(d, w)] == 1))\n\n# Exactly three wings have males assigned\nsolver.add(Sum([assign[(d, w)] for d in dorms for w in wings]) == 3)\n\n# Richards North and Tuscarora North are assigned females\nsolver.add(assign[('Richards', 'North')] == 0)\nsolver.add(assign[('Tuscarora', 'North')] == 0)\n\n# If a dorm has males assigned to one wing, then the other wing is females\nfor d in dorms:\n    male_north = assign[(d, 'North')] == 1\n    male_south = assign[(d, 'South')] == 1\n    # If North is male, South is female\n    solver.add(Implies(male_north, assign[(d, 'South')] == 0))\n    # If South is male, North is female\n    solver.add(Implies(male_south, assign[(d, 'North')] == 0))\n\n# If males are assigned to Veblen South, then Wisteria North is males\nsolver.add(Implies(assign[('Veblen', 'South')] == 1, assign[('Wisteria', 'North')] == 1))\n\n# Tuscarora South is assigned females (condition for the question)\nsolver.add(assign[('Tuscarora', 'South')] == 0)\n\n# OPTION CHECKING\noptions = {\n    'A': [('Richards', 'South'), ('Wisteria', 'North')],\n    'B': [('Richards', 'South'), ('Wisteria', 'South')],\n    'C': [('Veblen', 'North'), ('Wisteria', 'North')],\n    'D': [('Veblen', 'South'), ('Wisteria', 'South')],\n    'E': [('Veblen', 'South'), ('Veblen', 'North')],\n}\n\nfor opt in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add constraint that both wings in option have females (0)\n    solver.add(assign[options[opt][0]] == 0)\n    solver.add(assign[options[opt][1]] == 0)\n    if solver.check() == sat:\n        print(f\"'{opt}'\")\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "In a single day, exactly seven trucks—S, T, U, W, X, Y, and Z—are the only arrivals at a warehouse. No truck arrives at the same time as any other truck, and no truck arrives more than once that day. Each truck is either green or red (but not both). The following conditions apply: No two consecutive arrivals are red. Y arrives at some time before both T and W. Exactly two of the trucks that arrive before Y are red. S is the sixth arrival. Z arrives at some time before U.\n\nWhich one of the following could be the order, from first to last, in which the trucks arrive?\n\nOptions:\n(A) X, Z, U, Y, W, S, T\n(B) X, Y, Z, U, W, S, T\n(C) Z, W, U, T, Y, S, X\n(D) Z, U, T, Y, W, S, X\n(E) U, Z, Y, T, S, W, X",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrucks = ['S', 'T', 'U', 'W', 'X', 'Y', 'Z']\nn = len(trucks)\n\n# Create Int variables for arrival positions (1-based)\narrivals = {t: Int(t) for t in trucks}\n\n# Create Bool variables for color: True = Red, False = Green\ncolors = {t: Bool(f\"{t}_red\") for t in trucks}\n\n# Positions range from 1 to 7\npos_range = [And(arrivals[t] >= 1, arrivals[t] <= n) for t in trucks]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each truck arrives exactly once, so all positions are distinct\nsolver.add(pos_range)\nsolver.add(Distinct([arrivals[t] for t in trucks]))\n\n# S is the sixth arrival\nsolver.add(arrivals['S'] == 6)\n\n# No two consecutive arrivals are red\n# We need to enforce that for all positions i in 1..6,\n# the truck arriving at i and the truck arriving at i+1 cannot both be red.\n\n# To do this, create an array mapping position to truck:\n# We will create an array arrival_pos[1..7] = truck index (0..6)\n# But since Z3 does not support arrays of Int to string, we create helper variables\n\n# Create 7 Int variables pos_to_truck[i] = index of truck arriving at position i (0..6)\ntruck_indices = {t: i for i, t in enumerate(trucks)}\npos_to_truck = [Int(f\"pos_{i+1}\") for i in range(n)]\n\n# Link pos_to_truck and arrivals: for each truck t, arrivals[t] == i+1 <=> pos_to_truck[i] == truck_indices[t]\nfor i in range(n):\n    # For each position i+1, pos_to_truck[i] must be one of truck indices\n    solver.add(And(pos_to_truck[i] >= 0, pos_to_truck[i] < n))\n\nfor t in trucks:\n    # arrivals[t] in 1..7\n    # For each position i, pos_to_truck[i] == truck_indices[t] iff arrivals[t] == i+1\n    for i in range(n):\n        solver.add(Implies(arrivals[t] == i+1, pos_to_truck[i] == truck_indices[t]))\n        solver.add(Implies(pos_to_truck[i] == truck_indices[t], arrivals[t] == i+1))\n\n# pos_to_truck must be distinct\nsolver.add(Distinct(pos_to_truck))\n\n# No two consecutive arrivals are red:\n# For positions i=1..6, colors of trucks at pos i and pos i+1 cannot both be red\nfor i in range(n-1):\n    t1 = pos_to_truck[i]\n    t2 = pos_to_truck[i+1]\n    # We need to express: not (colors[t1] and colors[t2])\n    # Since t1 and t2 are Int variables, use a helper function to get color by index\n\ndef color_by_index(idx):\n    # Return the Bool color variable corresponding to truck index idx\n    # Since idx is a Z3 Int variable, we use If expressions\n    conds = []\n    for t, ix in truck_indices.items():\n        conds.append((idx == ix, colors[t]))\n    # Build nested If\n    expr = False\n    for cond, col in reversed(conds):\n        expr = If(cond, col, expr)\n    return expr\n\nfor i in range(n-1):\n    c1 = color_by_index(pos_to_truck[i])\n    c2 = color_by_index(pos_to_truck[i+1])\n    solver.add(Not(And(c1, c2)))\n\n# Y arrives before both T and W\nsolver.add(arrivals['Y'] < arrivals['T'])\nsolver.add(arrivals['Y'] < arrivals['W'])\n\n# Exactly two of the trucks that arrive before Y are red\n# Find trucks that arrive before Y: arrivals[t] < arrivals[Y]\n# Count how many of these are red == 2\n\n# Create list of Bool variables: arrives_before_Y[t] = Bool indicating if t arrives before Y\narrives_before_Y = {t: Bool(f\"{t}_before_Y\") for t in trucks}\n\nfor t in trucks:\n    solver.add(arrives_before_Y[t] == (arrivals[t] < arrivals['Y']))\n\n# Count how many of these arrive_before_Y trucks are red\nreds_before_Y = []\nfor t in trucks:\n    # Only count if arrive before Y\n    reds_before_Y.append(And(arrives_before_Y[t], colors[t]))\n\nsolver.add(Sum([If(cond, 1, 0) for cond in reds_before_Y]) == 2)\n\n# Z arrives before U\nsolver.add(arrivals['Z'] < arrivals['U'])\n\n# OPTION CHECKING\noptions = [\n    ['X', 'Z', 'U', 'Y', 'W', 'S', 'T'],  # A\n    ['X', 'Y', 'Z', 'U', 'W', 'S', 'T'],  # B\n    ['Z', 'W', 'U', 'T', 'Y', 'S', 'X'],  # C\n    ['Z', 'U', 'T', 'Y', 'W', 'S', 'X'],  # D\n    ['U', 'Z', 'Y', 'T', 'S', 'W', 'X']   # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that arrivals match the option order\n    # position 1..7 matches option[i]\n    for pos, t in enumerate(option, start=1):\n        solver.add(arrivals[t] == pos)\n    # Check if satisfiable\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "In a single day, exactly seven trucks—S, T, U, W, X, Y, and Z—are the only arrivals at a warehouse. No truck arrives at the same time as any other truck, and no truck arrives more than once that day. Each truck is either green or red (but not both). The following conditions apply: No two consecutive arrivals are red. Y arrives at some time before both T and W. Exactly two of the trucks that arrive before Y are red. S is the sixth arrival. Z arrives at some time before U.\n\nIf X is the third arrival, then which one of the following trucks must be green?\n\nOptions:\n(A) S\n(B) T\n(C) U\n(D) W\n(E) Z",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrucks = ['S', 'T', 'U', 'W', 'X', 'Y', 'Z']\npositions = {t: Int(t) for t in trucks}  # Position of each truck in arrival order (1 to 7)\ncolors = {t: Int(f\"{t}_color\") for t in trucks}  # 0 = green, 1 = red\n\nsolver = Solver()\n\n# Each truck arrives exactly once at a unique position 1 through 7\nfor t in trucks:\n    solver.add(And(positions[t] >= 1, positions[t] <= 7))\nsolver.add(Distinct([positions[t] for t in trucks]))\n\n# Each truck is either green (0) or red (1)\nfor t in trucks:\n    solver.add(Or(colors[t] == 0, colors[t] == 1))\n\n# CONSTRAINTS\n\n# 1. No two consecutive arrivals are red\n# For all positions from 1 to 6, the trucks arriving at pos and pos+1 cannot both be red\n# We need to relate positions to trucks, so create an array mapping position to truck index\n# Create position_to_truck: an array of size 7 where position_to_truck[pos-1] = truck at pos\n# Implemented by adding constraints that for each position, exactly one truck is at that position\n\n# We create a list of Int variables pos_index from 0 to 6 representing positions 1 to 7\n# But we already have positions[t] for each truck, so we can reason with them\n\n# For each position from 1 to 6, find trucks at pos and pos+1 and ensure not both red\n# We do this by creating conditions over all pairs of trucks whose positions differ by 1\n\nfor pos in range(1, 7):\n    # For each pair of trucks (t1, t2), if positions[t1] == pos and positions[t2] == pos+1, then not both red\n    conds = []\n    for t1 in trucks:\n        for t2 in trucks:\n            if t1 != t2:\n                cond = And(positions[t1] == pos, positions[t2] == pos + 1)\n                conds.append(cond)\n    # If any cond in conds is true, then colors[t1] and colors[t2] not both red\n    # We encode: For all pairs (t1,t2) with positions[t1]==pos and positions[t2]==pos+1:\n    # not (colors[t1] == 1 and colors[t2] == 1)\n    # This is equivalent to: For all t1,t2, (positions[t1]==pos and positions[t2]==pos+1) => Not both red\n    # So for all t1,t2:\n    # (positions[t1]==pos and positions[t2]==pos+1) => Not (colors[t1]==1 and colors[t2]==1)\n    # We add these constraints for all pairs\n\nfor pos in range(1, 7):\n    for t1 in trucks:\n        for t2 in trucks:\n            if t1 != t2:\n                solver.add(Implies(And(positions[t1] == pos, positions[t2] == pos + 1),\n                                   Or(colors[t1] == 0, colors[t2] == 0)))\n\n# 2. Y arrives at some time before both T and W\nsolver.add(positions['Y'] < positions['T'])\nsolver.add(positions['Y'] < positions['W'])\n\n# 3. Exactly two of the trucks that arrive before Y are red\n# Find trucks with position less than positions['Y'], count how many are red, equals 2\n# We create a list of Bool variables is_before_Y_red for each truck\nis_before_Y_red = []\nfor t in trucks:\n    is_before = Bool(f\"{t}_before_Y\")\n    solver.add(is_before == (positions[t] < positions['Y']))\n    is_red = Bool(f\"{t}_is_red\")\n    solver.add(is_red == (colors[t] == 1))\n    is_before_red = Bool(f\"{t}_before_Y_red\")\n    solver.add(is_before_red == And(is_before, is_red))\n    is_before_Y_red.append(is_before_red)\nsolver.add(Sum([If(b, 1, 0) for b in is_before_Y_red]) == 2)\n\n# 4. S is the sixth arrival\nsolver.add(positions['S'] == 6)\n\n# 5. Z arrives at some time before U\nsolver.add(positions['Z'] < positions['U'])\n\n# OPTION CHECKING\n# We are given: X is the third arrival\nsolver.add(positions['X'] == 3)\n\noptions = ['S', 'T', 'U', 'W', 'Z']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Check if opt can be red (1)\n    solver.add(colors[opt] == 1)\n    if solver.check() == unsat:\n        # If unsat, opt cannot be red, so must be green\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "In a single day, exactly seven trucks—S, T, U, W, X, Y, and Z—are the only arrivals at a warehouse. No truck arrives at the same time as any other truck, and no truck arrives more than once that day. Each truck is either green or red (but not both). The following conditions apply: No two consecutive arrivals are red. Y arrives at some time before both T and W. Exactly two of the trucks that arrive before Y are red. S is the sixth arrival. Z arrives at some time before U.\n\nWhich one of the following pairs of trucks CANNOT arrive consecutively at the warehouse?\n\nOptions:\n(A) U and Y\n(B) X and Y\n(C) Y and T\n(D) Y and W\n(E) Y and Z",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntrucks = ['S', 'T', 'U', 'W', 'X', 'Y', 'Z']\nnum_trucks = len(trucks)\n\n# Map truck names to indices for easy reference\ntruck_indices = {truck: i for i, truck in enumerate(trucks)}\n\n# Arrival positions: integer variables from 1 to 7 (1-based indexing)\narrival_pos = {truck: Int(f'arr_{truck}') for truck in trucks}\n\n# Color: 0 for green, 1 for red\ncolor = {truck: Int(f'color_{truck}') for truck in trucks}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each truck arrives exactly once at a unique time from 1 to 7\nfor truck in trucks:\n    solver.add(And(arrival_pos[truck] >= 1, arrival_pos[truck] <= 7))\nsolver.add(Distinct([arrival_pos[truck] for truck in trucks]))\n\n# 2) Each truck is either green (0) or red (1)\nfor truck in trucks:\n    solver.add(Or(color[truck] == 0, color[truck] == 1))\n\n# 3) No two consecutive arrivals are red\n# For positions 1 to 6, the trucks arriving at positions i and i+1 cannot both be red\n# We will create an array pos_to_truck to get which truck arrives at position i\n\n# Create auxiliary array: pos_to_truck[i] = truck at arrival position i+1 (0-based index)\n# We can create 7 integer variables pos_to_truck[0..6] each representing truck index 0..6\npos_to_truck = [Int(f'pos_{i+1}') for i in range(num_trucks)]\nfor i in range(num_trucks):\n    solver.add(And(pos_to_truck[i] >= 0, pos_to_truck[i] < num_trucks))\nsolver.add(Distinct(pos_to_truck))\n\n# Link arrival_pos and pos_to_truck\n# For each truck t, arrival_pos[t] = p means pos_to_truck[p-1] = index of t\nfor truck in trucks:\n    idx = truck_indices[truck]\n    # arrival_pos[truck] -1 = position index in pos_to_truck\n    # So pos_to_truck[arrival_pos[truck]-1] == idx\n    # Use element constraint: pos_to_truck[arrival_pos[truck]-1] == idx\n    # Z3 does not support direct array indexing with variable, use helper constraints\n    # We'll use the fact that pos_to_truck is a permutation of 0..6, so:\n    # For all i in 0..6: (arrival_pos[truck] == i+1) => (pos_to_truck[i] == idx)\n    solver.add(Or([And(arrival_pos[truck] == i+1, pos_to_truck[i] == idx) for i in range(num_trucks)]))\n\n# Now add constraint: no two consecutive arrivals are red\nfor i in range(num_trucks - 1):\n    t1 = pos_to_truck[i]\n    t2 = pos_to_truck[i+1]\n    # color[t1] + color[t2] <= 1\n    # But t1 and t2 are Int variables representing truck indices, need to get color of trucks at those indices\n    # We'll create color arrays indexed by truck index for lookup\ncolor_array = [color[truck] for truck in trucks]\n\nfor i in range(num_trucks - 1):\n    # We want: color_array[pos_to_truck[i]] + color_array[pos_to_truck[i+1]] <= 1\n    # Use If expressions to get colors at pos_to_truck[i] and pos_to_truck[i+1]\n    c1 = Sum([If(pos_to_truck[i] == j, color_array[j], 0) for j in range(num_trucks)])\n    c2 = Sum([If(pos_to_truck[i+1] == j, color_array[j], 0) for j in range(num_trucks)])\n    solver.add(c1 + c2 <= 1)\n\n# 4) Y arrives before both T and W\nsolver.add(arrival_pos['Y'] < arrival_pos['T'])\nsolver.add(arrival_pos['Y'] < arrival_pos['W'])\n\n# 5) Exactly two of the trucks that arrive before Y are red\n# Trucks that arrive before Y: those with arrival_pos < arrival_pos['Y']\n# Count how many of them are red, must be exactly 2\n\n# Create boolean variables for each truck: arrives_before_Y[truck] = True if arrival_pos[truck] < arrival_pos['Y']\narrives_before_Y = {truck: Bool(f'beforeY_{truck}') for truck in trucks}\nfor truck in trucks:\n    solver.add(arrives_before_Y[truck] == (arrival_pos[truck] < arrival_pos['Y']))\n\n# Sum of color[truck] for trucks arriving before Y = 2\nreds_before_Y = []\nfor truck in trucks:\n    # If arrives_before_Y[truck] then color[truck], else 0\n    reds_before_Y.append(If(arrives_before_Y[truck], color[truck], 0))\nsolver.add(Sum(reds_before_Y) == 2)\n\n# 6) S is the sixth arrival\nsolver.add(arrival_pos['S'] == 6)\n\n# 7) Z arrives before U\nsolver.add(arrival_pos['Z'] < arrival_pos['U'])\n\n# OPTION CHECKING\noptions = {\n    'A': ('U', 'Y'),\n    'B': ('X', 'Y'),\n    'C': ('Y', 'T'),\n    'D': ('Y', 'W'),\n    'E': ('Y', 'Z'),\n}\n\n# For each option, check if the pair can arrive consecutively in either order\n# That means arrival positions differ by 1 (either first before second or second before first)\n# If no solution exists with that pair consecutive, then that option is the answer\n\nfor letter, (truck1, truck2) in options.items():\n    solver.push()\n    pos1 = arrival_pos[truck1]\n    pos2 = arrival_pos[truck2]\n    # Constraint: abs(pos1 - pos2) == 1\n    solver.add(Or(pos1 + 1 == pos2, pos2 + 1 == pos1))\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        print(f\"'{letter}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.\n\nWhich one of the following could be an accurate matching of the bookshelves to the books on each of them?\n\nOptions:\n(A) first shelf: Hausa grammar second shelf: semantics monograph, Vonnegut novel third shelf: Farsi grammar, phonology monograph, Woolf novel\n(B) first shelf: semantics monograph second shelf: Farsi grammar, Vonnegut novel third shelf: Hausa grammar, phonology monograph, Woolf novel\n(C) first shelf: Vonnegut novel second shelf: phonology monograph, Farsi grammar third shelf: Hausa grammar, semantics monograph, Woolf novel\n(D) first shelf: Woolf novel second shelf: phonology and semantics monographs third shelf: Farsi and Hausa grammars, Vonnegut novel\n(E) first shelf: Woolf novel second shelf: Farsi grammar, Vonnegut novel third shelf: Hausa grammar, phonology and semantics monographs",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbooks = ['Farsi_grammar', 'Hausa_grammar', 'Phonology_monograph', 'Semantics_monograph', 'Vonnegut_novel', 'Woolf_novel']\nshelves = [0, 1, 2]  # 0: first shelf, 1: second shelf, 2: third shelf\n\n# Create a variable for each book representing the shelf it is on\nbook_shelf = {book: Int(book) for book in books}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each book must be on a valid shelf\nfor book in books:\n    solver.add(And(book_shelf[book] >= 0, book_shelf[book] <= 2))\n\n# Shelf capacities:\n# first shelf: 1 book\n# second shelf: 2 books\n# third shelf: 3 books\nfor shelf in shelves:\n    count_on_shelf = Sum([If(book_shelf[book] == shelf, 1, 0) for book in books])\n    if shelf == 0:\n        solver.add(count_on_shelf == 1)\n    elif shelf == 1:\n        solver.add(count_on_shelf == 2)\n    else:\n        solver.add(count_on_shelf == 3)\n\n# There is at least one novel on the same shelf as the Farsi grammar\nfarsi_shelf = book_shelf['Farsi_grammar']\nvonnegut_shelf = book_shelf['Vonnegut_novel']\nwoolf_shelf = book_shelf['Woolf_novel']\nnovel_same_shelf = Or(farsi_shelf == vonnegut_shelf, farsi_shelf == woolf_shelf)\nsolver.add(novel_same_shelf)\n\n# The monographs are not both on the same shelf\nphonology_shelf = book_shelf['Phonology_monograph']\nsemantics_shelf = book_shelf['Semantics_monograph']\nsolver.add(phonology_shelf != semantics_shelf)\n\n# The Vonnegut novel is not on the same shelf as either monograph\nsolver.add(vonnegut_shelf != phonology_shelf)\nsolver.add(vonnegut_shelf != semantics_shelf)\n\n# OPTION CHECKING\n\noptions = [\n    # (A)\n    {\n        'Farsi_grammar': 2,\n        'Hausa_grammar': 0,\n        'Phonology_monograph': 2,\n        'Semantics_monograph': 1,\n        'Vonnegut_novel': 1,\n        'Woolf_novel': 2\n    },\n    # (B)\n    {\n        'Farsi_grammar': 1,\n        'Hausa_grammar': 2,\n        'Phonology_monograph': 2,\n        'Semantics_monograph': 0,\n        'Vonnegut_novel': 1,\n        'Woolf_novel': 2\n    },\n    # (C)\n    {\n        'Farsi_grammar': 1,\n        'Hausa_grammar': 2,\n        'Phonology_monograph': 1,\n        'Semantics_monograph': 2,\n        'Vonnegut_novel': 0,\n        'Woolf_novel': 2\n    },\n    # (D)\n    {\n        'Farsi_grammar': 2,\n        'Hausa_grammar': 2,\n        'Phonology_monograph': 1,\n        'Semantics_monograph': 1,\n        'Vonnegut_novel': 2,\n        'Woolf_novel': 0\n    },\n    # (E)\n    {\n        'Farsi_grammar': 1,\n        'Hausa_grammar': 2,\n        'Phonology_monograph': 2,\n        'Semantics_monograph': 2,\n        'Vonnegut_novel': 1,\n        'Woolf_novel': 0\n    }\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    for book, shelf_num in option.items():\n        solver.add(book_shelf[book] == shelf_num)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.\n\nWhich one of the following CANNOT be true?\n\nOptions:\n(A) A grammar is on the first shelf.\n(B) A linguistics monograph is on the same shelf as the Hausa grammar.\n(C) A novel is on the first shelf.\n(D) The novels are on the same shelf as each other.\n(E) Neither linguistics monograph is on the first shelf.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Shelves: 0 = first shelf (1 book), 1 = second shelf (2 books), 2 = third shelf (3 books)\nshelves = [0, 1, 2]\nbooks = ['Farsi_grammar', 'Hausa_grammar', 'Phonology_monograph', 'Semantics_monograph', 'Vonnegut_novel', 'Woolf_novel']\n\n# Create a variable for each book representing the shelf it is on\nbook_shelf = {b: Int(b) for b in books}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each book is on a valid shelf\nfor b in books:\n    solver.add(And(book_shelf[b] >= 0, book_shelf[b] <= 2))\n\n# Shelf capacity constraints\n# Count how many books on each shelf must match the shelf capacity\nfor shelf in shelves:\n    count_on_shelf = Sum([If(book_shelf[b] == shelf, 1, 0) for b in books])\n    if shelf == 0:\n        solver.add(count_on_shelf == 1)\n    elif shelf == 1:\n        solver.add(count_on_shelf == 2)\n    else:\n        solver.add(count_on_shelf == 3)\n\n# There is at least one novel on the same shelf as the Farsi grammar\nfarsi_shelf = book_shelf['Farsi_grammar']\nvonnegut_shelf = book_shelf['Vonnegut_novel']\nwoolf_shelf = book_shelf['Woolf_novel']\n\nnovel_same_shelf_as_farsi = Or([vonnegut_shelf == farsi_shelf, woolf_shelf == farsi_shelf])\nsolver.add(novel_same_shelf_as_farsi)\n\n# The monographs are not both on the same shelf\nphonology_shelf = book_shelf['Phonology_monograph']\nsemantics_shelf = book_shelf['Semantics_monograph']\nsolver.add(phonology_shelf != semantics_shelf)\n\n# The Vonnegut novel is not on the same shelf as either monograph\nsolver.add(vonnegut_shelf != phonology_shelf)\nsolver.add(vonnegut_shelf != semantics_shelf)\n\n# OPTION CHECKING\noptions = [\n    # (A) A grammar is on the first shelf.\n    Or(book_shelf['Farsi_grammar'] == 0, book_shelf['Hausa_grammar'] == 0),\n\n    # (B) A linguistics monograph is on the same shelf as the Hausa grammar.\n    Or(phonology_shelf == book_shelf['Hausa_grammar'], semantics_shelf == book_shelf['Hausa_grammar']),\n\n    # (C) A novel is on the first shelf.\n    Or(vonnegut_shelf == 0, woolf_shelf == 0),\n\n    # (D) The novels are on the same shelf as each other.\n    vonnegut_shelf == woolf_shelf,\n\n    # (E) Neither linguistics monograph is on the first shelf.\n    And(phonology_shelf != 0, semantics_shelf != 0)\n]\n\n# We want to find which option CANNOT be true, i.e., adding the option as a constraint makes the problem unsatisfiable.\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.\n\nWhich one of the following must be true?\n\nOptions:\n(A) A linguistics monograph and a grammar are on the second shelf.\n(B) A novel and a grammar are on the second shelf.\n(C) At least one linguistics monograph and at least one grammar are on the third shelf.\n(D) At least one novel and at least one grammar are on the third shelf.\n(E) At least one novel and at least one linguistics monograph are on the third shelf.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n\n# Books\nbooks = ['Farsi_Grammar', 'Hausa_Grammar',\n         'Phonology_Monograph', 'Semantics_Monograph',\n         'Vonnegut_Novel', 'Woolf_Novel']\n\n# Shelves indices\nshelves = [0, 1, 2]  # 0: first shelf, 1: second shelf, 2: third shelf\n\n# Categories for convenience\ngrammars = ['Farsi_Grammar', 'Hausa_Grammar']\nmonographs = ['Phonology_Monograph', 'Semantics_Monograph']\nnovels = ['Vonnegut_Novel', 'Woolf_Novel']\n\n# Number of books per shelf\nbooks_per_shelf = [1, 2, 3]\n\n# Create Z3 Int variables for each book's shelf assignment\nbook_shelf = {}\nfor b in books:\n    book_shelf[b] = Int(b)\n    \n# CONSTRAINTS\n\nsolver = Solver()\n\n# Each book is assigned to a valid shelf index\nfor b in books:\n    solver.add(And(book_shelf[b] >= 0, book_shelf[b] <= 2))\n\n# The number of books on each shelf must be as specified\nfor shelf in shelves:\n    count_on_shelf = Sum([If(book_shelf[b] == shelf, 1, 0) for b in books])\n    solver.add(count_on_shelf == books_per_shelf[shelf])\n\n# Constraint 1: There is at least one novel on the same shelf as the Farsi grammar\nfarsi_shelf = book_shelf['Farsi_Grammar']\nnovel_same_shelf = Or([book_shelf[novel] == farsi_shelf for novel in novels])\nsolver.add(novel_same_shelf)\n\n# Constraint 2: The monographs are not both on the same shelf\nsolver.add(book_shelf['Phonology_Monograph'] != book_shelf['Semantics_Monograph'])\n\n# Constraint 3: The Vonnegut novel is not on the same shelf as either monograph\nvonnegut_shelf = book_shelf['Vonnegut_Novel']\nsolver.add(vonnegut_shelf != book_shelf['Phonology_Monograph'])\nsolver.add(vonnegut_shelf != book_shelf['Semantics_Monograph'])\n\n# OPTION CHECKING\n\noptions = [\n    # (A) A linguistics monograph and a grammar are on the second shelf.\n    And(\n        Or([book_shelf[m] == 1 for m in monographs]),\n        Or([book_shelf[g] == 1 for g in grammars])\n    ),\n    # (B) A novel and a grammar are on the second shelf.\n    And(\n        Or([book_shelf[n] == 1 for n in novels]),\n        Or([book_shelf[g] == 1 for g in grammars])\n    ),\n    # (C) At least one linguistics monograph and at least one grammar are on the third shelf.\n    And(\n        Or([book_shelf[m] == 2 for m in monographs]),\n        Or([book_shelf[g] == 2 for g in grammars])\n    ),\n    # (D) At least one novel and at least one grammar are on the third shelf.\n    And(\n        Or([book_shelf[n] == 2 for n in novels]),\n        Or([book_shelf[g] == 2 for g in grammars])\n    ),\n    # (E) At least one novel and at least one linguistics monograph are on the third shelf.\n    And(\n        Or([book_shelf[n] == 2 for n in novels]),\n        Or([book_shelf[m] == 2 for m in monographs])\n    )\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add negation of option to check if option must be true\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.\n\nIf both grammars are on the same shelf, which one of the following could be true?\n\nOptions:\n(A) The phonology monograph is on the third shelf.\n(B) A novel is on the first shelf.\n(C) Both novels are on the second shelf.\n(D) The Farsi grammar is on the second shelf.\n(E) The phonology monograph is on the first shelf.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Shelves: 0 (first), 1 (second), 2 (third)\nshelves = [0, 1, 2]\n\n# Books:\nbooks = [\n    'Farsi_grammar',    # 0\n    'Hausa_grammar',    # 1\n    'Phonology_monograph',  # 2\n    'Semantics_monograph',  # 3\n    'Vonnegut_novel',       # 4\n    'Woolf_novel'           # 5\n]\n\n# Create Z3 Int variables for shelf assignments\nbook_shelf = {}\nfor b in books:\n    book_shelf[b] = Int(b)\n    \n# Number of books on each shelf\nbooks_per_shelf = {0:1, 1:2, 2:3}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each book must be on a valid shelf\nfor b in books:\n    solver.add(And(book_shelf[b] >= 0, book_shelf[b] <= 2))\n\n# The number of books on each shelf must match the given counts\nfor shelf in shelves:\n    count_on_shelf = Sum([If(book_shelf[b] == shelf, 1, 0) for b in books])\n    solver.add(count_on_shelf == books_per_shelf[shelf])\n\n# Given conditions:\n\n# 1) There is at least one novel on the same shelf as the Farsi grammar.\nfarsi_shelf = book_shelf['Farsi_grammar']\nvonnegut_shelf = book_shelf['Vonnegut_novel']\nwoolf_shelf = book_shelf['Woolf_novel']\n\nnovel_same_shelf_as_farsi = Or(farsi_shelf == vonnegut_shelf, farsi_shelf == woolf_shelf)\nsolver.add(novel_same_shelf_as_farsi)\n\n# 2) The monographs are not both on the same shelf.\nphonology_shelf = book_shelf['Phonology_monograph']\nsemantics_shelf = book_shelf['Semantics_monograph']\nsolver.add(phonology_shelf != semantics_shelf)\n\n# 3) The Vonnegut novel is not on the same shelf as either monograph.\nsolver.add(vonnegut_shelf != phonology_shelf)\nsolver.add(vonnegut_shelf != semantics_shelf)\n\n# Additional condition for the question:\n# Both grammars are on the same shelf.\nsolver.add(book_shelf['Farsi_grammar'] == book_shelf['Hausa_grammar'])\n\n# OPTION CHECKING\noptions = {\n    'A': book_shelf['Phonology_monograph'] == 2,  # third shelf\n    'B': Or([book_shelf[novel] == 0 for novel in ['Vonnegut_novel', 'Woolf_novel']]),  # novel on first shelf\n    'C': And(book_shelf['Vonnegut_novel'] == 1, book_shelf['Woolf_novel'] == 1),  # both novels on second shelf\n    'D': book_shelf['Farsi_grammar'] == 1,  # Farsi grammar on second shelf\n    'E': book_shelf['Phonology_monograph'] == 0  # phonology monograph on first shelf\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.\n\nWhich one of the following must be true?\n\nOptions:\n(A) A linguistics monograph is on the first shelf.\n(B) No more than one novel is on each shelf.\n(C) The Farsi grammar is not on the same shelf as the Hausa grammar.\n(D) The semantics monograph is not on the same shelf as the Woolf novel.\n(E) The Woolf novel is not on the first shelf.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbooks = ['Farsi_grammar', 'Hausa_grammar', 'Phonology_monograph', 'Semantics_monograph', 'Vonnegut_novel', 'Woolf_novel']\nshelves = [0, 1, 2]  # 0: first shelf (1 book), 1: second shelf (2 books), 2: third shelf (3 books)\n\n# Create Z3 Int variables for each book representing the shelf it is on\nbook_shelf = {b: Int(b) for b in books}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each book is on a valid shelf\nfor b in books:\n    solver.add(And(book_shelf[b] >= 0, book_shelf[b] <= 2))\n\n# Shelf capacity constraints\n# Count books on each shelf\nfor sh in shelves:\n    count_books_on_shelf = Sum([If(book_shelf[b] == sh, 1, 0) for b in books])\n    if sh == 0:\n        solver.add(count_books_on_shelf == 1)\n    elif sh == 1:\n        solver.add(count_books_on_shelf == 2)\n    else:\n        solver.add(count_books_on_shelf == 3)\n\n# Constraint 1: There is at least one novel on the same shelf as the Farsi grammar\n# Novels: Vonnegut_novel, Woolf_novel\nfarsi_shelf = book_shelf['Farsi_grammar']\nnovel1_shelf = book_shelf['Vonnegut_novel']\nnovel2_shelf = book_shelf['Woolf_novel']\nnovel_same_shelf_as_farsi = Or([novel1_shelf == farsi_shelf, novel2_shelf == farsi_shelf])\nsolver.add(novel_same_shelf_as_farsi)\n\n# Constraint 2: The monographs are not both on the same shelf\n# Monographs: Phonology_monograph, Semantics_monograph\nphonology_shelf = book_shelf['Phonology_monograph']\nsemantics_shelf = book_shelf['Semantics_monograph']\nsolver.add(phonology_shelf != semantics_shelf)\n\n# Constraint 3: The Vonnegut novel is not on the same shelf as either monograph\nsolver.add(novel1_shelf != phonology_shelf)\nsolver.add(novel1_shelf != semantics_shelf)\n\n# OPTION CHECKING\n\n# Define options as functions that add the option's statement as a constraint and check satisfiability\n\ndef check_option_A():\n    # (A) A linguistics monograph is on the first shelf (shelf 0)\n    # So either phonology or semantics is on shelf 0\n    return Or([phonology_shelf == 0, semantics_shelf == 0])\n\ndef check_option_B():\n    # (B) No more than one novel is on each shelf\n    # Check for each shelf that the number of novels on that shelf <= 1\n    conds = []\n    for sh in shelves:\n        count_novels = Sum([If(book_shelf[b] == sh, 1, 0) for b in ['Vonnegut_novel', 'Woolf_novel']])\n        conds.append(count_novels <= 1)\n    return And(conds)\n\ndef check_option_C():\n    # (C) The Farsi grammar is not on the same shelf as the Hausa grammar\n    return book_shelf['Farsi_grammar'] != book_shelf['Hausa_grammar']\n\ndef check_option_D():\n    # (D) The semantics monograph is not on the same shelf as the Woolf novel\n    return book_shelf['Semantics_monograph'] != book_shelf['Woolf_novel']\n\ndef check_option_E():\n    # (E) The Woolf novel is not on the first shelf\n    return book_shelf['Woolf_novel'] != 0\n\noptions = [check_option_A, check_option_B, check_option_C, check_option_D, check_option_E]\n\nfor i, option_func in enumerate(options):\n    solver.push()\n    # Add the negation of the option to see if it can be false\n    solver.add(Not(option_func()))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true in all solutions\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.\n\nIf the Farsi grammar is not on the third shelf, which one of the following could be true?\n\nOptions:\n(A) The phonology monograph is on the second shelf.\n(B) The Hausa grammar is on the second shelf.\n(C) The semantics monograph is on the third shelf.\n(D) The Vonnegut novel is on the third shelf.\n(E) The Woolf novel is on the second shelf.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nshelves = [0, 1, 2]  # 0: first shelf, 1: second shelf, 2: third shelf\n\nbooks = ['Farsi', 'Hausa', 'Phonology', 'Semantics', 'Vonnegut', 'Woolf']\n\n# Create Z3 Int variables for each book representing the shelf index\nbook_shelf = {b: Int(b) for b in books}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each book is on a valid shelf\nfor b in books:\n    solver.add(And(book_shelf[b] >= 0, book_shelf[b] <= 2))\n\n# Shelf 0 has exactly 1 book\ncount_shelf0 = Sum([If(book_shelf[b] == 0, 1, 0) for b in books])\nsolver.add(count_shelf0 == 1)\n\n# Shelf 1 has exactly 2 books\ncount_shelf1 = Sum([If(book_shelf[b] == 1, 1, 0) for b in books])\nsolver.add(count_shelf1 == 2)\n\n# Shelf 2 has exactly 3 books\ncount_shelf2 = Sum([If(book_shelf[b] == 2, 1, 0) for b in books])\nsolver.add(count_shelf2 == 3)\n\n# There is at least one novel on the same shelf as the Farsi grammar\n# Novels are Vonnegut and Woolf\nnovels = ['Vonnegut', 'Woolf']\nfarsi_shelf = book_shelf['Farsi']\nnovel_on_farsi_shelf = Or([book_shelf[n] == farsi_shelf for n in novels])\nsolver.add(novel_on_farsi_shelf)\n\n# The monographs are not both on the same shelf\n# Monographs: Phonology, Semantics\nsolver.add(book_shelf['Phonology'] != book_shelf['Semantics'])\n\n# The Vonnegut novel is not on the same shelf as either monograph\nsolver.add(book_shelf['Vonnegut'] != book_shelf['Phonology'])\nsolver.add(book_shelf['Vonnegut'] != book_shelf['Semantics'])\n\n# The Farsi grammar is NOT on the third shelf (shelf 2)\nsolver.add(book_shelf['Farsi'] != 2)\n\n# OPTION CHECKING\noptions = [\n    ('A', book_shelf['Phonology'] == 1),\n    ('B', book_shelf['Hausa'] == 1),\n    ('C', book_shelf['Semantics'] == 2),\n    ('D', book_shelf['Vonnegut'] == 2),\n    ('E', book_shelf['Woolf'] == 1)\n]\n\nfor letter, option_constraint in options:\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A total of six books occupies three small shelves—one on the first shelf, two on the second shelf, and three on the third shelf. Two of the books are grammars—one of Farsi, the other of Hausa. Two others are linguistics monographs—one on phonology, the other on semantics. The remaining two books are novels—one by Vonnegut, the other by Woolf. The books' arrangement is consistent with the following: There is at least one novel on the same shelf as the Farsi grammar. The monographs are not both on the same shelf. The Vonnegut novel is not on the same shelf as either monograph.\n\nIf the Hausa grammar and the phonology monograph are on the same shelf, which one of the following must be true?\n\nOptions:\n(A) The phonology monograph is on the third shelf.\n(B) The Vonnegut novel is on the second shelf.\n(C) The semantics monograph is on the second shelf.\n(D) The semantics monograph is on the first shelf.\n(E) The Woolf novel is on the third shelf.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nbooks = ['Farsi_grammar', 'Hausa_grammar', 'Phonology_monograph', 'Semantics_monograph', 'Vonnegut_novel', 'Woolf_novel']\nshelves = [0, 1, 2]  # shelf indices: 0 = first shelf, 1 = second shelf, 2 = third shelf\n\n# Create Z3 Int variables for each book's shelf assignment\nbook_shelf = {b: Int(b) for b in books}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each book must be assigned to a valid shelf\nfor b in books:\n    solver.add(And(book_shelf[b] >= 0, book_shelf[b] <= 2))\n\n# Shelf capacities:\n# first shelf has exactly 1 book\n# second shelf has exactly 2 books\n# third shelf has exactly 3 books\nfor shelf in shelves:\n    count_on_shelf = Sum([If(book_shelf[b] == shelf, 1, 0) for b in books])\n    if shelf == 0:\n        solver.add(count_on_shelf == 1)\n    elif shelf == 1:\n        solver.add(count_on_shelf == 2)\n    else:\n        solver.add(count_on_shelf == 3)\n\n# There is at least one novel on the same shelf as the Farsi grammar\nfarsi_shelf = book_shelf['Farsi_grammar']\nvonnegut_shelf = book_shelf['Vonnegut_novel']\nwoolf_shelf = book_shelf['Woolf_novel']\nnovel_on_farsi_shelf = Or(farsi_shelf == vonnegut_shelf, farsi_shelf == woolf_shelf)\nsolver.add(novel_on_farsi_shelf)\n\n# The monographs are not both on the same shelf\nsolver.add(book_shelf['Phonology_monograph'] != book_shelf['Semantics_monograph'])\n\n# The Vonnegut novel is not on the same shelf as either monograph\nsolver.add(vonnegut_shelf != book_shelf['Phonology_monograph'])\nsolver.add(vonnegut_shelf != book_shelf['Semantics_monograph'])\n\n# Given condition for the question:\n# Hausa grammar and phonology monograph are on the same shelf\nsolver.add(book_shelf['Hausa_grammar'] == book_shelf['Phonology_monograph'])\n\n# OPTION CHECKING\noptions = [\n    # (A) The phonology monograph is on the third shelf.\n    book_shelf['Phonology_monograph'] == 2,\n    # (B) The Vonnegut novel is on the second shelf.\n    vonnegut_shelf == 1,\n    # (C) The semantics monograph is on the second shelf.\n    book_shelf['Semantics_monograph'] == 1,\n    # (D) The semantics monograph is on the first shelf.\n    book_shelf['Semantics_monograph'] == 0,\n    # (E) The Woolf novel is on the third shelf.\n    woolf_shelf == 2\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Check if the negation of the option is possible\n    solver.add(Not(option))\n    if solver.check() == unsat:\n        # If negation is unsat, option must be true in all models\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A swim team with exactly five members—Jacobson, Kruger, Lu, Miller, Ortiz—swims a ten-lap relay race. Each team member swims exactly two of the laps: one swims laps 1 and 6, one swims laps 2 and 7, one swims laps 3 and 8, one swims laps 4 and 9, and one swims laps 5 and 10. The following conditions apply: Neither of Kruger's laps is immediately before either of Lu's. Jacobson does not swim lap 9. Ortiz's first lap is after (but not necessarily immediately after) Miller's. At least one of Jacobson's laps is immediately after one of Ortiz's laps.\n\nWhich one of the following could be an accurate list of the swimmers of the first five laps, in order from lap 1 through lap 5?\n\nOptions:\n(A) Jacobson, Kruger, Miller, Lu, Ortiz\n(B) Kruger, Miller, Ortiz, Jacobson, Lu\n(C) Lu, Miller, Jacobson, Kruger, Ortiz\n(D) Ortiz, Kruger, Miller, Lu, Jacobson\n(E) Miller, Ortiz, Jacobson, Kruger, Lu",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nswimmers = ['Jacobson', 'Kruger', 'Lu', 'Miller', 'Ortiz']\nlaps = list(range(1, 11))  # laps 1 to 10\n\n# Map swimmers to indices for Z3 variables\nswimmer_idx = {s: i for i, s in enumerate(swimmers)}\n\n# Each lap is assigned a swimmer (Int variable from 0 to 4)\nlap_swimmer = [Int(f'lap_{i}') for i in laps]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each lap's swimmer index is valid\nfor lap_var in lap_swimmer:\n    solver.add(And(lap_var >= 0, lap_var < len(swimmers)))\n\n# Each swimmer swims exactly two laps\nfor s in range(len(swimmers)):\n    count_s = Sum([If(lap_swimmer[i] == s, 1, 0) for i in range(len(lap_swimmer))])\n    solver.add(count_s == 2)\n\n# The pairs of laps for each swimmer:\n# One swims laps 1 and 6, one swims laps 2 and 7, one swims laps 3 and 8, one swims laps 4 and 9, one swims laps 5 and 10.\n# So each swimmer is assigned to exactly one of these pairs.\npairs = [(0, 5), (1, 6), (2, 7), (3, 8), (4, 9)]  # zero-based indices of laps\n\n# For each swimmer, find which pair they occupy\n# Create a list of Bool variables: pair_used[s][p] = True if swimmer s swims pair p\npair_used = [[Bool(f'pair_used_{s}_{p}') for p in range(5)] for s in range(5)]\n\n# Each swimmer uses exactly one pair\nfor s in range(5):\n    solver.add(Sum([If(pair_used[s][p], 1, 0) for p in range(5)]) == 1)\n\n# Each pair is used by exactly one swimmer\nfor p in range(5):\n    solver.add(Sum([If(pair_used[s][p], 1, 0) for s in range(5)]) == 1)\n\n# Link pair_used and lap_swimmer assignments\nfor s in range(5):\n    for p in range(5):\n        # If swimmer s uses pair p, then lap_swimmer at pair p's laps must be s\n        lap1, lap2 = pairs[p]\n        solver.add(Implies(pair_used[s][p], And(lap_swimmer[lap1] == s, lap_swimmer[lap2] == s)))\n\n# Constraint 1: Neither of Kruger's laps is immediately before either of Lu's.\nk = swimmer_idx['Kruger']\nl = swimmer_idx['Lu']\nfor i in range(9):  # laps 1 to 9 zero-based\n    # If lap i is Kruger and lap i+1 is Lu, forbidden\n    solver.add(Not(And(lap_swimmer[i] == k, lap_swimmer[i+1] == l)))\n\n# Constraint 2: Jacobson does not swim lap 9.\nj = swimmer_idx['Jacobson']\nsolver.add(lap_swimmer[8] != j)  # lap 9 zero-based index 8\n\n# Constraint 3: Ortiz's first lap is after Miller's.\no = swimmer_idx['Ortiz']\nm = swimmer_idx['Miller']\n\n# Find first lap of Ortiz and Miller\n# Create Int variables for first lap of Ortiz and Miller\nfirst_ortiz = Int('first_ortiz')\nfirst_miller = Int('first_miller')\n\nsolver.add(first_ortiz >= 1, first_ortiz <= 10)\nsolver.add(first_miller >= 1, first_miller <= 10)\n\n# For each lap, if lap_swimmer == Ortiz, first_ortiz <= lap number\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\n\n# For each lap, if lap_swimmer == Miller, first_miller <= lap number\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == m, first_miller <= i+1))\n\n# First lap is minimum lap number for the swimmer\n# So for all laps, first_ortiz >= lap number if lap_swimmer == Ortiz\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == m, first_miller <= i+1))\n# Now ensure first_ortiz is indeed the minimum of Ortiz's laps\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == m, first_miller <= i+1))\n\n# Actually, to get minimum, add constraints:\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == m, first_miller <= i+1))\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\n# Also, first_ortiz >= all lap numbers with Ortiz, so first_ortiz is minimum\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == m, first_miller <= i+1))\n\n# To ensure first_ortiz is the minimum lap Ortiz swims:\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\n# For all laps, first_ortiz >= lap if lap_swimmer == o\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\n# Similarly for Miller\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == m, first_miller <= i+1))\n\n# Actually, the above is redundant; better to define first_ortiz as minimum lap with Ortiz:\n# To do this, add that first_ortiz is less or equal to any lap Ortiz swims, and greater or equal to some lap Ortiz swims\n# Let's add these constraints:\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\nsolver.add(Or([lap_swimmer[i] == o for i in range(10)]))\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\nsolver.add(Or([lap_swimmer[i] == o for i in range(10)]))\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\nsolver.add(Or([lap_swimmer[i] == o for i in range(10)]))\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\n\n# Similarly for Miller\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == m, first_miller <= i+1))\nsolver.add(Or([lap_swimmer[i] == m for i in range(10)]))\n\n# To ensure first_ortiz is minimum lap Ortiz swims:\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\nfor i in range(10):\n    solver.add(Implies(lap_swimmer[i] == o, first_ortiz <= i+1))\n# Also, for all laps, first_ortiz >= lap number if lap_swimmer == o is false is not needed because first_ortiz is min\n# Similarly for Miller\n\n# Finally, Ortiz's first lap is after Miller's first lap\nsolver.add(first_ortiz > first_miller)\n\n# Constraint 4: At least one of Jacobson's laps is immediately after one of Ortiz's laps.\n# There exists i in 1..9 such that lap i is Ortiz and lap i+1 is Jacobson\nfound_adjacent = []\nfor i in range(9):\n    found_adjacent.append(And(lap_swimmer[i] == o, lap_swimmer[i+1] == j))\nsolver.add(Or(found_adjacent))\n\n# OPTION CHECKING\noptions = [\n    ['Jacobson', 'Kruger', 'Miller', 'Lu', 'Ortiz'],   # A\n    ['Kruger', 'Miller', 'Ortiz', 'Jacobson', 'Lu'],   # B\n    ['Lu', 'Miller', 'Jacobson', 'Kruger', 'Ortiz'],   # C\n    ['Ortiz', 'Kruger', 'Miller', 'Lu', 'Jacobson'],   # D\n    ['Miller', 'Ortiz', 'Jacobson', 'Kruger', 'Lu']    # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that laps 1-5 are assigned according to the option\n    for lap_i in range(5):\n        solver.add(lap_swimmer[lap_i] == swimmer_idx[option[lap_i]])\n    # Check satisfiability\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A swim team with exactly five members—Jacobson, Kruger, Lu, Miller, Ortiz—swims a ten-lap relay race. Each team member swims exactly two of the laps: one swims laps 1 and 6, one swims laps 2 and 7, one swims laps 3 and 8, one swims laps 4 and 9, and one swims laps 5 and 10. The following conditions apply: Neither of Kruger's laps is immediately before either of Lu's. Jacobson does not swim lap 9. Ortiz's first lap is after (but not necessarily immediately after) Miller's. At least one of Jacobson's laps is immediately after one of Ortiz's laps.\n\nIf Ortiz swims lap 4, then which one of the following could be true?\n\nOptions:\n(A) Jacobson swims lap 1.\n(B) Jacobson swims lap 3.\n(C) Kruger swims lap 5.\n(D) Lu swims lap 3.\n(E) Miller swims lap 5.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nswimmers = ['Jacobson', 'Kruger', 'Lu', 'Miller', 'Ortiz']\nlaps = list(range(1, 11))\n\n# Each swimmer swims exactly two laps: (1,6), (2,7), (3,8), (4,9), (5,10)\n# Assign each swimmer to one pair index: 0->(1,6), 1->(2,7), 2->(3,8), 3->(4,9), 4->(5,10)\npair_indices = list(range(5))\npair_to_laps = {\n    0: (1, 6),\n    1: (2, 7),\n    2: (3, 8),\n    3: (4, 9),\n    4: (5, 10)\n}\n\n# Create variables: swimmer_to_pair: swimmer -> pair index\nswimmer_to_pair = {}\nfor s in swimmers:\n    swimmer_to_pair[s] = Int(s)\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each swimmer assigned to exactly one pair index 0..4\nfor s in swimmers:\n    solver.add(And(swimmer_to_pair[s] >= 0, swimmer_to_pair[s] < 5))\n\n# All swimmers assigned distinct pairs\nsolver.add(Distinct([swimmer_to_pair[s] for s in swimmers]))\n\n# Jacobson does not swim lap 9 -> Jacobson's pair != 3 (4,9)\nsolver.add(swimmer_to_pair['Jacobson'] != 3)\n\n# Ortiz's first lap is after Miller's first lap\n# Compare pair indices: Ortiz's pair > Miller's pair\nsolver.add(swimmer_to_pair['Ortiz'] > swimmer_to_pair['Miller'])\n\n# Neither of Kruger's laps is immediately before either of Lu's laps\n# For pairs p and q, laps are (p, p+5) and (q, q+5)\n# Immediate before means lap x immediately before lap y means y = x+1\n# So check no lap of Kruger is immediately before any lap of Lu\n\nKruger_pair = swimmer_to_pair['Kruger']\nLu_pair = swimmer_to_pair['Lu']\n\n# Kruger laps\nKruger_laps = [Kruger_pair + 1, Kruger_pair + 6]\n# Lu laps\nLu_laps = [Lu_pair + 1, Lu_pair + 6]\n\n# For all Kruger_lap in {p1,p2} and Lu_lap in {q1,q2}, no Kruger_lap +1 == Lu_lap\n# So for all pairs, (Kruger_lap + 1 != Lu_lap)\nfor k_lap in Kruger_laps:\n    for l_lap in Lu_laps:\n        solver.add(k_lap + 1 != l_lap)\n\n# At least one of Jacobson's laps is immediately after one of Ortiz's laps\nJacobson_pair = swimmer_to_pair['Jacobson']\nOrtiz_pair = swimmer_to_pair['Ortiz']\n\nJacobson_laps = [Jacobson_pair + 1, Jacobson_pair + 6]\nOrtiz_laps = [Ortiz_pair + 1, Ortiz_pair + 6]\n\n# There exists j_lap in Jacobson_laps and o_lap in Ortiz_laps such that j_lap == o_lap + 1\nimmediate_after_conditions = []\nfor j_lap in Jacobson_laps:\n    for o_lap in Ortiz_laps:\n        immediate_after_conditions.append(j_lap == o_lap + 1)\nsolver.add(Or(immediate_after_conditions))\n\n# Ortiz swims lap 4 -> Ortiz's pair is 3 (laps 4 and 9)\nsolver.add(swimmer_to_pair['Ortiz'] == 3)\n\n# OPTION CHECKING\n# Options:\n# (A) Jacobson swims lap 1 -> Jacobson's pair == 0\n# (B) Jacobson swims lap 3 -> Jacobson's pair == 2\n# (C) Kruger swims lap 5 -> Kruger's pair == 4\n# (D) Lu swims lap 3 -> Lu's pair == 2\n# (E) Miller swims lap 5 -> Miller's pair == 4\n\noptions = {\n    'A': swimmer_to_pair['Jacobson'] == 0,\n    'B': swimmer_to_pair['Jacobson'] == 2,\n    'C': swimmer_to_pair['Kruger'] == 4,\n    'D': swimmer_to_pair['Lu'] == 2,\n    'E': swimmer_to_pair['Miller'] == 4\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A swim team with exactly five members—Jacobson, Kruger, Lu, Miller, Ortiz—swims a ten-lap relay race. Each team member swims exactly two of the laps: one swims laps 1 and 6, one swims laps 2 and 7, one swims laps 3 and 8, one swims laps 4 and 9, and one swims laps 5 and 10. The following conditions apply: Neither of Kruger's laps is immediately before either of Lu's. Jacobson does not swim lap 9. Ortiz's first lap is after (but not necessarily immediately after) Miller's. At least one of Jacobson's laps is immediately after one of Ortiz's laps.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Jacobson swims lap 4.\n(B) Kruger swims lap 5.\n(C) Lu swims lap 5.\n(D) Miller swims lap 10.\n(E) Ortiz swims lap 6.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nswimmers = ['Jacobson', 'Kruger', 'Lu', 'Miller', 'Ortiz']\nlaps = list(range(1, 11))  # laps 1 to 10\n\n# Each swimmer swims exactly two laps: laps 1&6, 2&7, 3&8, 4&9, 5&10\n# Assign each swimmer to a pair index: 0->(1,6), 1->(2,7), 2->(3,8), 3->(4,9), 4->(5,10)\npair_indices = list(range(5))\npair_to_laps = {\n    0: (1, 6),\n    1: (2, 7),\n    2: (3, 8),\n    3: (4, 9),\n    4: (5, 10),\n}\n\n# Create a Z3 Int variable for each swimmer indicating which pair of laps they swim\nswimmer_pair = {s: Int(s) for s in swimmers}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each swimmer assigned to exactly one pair index 0..4\nfor s in swimmers:\n    solver.add(And(swimmer_pair[s] >= 0, swimmer_pair[s] <= 4))\n\n# All swimmers assigned to different pairs (Distinct)\nsolver.add(Distinct([swimmer_pair[s] for s in swimmers]))\n\n# Constraint 1: Neither of Kruger's laps is immediately before either of Lu's\n# We get Kruger's laps and Lu's laps from their pair indices\n# That is, no lap of Kruger is immediately before any lap of Lu\n# For each lap k in Kruger laps and each lap l in Lu laps: l != k+1\n\n# Define function to get laps from pair index variable\ndef get_laps(pair_var):\n    # pair_var is Int variable (0..4)\n    # returns tuple of two Int expressions for laps\n    # Use conditional expressions to map pair_var to laps\n    # We'll create two Int expressions for laps1 and laps2 using If\n    laps1 = If(pair_var == 0, 1,\n           If(pair_var == 1, 2,\n           If(pair_var == 2, 3,\n           If(pair_var == 3, 4,\n           5))))\n    laps2 = If(pair_var == 0, 6,\n           If(pair_var == 1, 7,\n           If(pair_var == 2, 8,\n           If(pair_var == 3, 9,\n           10))))\n    return (laps1, laps2)\n\nkruger_laps = get_laps(swimmer_pair['Kruger'])\nlu_laps = get_laps(swimmer_pair['Lu'])\n\n# Neither of Kruger's laps is immediately before either of Lu's laps\n# So for all k in Kruger laps, l in Lu laps: l != k+1\n# This is: Not(Or([l == k+1 for k in kruger_laps for l in lu_laps]))\nimmediately_before_conditions = [lu_lap == krug_lap + 1 for krug_lap in kruger_laps for lu_lap in lu_laps]\nsolver.add(Not(Or(immediately_before_conditions)))\n\n# Constraint 2: Jacobson does not swim lap 9\n# Jacobson's pair cannot be the one containing lap 9, which is pair index 3 (laps 4 and 9)\nsolver.add(swimmer_pair['Jacobson'] != 3)\n\n# Constraint 3: Ortiz's first lap is after (not necessarily immediately after) Miller's\n# Ortiz's first lap > Miller's first lap\nortiz_first_lap = If(swimmer_pair['Ortiz'] == 0, 1,\n                 If(swimmer_pair['Ortiz'] == 1, 2,\n                 If(swimmer_pair['Ortiz'] == 2, 3,\n                 If(swimmer_pair['Ortiz'] == 3, 4,\n                 5))))\nmiller_first_lap = If(swimmer_pair['Miller'] == 0, 1,\n                  If(swimmer_pair['Miller'] == 1, 2,\n                  If(swimmer_pair['Miller'] == 2, 3,\n                  If(swimmer_pair['Miller'] == 3, 4,\n                  5))))\nsolver.add(ortiz_first_lap > miller_first_lap)\n\n# Constraint 4: At least one of Jacobson's laps is immediately after one of Ortiz's laps\n# That is, exists laps j in Jacobson, o in Ortiz: j == o + 1\njacobson_laps = get_laps(swimmer_pair['Jacobson'])\nortiz_laps = get_laps(swimmer_pair['Ortiz'])\nimmediately_after_conditions = [jac_lap == ort_lap + 1 for jac_lap in jacobson_laps for ort_lap in ortiz_laps]\nsolver.add(Or(immediately_after_conditions))\n\n# OPTION CHECKING\noptions = {\n    'A': ('Jacobson', 4),\n    'B': ('Kruger', 5),\n    'C': ('Lu', 5),\n    'D': ('Miller', 10),\n    'E': ('Ortiz', 6),\n}\n\nfor letter, (swimmer, lap) in options.items():\n    solver.push()\n    # Add constraint: swimmer swims lap\n    # swimmer's pair contains lap\n    # So swimmer_pair must be the pair index whose laps contain lap\n    # Find which pair index contains lap\n    pair_index_for_lap = None\n    for pi, (lap1, lap2) in pair_to_laps.items():\n        if lap == lap1 or lap == lap2:\n            pair_index_for_lap = pi\n            break\n    solver.add(swimmer_pair[swimmer] == pair_index_for_lap)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.\n\nWhich one of the following could be the order, from first to last, in which the clowns get out of the car?\n\nOptions:\n(A) T, Z, V, R, W, Y, S, Q\n(B) Z, R, W, Q, T, V, Y, S\n(C) R, W, T, V, Q, Z, S, Y\n(D) Z, W, R, T, V, Y, Q, S\n(E) R, W, T, V, Z, S, Y, Q",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclowns = ['Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'Z']\n# Create Int variables representing the position (1 to 8) where each clown gets out\npositions = {c: Int(c) for c in clowns}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Positions are between 1 and 8\nfor c in clowns:\n    solver.add(And(positions[c] >= 1, positions[c] <= 8))\n\n# All positions are distinct (no two clowns get out at the same time)\nsolver.add(Distinct([positions[c] for c in clowns]))\n\n# V gets out before both Y and Q\nsolver.add(positions['V'] < positions['Y'])\nsolver.add(positions['V'] < positions['Q'])\n\n# Q gets out after Z\nsolver.add(positions['Q'] > positions['Z'])\n\n# T gets out before V but after R\nsolver.add(positions['T'] < positions['V'])\nsolver.add(positions['T'] > positions['R'])\n\n# S gets out after V\nsolver.add(positions['S'] > positions['V'])\n\n# R gets out before W\nsolver.add(positions['R'] < positions['W'])\n\n# OPTION CHECKING\noptions = [\n    ['T', 'Z', 'V', 'R', 'W', 'Y', 'S', 'Q'],  # A\n    ['Z', 'R', 'W', 'Q', 'T', 'V', 'Y', 'S'],  # B\n    ['R', 'W', 'T', 'V', 'Q', 'Z', 'S', 'Y'],  # C\n    ['Z', 'W', 'R', 'T', 'V', 'Y', 'Q', 'S'],  # D\n    ['R', 'W', 'T', 'V', 'Z', 'S', 'Y', 'Q'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that the positions match the option order\n    # option[0] is at position 1, option[1] at position 2, ..., option[7] at position 8\n    for pos, clown in enumerate(option, start=1):\n        solver.add(positions[clown] == pos)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Y is the second clown to get out of the car.\n(B) R is the third clown to get out of the car.\n(C) Q is the fourth clown to get out of the car.\n(D) S is the fifth clown to get out of the car.\n(E) V is the sixth clown to get out of the car.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclowns = ['Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'Z']\nnum_positions = 8\n\n# Create a Z3 Int variable for each clown representing the order they get out (1 to 8)\norder = {c: Int(c) for c in clowns}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each clown's order is between 1 and 8\nfor c in clowns:\n    solver.add(And(order[c] >= 1, order[c] <= num_positions))\n\n# All clowns have distinct positions\nsolver.add(Distinct([order[c] for c in clowns]))\n\n# V gets out before both Y and Q\nsolver.add(order['V'] < order['Y'])\nsolver.add(order['V'] < order['Q'])\n\n# Q gets out after Z\nsolver.add(order['Q'] > order['Z'])\n\n# T gets out before V but after R\nsolver.add(order['T'] < order['V'])\nsolver.add(order['T'] > order['R'])\n\n# S gets out after V\nsolver.add(order['S'] > order['V'])\n\n# R gets out before W\nsolver.add(order['R'] < order['W'])\n\n# OPTION CHECKING\n# Define the options as tuples: (clown, position)\noptions = [\n    ('Y', 2),  # A\n    ('R', 3),  # B\n    ('Q', 4),  # C\n    ('S', 5),  # D\n    ('V', 6)   # E\n]\n\nfor i, (clown, pos) in enumerate(options):\n    solver.push()\n    solver.add(order[clown] == pos)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.\n\nIf Z is the seventh clown to get out of the car, then which one of the following could be true?\n\nOptions:\n(A) R is the second clown to get out of the car.\n(B) T is the fourth clown to get out of the car.\n(C) W is the fifth clown to get out of the car.\n(D) V is the sixth clown to get out of the car.\n(E) Y is the eighth clown to get out of the car.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclowns = ['Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'Z']\npositions = {c: Int(c) for c in clowns}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each clown's position is between 1 and 8\nfor c in clowns:\n    solver.add(And(positions[c] >= 1, positions[c] <= 8))\n\n# All positions are distinct\nsolver.add(Distinct([positions[c] for c in clowns]))\n\n# Given conditions:\n# V gets out before both Y and Q\nsolver.add(positions['V'] < positions['Y'])\nsolver.add(positions['V'] < positions['Q'])\n\n# Q gets out after Z\nsolver.add(positions['Q'] > positions['Z'])\n\n# T gets out before V but after R\nsolver.add(positions['T'] < positions['V'])\nsolver.add(positions['T'] > positions['R'])\n\n# S gets out after V\nsolver.add(positions['S'] > positions['V'])\n\n# R gets out before W\nsolver.add(positions['R'] < positions['W'])\n\n# Z is the seventh clown to get out\nsolver.add(positions['Z'] == 7)\n\n# OPTION CHECKING\noptions = {\n    'A': positions['R'] == 2,\n    'B': positions['T'] == 4,\n    'C': positions['W'] == 5,\n    'D': positions['V'] == 6,\n    'E': positions['Y'] == 8\n}\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.\n\nIf Q is the fifth clown to get out of the car, then each of the following could be true EXCEPT:\n\nOptions:\n(A) Z is the first clown to get out of the car.\n(B) T is the second clown to get out of the car.\n(C) V is the third clown to get out of the car.\n(D) W is the fourth clown to get out of the car.\n(E) Y is the sixth clown to get out of the car.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclowns = ['Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'Z']\npositions = {c: Int(c) for c in clowns}\n\n# Positions range from 1 to 8\nsolver = Solver()\nfor c in clowns:\n    solver.add(And(positions[c] >= 1, positions[c] <= 8))\n\n# All positions are distinct\nsolver.add(Distinct([positions[c] for c in clowns]))\n\n# Constraints from the problem\n# V < Y and V < Q\nsolver.add(positions['V'] < positions['Y'])\nsolver.add(positions['V'] < positions['Q'])\n\n# Q > Z\nsolver.add(positions['Q'] > positions['Z'])\n\n# T < V and T > R\nsolver.add(positions['T'] < positions['V'])\nsolver.add(positions['T'] > positions['R'])\n\n# S > V\nsolver.add(positions['S'] > positions['V'])\n\n# R < W\nsolver.add(positions['R'] < positions['W'])\n\n# Q is the 5th clown\nsolver.add(positions['Q'] == 5)\n\n# OPTION CHECKING\noptions = {\n    'A': positions['Z'] == 1,\n    'B': positions['T'] == 2,\n    'C': positions['V'] == 3,\n    'D': positions['W'] == 4,\n    'E': positions['Y'] == 6\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.\n\nIf R is the second clown to get out of the car, which one of the following must be true?\n\nOptions:\n(A) S gets out of the car at some time before T does.\n(B) T gets out of the car at some time before W does.\n(C) W gets out of the car at some time before V does.\n(D) Y gets out of the car at some time before Q does.\n(E) Z gets out of the car at some time before W does.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclowns = ['Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'Z']\npositions = {c: Int(c) for c in clowns}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each clown's position is between 1 and 8\nfor c in clowns:\n    solver.add(And(positions[c] >= 1, positions[c] <= 8))\n\n# All positions are distinct\nsolver.add(Distinct([positions[c] for c in clowns]))\n\n# Given conditions:\n# V before Y and Q\nsolver.add(positions['V'] < positions['Y'])\nsolver.add(positions['V'] < positions['Q'])\n\n# Q after Z\nsolver.add(positions['Q'] > positions['Z'])\n\n# T before V but after R\nsolver.add(positions['T'] < positions['V'])\nsolver.add(positions['T'] > positions['R'])\n\n# S after V\nsolver.add(positions['S'] > positions['V'])\n\n# R before W\nsolver.add(positions['R'] < positions['W'])\n\n# Given: R is second\nsolver.add(positions['R'] == 2)\n\n# OPTION CHECKING\noptions = {\n    'A': positions['S'] < positions['T'],  # S before T\n    'B': positions['T'] < positions['W'],  # T before W\n    'C': positions['W'] < positions['V'],  # W before V\n    'D': positions['Y'] < positions['Q'],  # Y before Q\n    'E': positions['Z'] < positions['W'],  # Z before W\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(Not(condition))  # Check if option can be false\n    if solver.check() == unsat:\n        # If negation is unsat, condition must be true\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "A car drives into the center ring of a circus and exactly eight clowns—Q, R, S, T, V, W, Y, and Z—get out of the car, one clown at a time. The order in which the clowns get out of the car is consistent with the following conditions: V gets out at some time before both Y and Q. Q gets out at some time after Z. T gets out at some time before V but at some time after R. S gets out at some time after V. R gets out at some time before W.\n\nIf V gets out of the car at some time before Z does, then which one of the following could be true?\n\nOptions:\n(A) R is the second clown to get out of the car.\n(B) T is the fourth clown to get out of the car.\n(C) Q is the fourth clown to get out of the car.\n(D) V is the fifth clown to get out of the car.\n(E) Z is the sixth clown to get out of the car.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nclowns = ['Q', 'R', 'S', 'T', 'V', 'W', 'Y', 'Z']\npositions = {c: Int(c) for c in clowns}  # Position in order (1 to 8)\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each clown's position is between 1 and 8\nfor c in clowns:\n    solver.add(And(positions[c] >= 1, positions[c] <= 8))\n\n# All positions are distinct\nsolver.add(Distinct([positions[c] for c in clowns]))\n\n# Given conditions:\n# V gets out before Y and Q\nsolver.add(positions['V'] < positions['Y'])\nsolver.add(positions['V'] < positions['Q'])\n\n# Q gets out after Z\nsolver.add(positions['Q'] > positions['Z'])\n\n# T gets out before V but after R\nsolver.add(positions['T'] < positions['V'])\nsolver.add(positions['T'] > positions['R'])\n\n# S gets out after V\nsolver.add(positions['S'] > positions['V'])\n\n# R gets out before W\nsolver.add(positions['R'] < positions['W'])\n\n# Additional condition for the question:\n# V gets out before Z\nsolver.add(positions['V'] < positions['Z'])\n\n# OPTION CHECKING\noptions = {\n    'A': positions['R'] == 2,\n    'B': positions['T'] == 4,\n    'C': positions['Q'] == 4,\n    'D': positions['V'] == 5,\n    'E': positions['Z'] == 6\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Each of six tasks—harvesting, milling, plowing, spinning, threshing, and weaving—will be demonstrated exactly once at a farm exhibition. No two tasks will be demonstrated concurrently. Three volunteers—Frank, Gladys, and Leslie—will each demonstrate exactly two of the tasks. The tasks must be demonstrated in accordance with the following conditions: Frank demonstrates exactly one task before Gladys demonstrates any of the tasks. Frank performs neither the first nor the last demonstration. Gladys demonstrates neither harvesting nor milling. Leslie demonstrates neither harvesting nor threshing. Milling is the next task demonstrated after threshing is demonstrated.\n\nWhich one of the following is an acceptable list of the volunteers and the tasks each demonstrates, in order from the first to the last demonstration?\n\nOptions:\n(A) Frank: weaving; Gladys: threshing; Leslie: milling; Leslie: spinning; Frank: harvesting; Gladys: plowing\n(B) Leslie: plowing; Frank: harvesting; Frank: threshing; Leslie: milling; Gladys: spinning; Gladys: weaving\n(C) Leslie: plowing; Frank: spinning; Gladys: threshing; Leslie: milling; Frank: harvesting; Gladys: weaving\n(D) Leslie: spinning; Leslie: weaving; Frank: plowing; Gladys: harvesting; Frank: threshing; Gladys: milling\n(E) Leslie: weaving; Frank: threshing; Gladys: spinning; Leslie: milling; Frank: harvesting; Gladys: plowing",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ntasks = ['harvesting', 'milling', 'plowing', 'spinning', 'threshing', 'weaving']\nvolunteers = ['Frank', 'Gladys', 'Leslie']\n\nnum_tasks = len(tasks)\n\n# Create Z3 Int variables for volunteer demonstrating each task in order (0=Frank,1=Gladys,2=Leslie)\nvol_map = {'Frank': 0, 'Gladys': 1, 'Leslie': 2}\ntask_map = {t: i for i, t in enumerate(tasks)}\n\n# For each position (0 to 5), volunteer demonstrating the task\ndemonstrators = [Int(f'dem_{i}') for i in range(num_tasks)]\n# For each position, task demonstrated\ntask_order = [Int(f'task_{i}') for i in range(num_tasks)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each demonstrator variable in [0,2]\nfor d in demonstrators:\n    solver.add(And(d >= 0, d <= 2))\n\n# Each task variable in [0,5]\nfor t in task_order:\n    solver.add(And(t >= 0, t < num_tasks))\n\n# All tasks appear exactly once in order\nsolver.add(Distinct(task_order))\n\n# Each volunteer demonstrates exactly two tasks (count occurrences)\nfor v in range(3):\n    count = Sum([If(demonstrators[i] == v, 1, 0) for i in range(num_tasks)])\n    solver.add(count == 2)\n\n# Frank demonstrates exactly one task before Gladys demonstrates any\n# Find earliest Frank demo and earliest Gladys demo\nfrank_positions = [i for i in range(num_tasks)]\ngladys_positions = [i for i in range(num_tasks)]\n# We'll encode: number of Frank demos before first Gladys demo == 1\n\n# First Gladys demo position:\nfirst_gladys = Int('first_gladys')\nsolver.add(first_gladys >= 0, first_gladys < num_tasks)\n# first_gladys is minimal i with demonstrators[i] == Gladys (1)\nfor i in range(num_tasks):\n    cond = demonstrators[i] == vol_map['Gladys']\n    solver.add(If(i == first_gladys, cond, True))\n    # For all j < first_gladys, demonstrators[j] != Gladys\n    for j in range(i):\n        solver.add(Implies(first_gladys == i, demonstrators[j] != vol_map['Gladys']))\n\n# Count Frank demos before first_gladys == 1\nfrank_before_gladys = Sum([If(And(i < first_gladys, demonstrators[i] == vol_map['Frank']), 1, 0) for i in range(num_tasks)])\nsolver.add(frank_before_gladys == 1)\n\n# Frank performs neither first nor last demonstration\nsolver.add(demonstrators[0] != vol_map['Frank'])\nsolver.add(demonstrators[-1] != vol_map['Frank'])\n\n# Gladys demonstrates neither harvesting nor milling\n# For all i with demonstrators[i] == Gladys, task_order[i] != harvesting(0) or milling(1)\nfor i in range(num_tasks):\n    solver.add(Implies(demonstrators[i] == vol_map['Gladys'], And(task_order[i] != task_map['harvesting'], task_order[i] != task_map['milling'])))\n\n# Leslie demonstrates neither harvesting nor threshing\nfor i in range(num_tasks):\n    solver.add(Implies(demonstrators[i] == vol_map['Leslie'], And(task_order[i] != task_map['harvesting'], task_order[i] != task_map['threshing'])))\n\n# Milling is the next task demonstrated after threshing\n# Find index of threshing and milling in task_order\nthreshing_pos = Int('threshing_pos')\nmilling_pos = Int('milling_pos')\nsolver.add(threshing_pos >= 0, threshing_pos < num_tasks)\nsolver.add(milling_pos >= 0, milling_pos < num_tasks)\nfor i in range(num_tasks):\n    solver.add(If(task_order[i] == task_map['threshing'], threshing_pos == i, True))\n    solver.add(If(task_order[i] == task_map['milling'], milling_pos == i, True))\nsolver.add(milling_pos == threshing_pos + 1)\n\n# OPTION CHECKING\n\noptions = [\n    [('Frank', 'weaving'), ('Gladys', 'threshing'), ('Leslie', 'milling'), ('Leslie', 'spinning'), ('Frank', 'harvesting'), ('Gladys', 'plowing')],\n    [('Leslie', 'plowing'), ('Frank', 'harvesting'), ('Frank', 'threshing'), ('Leslie', 'milling'), ('Gladys', 'spinning'), ('Gladys', 'weaving')],\n    [('Leslie', 'plowing'), ('Frank', 'spinning'), ('Gladys', 'threshing'), ('Leslie', 'milling'), ('Frank', 'harvesting'), ('Gladys', 'weaving')],\n    [('Leslie', 'spinning'), ('Leslie', 'weaving'), ('Frank', 'plowing'), ('Gladys', 'harvesting'), ('Frank', 'threshing'), ('Gladys', 'milling')],\n    [('Leslie', 'weaving'), ('Frank', 'threshing'), ('Gladys', 'spinning'), ('Leslie', 'milling'), ('Frank', 'harvesting'), ('Gladys', 'plowing')],\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this option\n    # Set demonstrators and task_order matching the option\n    for pos, (vol, tsk) in enumerate(option):\n        solver.add(demonstrators[pos] == vol_map[vol])\n        solver.add(task_order[pos] == task_map[tsk])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.\n\nWhich one of the following could be a complete and accurate matching of the applicants with the departments in which they were hired?\n\nOptions:\n(A) management: Weiss; production: Feng, Herrera, Yates; sales: Garcia, Ilias, Xavier\n(B) management: Weiss; production: Garcia, Ilias, Xavier; sales: Feng, Herrera, Yates\n(C) management: Xavier; production: Feng, Garcia, Herrera; sales: Ilias, Yates, Weiss\n(D) management: Xavier; production: Feng, Herrera, Ilias; sales: Garcia, Weiss, Yates\n(E) management: Xavier; production: Feng, Ilias, Weiss; sales: Garcia, Herrera, Yates",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Feng', 'Garcia', 'Herrera', 'Ilias', 'Weiss', 'Xavier', 'Yates']\ndepartments = ['management', 'production', 'sales']\ndept_indices = {d: i for i, d in enumerate(departments)}\n\n# Create Z3 Int variables for each applicant's department (0=management,1=production,2=sales)\napp_dept = {a: Int(a) for a in applicants}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each applicant's department must be valid index\nfor a in applicants:\n    solver.add(And(app_dept[a] >= 0, app_dept[a] < len(departments)))\n\n# Count of applicants in each department must be correct:\n# management: 1, production: 3, sales: 3\n# To count, create conditions for each dept per applicant\nmanagement_count = Sum([If(app_dept[a] == dept_indices['management'], 1, 0) for a in applicants])\nproduction_count = Sum([If(app_dept[a] == dept_indices['production'], 1, 0) for a in applicants])\nsales_count = Sum([If(app_dept[a] == dept_indices['sales'], 1, 0) for a in applicants])\n\nsolver.add(management_count == 1)\nsolver.add(production_count == 3)\nsolver.add(sales_count == 3)\n\n# Herrera is hired for a position in the same department as Yates\nsolver.add(app_dept['Herrera'] == app_dept['Yates'])\n\n# Feng is hired for a position in a different department from Garcia\nsolver.add(app_dept['Feng'] != app_dept['Garcia'])\n\n# If Xavier is hired for a sales position, then Weiss is hired for a production position\nsolver.add(Implies(app_dept['Xavier'] == dept_indices['sales'], app_dept['Weiss'] == dept_indices['production']))\n\n# Feng is hired for a production position\nsolver.add(app_dept['Feng'] == dept_indices['production'])\n\n# OPTION CHECKING\noptions = [\n    # (A) management: Weiss; production: Feng, Herrera, Yates; sales: Garcia, Ilias, Xavier\n    {\n        'Weiss': 'management',\n        'Feng': 'production',\n        'Herrera': 'production',\n        'Yates': 'production',\n        'Garcia': 'sales',\n        'Ilias': 'sales',\n        'Xavier': 'sales'\n    },\n    # (B) management: Weiss; production: Garcia, Ilias, Xavier; sales: Feng, Herrera, Yates\n    {\n        'Weiss': 'management',\n        'Garcia': 'production',\n        'Ilias': 'production',\n        'Xavier': 'production',\n        'Feng': 'sales',\n        'Herrera': 'sales',\n        'Yates': 'sales'\n    },\n    # (C) management: Xavier; production: Feng, Garcia, Herrera; sales: Ilias, Yates, Weiss\n    {\n        'Xavier': 'management',\n        'Feng': 'production',\n        'Garcia': 'production',\n        'Herrera': 'production',\n        'Ilias': 'sales',\n        'Yates': 'sales',\n        'Weiss': 'sales'\n    },\n    # (D) management: Xavier; production: Feng, Herrera, Ilias; sales: Garcia, Weiss, Yates\n    {\n        'Xavier': 'management',\n        'Feng': 'production',\n        'Herrera': 'production',\n        'Ilias': 'production',\n        'Garcia': 'sales',\n        'Weiss': 'sales',\n        'Yates': 'sales'\n    },\n    # (E) management: Xavier; production: Feng, Ilias, Weiss; sales: Garcia, Herrera, Yates\n    {\n        'Xavier': 'management',\n        'Feng': 'production',\n        'Ilias': 'production',\n        'Weiss': 'production',\n        'Garcia': 'sales',\n        'Herrera': 'sales',\n        'Yates': 'sales'\n    }\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this option\n    for a in applicants:\n        dept_idx = dept_indices[option[a]]\n        solver.add(app_dept[a] == dept_idx)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.\n\nWhich one of the following is a complete and accurate list of the applicants, each of whom CANNOT be hired for a production position?\n\nOptions:\n(A) Feng, Ilias, Xavier\n(B) Garcia, Herrera, Yates\n(C) Herrera, Yates\n(D) Garcia\n(E) Ilias",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Feng', 'Garcia', 'Herrera', 'Ilias', 'Weiss', 'Xavier', 'Yates']\ndepartments = ['Management', 'Production', 'Sales']\n\n# Map departments to indices\ndept_indices = {dept: i for i, dept in enumerate(departments)}\n\n# Create Z3 Int variables for each applicant's department (0=Management,1=Production,2=Sales)\ndept_vars = {applicant: Int(applicant) for applicant in applicants}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each applicant's department must be valid\nfor applicant in applicants:\n    solver.add(And(dept_vars[applicant] >= 0, dept_vars[applicant] < len(departments)))\n\n# Department counts: 1 Management, 3 Production, 3 Sales\n# Count number of applicants in each department\ncount_management = Sum([If(dept_vars[applicant] == dept_indices['Management'], 1, 0) for applicant in applicants])\ncount_production = Sum([If(dept_vars[applicant] == dept_indices['Production'], 1, 0) for applicant in applicants])\ncount_sales = Sum([If(dept_vars[applicant] == dept_indices['Sales'], 1, 0) for applicant in applicants])\n\nsolver.add(count_management == 1)\nsolver.add(count_production == 3)\nsolver.add(count_sales == 3)\n\n# Herrera and Yates are in the same department\nsolver.add(dept_vars['Herrera'] == dept_vars['Yates'])\n\n# Feng is in a different department from Garcia\nsolver.add(dept_vars['Feng'] != dept_vars['Garcia'])\n\n# If Xavier is hired for sales, then Weiss is hired for production\nsolver.add(Implies(dept_vars['Xavier'] == dept_indices['Sales'], dept_vars['Weiss'] == dept_indices['Production']))\n\n# Feng is hired for a production position\nsolver.add(dept_vars['Feng'] == dept_indices['Production'])\n\n# OPTION CHECKING\n# Each option lists applicants who CANNOT be hired for production.\n# For each option, we will check if it is possible for any applicant in the option to be in production.\n# If any applicant in the option can be in production, then that option is invalid.\n# The correct option is the one where NONE of the listed applicants can be hired for production.\n\noptions = {\n    'A': ['Feng', 'Ilias', 'Xavier'],\n    'B': ['Garcia', 'Herrera', 'Yates'],\n    'C': ['Herrera', 'Yates'],\n    'D': ['Garcia'],\n    'E': ['Ilias']\n}\n\nfor letter, applicants_list in options.items():\n    solver.push()\n    # Add constraint that at least one applicant in the list is hired for production\n    can_be_production = Or([dept_vars[applicant] == dept_indices['Production'] for applicant in applicants_list])\n    solver.add(can_be_production)\n    if solver.check() == sat:\n        # This means at least one applicant in the list can be hired for production, so option is invalid\n        solver.pop()\n        continue\n    else:\n        # No applicant in the list can be hired for production, so this is the correct option\n        print(f\"'{letter}'\")\n        solver.pop()\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.\n\nEach of the following could be an accurate partial list of the applicants hired for sales positions EXCEPT:\n\nOptions:\n(A) Garcia, Ilias\n(B) Garcia, Xavier\n(C) Garcia, Yates\n(D) Herrera, Weiss\n(E) Herrera, Xavier",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Feng', 'Garcia', 'Herrera', 'Ilias', 'Weiss', 'Xavier', 'Yates']\ndepartments = ['Management', 'Production', 'Sales']  # 0: Management, 1: Production, 2: Sales\n\n# Map applicant to a Z3 Int variable representing their department\ndept = {a: Int(a) for a in applicants}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each applicant's department must be valid\nfor a in applicants:\n    solver.add(And(dept[a] >= 0, dept[a] < len(departments)))\n\n# Exactly one management position\n# Exactly three production positions\n# Exactly three sales positions\nmanagement_count = Sum([If(dept[a] == 0, 1, 0) for a in applicants])\nproduction_count = Sum([If(dept[a] == 1, 1, 0) for a in applicants])\nsales_count = Sum([If(dept[a] == 2, 1, 0) for a in applicants])\n\nsolver.add(management_count == 1)\nsolver.add(production_count == 3)\nsolver.add(sales_count == 3)\n\n# Herrera is hired for a position in the same department as Yates\nsolver.add(dept['Herrera'] == dept['Yates'])\n\n# Feng is hired for a position in a different department from Garcia\nsolver.add(dept['Feng'] != dept['Garcia'])\n\n# If Xavier is hired for a sales position, then Weiss is hired for a production position\nsolver.add(Implies(dept['Xavier'] == 2, dept['Weiss'] == 1))\n\n# Feng is hired for a production position\nsolver.add(dept['Feng'] == 1)\n\n# OPTION CHECKING\noptions = [\n    ['Garcia', 'Ilias'],    # A\n    ['Garcia', 'Xavier'],   # B\n    ['Garcia', 'Yates'],    # C\n    ['Herrera', 'Weiss'],   # D\n    ['Herrera', 'Xavier']   # E\n]\n\nfor i, partial_sales in enumerate(options):\n    solver.push()\n    # Add constraint: all listed applicants are in sales (department 2)\n    for a in partial_sales:\n        solver.add(dept[a] == 2)\n    # Check if model is satisfiable\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.\n\nIf Feng is hired for a position in the same department as Xavier, then each of the following could be true EXCEPT:\n\nOptions:\n(A) Garcia is hired for a sales position.\n(B) Herrera is hired for a production position.\n(C) Ilias is hired for a sales position.\n(D) Weiss is hired for the management position.\n(E) Weiss is hired for a production position.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Feng', 'Garcia', 'Herrera', 'Ilias', 'Weiss', 'Xavier', 'Yates']\ndepartments = ['Management', 'Production', 'Sales']\n\n# Map departments to indices\ndept_indices = {d: i for i, d in enumerate(departments)}\n\n# Create Z3 Int variables for each applicant's department\ndept_vars = {a: Int(a) for a in applicants}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each applicant's department must be valid (0 to 2)\nfor a in applicants:\n    solver.add(And(dept_vars[a] >= 0, dept_vars[a] < len(departments)))\n\n# Department counts:\n# 1 in Management, 3 in Production, 3 in Sales\n# Count number of applicants in each department\ndef count_in_dept(dept_index):\n    return Sum([If(dept_vars[a] == dept_index, 1, 0) for a in applicants])\n\nsolver.add(count_in_dept(dept_indices['Management']) == 1)\nsolver.add(count_in_dept(dept_indices['Production']) == 3)\nsolver.add(count_in_dept(dept_indices['Sales']) == 3)\n\n# Herrera is hired for a position in the same department as Yates\nsolver.add(dept_vars['Herrera'] == dept_vars['Yates'])\n\n# Feng is hired for a position in a different department from Garcia\nsolver.add(dept_vars['Feng'] != dept_vars['Garcia'])\n\n# If Xavier is hired for a sales position, then Weiss is hired for a production position\nsolver.add(Implies(dept_vars['Xavier'] == dept_indices['Sales'], dept_vars['Weiss'] == dept_indices['Production']))\n\n# Feng is hired for a production position\nsolver.add(dept_vars['Feng'] == dept_indices['Production'])\n\n# Additional condition for the question:\n# Feng is hired for a position in the same department as Xavier\nsolver.add(dept_vars['Feng'] == dept_vars['Xavier'])\n\n# OPTION CHECKING\n# We test each option by adding the option's condition and checking if the model is satisfiable.\n# The EXCEPT option is the one that makes the system unsatisfiable.\n\noptions = {\n    'A': dept_vars['Garcia'] == dept_indices['Sales'],\n    'B': dept_vars['Herrera'] == dept_indices['Production'],\n    'C': dept_vars['Ilias'] == dept_indices['Sales'],\n    'D': dept_vars['Weiss'] == dept_indices['Management'],\n    'E': dept_vars['Weiss'] == dept_indices['Production'],\n}\n\nfor letter, condition in options.items():\n    solver.push()\n    solver.add(condition)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Seven job applicants—Feng, Garcia, Herrera, Ilias, Weiss, Xavier, and Yates—are hired to fill seven new positions at Chroma, Inc. One position is in the management department, three are in the production department, and three are in the sales department. The following conditions must apply: Herrera is hired for a position in the same department as Yates. Feng is hired for a position in a different department from Garcia. If Xavier is hired for a sales position, then Weiss is hired for a production position. Feng is hired for a production position.\n\nIf Xavier is not hired for one of the production positions, then which one of the following could be true?\n\nOptions:\n(A) Feng and Herrera are both hired for sales positions.\n(B) Herrera and Weiss are both hired for sales positions.\n(C) Feng and Yates are both hired for production positions.\n(D) Garcia and Weiss are both hired for production positions.\n(E) Herrera and Weiss are both hired for production positions.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\napplicants = ['Feng', 'Garcia', 'Herrera', 'Ilias', 'Weiss', 'Xavier', 'Yates']\ndepartments = ['Management', 'Production', 'Sales']  # 0,1,2\n\n# Create variables: department assignment for each applicant\ndept = {a: Int(a) for a in applicants}\n\nsolver = Solver()\n\n# Each applicant's department is in [0..2]\nfor a in applicants:\n    solver.add(And(dept[a] >= 0, dept[a] < 3))\n\n# Department counts: 1 Management, 3 Production, 3 Sales\n# Count how many applicants assigned to each department\ndef count_dept(d):\n    return Sum([If(dept[a] == d, 1, 0) for a in applicants])\n\nsolver.add(count_dept(0) == 1)  # Management\nsolver.add(count_dept(1) == 3)  # Production\nsolver.add(count_dept(2) == 3)  # Sales\n\n# CONSTRAINTS\n\n# 1) Herrera is hired for a position in the same department as Yates\nsolver.add(dept['Herrera'] == dept['Yates'])\n\n# 2) Feng is hired for a position in a different department from Garcia\nsolver.add(dept['Feng'] != dept['Garcia'])\n\n# 3) If Xavier is hired for a sales position, then Weiss is hired for a production position\nsolver.add(Implies(dept['Xavier'] == 2, dept['Weiss'] == 1))\n\n# 4) Feng is hired for a production position\nsolver.add(dept['Feng'] == 1)\n\n# OPTION CHECKING\n\n# We want to check which option could be true if Xavier is NOT hired for production\n# So add constraint: Xavier is NOT in production (dept != 1)\nsolver.add(dept['Xavier'] != 1)\n\n# Define a helper function to check if a pair of applicants are both assigned to a given department\ndef both_in_department(a1, a2, d):\n    return And(dept[a1] == d, dept[a2] == d)\n\noptions = [\n    both_in_department('Feng', 'Herrera', 2),  # (A) both sales\n    both_in_department('Herrera', 'Weiss', 2), # (B) both sales\n    both_in_department('Feng', 'Yates', 1),    # (C) both production\n    both_in_department('Garcia', 'Weiss', 1),  # (D) both production\n    both_in_department('Herrera', 'Weiss', 1)  # (E) both production\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Musicians perform each of exactly five pieces—Nexus, Onyx, Synchrony, Tailwind, and Virtual—once, and one at a time; the pieces are performed successively (though not necessarily in that order). Each piece is performed with exactly two instruments: Nexus with fiddle and lute, Onyx with harp and mandolin, Synchrony with guitar and harp, Tailwind with fiddle and guitar, and Virtual with lute and mandolin. The following conditions must apply: Each piece shares one instrument with the piece performed immediately before it or after it (or both). Either Nexus or Tailwind is performed second.\n\nWhich one of the following could be the order, from first to last, in which the pieces are performed?\n\nOptions:\n(A) Nexus, Synchrony, Onyx, Virtual, Tailwind\n(B) Synchrony, Tailwind, Onyx, Nexus, Virtual\n(C) Tailwind, Nexus, Onyx, Virtual, Synchrony\n(D) Tailwind, Nexus, Synchrony, Onyx, Virtual\n(E) Virtual, Nexus, Synchrony, Onyx, Tailwind",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npieces = ['Nexus', 'Onyx', 'Synchrony', 'Tailwind', 'Virtual']\ninstruments_map = {\n    'Nexus': ['fiddle', 'lute'],\n    'Onyx': ['harp', 'mandolin'],\n    'Synchrony': ['guitar', 'harp'],\n    'Tailwind': ['fiddle', 'guitar'],\n    'Virtual': ['lute', 'mandolin']\n}\n\n# Map pieces to indices for Z3 variables\npiece_indices = {p: i for i, p in enumerate(pieces)}\n\n# Create a list of 5 Z3 Int variables representing the order of pieces performed\n# order[i] = index of piece performed at position i (0-based)\norder = [Int(f'order_{i}') for i in range(5)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each position must be a valid piece index\nfor pos in range(5):\n    solver.add(And(order[pos] >= 0, order[pos] < 5))\n\n# All pieces must be performed exactly once - all different\nsolver.add(Distinct(order))\n\n# Either Nexus or Tailwind is performed second (position 1)\nnexus_index = piece_indices['Nexus']\ntailwind_index = piece_indices['Tailwind']\nsolver.add(Or(order[1] == nexus_index, order[1] == tailwind_index))\n\n# Helper function to get instruments of a piece index\ndef get_instruments(piece_idx):\n    # Return the instruments list of the piece at piece_idx\n    # Since piece_idx is Z3 Int variable, we create a function that returns the instruments as sets for each piece index\n    # We'll do this check by constraints later\n    return instruments_map[pieces[piece_idx]]\n\n# Since we cannot do direct instrument lookup with Z3 Int, we create bool variables for each piece and instrument\n# Create a dictionary: piece_instrument[piece][instrument] = Bool indicating if piece has that instrument\nall_instruments = ['fiddle', 'lute', 'harp', 'mandolin', 'guitar']\npiece_instrument = {}\nfor p in pieces:\n    piece_instrument[p] = {}\n    for inst in all_instruments:\n        piece_instrument[p][inst] = inst in instruments_map[p]\n\n# For each adjacent pair in the order, the pieces must share exactly one instrument\n# Actually, the problem states: Each piece shares one instrument with the piece immediately before or after it (or both)\n# So for each position i, the piece at position i must share at least one instrument with piece at i-1 or i+1 (if they exist)\n# We'll model this condition for positions 0 to 4\n\n# To model the instruments of the pieces at positions i and j, we create functions to check if two pieces share an instrument\n\n# Create Int variables for instruments presence per piece index\n# We'll create a function that returns a set of instruments for a piece index\n\n# To check if two pieces share an instrument, we will create constraints that check if the instruments overlap\n\n# Create helper arrays of instrument presence per piece index for quick access\n# piece_instruments_matrix[piece_index][instrument_index] = Bool (True if piece has instrument)\ninstrument_indices = {inst: i for i, inst in enumerate(all_instruments)}\npiece_instruments_matrix = []\nfor p in pieces:\n    row = []\n    for inst in all_instruments:\n        row.append(BoolVal(inst in instruments_map[p]))\n    piece_instruments_matrix.append(row)\n\n# Function to get instrument presence Bool for piece variable (Z3 Int) and instrument index\n# Since piece variable is Z3 Int, we construct a piece_instrument presence by using If for each piece index\ndef has_instrument(piece_var, inst_idx):\n    # piece_var is Int variable (0..4)\n    # inst_idx is int\n    conds = []\n    for p_idx in range(5):\n        conds.append(If(piece_var == p_idx, piece_instruments_matrix[p_idx][inst_idx], False))\n    return Or(conds)\n\n# For each position i, piece at i must share at least one instrument with piece at i-1 or i+1 (if those exist)\nfor i in range(5):\n    piece_i = order[i]\n    neighbors = []\n    if i > 0:\n        neighbors.append(order[i-1])\n    if i < 4:\n        neighbors.append(order[i+1])\n    # For each neighbor, check if pieces share an instrument\n    share_instrument_with_neighbor = []\n    for neighbor in neighbors:\n        # Check if piece_i and neighbor share at least one instrument\n        # For each instrument, check if both pieces have it\n        shared_insts = []\n        for inst_idx in range(len(all_instruments)):\n            inst_in_piece_i = has_instrument(piece_i, inst_idx)\n            inst_in_neighbor = has_instrument(neighbor, inst_idx)\n            shared_insts.append(And(inst_in_piece_i, inst_in_neighbor))\n        share_instrument_with_neighbor.append(Or(shared_insts))\n    # i-th piece must share instrument with at least one neighbor\n    solver.add(Or(share_instrument_with_neighbor))\n\n# OPTION CHECKING\noptions = [\n    ['Nexus', 'Synchrony', 'Onyx', 'Virtual', 'Tailwind'],   # A\n    ['Synchrony', 'Tailwind', 'Onyx', 'Nexus', 'Virtual'],   # B\n    ['Tailwind', 'Nexus', 'Onyx', 'Virtual', 'Synchrony'],   # C\n    ['Tailwind', 'Nexus', 'Synchrony', 'Onyx', 'Virtual'],   # D\n    ['Virtual', 'Nexus', 'Synchrony', 'Onyx', 'Tailwind']    # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that order matches option\n    for pos in range(5):\n        solver.add(order[pos] == piece_indices[option[pos]])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Musicians perform each of exactly five pieces—Nexus, Onyx, Synchrony, Tailwind, and Virtual—once, and one at a time; the pieces are performed successively (though not necessarily in that order). Each piece is performed with exactly two instruments: Nexus with fiddle and lute, Onyx with harp and mandolin, Synchrony with guitar and harp, Tailwind with fiddle and guitar, and Virtual with lute and mandolin. The following conditions must apply: Each piece shares one instrument with the piece performed immediately before it or after it (or both). Either Nexus or Tailwind is performed second.\n\nWhich one of the following instruments CANNOT be shared by the third and fourth pieces performed?\n\nOptions:\n(A) fiddle\n(B) guitar\n(C) harp\n(D) lute\n(E) mandolin",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npieces = ['Nexus', 'Onyx', 'Synchrony', 'Tailwind', 'Virtual']\ninstruments = ['fiddle', 'lute', 'harp', 'mandolin', 'guitar']\n\n# Map pieces to their instruments (indices)\npiece_instruments = {\n    'Nexus': ['fiddle', 'lute'],\n    'Onyx': ['harp', 'mandolin'],\n    'Synchrony': ['guitar', 'harp'],\n    'Tailwind': ['fiddle', 'guitar'],\n    'Virtual': ['lute', 'mandolin']\n}\n\n# Create Z3 variables: position of each piece (0-based index)\npos = {p: Int(p) for p in pieces}\n\n# Create inverse: piece at each position\n# We'll create an array of Ints mapping position to piece index\npiece_index = {p: i for i, p in enumerate(pieces)}\n\npos_to_piece = [Int(f'pos_to_piece_{i}') for i in range(5)]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Positions between 0 and 4\nfor p in pieces:\n    solver.add(And(pos[p] >= 0, pos[p] < 5))\n\n# Positions are distinct (all pieces in different positions)\nsolver.add(Distinct([pos[p] for p in pieces]))\n\n# Link pos_to_piece and pos variables\n# For each position i, pos_to_piece[i] = index of piece at position i\nfor i in range(5):\n    # pos_to_piece[i] in 0..4\n    solver.add(And(pos_to_piece[i] >= 0, pos_to_piece[i] < 5))\n\n# For each piece p, pos_to_piece[pos[p]] == piece_index[p]\n# We encode this by ensuring that for each p and i:\n# If pos[p] == i then pos_to_piece[i] == piece_index[p]\n# This is a big set of implications:\nfor p in pieces:\n    for i in range(5):\n        solver.add(Implies(pos[p] == i, pos_to_piece[i] == piece_index[p]))\n\n# Also, each pos_to_piece[i] corresponds to exactly one piece\n# So pos_to_piece is a permutation of [0..4]\nsolver.add(Distinct(pos_to_piece))\n\n# Condition: Either Nexus or Tailwind is performed second (position 1)\nsolver.add(Or(pos['Nexus'] == 1, pos['Tailwind'] == 1))\n\n# Condition: Each piece shares one instrument with the piece immediately before or after it (or both)\n# For positions 0..4, for each piece at i, it must share one instrument with piece at i-1 or i+1 if those exist\n\n# Helper: function to get instruments of piece by index\ndef instruments_of_piece_index(idx):\n    # idx is Int in [0..4]\n    # We create a function that returns the set of instruments for that piece index\n    # But we can't do set operations in Z3, so we will do equality checks on instruments\n    # Instead, we will write a helper to check if two pieces share an instrument\n    return piece_instruments[pieces[idx]]\n\n# To check if two pieces share an instrument, we check if their instruments intersect\n\n# We'll write a helper function that returns a Bool expression whether two pieces share an instrument\ndef share_instrument(idx1, idx2):\n    # idx1 and idx2 are Int constants representing piece indices 0..4\n    # We will build Or of equal instruments\n    # For each instrument, check if it is in both pieces\n    # Since we have fixed pieces and instruments, we can check for each instrument\n    # The pieces are constants indexed by idx, so we can create constraints as:\n    # For each instrument, check if instrument in piece1 and in piece2\n    # We'll create a Bool expression that is True if any instrument is in both pieces\n\n    # For each instrument, check if it is in piece1 and in piece2\n    # We can do this by enumerating all 25 pairs of pieces and precomputing which share instruments\n    # But idx1 and idx2 are Z3 Int variables, so we need to encode this as a big Or of Ands\n\n    # We'll create a big Or over all pairs (pi, pj) where pi == idx1 and pj == idx2 and pieces share instrument\n\n    # Precompute pairs of piece indices that share instruments\n    shared_pairs = []\n    for i1 in range(5):\n        for i2 in range(5):\n            # Check if pieces[i1] and pieces[i2] share an instrument\n            inst1 = set(piece_instruments[pieces[i1]])\n            inst2 = set(piece_instruments[pieces[i2]])\n            if len(inst1.intersection(inst2)) > 0:\n                shared_pairs.append((i1, i2))\n\n    # Now create Or over (idx1 == i1 and idx2 == i2) for all (i1,i2) in shared_pairs\n    ors = []\n    for (i1, i2) in shared_pairs:\n        ors.append(And(idx1 == i1, idx2 == i2))\n    return Or(ors)\n\n# For positions 0..4, for piece at pos i, it must share an instrument with piece at i-1 or i+1 if those positions exist\nfor i in range(5):\n    # piece at position i: pos_to_piece[i]\n    neighbors = []\n    if i > 0:\n        neighbors.append(pos_to_piece[i-1])\n    if i < 4:\n        neighbors.append(pos_to_piece[i+1])\n\n    # If neighbors exist, piece at i shares instrument with at least one neighbor\n    if neighbors:\n        share_with_neighbors = []\n        for n in neighbors:\n            share_with_neighbors.append(share_instrument(pos_to_piece[i], n))\n        solver.add(Or(share_with_neighbors))\n\n# OPTION CHECKING\n# We check for each option whether the instrument can be shared by pieces 3 and 4 (positions 2 and 3)\n# Positions are 0-based, so 3rd piece is at pos 2, 4th piece at pos 3\n\n# We want to find which instrument CANNOT be shared by the third and fourth pieces performed\n# So for each instrument, we check if there is a solution where the pieces at pos 2 and 3 share that instrument\n# If no solution exists, that instrument cannot be shared\n\n# Helper: function to check if two pieces share a specific instrument\ndef share_specific_instrument(idx1, idx2, instrument):\n    # Returns a Bool expression that is True if both pieces have the instrument\n    # instrument is string, e.g. 'fiddle'\n    # Check if instrument in piece_instruments[pieces[idx1]] and in piece_instruments[pieces[idx2]]\n    # For all pairs (i1,i2), we create Or over (idx1==i1 and idx2==i2 and both have instrument)\n    ors = []\n    for i1 in range(5):\n        for i2 in range(5):\n            if instrument in piece_instruments[pieces[i1]] and instrument in piece_instruments[pieces[i2]]:\n                ors.append(And(idx1 == i1, idx2 == i2))\n    return Or(ors)\n\noptions = ['fiddle', 'guitar', 'harp', 'lute', 'mandolin']\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, instrument in enumerate(options):\n    solver.push()\n    # Add constraint: pieces at positions 2 and 3 share this instrument\n    solver.add(share_specific_instrument(pos_to_piece[2], pos_to_piece[3], instrument))\n    if solver.check() == sat:\n        # This instrument can be shared by 3rd and 4th pieces\n        solver.pop()\n    else:\n        # This instrument cannot be shared\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Musicians perform each of exactly five pieces—Nexus, Onyx, Synchrony, Tailwind, and Virtual—once, and one at a time; the pieces are performed successively (though not necessarily in that order). Each piece is performed with exactly two instruments: Nexus with fiddle and lute, Onyx with harp and mandolin, Synchrony with guitar and harp, Tailwind with fiddle and guitar, and Virtual with lute and mandolin. The following conditions must apply: Each piece shares one instrument with the piece performed immediately before it or after it (or both). Either Nexus or Tailwind is performed second.\n\nEach of the following could be the piece performed first EXCEPT:\n\nOptions:\n(A) Nexus\n(B) Onyx\n(C) Synchrony\n(D) Tailwind\n(E) Virtual",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npieces = ['Nexus', 'Onyx', 'Synchrony', 'Tailwind', 'Virtual']\ninstruments = ['fiddle', 'lute', 'harp', 'mandolin', 'guitar']\n\n# Map pieces to instruments indices\npiece_instruments = {\n    'Nexus': ['fiddle', 'lute'],\n    'Onyx': ['harp', 'mandolin'],\n    'Synchrony': ['guitar', 'harp'],\n    'Tailwind': ['fiddle', 'guitar'],\n    'Virtual': ['lute', 'mandolin']\n}\n\n# Convert instrument names to indices for easier comparison\ninstr_index = {instr: i for i, instr in enumerate(instruments)}\npiece_instr_indices = {\n    p: [instr_index[i] for i in piece_instruments[p]]\n    for p in pieces\n}\n\n# Positions 0 to 4 for the 5 pieces\npositions = range(5)\n\n# Create variables: piece_at_pos[i] gives the piece index performed at position i\npiece_at_pos = [Int(f'pos_{i}') for i in positions]\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each position has a piece index between 0 and 4\nfor pos in positions:\n    solver.add(And(piece_at_pos[pos] >= 0, piece_at_pos[pos] < len(pieces)))\n\n# All pieces are performed exactly once - all positions distinct\nsolver.add(Distinct(piece_at_pos))\n\n# Either Nexus or Tailwind is performed second (position 1)\nnexus_idx = pieces.index('Nexus')\ntailwind_idx = pieces.index('Tailwind')\nsolver.add(Or(piece_at_pos[1] == nexus_idx, piece_at_pos[1] == tailwind_idx))\n\n# Helper function: pieces share one instrument\ndef share_instrument(p1_idx, p2_idx):\n    # Get instruments of p1 and p2\n    p1_instr = piece_instr_indices[pieces[p1_idx]]\n    p2_instr = piece_instr_indices[pieces[p2_idx]]\n    # They share one instrument if intersection of their instrument lists is not empty\n    # Create a BoolExpr that is True if any instrument matches\n    shared = []\n    for i1 in p1_instr:\n        for i2 in p2_instr:\n            shared.append(i1 == i2)\n    return Or(shared)\n\n# Constraint: Each piece shares one instrument with piece immediately before or after (or both)\nfor pos in positions:\n    # For each position, get piece index variable\n    curr = piece_at_pos[pos]\n    neighbors = []\n    if pos > 0:\n        neighbors.append(piece_at_pos[pos-1])\n    if pos < 4:\n        neighbors.append(piece_at_pos[pos+1])\n    # For each neighbor, check if shares instrument\n    # At least one neighbor shares instrument with current piece\n    share_bools = []\n    for neighbor in neighbors:\n        # We need to encode share_instrument(curr, neighbor) as Z3 constraints\n        # Because curr and neighbor are variables, we must encode the condition with Ifs\n        # We'll build a big Or over all possible pairs of piece indices where instruments share\n        # For each pair of pieces, precompute if they share instrument\n        share_cases = []\n        for p1 in range(len(pieces)):\n            for p2 in range(len(pieces)):\n                if p1 == p2:\n                    # Same piece, instruments obviously shared\n                    share = True\n                else:\n                    # Check if they share instrument\n                    instrs1 = set(piece_instr_indices[pieces[p1]])\n                    instrs2 = set(piece_instr_indices[pieces[p2]])\n                    share = len(instrs1.intersection(instrs2)) > 0\n                # If curr==p1 and neighbor==p2 then share_instrument is share\n                share_cases.append(And(curr == p1, neighbor == p2, share))\n        share_bools.append(Or(share_cases))\n    # At least one neighbor shares instrument with current piece\n    solver.add(Or(share_bools))\n\n# OPTION CHECKING\n# We want to find which option cannot be first piece performed (position 0)\n# Test each option: add constraint piece_at_pos[0] == option_idx and check satisfiability\noptions = ['Nexus', 'Onyx', 'Synchrony', 'Tailwind', 'Virtual']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(piece_at_pos[0] == pieces.index(opt))\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Musicians perform each of exactly five pieces—Nexus, Onyx, Synchrony, Tailwind, and Virtual—once, and one at a time; the pieces are performed successively (though not necessarily in that order). Each piece is performed with exactly two instruments: Nexus with fiddle and lute, Onyx with harp and mandolin, Synchrony with guitar and harp, Tailwind with fiddle and guitar, and Virtual with lute and mandolin. The following conditions must apply: Each piece shares one instrument with the piece performed immediately before it or after it (or both). Either Nexus or Tailwind is performed second.\n\nIf Synchrony is performed fifth, then which one of the following could be true?\n\nOptions:\n(A) Nexus is performed third.\n(B) Onyx is performed third.\n(C) Tailwind is performed fourth.\n(D) Virtual is performed first.\n(E) Virtual is performed second.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\npieces = ['Nexus', 'Onyx', 'Synchrony', 'Tailwind', 'Virtual']\ninstruments = ['fiddle', 'lute', 'harp', 'mandolin', 'guitar']\n\n# Map pieces to their instruments (indices)\npiece_instruments = {\n    'Nexus': ['fiddle', 'lute'],\n    'Onyx': ['harp', 'mandolin'],\n    'Synchrony': ['guitar', 'harp'],\n    'Tailwind': ['fiddle', 'guitar'],\n    'Virtual': ['lute', 'mandolin']\n}\n\n# Create index mappings for instruments\ninstr_index = {instr: i for i, instr in enumerate(instruments)}\n\n# Convert piece instruments to sets of indices for easier constraints\npiece_instr_indices = {}\nfor p in pieces:\n    piece_instr_indices[p] = set(instr_index[i] for i in piece_instruments[p])\n\n# Variables: position of each piece (1 to 5)\npos = {p: Int(p) for p in pieces}\n\n# Also inverse: piece at each position (0-based index for convenience)\n# We'll create an array of 5 elements, each is a piece index (0..4)\npos_values = [Int(f'pos_{i+1}') for i in range(5)]\n\n# Map piece to index\npiece_index = {p: i for i, p in enumerate(pieces)}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Positions are between 1 and 5\nfor p in pieces:\n    solver.add(And(pos[p] >= 1, pos[p] <= 5))\n\n# All pieces have distinct positions\nsolver.add(Distinct([pos[p] for p in pieces]))\n\n# Link pos_values and pos: pos_values[i] == piece index at position i+1\nfor i in range(5):\n    # pos_values[i] in 0..4\n    solver.add(And(pos_values[i] >= 0, pos_values[i] < 5))\n\n# Each piece appears exactly once in pos_values\nsolver.add(Distinct(pos_values))\n\n# Link pos and pos_values\nfor p in pieces:\n    # pos[p] - 1 == index where pos_values equals piece_index[p]\n    # Implement: pos[p] -1 == the position in pos_values where piece_index[p] occurs\n    # We encode this by:\n    # For each i in 0..4: pos[p] == i+1 iff pos_values[i] == piece_index[p]\n    # Use Or over i\n    solver.add(Or([And(pos[p] == i+1, pos_values[i] == piece_index[p]) for i in range(5)]))\n\n# Constraint: Either Nexus or Tailwind is performed second\nsolver.add(Or(pos['Nexus'] == 2, pos['Tailwind'] == 2))\n\n# Constraint: Each piece shares one instrument with the piece immediately before or after it (or both)\n# For positions 1 to 5, check neighbors for shared instrument\n# For i in 1..5, check piece at pos i and neighbors (i-1 and i+1 if exist)\n# We express this on pos_values array\nfor i in range(5):\n    # piece at position i\n    p_idx = pos_values[i]\n    # neighbors indices\n    neighbors = []\n    if i > 0:\n        neighbors.append(pos_values[i-1])\n    if i < 4:\n        neighbors.append(pos_values[i+1])\n    # For each neighbor, check if share instrument with p_idx\n    # We encode: Or over neighbors of (share instrument)\n    # share instrument means intersection of instruments sets not empty\n    # We'll create a helper function to encode share instrument between two piece indices\n    def share_instrument_expr(p1_idx, p2_idx):\n        # p1_idx and p2_idx are Int variables 0..4\n        # We encode as Or over all instruments: instrument in both pieces\n        ors = []\n        for instr_i in range(len(instruments)):\n            # instr_i in piece_instr_indices[p1] and instr_i in piece_instr_indices[p2]\n            # To encode membership, we create Bool constants for each piece and instrument\n            # Since piece_instr_indices is fixed, we can encode membership as constants\n            # So we encode: (instr_i in piece_instr_indices[p1]) and (instr_i in piece_instr_indices[p2])\n            # Because p1_idx and p2_idx are variables, we need to encode membership based on piece index\n            # We'll create a function that returns True if instr_i in piece_instr_indices[piece]\n            # So for each piece index, we have a set of instruments\n            # We'll encode membership as Or over piece indices with that instrument\n            # But since p1_idx and p2_idx are variables, we check if both pieces have instr_i\n            # Encode: And(Or over pieces with instr_i for p1_idx, Or over pieces with instr_i for p2_idx)\n            # Actually simpler: For each piece index, we know if it has instr_i or not\n            # We encode membership as equality to piece indices that have instr_i\n            # So for p1_idx: Or([p1_idx == idx for idx in pieces_with_instr_i])\n            pieces_with_instr_i = [piece_index[p] for p in pieces if instr_i in piece_instr_indices[p]]\n            p1_has = Or([p1_idx == idx for idx in pieces_with_instr_i]) if pieces_with_instr_i else False\n            p2_has = Or([p2_idx == idx for idx in pieces_with_instr_i]) if pieces_with_instr_i else False\n            ors.append(And(p1_has, p2_has))\n        return Or(ors)\n    # At least one neighbor shares instrument\n    neighbor_shares = [share_instrument_expr(p_idx, n_idx) for n_idx in neighbors]\n    solver.add(Or(neighbor_shares))\n\n# Synchrony is performed fifth (given condition)\nsolver.add(pos['Synchrony'] == 5)\n\n# OPTION CHECKING\noptions = [\n    ('A', pos['Nexus'] == 3),\n    ('B', pos['Onyx'] == 3),\n    ('C', pos['Tailwind'] == 4),\n    ('D', pos['Virtual'] == 1),\n    ('E', pos['Virtual'] == 2)\n]\n\nfor letter, cond in options:\n    solver.push()\n    solver.add(cond)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Eight files will be ordered from first to eighth. Each file falls into exactly one of three categories: red files (H, M, O), green files (P, V, X), or yellow files (T, Z). The files must be ordered according to the following conditions: H must be placed into some position before O, but H cannot immediately precede O. X must be placed into some position before V. X and V must be separated by the same number of files as separate H and O. Z must immediately precede M. The first file cannot be a red file.\n\nWhich one of the following is an acceptable ordering of the files from first to eighth?\n\nOptions:\n(A) H X O V Z M P T\n(B) P M Z H X O V T\n(C) P Z M H O T X V\n(D) X Z M V H T P O\n(E) Z M H P O X V T",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfiles = ['H', 'M', 'O', 'P', 'V', 'X', 'T', 'Z']\npositions = {f: Int(f) for f in files}\n\n# Categories\nred_files = ['H', 'M', 'O']\ngreen_files = ['P', 'V', 'X']\nyellow_files = ['T', 'Z']\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are between 1 and 8\nfor f in files:\n    solver.add(And(positions[f] >= 1, positions[f] <= 8))\n\n# All positions are distinct\nsolver.add(Distinct([positions[f] for f in files]))\n\n# H must be before O, but cannot immediately precede O\nsolver.add(positions['H'] < positions['O'])\nsolver.add(positions['O'] - positions['H'] != 1)\n\n# X must be before V\nsolver.add(positions['X'] < positions['V'])\n\n# X and V must be separated by the same number of files as H and O\n# Distance between X and V = positions['V'] - positions['X'] -1\n# Distance between H and O = positions['O'] - positions['H'] -1\ndist_HO = positions['O'] - positions['H'] - 1\ndist_XV = positions['V'] - positions['X'] - 1\nsolver.add(dist_HO == dist_XV)\n\n# Z must immediately precede M\nsolver.add(positions['Z'] + 1 == positions['M'])\n\n# The first file cannot be a red file\n# So no red file is in position 1\nfor f in red_files:\n    solver.add(positions[f] != 1)\n\n# OPTION CHECKING\noptions = [\n    ['H', 'X', 'O', 'V', 'Z', 'M', 'P', 'T'], # A\n    ['P', 'M', 'Z', 'H', 'X', 'O', 'V', 'T'], # B\n    ['P', 'Z', 'M', 'H', 'O', 'T', 'X', 'V'], # C\n    ['X', 'Z', 'M', 'V', 'H', 'T', 'P', 'O'], # D\n    ['Z', 'M', 'H', 'P', 'O', 'X', 'V', 'T'], # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints that positions match the option order\n    for pos, f in enumerate(option, start=1):\n        solver.add(positions[f] == pos)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Eight files will be ordered from first to eighth. Each file falls into exactly one of three categories: red files (H, M, O), green files (P, V, X), or yellow files (T, Z). The files must be ordered according to the following conditions: H must be placed into some position before O, but H cannot immediately precede O. X must be placed into some position before V. X and V must be separated by the same number of files as separate H and O. Z must immediately precede M. The first file cannot be a red file.\n\nThe largest possible number of files that can separate Z from H is\n\nOptions:\n(A) two\n(B) three\n(C) four\n(D) five\n(E) six",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfiles = ['H', 'M', 'O', 'P', 'V', 'X', 'T', 'Z']\ncategories = {\n    'H': 'red',\n    'M': 'red',\n    'O': 'red',\n    'P': 'green',\n    'V': 'green',\n    'X': 'green',\n    'T': 'yellow',\n    'Z': 'yellow'\n}\npositions = {f: Int(f) for f in files}  # position of each file (1 to 8)\n\n# Helper function to get category indices\ndef is_red(f):\n    return categories[f] == 'red'\n\ndef is_green(f):\n    return categories[f] == 'green'\n\ndef is_yellow(f):\n    return categories[f] == 'yellow'\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions must be between 1 and 8\nfor f in files:\n    solver.add(And(positions[f] >= 1, positions[f] <= 8))\n\n# All positions distinct\nsolver.add(Distinct([positions[f] for f in files]))\n\n# H must be before O\nsolver.add(positions['H'] < positions['O'])\n\n# H cannot immediately precede O\nsolver.add(positions['H'] + 1 != positions['O'])\n\n# X must be before V\nsolver.add(positions['X'] < positions['V'])\n\n# X and V must be separated by the same number of files as H and O\n# Number of files separating two files = absolute difference of positions - 1\nsep_HO = positions['O'] - positions['H'] - 1\nsep_XV = positions['V'] - positions['X'] - 1\nsolver.add(sep_HO == sep_XV)\n\n# Z must immediately precede M\nsolver.add(positions['Z'] + 1 == positions['M'])\n\n# The first file cannot be a red file\n# The file at position 1 is not red\n# So for all red files f, positions[f] != 1\nfor f in files:\n    if is_red(f):\n        solver.add(positions[f] != 1)\n\n# We want to find the largest possible number of files that can separate Z from H\n# That is, maximize abs(positions['Z'] - positions['H']) -1\n\n# We will check each option from largest to smallest (E to A) to find the maximum possible separation\n\noptions = {\n    'A': 2,\n    'B': 3,\n    'C': 4,\n    'D': 5,\n    'E': 6\n}\n\n# Check options from largest to smallest\nfor letter in ['E', 'D', 'C', 'B', 'A']:\n    solver.push()\n    sep = options[letter]\n    # abs(positions['Z'] - positions['H']) - 1 == sep\n    diff = positions['Z'] - positions['H']\n    abs_diff = If(diff >= 0, diff, -diff)\n    solver.add(abs_diff - 1 == sep)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Eight files will be ordered from first to eighth. Each file falls into exactly one of three categories: red files (H, M, O), green files (P, V, X), or yellow files (T, Z). The files must be ordered according to the following conditions: H must be placed into some position before O, but H cannot immediately precede O. X must be placed into some position before V. X and V must be separated by the same number of files as separate H and O. Z must immediately precede M. The first file cannot be a red file.\n\nIf each of the three red files is immediately followed by a green file, which one of the following must be a yellow file?\n\nOptions:\n(A) the first\n(B) the second\n(C) the third\n(D) the fourth\n(E) the fifth",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfiles = ['H', 'M', 'O', 'P', 'V', 'X', 'T', 'Z']\ncategories = {'H': 'red', 'M': 'red', 'O': 'red',\n              'P': 'green', 'V': 'green', 'X': 'green',\n              'T': 'yellow', 'Z': 'yellow'}\n\npositions = {f: Int(f) for f in files}  # position of each file (1 to 8)\n\n# List of all positions variables\npos_vars = [positions[f] for f in files]\n\n# Solver instance\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Positions are between 1 and 8\nfor p in pos_vars:\n    solver.add(And(p >= 1, p <= 8))\n\n# All positions distinct\nsolver.add(Distinct(pos_vars))\n\n# H before O, but H cannot immediately precede O\nsolver.add(positions['H'] < positions['O'])\nsolver.add(positions['H'] + 1 != positions['O'])\n\n# X before V\nsolver.add(positions['X'] < positions['V'])\n\n# X and V separated by same number of files as separate H and O\n# Separation means number of files between them = abs(pos1 - pos2) - 1\nsep_HO = positions['O'] - positions['H'] - 1\nsep_XV = positions['V'] - positions['X'] - 1\nsolver.add(sep_HO == sep_XV)\n\n# Z immediately precedes M\nsolver.add(positions['Z'] + 1 == positions['M'])\n\n# The first file cannot be a red file\n# So no file with category red can be in position 1\nfor f in files:\n    if categories[f] == 'red':\n        solver.add(positions[f] != 1)\n\n# Additional condition for the question:\n# Each of the three red files (H, M, O) is immediately followed by a green file.\n# So for each red file R, there exists a green file G such that positions[G] == positions[R] + 1\nred_files = ['H', 'M', 'O']\ngreen_files = ['P', 'V', 'X']\n\n# We must ensure for each red file R, that the file immediately after R is a green file.\n# Since each file has a unique position, we can express that for each red file R,\n# there exists a green file G such that positions[G] == positions[R] + 1,\n# and this G is unique per red file (no overlap needed because positions are unique).\n\n# For each red file, create a constraint that the file immediately after is green\nfor r in red_files:\n    # Create a list of conditions: positions[g] == positions[r] + 1 for g in green_files\n    conds = [positions[g] == positions[r] + 1 for g in green_files]\n    solver.add(Or(conds))\n\n# OPTION CHECKING\n# We want to find which position must be a yellow file.\n# Positions are from 1 to 8.\n# The question options are:\n# (A) the first (position 1)\n# (B) the second (position 2)\n# (C) the third (position 3)\n# (D) the fourth (position 4)\n# (E) the fifth (position 5)\n\noptions = [1, 2, 3, 4, 5]\noption_letters = ['A', 'B', 'C', 'D', 'E']\n\n# For each option, check if the file at that position must be yellow.\n# To check \"must be\", we check if the negation is unsat.\n# That is, if we add a constraint that the file at that position is NOT yellow,\n# and the solver says unsat, then it must be yellow.\n\nfor i, pos_check in enumerate(options):\n    solver.push()\n    # Add constraint: the file at position pos_check is NOT yellow\n    # That means: For all files f, if positions[f] == pos_check, then categories[f] != 'yellow'\n    # Since only one file can be at pos_check, we can express this as:\n    # For all files f, (positions[f] == pos_check) => categories[f] != 'yellow'\n    # categories are strings, so we cannot directly add constraints with strings.\n    # Instead, we add a constraint that the file at pos_check is from red or green categories.\n\n    # Build list of files that are NOT yellow\n    not_yellow_files = [f for f in files if categories[f] != 'yellow']\n    # The file at pos_check must be one of not_yellow_files\n    # So: Or(positions[f] == pos_check for f in not_yellow_files)\n    solver.add(Or([positions[f] == pos_check for f in not_yellow_files]))\n    if solver.check() == unsat:\n        print(f\"'{option_letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Eight files will be ordered from first to eighth. Each file falls into exactly one of three categories: red files (H, M, O), green files (P, V, X), or yellow files (T, Z). The files must be ordered according to the following conditions: H must be placed into some position before O, but H cannot immediately precede O. X must be placed into some position before V. X and V must be separated by the same number of files as separate H and O. Z must immediately precede M. The first file cannot be a red file.\n\nThe largest possible number of files that can separate X from V is\n\nOptions:\n(A) three\n(B) four\n(C) five\n(D) six\n(E) seven",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfiles = ['H', 'M', 'O', 'P', 'V', 'X', 'T', 'Z']\npositions = {f: Int(f) for f in files}\n\ncolors = {\n    'H': 'red', 'M': 'red', 'O': 'red',\n    'P': 'green', 'V': 'green', 'X': 'green',\n    'T': 'yellow', 'Z': 'yellow'\n}\n\n# We have 8 positions: 1 to 8\npos_min = 1\npos_max = 8\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each file occupies a unique position from 1 to 8\nfor f in files:\n    solver.add(And(positions[f] >= pos_min, positions[f] <= pos_max))\nsolver.add(Distinct([positions[f] for f in files]))\n\n# H must be before O, but H cannot immediately precede O\nsolver.add(positions['H'] < positions['O'])\nsolver.add(positions['O'] - positions['H'] > 1)\n\n# X must be before V\nsolver.add(positions['X'] < positions['V'])\n\n# X and V must be separated by the same number of files as separate H and O\n# Number of files between X and V = positions[V] - positions[X] - 1\n# Number of files between H and O = positions[O] - positions[H] - 1\nnum_between_HO = positions['O'] - positions['H'] - 1\nnum_between_XV = positions['V'] - positions['X'] - 1\nsolver.add(num_between_XV == num_between_HO)\n\n# Z must immediately precede M\nsolver.add(positions['Z'] + 1 == positions['M'])\n\n# The first file cannot be a red file\n# Red files are H, M, O\n# So positions of these cannot be 1\nfor f in ['H', 'M', 'O']:\n    solver.add(positions[f] != 1)\n\n# OPTION CHECKING\n# We want to find the largest possible number of files separating X and V\n# That is num_between_XV = positions[V] - positions[X] - 1\n\n# Possible maximum number of files between X and V can be from 0 to 7 (max 7 files between first and last)\n\n# We will check options from largest to smallest to find the maximum that is satisfiable\n\noptions = {\n    'A': 3,\n    'B': 4,\n    'C': 5,\n    'D': 6,\n    'E': 7\n}\n\n# Check from largest to smallest to find the maximum satisfiable\nfor letter in ['E', 'D', 'C', 'B', 'A']:\n    solver.push()\n    solver.add(num_between_XV == options[letter])\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Exactly three employees of Capital Enterprises—Maria, Suki, and Tate—attend a three-day conference together. Each day, there are exactly three sessions on the three topics of the conference—one on hiring, one on investing, and one on regulations. The following rules govern the conference: Each conference participant attends exactly two sessions, which are on different topics and on different days. Neither Maria nor Suki attends any session on investing. Tate does not attend any session on the third day. At most two Capital employees attend any given session together.\n\nWhat is the maximum number of sessions attended by at least one Capital employee?\n\nOptions:\n(A) three\n(B) four\n(C) five\n(D) six\n(E) seven",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['Maria', 'Suki', 'Tate']\ndays = [0, 1, 2]  # 0=Day1,1=Day2,2=Day3\ntopics = ['Hiring', 'Investing', 'Regulations']\n\nnum_days = len(days)\nnum_topics = len(topics)\n\n# Create variables: attendance[e][d][t] = Bool indicating if employee e attends session (d,t)\nattendance = {}\nfor e in employees:\n    for d in days:\n        for t in range(num_topics):\n            attendance[(e,d,t)] = Bool(f\"{e}_{d}_{t}\")\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each employee attends exactly two sessions on different days and different topics\nfor e in employees:\n    # Count of sessions attended = 2\n    sessions = [attendance[(e,d,t)] for d in days for t in range(num_topics)]\n    solver.add(Sum([If(s, 1, 0) for s in sessions]) == 2)\n    \n    # Sessions attended must be on different days\n    # So the two sessions must have different days\n    # Also different topics\n    # Extract all pairs of sessions attended and ensure no two are on same day or same topic\n    # Because only two sessions, just enforce that the two sessions differ in day and topic\n    # To do this, collect all sessions attended, and enforce that if two are attended, days and topics differ\n    \n    # We can collect the list of attended sessions as pairs (d,t)\n    # But Z3 can't easily iterate over Bool variables to find pairs directly\n    # So let's create helper variables for the two sessions attended:\n    # We can model the two sessions attended by e as two pairs of (day, topic)\n    # But that is complex; instead, we enforce that no two attended sessions share day or topic\n    \n    # For all pairs of sessions for employee e:\n    session_indices = [(d,t) for d in days for t in range(num_topics)]\n    for i in range(len(session_indices)):\n        for j in range(i+1, len(session_indices)):\n            d1,t1 = session_indices[i]\n            d2,t2 = session_indices[j]\n            s1 = attendance[(e,d1,t1)]\n            s2 = attendance[(e,d2,t2)]\n            # If both sessions attended, then days differ and topics differ\n            solver.add(Implies(And(s1, s2), And(d1 != d2, t1 != t2)))\n\n# Neither Maria nor Suki attends any session on investing (topic index 1)\nfor e in ['Maria', 'Suki']:\n    for d in days:\n        solver.add(attendance[(e,d,1)] == False)\n\n# Tate does not attend any session on the third day (day index 2)\nfor t in range(num_topics):\n    solver.add(attendance[('Tate', 2, t)] == False)\n\n# At most two employees attend any given session together\nfor d in days:\n    for t in range(num_topics):\n        attendees = [attendance[(e,d,t)] for e in employees]\n        solver.add(Sum([If(a,1,0) for a in attendees]) <= 2)\n\n# OPTION CHECKING\n# We want to find the maximum number of sessions attended by at least one Capital employee\n# There are 3 days * 3 topics = 9 sessions total\n# For each possible number from 7 down to 3 (options E to A), check if possible\n\n# Create variables for session attended by any employee\nsession_attended = {}\nfor d in days:\n    for t in range(num_topics):\n        session_attended[(d,t)] = Bool(f\"session_{d}_{t}_attended\")\n        # session_attended is True if any employee attends that session\n        attendees = [attendance[(e,d,t)] for e in employees]\n        solver.add(session_attended[(d,t)] == Or(attendees))\n\n# Check from highest option down to lowest, only one correct option\noptions = [('A',3), ('B',4), ('C',5), ('D',6), ('E',7)]\n\nfor letter, val in reversed(options):\n    solver.push()\n    # At least val sessions attended by someone\n    solver.add(Sum([If(session_attended[(d,t)],1,0) for d in days for t in range(num_topics)]) >= val)\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Exactly three employees of Capital Enterprises—Maria, Suki, and Tate—attend a three-day conference together. Each day, there are exactly three sessions on the three topics of the conference—one on hiring, one on investing, and one on regulations. The following rules govern the conference: Each conference participant attends exactly two sessions, which are on different topics and on different days. Neither Maria nor Suki attends any session on investing. Tate does not attend any session on the third day. At most two Capital employees attend any given session together.\n\nWhich one of the following must be false?\n\nOptions:\n(A) Maria attends sessions only on the first two days.\n(B) Suki attends sessions only on the last two days.\n(C) Exactly two Capital employees attend a session together on the second day.\n(D) Exactly one session is attended by one or more Capital employees on the second day.\n(E) Exactly three sessions are attended by one or more Capital employees on the third day.",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['Maria', 'Suki', 'Tate']\ndays = [0, 1, 2]  # 0=Day1, 1=Day2, 2=Day3\ntopics = ['Hiring', 'Investing', 'Regulations']\n\n# Each employee attends exactly two sessions on different days and different topics\n# Represent attendance as a Bool variable: attend[employee][day][topic]\nattend = {}\nfor e in employees:\n    for d in days:\n        for t in topics:\n            attend[(e, d, t)] = Bool(f\"{e}_{d}_{t}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each employee attends exactly two sessions\nfor e in employees:\n    sessions = [attend[(e, d, t)] for d in days for t in topics]\n    solver.add(Sum([If(s, 1, 0) for s in sessions]) == 2)\n\n# 2. Each employee's two sessions are on different days\nfor e in employees:\n    for d in days:\n        sessions_on_day = [attend[(e, d, t)] for t in topics]\n        solver.add(Sum([If(s, 1, 0) for s in sessions_on_day]) <= 1)\n\n# 3. Each employee's two sessions are on different topics\nfor e in employees:\n    for t in topics:\n        sessions_on_topic = [attend[(e, d, t)] for d in days]\n        solver.add(Sum([If(s, 1, 0) for s in sessions_on_topic]) <= 1)\n\n# 4. Neither Maria nor Suki attends any session on investing\nfor e in ['Maria', 'Suki']:\n    for d in days:\n        solver.add(attend[(e, d, 'Investing')] == False)\n\n# 5. Tate does not attend any session on the third day (day 2)\nfor t in topics:\n    solver.add(attend[('Tate', 2, t)] == False)\n\n# 6. At most two Capital employees attend any given session together\nfor d in days:\n    for t in topics:\n        attendees = [attend[(e, d, t)] for e in employees]\n        solver.add(Sum([If(a, 1, 0) for a in attendees]) <= 2)\n\n# OPTION CHECKING\n\n# We will check each option by adding its condition and checking if the model is satisfiable.\n# If adding the option's condition leads to unsat, it must be false.\n\n# Helper functions for options:\n\ndef option_A():\n    # Maria attends sessions only on the first two days (day 0 and 1)\n    # So Maria attends no sessions on day 2\n    for t in topics:\n        if solver.check(attend[('Maria', 2, t)] == True) == sat:\n            # If Maria can attend on day 2, then option A is false\n            pass\n    # Add constraint: Maria attends no sessions on day 2\n    return And([attend[('Maria', 2, t)] == False for t in topics])\n\ndef option_B():\n    # Suki attends sessions only on the last two days (day 1 and 2)\n    # So Suki attends no sessions on day 0\n    return And([attend[('Suki', 0, t)] == False for t in topics])\n\ndef option_C():\n    # Exactly two Capital employees attend a session together on the second day (day 1)\n    # So there exists a session on day 1 with exactly two attendees\n    # and no session on day 1 has three attendees (impossible anyway)\n    # and at least one session on day 1 has exactly two attendees\n    # and others can have 0,1 or 2 attendees\n    two_attendees_sessions = []\n    for t in topics:\n        attendees = [attend[(e, 1, t)] for e in employees]\n        count = Sum([If(a, 1, 0) for a in attendees])\n        two_attendees_sessions.append(count == 2)\n    # Exactly one or more sessions with exactly two attendees on day 1\n    # Option says \"Exactly two Capital employees attend a session together on the second day.\"\n    # This means at least one session has exactly two attendees.\n    # The option wording is ambiguous if it means exactly one such session or at least one.\n    # We interpret it as at least one session with exactly two attendees.\n    return Or(two_attendees_sessions)\n\ndef option_D():\n    # Exactly one session is attended by one or more Capital employees on the second day (day 1)\n    # Count how many sessions on day 1 have >=1 attendees\n    sessions_with_attendees = []\n    for t in topics:\n        attendees = [attend[(e, 1, t)] for e in employees]\n        count = Sum([If(a, 1, 0) for a in attendees])\n        sessions_with_attendees.append(count >= 1)\n    # Exactly one session on day 1 has attendees\n    return PbEq([(s, 1) for s in sessions_with_attendees], 1)\n\ndef option_E():\n    # Exactly three sessions are attended by one or more Capital employees on the third day (day 2)\n    # There are exactly 3 sessions per day, so this means all 3 sessions on day 3 have at least one attendee\n    sessions_with_attendees = []\n    for t in topics:\n        attendees = [attend[(e, 2, t)] for e in employees]\n        count = Sum([If(a, 1, 0) for a in attendees])\n        sessions_with_attendees.append(count >= 1)\n    # Exactly three sessions have attendees on day 3\n    return PbEq([(s, 1) for s in sessions_with_attendees], 3)\n\noptions = [option_A(), option_B(), option_C(), option_D(), option_E()]\n\nletters = ['A', 'B', 'C', 'D', 'E']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == unsat:\n        print(f\"'{letters[i]}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Exactly three employees of Capital Enterprises—Maria, Suki, and Tate—attend a three-day conference together. Each day, there are exactly three sessions on the three topics of the conference—one on hiring, one on investing, and one on regulations. The following rules govern the conference: Each conference participant attends exactly two sessions, which are on different topics and on different days. Neither Maria nor Suki attends any session on investing. Tate does not attend any session on the third day. At most two Capital employees attend any given session together.\n\nEach of the following is possible EXCEPT:\n\nOptions:\n(A) Every session attended by at least one Capital employee is attended by exactly one Capital employee.\n(B) Every session attended by at least one Capital employee is attended by exactly two Capital employees.\n(C) Every session attended by Maria is also attended by Suki.\n(D) Every session attended by Suki is also attended by Tate.\n(E) Every session attended by Tate is also attended by Maria.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['Maria', 'Suki', 'Tate']\ndays = [0, 1, 2]  # 0=Day1, 1=Day2, 2=Day3\ntopics = ['Hiring', 'Investing', 'Regulations']\n\nnum_employees = len(employees)\nnum_days = len(days)\nnum_topics = len(topics)\n\n# Create variables: attendance[e][d][t] = Bool indicating if employee e attends session on day d, topic t\nattendance = {}\nfor e in employees:\n    for d in days:\n        for t in topics:\n            attendance[(e, d, t)] = Bool(f\"{e}_{d}_{t}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each employee attends exactly two sessions\nfor e in employees:\n    sess = [attendance[(e, d, t)] for d in days for t in topics]\n    solver.add(Sum([If(s, 1, 0) for s in sess]) == 2)\n\n# 2) The two sessions attended by each employee are on different days and different topics\nfor e in employees:\n    # For all pairs of sessions, if both attended, days and topics differ\n    for d1 in days:\n        for t1 in topics:\n            for d2 in days:\n                for t2 in topics:\n                    if d1 == d2 and t1 == t2:\n                        continue\n                    # If both sessions attended, then d1 != d2 and t1 != t2\n                    # So if both attended, then d1 != d2 and t1 != t2\n                    # Contrapositive: if d1 == d2 or t1 == t2 then not both attended\n                    same_day = (d1 == d2)\n                    same_topic = (t1 == t2)\n                    if same_day or same_topic:\n                        solver.add(Or(Not(attendance[(e, d1, t1)]), Not(attendance[(e, d2, t2)])))\n\n# 3) Neither Maria nor Suki attends any session on investing\nfor e in ['Maria', 'Suki']:\n    for d in days:\n        solver.add(attendance[(e, d, 'Investing')] == False)\n\n# 4) Tate does not attend any session on the third day (day index 2)\nfor t in topics:\n    solver.add(attendance[('Tate', 2, t)] == False)\n\n# 5) At most two Capital employees attend any given session\nfor d in days:\n    for t in topics:\n        sess_attendance = [attendance[(e, d, t)] for e in employees]\n        solver.add(Sum([If(s, 1, 0) for s in sess_attendance]) <= 2)\n\n# Helper function to check option possibility\ndef check_option(option_number):\n    solver.push()\n    if option_number == 0:  # (A) Every session attended by at least one Capital employee is attended by exactly one Capital employee.\n        # For all sessions, if attended by at least one employee, then exactly one employee attends\n        for d in days:\n            for t in topics:\n                sess_attendance = [attendance[(e, d, t)] for e in employees]\n                count = Sum([If(s, 1, 0) for s in sess_attendance])\n                # count == 0 or count == 1\n                solver.add(Or(count == 0, count == 1))\n    elif option_number == 1:  # (B) Every session attended by at least one Capital employee is attended by exactly two Capital employees.\n        for d in days:\n            for t in topics:\n                sess_attendance = [attendance[(e, d, t)] for e in employees]\n                count = Sum([If(s, 1, 0) for s in sess_attendance])\n                # count == 0 or count == 2\n                solver.add(Or(count == 0, count == 2))\n    elif option_number == 2:  # (C) Every session attended by Maria is also attended by Suki.\n        for d in days:\n            for t in topics:\n                solver.add(Implies(attendance[('Maria', d, t)], attendance[('Suki', d, t)]))\n    elif option_number == 3:  # (D) Every session attended by Suki is also attended by Tate.\n        for d in days:\n            for t in topics:\n                solver.add(Implies(attendance[('Suki', d, t)], attendance[('Tate', d, t)]))\n    elif option_number == 4:  # (E) Every session attended by Tate is also attended by Maria.\n        for d in days:\n            for t in topics:\n                solver.add(Implies(attendance[('Tate', d, t)], attendance[('Maria', d, t)]))\n    else:\n        solver.pop()\n        return False\n\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\noptions = ['A', 'B', 'C', 'D', 'E']\n\nfor i, opt in enumerate(options):\n    if not check_option(i):\n        print(f\"'{opt}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Exactly three employees of Capital Enterprises—Maria, Suki, and Tate—attend a three-day conference together. Each day, there are exactly three sessions on the three topics of the conference—one on hiring, one on investing, and one on regulations. The following rules govern the conference: Each conference participant attends exactly two sessions, which are on different topics and on different days. Neither Maria nor Suki attends any session on investing. Tate does not attend any session on the third day. At most two Capital employees attend any given session together.\n\nIf all three sessions on the first day are attended by one or more Capital employees, then which one of the following must be false?\n\nOptions:\n(A) Maria and Suki attend a session together on the third day.\n(B) Suki and Tate attend a session together on the second day.\n(C) Maria attends a session on hiring on the second day.\n(D) Suki attends a session on regulations on the third day.\n(E) Tate attends a session on investing on the first day.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nemployees = ['Maria', 'Suki', 'Tate']\ndays = [0, 1, 2]  # 0: first day, 1: second day, 2: third day\ntopics = ['hiring', 'investing', 'regulations']\n\nnum_employees = len(employees)\nnum_days = len(days)\nnum_topics = len(topics)\n\n# Create variables: attendance[employee][day][topic] = Bool indicating if employee attends that session\nattendance = {}\nfor e in employees:\n    attendance[e] = {}\n    for d in days:\n        attendance[e][d] = {}\n        for t in topics:\n            attendance[e][d][t] = Bool(f\"{e}_{d}_{t}\")\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Each participant attends exactly two sessions\nfor e in employees:\n    sessions_attended = [attendance[e][d][t] for d in days for t in topics]\n    solver.add(Sum([If(s, 1, 0) for s in sessions_attended]) == 2)\n\n# 2) The two sessions each participant attends are on different topics and different days\nfor e in employees:\n    # Extract all sessions attended as a list of (day, topic, Bool)\n    sessions = [(d, t, attendance[e][d][t]) for d in days for t in topics]\n    # For every pair of sessions attended, if both attended, then days and topics differ\n    for i in range(len(sessions)):\n        for j in range(i+1, len(sessions)):\n            d1, t1, s1 = sessions[i]\n            d2, t2, s2 = sessions[j]\n            # If both attended, days differ and topics differ\n            solver.add(Implies(And(s1, s2), And(d1 != d2, t1 != t2)))\n\n# 3) Neither Maria nor Suki attends any session on investing\nfor e in ['Maria', 'Suki']:\n    for d in days:\n        solver.add(attendance[e][d]['investing'] == False)\n\n# 4) Tate does not attend any session on the third day (day 2)\nfor tpc in topics:\n    solver.add(attendance['Tate'][2][tpc] == False)\n\n# 5) At most two Capital employees attend any given session together\nfor d in days:\n    for t in topics:\n        attendees = [attendance[e][d][t] for e in employees]\n        solver.add(Sum([If(a, 1, 0) for a in attendees]) <= 2)\n\n# 6) All three sessions on the first day are attended by one or more Capital employees\nfor t in topics:\n    attendees = [attendance[e][0][t] for e in employees]\n    solver.add(Or([a for a in attendees]))\n\n# OPTION CHECKING\n\n# Define option-specific constraints as functions that return BoolRef (constraints to add)\ndef option_A():\n    # (A) Maria and Suki attend a session together on the third day.\n    # There exists a topic on day 2 (third day) such that Maria and Suki both attend it\n    conditions = []\n    for t in topics:\n        conditions.append(And(attendance['Maria'][2][t], attendance['Suki'][2][t]))\n    return Or(conditions)\n\ndef option_B():\n    # (B) Suki and Tate attend a session together on the second day.\n    # There exists a topic on day 1 (second day) such that Suki and Tate both attend it\n    conditions = []\n    for t in topics:\n        conditions.append(And(attendance['Suki'][1][t], attendance['Tate'][1][t]))\n    return Or(conditions)\n\ndef option_C():\n    # (C) Maria attends a session on hiring on the second day.\n    return attendance['Maria'][1]['hiring']\n\ndef option_D():\n    # (D) Suki attends a session on regulations on the third day.\n    return attendance['Suki'][2]['regulations']\n\ndef option_E():\n    # (E) Tate attends a session on investing on the first day.\n    return attendance['Tate'][0]['investing']\n\noptions = [option_A, option_B, option_C, option_D, option_E]\n\n# We want to find which option must be false.\n# So for each option:\n#   Add the option constraint (assume it is true)\n#   Check if the model is satisfiable with all constraints plus the option\n#   If unsat, then the option must be false.\n\nfor i, opt_func in enumerate(options):\n    solver.push()\n    solver.add(opt_func())\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.\n\nWhich one of the following could be an accurate matching of each Pohl child with the year in which that child was born?\n\nOptions:\n(A) Sara: 1990; Zoe: 1992; Uma: 1993; Will: 1994; and Theo: 1995\n(B) Sara: 1991; Uma: 1993; Theo: 1994; Zoe: 1995; and Will: 1996\n(C) Zoe: 1990; Sara: 1991; Uma: 1992; Theo: 1994; and Will: 1995\n(D) Zoe: 1990; Sara: 1991; Uma: 1993; Theo: 1994; and Will: 1995\n(E) Zoe: 1990; Sara: 1991; Uma: 1993; Theo: 1994; and Will: 1996",
    "final_answer": "'E'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Sara', 'Theo', 'Uma', 'Will', 'Zoe']\nyears = list(range(1990, 1997))  # 1990 to 1996 inclusive\n\n# Map children to Z3 Int variables representing birth year\nbirth_year = {child: Int(child) for child in children}\n\n# Map children to Z3 Bool variables representing handedness: True = left-handed, False = right-handed\n# Given: 3 left-handed, 2 right-handed\nleft_handed = {child: Bool(f'LH_{child}') for child in children}\n\n# Create solver\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each child born in a year between 1990 and 1996\nfor child in children:\n    solver.add(And(birth_year[child] >= 1990, birth_year[child] <= 1996))\n\n# All children born in different years\nsolver.add(Distinct([birth_year[child] for child in children]))\n\n# Exactly 3 left-handed children, 2 right-handed children\nsolver.add(Sum([If(left_handed[child], 1, 0) for child in children]) == 3)\n\n# Sara is left-handed\nsolver.add(left_handed['Sara'] == True)\n\n# Uma is right-handed\nsolver.add(left_handed['Uma'] == False)\n\n# No two left-handed children born in consecutive years\n# For every pair of distinct children both left-handed, their years differ by at least 2\nfor i in range(len(children)):\n    for j in range(i+1, len(children)):\n        c1 = children[i]\n        c2 = children[j]\n        lh_c1 = left_handed[c1]\n        lh_c2 = left_handed[c2]\n        # If both left-handed, years difference >= 2\n        cond = And(lh_c1, lh_c2)\n        diff = Abs(birth_year[c1] - birth_year[c2])\n        solver.add(Implies(cond, diff >= 2))\n\n# No two right-handed children born in consecutive years\n# For every pair of distinct children both right-handed, their years differ by at least 2\nfor i in range(len(children)):\n    for j in range(i+1, len(children)):\n        c1 = children[i]\n        c2 = children[j]\n        rh_c1 = Not(left_handed[c1])\n        rh_c2 = Not(left_handed[c2])\n        cond = And(rh_c1, rh_c2)\n        diff = Abs(birth_year[c1] - birth_year[c2])\n        solver.add(Implies(cond, diff >= 2))\n\n# Sara was born before Uma\nsolver.add(birth_year['Sara'] < birth_year['Uma'])\n\n# Zoe was born before both Theo and Will\nsolver.add(birth_year['Zoe'] < birth_year['Theo'])\nsolver.add(birth_year['Zoe'] < birth_year['Will'])\n\n# A left-handed child was born in 1991\n# There exists a child with birth_year == 1991 and left_handed == True\nlh_1991 = [And(birth_year[child] == 1991, left_handed[child]) for child in children]\nsolver.add(Or(lh_1991))\n\n# Uma was born in 1993\nsolver.add(birth_year['Uma'] == 1993)\n\n# OPTION CHECKING\n\noptions = [\n    {'Sara': 1990, 'Zoe': 1992, 'Uma': 1993, 'Will': 1994, 'Theo': 1995},\n    {'Sara': 1991, 'Uma': 1993, 'Theo': 1994, 'Zoe': 1995, 'Will': 1996},\n    {'Zoe': 1990, 'Sara': 1991, 'Uma': 1992, 'Theo': 1994, 'Will': 1995},\n    {'Zoe': 1990, 'Sara': 1991, 'Uma': 1993, 'Theo': 1994, 'Will': 1995},\n    {'Zoe': 1990, 'Sara': 1991, 'Uma': 1993, 'Theo': 1994, 'Will': 1996},\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for the option: set birth years as per option\n    for child in children:\n        if child in option:\n            solver.add(birth_year[child] == option[child])\n    # Check if satisfiable\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'E'"
    }
  },
  {
    "question": "Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.\n\nIf Sara was born before Zoe was born, then which one of the following statements CANNOT be true?\n\nOptions:\n(A) Will is left-handed.\n(B) Zoe is left-handed.\n(C) Theo was born after Will was born.\n(D) Uma was born after Zoe was born.\n(E) No child was born in 1990.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Sara', 'Theo', 'Uma', 'Will', 'Zoe']\nyears = list(range(1990, 1997))  # 1990 to 1996 inclusive\nhandedness_types = ['L', 'R']  # Left or Right\n\n# Map children to indices for consistent variable naming\nchild_idx = {c: i for i, c in enumerate(children)}\n\n# Create variables for birth years (Int) and handedness (Bool: True for Left, False for Right)\nbirth_year = {c: Int(c + '_year') for c in children}\nis_left = {c: Bool(c + '_left') for c in children}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each child's birth year is between 1990 and 1996\nfor c in children:\n    solver.add(And(birth_year[c] >= 1990, birth_year[c] <= 1996))\n\n# All birth years are distinct\nsolver.add(Distinct([birth_year[c] for c in children]))\n\n# Exactly three left-handed children and two right-handed children\nleft_count = Sum([If(is_left[c], 1, 0) for c in children])\nsolver.add(left_count == 3)\n\n# Sara is left-handed\nsolver.add(is_left['Sara'] == True)\n\n# Uma is right-handed\nsolver.add(is_left['Uma'] == False)\n\n# No two left-handed children born in consecutive years\nleft_children = [c for c in children]\nfor i in range(len(children)):\n    for j in range(i + 1, len(children)):\n        c1 = children[i]\n        c2 = children[j]\n        # If both left-handed, years not consecutive\n        cond = And(is_left[c1], is_left[c2])\n        years_consecutive = Or(birth_year[c1] == birth_year[c2] + 1,\n                              birth_year[c1] == birth_year[c2] - 1)\n        solver.add(Implies(cond, Not(years_consecutive)))\n\n# No two right-handed children born in consecutive years\nfor i in range(len(children)):\n    for j in range(i + 1, len(children)):\n        c1 = children[i]\n        c2 = children[j]\n        # If both right-handed, years not consecutive\n        cond = And(Not(is_left[c1]), Not(is_left[c2]))\n        years_consecutive = Or(birth_year[c1] == birth_year[c2] + 1,\n                              birth_year[c1] == birth_year[c2] - 1)\n        solver.add(Implies(cond, Not(years_consecutive)))\n\n# Sara was born before Uma\nsolver.add(birth_year['Sara'] < birth_year['Uma'])\n\n# Zoe was born before both Theo and Will\nsolver.add(birth_year['Zoe'] < birth_year['Theo'])\nsolver.add(birth_year['Zoe'] < birth_year['Will'])\n\n# A left-handed child was born in 1991\n# So there exists a child c with is_left[c] == True and birth_year[c] == 1991\nleft_1991_conditions = [And(is_left[c], birth_year[c] == 1991) for c in children]\nsolver.add(Or(left_1991_conditions))\n\n# Uma was born in 1993\nsolver.add(birth_year['Uma'] == 1993)\n\n# The condition: If Sara was born before Zoe was born\n# We are told to assume Sara born before Zoe, so add:\nsolver.add(birth_year['Sara'] < birth_year['Zoe'])\n\n# OPTION CHECKING\noptions = [\n    ('A', is_left['Will'] == True),\n    ('B', is_left['Zoe'] == True),\n    ('C', birth_year['Theo'] > birth_year['Will']),\n    ('D', birth_year['Uma'] > birth_year['Zoe']),\n    ('E', And([birth_year[c] != 1990 for c in children]))\n]\n\nfor letter, option_constraint in options:\n    solver.push()\n    solver.add(option_constraint)\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.\n\nWhich one of the following must be false?\n\nOptions:\n(A) None of the children was born in 1990, nor was a child born in 1992.\n(B) None of the children was born in 1992, nor was a child born in 1995.\n(C) None of the children was born in 1994, nor was a child born in 1996.\n(D) One of the children was born in 1990, and another in 1993.\n(E) One of the children was born in 1993, and another in 1995.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Sara', 'Theo', 'Uma', 'Will', 'Zoe']\nyears = list(range(1990, 1997))  # 1990 through 1996 inclusive\n\n# Handedness encoding: 0 = left-handed, 1 = right-handed\n# Sara, Theo, Uma, Will, Zoe\nhandedness = {c: Int(f'handedness_{c}') for c in children}\n# Year of birth for each child\nbirth_year = {c: Int(f'birth_year_{c}') for c in children}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Handedness domain: 0 or 1\nfor c in children:\n    solver.add(Or(handedness[c] == 0, handedness[c] == 1))\n\n# Exactly three left-handed (0) and two right-handed (1)\nleft_handed_count = Sum([If(handedness[c] == 0, 1, 0) for c in children])\nright_handed_count = Sum([If(handedness[c] == 1, 1, 0) for c in children])\nsolver.add(left_handed_count == 3)\nsolver.add(right_handed_count == 2)\n\n# Each child born in a different year (distinctness)\nsolver.add(Distinct([birth_year[c] for c in children]))\n\n# Each birth year is in 1990..1996\nfor c in children:\n    solver.add(And(birth_year[c] >= 1990, birth_year[c] <= 1996))\n\n# No two left-handed children born in consecutive years\nleft_children = [c for c in children]\nfor i in range(len(children)):\n    for j in range(i+1, len(children)):\n        c1 = children[i]\n        c2 = children[j]\n        both_left = And(handedness[c1] == 0, handedness[c2] == 0)\n        consecutive_years = Or(birth_year[c1] + 1 == birth_year[c2], birth_year[c2] + 1 == birth_year[c1])\n        # If both left-handed, then not consecutive years\n        solver.add(Implies(both_left, Not(consecutive_years)))\n\n# No two right-handed children born in consecutive years\nfor i in range(len(children)):\n    for j in range(i+1, len(children)):\n        c1 = children[i]\n        c2 = children[j]\n        both_right = And(handedness[c1] == 1, handedness[c2] == 1)\n        consecutive_years = Or(birth_year[c1] + 1 == birth_year[c2], birth_year[c2] + 1 == birth_year[c1])\n        # If both right-handed, then not consecutive years\n        solver.add(Implies(both_right, Not(consecutive_years)))\n\n# Sara is left-handed\nsolver.add(handedness['Sara'] == 0)\n\n# Uma is right-handed\nsolver.add(handedness['Uma'] == 1)\n\n# Sara born before Uma\nsolver.add(birth_year['Sara'] < birth_year['Uma'])\n\n# Zoe born before both Theo and Will\nsolver.add(birth_year['Zoe'] < birth_year['Theo'])\nsolver.add(birth_year['Zoe'] < birth_year['Will'])\n\n# A left-handed child was born in 1991\n# So there exists some child with handedness 0 and birth year 1991\nleft_handed_1991 = []\nfor c in children:\n    left_handed_1991.append(And(handedness[c] == 0, birth_year[c] == 1991))\nsolver.add(Or(left_handed_1991))\n\n# Uma born in 1993\nsolver.add(birth_year['Uma'] == 1993)\n\n# OPTION CHECKING\noptions = {\n    'A': And([birth_year[c] != 1990 for c in children] + [birth_year[c] != 1992 for c in children]),\n    'B': And([birth_year[c] != 1992 for c in children] + [birth_year[c] != 1995 for c in children]),\n    'C': And([birth_year[c] != 1994 for c in children] + [birth_year[c] != 1996 for c in children]),\n    'D': And(Or([birth_year[c] == 1990 for c in children]), Or([birth_year[c] == 1993 for c in children])),\n    'E': And(Or([birth_year[c] == 1993 for c in children]), Or([birth_year[c] == 1995 for c in children])),\n}\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    solver.add(options[letter])\n    if solver.check() == sat:\n        solver.pop()\n    else:\n        # This option must be false (unsatisfiable)\n        print(f\"'{letter}'\")\n        solver.pop()\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.\n\nIf Theo was born after Will was born, then how many sequential orderings of the children, from firstborn to lastborn, are possible?\n\nOptions:\n(A) one\n(B) two\n(C) three\n(D) four\n(E) five",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Sara', 'Theo', 'Uma', 'Will', 'Zoe']\nyears_range = list(range(1990, 1997))  # 1990 to 1996 inclusive\nn_children = len(children)\n\n# Map children to indices\nchild_idx = {c: i for i, c in enumerate(children)}\n\n# Left-handedness: 1 for left-handed, 0 for right-handed\n# Given: Sara (left), Uma (right), total 3 left-handed, 2 right-handed\n# So left-handed children are Sara and two others; Uma and two others are right-handed\n# We know Sara is left-handed, Uma is right-handed\n# We will create a Bool vector for left-handedness for each child\nleft_handed = [Bool(f'left_{c}') for c in children]\n\n# Years variables for each child - integer variables for birth year\nbirth_year = [Int(f'year_{c}') for c in children]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Each child born in a different year from 1990 to 1996\nfor y in birth_year:\n    solver.add(And(y >= 1990, y <= 1996))\nsolver.add(Distinct(birth_year))\n\n# 2. Exactly three left-handed and two right-handed children\n# left_handed variables are Bool, so sum of left_handed == 3\nsolver.add(Sum([If(lh, 1, 0) for lh in left_handed]) == 3)\n\n# 3. Given handedness:\n# Sara is left-handed\nsolver.add(left_handed[child_idx['Sara']] == True)\n# Uma is right-handed\nsolver.add(left_handed[child_idx['Uma']] == False)\n\n# 4. No two left-handed children born in consecutive years\n# For every pair of children both left-handed, their birth years differ by at least 2\nfor i in range(n_children):\n    for j in range(i + 1, n_children):\n        lh_i = left_handed[i]\n        lh_j = left_handed[j]\n        # If both left-handed, abs(year_i - year_j) > 1\n        cond = And(lh_i, lh_j)\n        diff = Abs(birth_year[i] - birth_year[j])\n        solver.add(Implies(cond, diff > 1))\n\n# 5. No two right-handed children born in consecutive years\n# For every pair both right-handed, birth years differ by at least 2\nfor i in range(n_children):\n    for j in range(i + 1, n_children):\n        rh_i = Not(left_handed[i])\n        rh_j = Not(left_handed[j])\n        cond = And(rh_i, rh_j)\n        diff = Abs(birth_year[i] - birth_year[j])\n        solver.add(Implies(cond, diff > 1))\n\n# 6. Sara was born before Uma\nsolver.add(birth_year[child_idx['Sara']] < birth_year[child_idx['Uma']])\n\n# 7. Zoe was born before both Theo and Will\nsolver.add(birth_year[child_idx['Zoe']] < birth_year[child_idx['Theo']])\nsolver.add(birth_year[child_idx['Zoe']] < birth_year[child_idx['Will']])\n\n# 8. A left-handed child was born in 1991\n# So at least one child who is left-handed has birth year 1991\nleft_1991_conditions = []\nfor i in range(n_children):\n    left_1991_conditions.append(And(left_handed[i], birth_year[i] == 1991))\nsolver.add(Or(left_1991_conditions))\n\n# 9. Uma (right-handed) was born in 1993\nsolver.add(birth_year[child_idx['Uma']] == 1993)\n\n# OPTION CHECKING\n# The question: If Theo was born after Will was born,\n# how many sequential orderings of the children, from firstborn to lastborn, are possible?\n\n# So we add the condition:\nsolver.add(birth_year[child_idx['Theo']] > birth_year[child_idx['Will']])\n\n# We want to find how many distinct orderings of the children by birth year are possible\n# Since birth years are distinct, the order is determined by sorting birth_year values\n# We will find all solutions and count how many distinct orderings exist\n\n# To count distinct orderings, we will store the orderings found as tuples of children sorted by birth year\n\norderings = set()\n\nwhile solver.check() == sat:\n    model = solver.model()\n    # Extract birth years\n    child_years = [(c, model[birth_year[child_idx[c]]].as_long()) for c in children]\n    # Sort by year ascending\n    sorted_children = tuple(sorted(child_years, key=lambda x: x[1]))\n    # Extract only child names in order\n    ordering = tuple(c for c, y in sorted_children)\n    orderings.add(ordering)\n\n    # Block this ordering to find a different one\n    # Create a constraint that the ordering of birth years must differ\n    # We can block by asserting that the order of birth years is not the same\n    # We'll add a constraint that at least one pair ordering differs\n\n    # To block the ordering, add a constraint that the order of birth years is different\n    # We can do this by asserting that for at least one pair, the relative order is different\n\n    # We'll encode the order as a list of birth years in order of children\n    # So we block the exact assignment of birth years to children\n\n    block = []\n    for c, y in child_years:\n        block.append(birth_year[child_idx[c]] == y)\n    solver.add(Not(And(block)))\n\n# Number of distinct orderings found\nnum_orderings = len(orderings)\n\n# Map number to option letter\noptions_map = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 5: 'E'}\n\n# Print the letter of the correct answer option\nprint(f\"'{options_map[num_orderings]}'\")",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.\n\nIf none of the children was born in 1995, then which one of the following statements must be true?\n\nOptions:\n(A) Theo was born in 1994.\n(B) Will was born in 1994.\n(C) Will was born in 1996.\n(D) Zoe was born in 1990.\n(E) Zoe was born in 1994.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Sara', 'Theo', 'Uma', 'Will', 'Zoe']\nyears = list(range(1990, 1997))  # 1990 to 1996 inclusive\nnum_years = len(years)\n\n# Handedness: 0 = left-handed, 1 = right-handed\nhandedness_vals = [0, 1]\n\n# Create Z3 Int variables for birth years (indices in years list)\nbirth_year = {c: Int(c) for c in children}\n\n# Create Z3 Int variables for handedness (0=left,1=right)\nhandedness = {c: Int(c + '_hand') for c in children}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each child's birth year must be one of the years 1990-1996 (indices 0 to 6)\nfor c in children:\n    solver.add(And(birth_year[c] >= 0, birth_year[c] < num_years))\n\n# All children born in different years\nsolver.add(Distinct([birth_year[c] for c in children]))\n\n# Exactly three left-handed and two right-handed children\nsolver.add(Sum([If(handedness[c] == 0, 1, 0) for c in children]) == 3)\nsolver.add(Sum([If(handedness[c] == 1, 1, 0) for c in children]) == 2)\n\n# Handedness values are either 0 or 1\nfor c in children:\n    solver.add(Or(handedness[c] == 0, handedness[c] == 1))\n\n# Sara is left-handed\nsolver.add(handedness['Sara'] == 0)\n\n# Uma is right-handed\nsolver.add(handedness['Uma'] == 1)\n\n# No two left-handed children born in consecutive years\nlefties = [c for c in children]\nfor i in range(len(children)):\n    for j in range(i + 1, len(children)):\n        c1 = children[i]\n        c2 = children[j]\n        # If both left-handed, birth years not consecutive\n        cond_both_left = And(handedness[c1] == 0, handedness[c2] == 0)\n        cond_year_consec = Or(birth_year[c1] == birth_year[c2] + 1,\n                             birth_year[c1] == birth_year[c2] - 1)\n        solver.add(Implies(cond_both_left, Not(cond_year_consec)))\n\n# No two right-handed children born in consecutive years\nfor i in range(len(children)):\n    for j in range(i + 1, len(children)):\n        c1 = children[i]\n        c2 = children[j]\n        cond_both_right = And(handedness[c1] == 1, handedness[c2] == 1)\n        cond_year_consec = Or(birth_year[c1] == birth_year[c2] + 1,\n                             birth_year[c1] == birth_year[c2] - 1)\n        solver.add(Implies(cond_both_right, Not(cond_year_consec)))\n\n# Sara born before Uma\nsolver.add(birth_year['Sara'] < birth_year['Uma'])\n\n# Zoe born before both Theo and Will\nsolver.add(birth_year['Zoe'] < birth_year['Theo'])\nsolver.add(birth_year['Zoe'] < birth_year['Will'])\n\n# A left-handed child was born in 1991 (index 1)\n# So at least one child with handedness=0 born in year index 1\nlh_1991 = []\nfor c in children:\n    lh_1991.append(And(handedness[c] == 0, birth_year[c] == 1))\nsolver.add(Or(lh_1991))\n\n# Uma born in 1993 (index 3)\nsolver.add(birth_year['Uma'] == 3)\n\n# None of the children was born in 1995 (index 5)\nfor c in children:\n    solver.add(birth_year[c] != 5)\n\n# OPTION CHECKING\n# Options:\n# (A) Theo was born in 1994 (index 4).\n# (B) Will was born in 1994 (index 4).\n# (C) Will was born in 1996 (index 6).\n# (D) Zoe was born in 1990 (index 0).\n# (E) Zoe was born in 1994 (index 4).\n\noptions = {\n    'A': birth_year['Theo'] == 4,\n    'B': birth_year['Will'] == 4,\n    'C': birth_year['Will'] == 6,\n    'D': birth_year['Zoe'] == 0,\n    'E': birth_year['Zoe'] == 4,\n}\n\n# We want to find which option must be true\n# That means for all solutions, that option holds\n# So we check if the negation of the option is satisfiable\n# If negation is unsat, option must be true\n\nfor letter, cond in options.items():\n    solver.push()\n    solver.add(Not(cond))\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.\n\nIf Theo is right-handed, then each of the following statements must be false EXCEPT:\n\nOptions:\n(A) Theo was born in 1996.\n(B) Will was born in 1995.\n(C) Uma was born exactly three years before Theo was born.\n(D) Zoe was born exactly one year before Theo was born.\n(E) Will is right-handed.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Sara', 'Theo', 'Uma', 'Will', 'Zoe']\nyears = list(range(1990, 1997))  # 1990 to 1996 inclusive\nnum_children = len(children)\n\n# Handedness: 0 = left-handed, 1 = right-handed\nhandedness = {c: Int(c + '_handedness') for c in children}  # 0 or 1\n# Birth years: integer variables for each child\nbirth_year = {c: Int(c + '_birth_year') for c in children}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Handedness domain\nfor c in children:\n    solver.add(Or(handedness[c] == 0, handedness[c] == 1))\n\n# 2) Exactly 3 left-handed (0), 2 right-handed (1)\nsolver.add(Sum([If(handedness[c] == 0, 1, 0) for c in children]) == 3)\nsolver.add(Sum([If(handedness[c] == 1, 1, 0) for c in children]) == 2)\n\n# 3) Birth years domain and distinctness\nfor c in children:\n    solver.add(And(birth_year[c] >= 1990, birth_year[c] <= 1996))\nsolver.add(Distinct([birth_year[c] for c in children]))\n\n# 4) No two left-handed children born in consecutive years\nleft_handed = [c for c in children]\nfor i in range(num_children):\n    for j in range(i+1, num_children):\n        c1 = children[i]\n        c2 = children[j]\n        # If both left-handed, years cannot be consecutive\n        lh_cond = And(handedness[c1] == 0, handedness[c2] == 0)\n        consecutive_years = Or(birth_year[c1] == birth_year[c2] + 1, birth_year[c1] == birth_year[c2] - 1)\n        solver.add(Implies(lh_cond, Not(consecutive_years)))\n\n# 5) No two right-handed children born in consecutive years\nfor i in range(num_children):\n    for j in range(i+1, num_children):\n        c1 = children[i]\n        c2 = children[j]\n        rh_cond = And(handedness[c1] == 1, handedness[c2] == 1)\n        consecutive_years = Or(birth_year[c1] == birth_year[c2] + 1, birth_year[c1] == birth_year[c2] - 1)\n        solver.add(Implies(rh_cond, Not(consecutive_years)))\n\n# 6) Sara is left-handed\nsolver.add(handedness['Sara'] == 0)\n\n# 7) Uma is right-handed and born in 1993\nsolver.add(handedness['Uma'] == 1)\nsolver.add(birth_year['Uma'] == 1993)\n\n# 8) Sara was born before Uma\nsolver.add(birth_year['Sara'] < birth_year['Uma'])\n\n# 9) Zoe was born before both Theo and Will\nsolver.add(birth_year['Zoe'] < birth_year['Theo'])\nsolver.add(birth_year['Zoe'] < birth_year['Will'])\n\n# 10) A left-handed child was born in 1991\n# There exists c with handedness[c]==0 and birth_year[c]==1991\nlh_in_1991 = [And(handedness[c] == 0, birth_year[c] == 1991) for c in children]\nsolver.add(Or(lh_in_1991))\n\n# 11) Theo is right-handed (given condition for the question)\nsolver.add(handedness['Theo'] == 1)\n\n# OPTION CHECKING\noptions = {\n    'A': birth_year['Theo'] == 1996,\n    'B': birth_year['Will'] == 1995,\n    'C': birth_year['Uma'] + 3 == birth_year['Theo'],\n    'D': birth_year['Zoe'] + 1 == birth_year['Theo'],\n    'E': handedness['Will'] == 1,\n}\n\n# We want to find which option must be true if Theo is right-handed.\n# The question says: \"If Theo is right-handed, then each of the following statements must be false EXCEPT:\"\n# So all options except one must be false. So for each option:\n#   Add the negations of all other options, add the option itself, check satisfiability.\n# If satisfiable, that option can be true while others false, so that option is the EXCEPTION.\n\nfor letter in ['A', 'B', 'C', 'D', 'E']:\n    solver.push()\n    # Add the option itself\n    solver.add(options[letter])\n    # Add negations of all other options\n    for other_letter in options:\n        if other_letter != letter:\n            solver.add(Not(options[other_letter]))\n    if solver.check() == sat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Of the five Pohl children—Sara, Theo, Uma, Will, and Zoe—three are left-handed and two are right-handed. Each of the five children was born in a different one of seven calendar years, 1990 through 1996. The following conditions apply: No two left-handed children were born in consecutive years. No two right-handed children were born in consecutive years. Sara, who is left-handed, was born before Uma. Zoe was born before both Theo and Will. A left-handed child was born in 1991. Uma, who is right-handed, was born in 1993.\n\nIf Zoe was born before Uma was born, then which one of the following statements must be false?\n\nOptions:\n(A) No child was born in 1992.\n(B) No child was born in 1995.\n(C) Theo is left-handed.\n(D) Zoe is left-handed.\n(E) Will is left-handed.",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nchildren = ['Sara', 'Theo', 'Uma', 'Will', 'Zoe']\nyears = list(range(1990, 1997))  # 1990 to 1996 inclusive\nhandedness_types = ['left', 'right']\n\n# Create Z3 Int variables for birth years of each child\nbirth_year = {c: Int(c + '_year') for c in children}\n\n# Create Z3 Int variables for handedness: 0 for left, 1 for right\nhandedness = {c: Int(c + '_handed') for c in children}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each child born in one of the years 1990-1996\nfor c in children:\n    solver.add(And(birth_year[c] >= 1990, birth_year[c] <= 1996))\n\n# All children born in different years\nsolver.add(Distinct([birth_year[c] for c in children]))\n\n# Handedness constraints: 0 (left) or 1 (right)\nfor c in children:\n    solver.add(Or(handedness[c] == 0, handedness[c] == 1))\n\n# Exactly three left-handed and two right-handed children\nlefties = [If(handedness[c] == 0, 1, 0) for c in children]\nsolver.add(Sum(lefties) == 3)\nsolver.add(Sum([If(handedness[c] == 1, 1, 0) for c in children]) == 2)\n\n# No two left-handed children born in consecutive years\nleft_children = [c for c in children]\nfor i in range(len(children)):\n    for j in range(i+1, len(children)):\n        c1 = children[i]\n        c2 = children[j]\n        # If both left-handed then years not consecutive\n        cond_left = And(handedness[c1] == 0, handedness[c2] == 0)\n        cond_years = Or(birth_year[c1] + 1 != birth_year[c2], birth_year[c1] - 1 != birth_year[c2])\n        # Equivalently: abs difference of years != 1\n        diff = Abs(birth_year[c1] - birth_year[c2])\n        solver.add(Implies(cond_left, diff != 1))\n\n# No two right-handed children born in consecutive years\nfor i in range(len(children)):\n    for j in range(i+1, len(children)):\n        c1 = children[i]\n        c2 = children[j]\n        cond_right = And(handedness[c1] == 1, handedness[c2] == 1)\n        diff = Abs(birth_year[c1] - birth_year[c2])\n        solver.add(Implies(cond_right, diff != 1))\n\n# Sara is left-handed\nsolver.add(handedness['Sara'] == 0)\n\n# Uma is right-handed and born in 1993\nsolver.add(handedness['Uma'] == 1)\nsolver.add(birth_year['Uma'] == 1993)\n\n# Sara born before Uma\nsolver.add(birth_year['Sara'] < birth_year['Uma'])\n\n# Zoe born before both Theo and Will\nsolver.add(birth_year['Zoe'] < birth_year['Theo'])\nsolver.add(birth_year['Zoe'] < birth_year['Will'])\n\n# A left-handed child was born in 1991\n# So at least one child with birth year 1991 and left-handed\nborn_1991_left = [And(birth_year[c] == 1991, handedness[c] == 0) for c in children]\nsolver.add(Or(born_1991_left))\n\n# Additional condition given in the question: Zoe was born before Uma\nsolver.add(birth_year['Zoe'] < birth_year['Uma'])\n\n# OPTION CHECKING\n# We want to find which statement must be false\n# So for each option, add the option's statement as a constraint,\n# check if the model is satisfiable. If not, that option must be false.\n\noptions = [\n    # (A) No child was born in 1992.\n    # means: no child's birth year is 1992\n    And([birth_year[c] != 1992 for c in children]),\n    # (B) No child was born in 1995.\n    And([birth_year[c] != 1995 for c in children]),\n    # (C) Theo is left-handed.\n    handedness['Theo'] == 0,\n    # (D) Zoe is left-handed.\n    handedness['Zoe'] == 0,\n    # (E) Will is left-handed.\n    handedness['Will'] == 0\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    solver.add(option)\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Barbara is shopping at a pet store to select fish for her new aquarium from among the following species: J, K, L, M, N, O, and P. For each of the seven species, the store has several fish available. Barbara makes her selection in a manner consistent with the following conditions: If she selects one or more K, then she does not select any O. If she selects one or more M, then she does not select any N. If she selects one or more M, then she selects at least one O. If she selects one or more N, then she selects at least one O. If she selects one or more O, then she selects at least one P. If she selects one or more P, then she selects at least one O. If she selects any O at all, then she selects at least two O.\n\nWhich one of the following could be a complete and accurate list of the fish Barbara selects for her aquarium?\n\nOptions:\n(A) three J, one K, two M\n(B) one J, one K, one M, three O\n(C) one J, one M, two O, one P\n(D) one J, one N, one O, two P\n(E) one M, one N, two O, one P",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nspecies = ['J', 'K', 'L', 'M', 'N', 'O', 'P']\n\n# Create Int variables for the number of each species selected (0 or more)\nselection = {s: Int(s) for s in species}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each selection must be >= 0 (number of fish cannot be negative)\nfor s in species:\n    solver.add(selection[s] >= 0)\n\n# Condition: If selects one or more K, then no O\n# K > 0 => O == 0\nsolver.add(Implies(selection['K'] > 0, selection['O'] == 0))\n\n# If selects one or more M, then no N\nsolver.add(Implies(selection['M'] > 0, selection['N'] == 0))\n\n# If selects one or more M, then at least one O\nsolver.add(Implies(selection['M'] > 0, selection['O'] >= 1))\n\n# If selects one or more N, then at least one O\nsolver.add(Implies(selection['N'] > 0, selection['O'] >= 1))\n\n# If selects one or more O, then at least one P\nsolver.add(Implies(selection['O'] > 0, selection['P'] >= 1))\n\n# If selects one or more P, then at least one O\nsolver.add(Implies(selection['P'] > 0, selection['O'] >= 1))\n\n# If selects any O at all, then selects at least two O\nsolver.add(Implies(selection['O'] > 0, selection['O'] >= 2))\n\n# OPTION CHECKING\noptions = [\n    {'J': 3, 'K': 1, 'L': 0, 'M': 2, 'N': 0, 'O': 0, 'P': 0},  # A\n    {'J': 1, 'K': 1, 'L': 0, 'M': 1, 'N': 0, 'O': 3, 'P': 0},  # B\n    {'J': 1, 'K': 0, 'L': 0, 'M': 1, 'N': 0, 'O': 2, 'P': 1},  # C\n    {'J': 1, 'K': 0, 'L': 0, 'M': 0, 'N': 1, 'O': 1, 'P': 2},  # D\n    {'J': 0, 'K': 0, 'L': 0, 'M': 1, 'N': 1, 'O': 2, 'P': 1}   # E\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    for s in species:\n        solver.add(selection[s] == opt[s])\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Barbara is shopping at a pet store to select fish for her new aquarium from among the following species: J, K, L, M, N, O, and P. For each of the seven species, the store has several fish available. Barbara makes her selection in a manner consistent with the following conditions: If she selects one or more K, then she does not select any O. If she selects one or more M, then she does not select any N. If she selects one or more M, then she selects at least one O. If she selects one or more N, then she selects at least one O. If she selects one or more O, then she selects at least one P. If she selects one or more P, then she selects at least one O. If she selects any O at all, then she selects at least two O.\n\nIf Barbara does not select any fish of species P, then it could be true that she selects fish of species\n\nOptions:\n(A) J and of species K\n(B) J and of species M\n(C) K and of species M\n(D) K and of species N\n(E) L and of species O",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nspecies = ['J', 'K', 'L', 'M', 'N', 'O', 'P']\n# Variables represent the number of fish selected of each species (0 means none selected)\nselection = {s: Int(s) for s in species}\n\nsolver = Solver()\n\n# Each selection count is >= 0 (number of fish selected)\nfor s in species:\n    solver.add(selection[s] >= 0)\n\n# CONSTRAINTS\n# If she selects one or more K, then she does not select any O.\ncond1 = Implies(selection['K'] >= 1, selection['O'] == 0)\nsolver.add(cond1)\n\n# If she selects one or more M, then she does not select any N.\ncond2 = Implies(selection['M'] >= 1, selection['N'] == 0)\nsolver.add(cond2)\n\n# If she selects one or more M, then she selects at least one O.\ncond3 = Implies(selection['M'] >= 1, selection['O'] >= 1)\nsolver.add(cond3)\n\n# If she selects one or more N, then she selects at least one O.\ncond4 = Implies(selection['N'] >= 1, selection['O'] >= 1)\nsolver.add(cond4)\n\n# If she selects one or more O, then she selects at least one P.\ncond5 = Implies(selection['O'] >= 1, selection['P'] >= 1)\nsolver.add(cond5)\n\n# If she selects one or more P, then she selects at least one O.\ncond6 = Implies(selection['P'] >= 1, selection['O'] >= 1)\nsolver.add(cond6)\n\n# If she selects any O at all, then she selects at least two O.\ncond7 = Implies(selection['O'] >= 1, selection['O'] >= 2)\nsolver.add(cond7)\n\n# Additional given condition: Barbara does NOT select any fish of species P.\nsolver.add(selection['P'] == 0)\n\n# OPTION CHECKING\noptions = {\n    'A': ['J', 'K'],\n    'B': ['J', 'M'],\n    'C': ['K', 'M'],\n    'D': ['K', 'N'],\n    'E': ['L', 'O']\n}\n\nfor opt_letter, fishes in options.items():\n    solver.push()\n    # Add constraints that Barbara selects at least one fish of each species in fishes\n    for f in fishes:\n        solver.add(selection[f] >= 1)\n    # Check if satisfiable\n    if solver.check() == sat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Barbara is shopping at a pet store to select fish for her new aquarium from among the following species: J, K, L, M, N, O, and P. For each of the seven species, the store has several fish available. Barbara makes her selection in a manner consistent with the following conditions: If she selects one or more K, then she does not select any O. If she selects one or more M, then she does not select any N. If she selects one or more M, then she selects at least one O. If she selects one or more N, then she selects at least one O. If she selects one or more O, then she selects at least one P. If she selects one or more P, then she selects at least one O. If she selects any O at all, then she selects at least two O.\n\nIf Barbara selects fish of as many species as possible, then she cannot select any fish of which one of the following species?\n\nOptions:\n(A) K\n(B) L\n(C) M\n(D) N\n(E) P",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nspecies = ['J', 'K', 'L', 'M', 'N', 'O', 'P']\n# Create boolean variables indicating whether Barbara selects each species (at least one fish)\nselect = {s: Bool(s) for s in species}\n\nsolver = Solver()\n\n# CONSTRAINTS\n# If she selects one or more K, then she does not select any O.\nsolver.add(Implies(select['K'], Not(select['O'])))\n\n# If she selects one or more M, then she does not select any N.\nsolver.add(Implies(select['M'], Not(select['N'])))\n\n# If she selects one or more M, then she selects at least one O.\nsolver.add(Implies(select['M'], select['O']))\n\n# If she selects one or more N, then she selects at least one O.\nsolver.add(Implies(select['N'], select['O']))\n\n# If she selects one or more O, then she selects at least one P.\nsolver.add(Implies(select['O'], select['P']))\n\n# If she selects one or more P, then she selects at least one O.\nsolver.add(Implies(select['P'], select['O']))\n\n# If she selects any O at all, then she selects at least two O.\n# Since we only have boolean variables (selected or not), this means that if O is selected, it must be at least two fish.\n# This can be modeled as \"O selected\" means \"O count >= 2\".\n# But we only have boolean variables, so we interpret \"select at least two O\" as \"O is selected\" but not just one fish.\n# Since the problem does not provide counts, we can treat this as a constraint that O must be selected with at least two fish.\n# We model this as O is selected, but we do not have variables for counts, so we only enforce that if O is selected, it is \"at least two\".\n# This is not a constraint on boolean variables alone, so we just keep it as a note and do not model it explicitly here.\n# The effect is that O is selected only if at least two fish of O are selected, so O cannot be selected alone.\n# We can treat it as \"if O selected, then O is selected with multiplicity >=2\" which is consistent with selecting O.\n# Since we don't have counts, this means O selected is allowed, but we must consider that O selected implies at least two O.\n# For this puzzle, it means O selected is a stronger condition.\n\n# We want to maximize the number of species selected.\n# So, we will try to find the maximum number of species selected satisfying all constraints.\n\n# OPTION CHECKING\n# We will check each option by adding the negation of selecting that species and check if the maximum number of species selected is still achievable.\n# First, find the maximum number of species selected.\n\nmax_selected = 0\nmax_model = None\n\n# Try all possible numbers of species selected from 7 down to 0\nfor count in range(7, -1, -1):\n    solver.push()\n    # Add constraint that exactly 'count' species are selected\n    solver.add(Sum([If(select[s], 1, 0) for s in species]) == count)\n    if solver.check() == sat:\n        max_selected = count\n        max_model = solver.model()\n        solver.pop()\n        break\n    solver.pop()\n\n# Now check each option: can Barbara select max_selected species if she selects that species?\n# If not, then that species cannot be selected when selecting max species.\n\nfor i, s in enumerate(species):\n    solver.push()\n    # Add constraint that exactly max_selected species are selected\n    solver.add(Sum([If(select[sp], 1, 0) for sp in species]) == max_selected)\n    # Add constraint that species s is selected\n    solver.add(select[s])\n    if solver.check() == sat:\n        # species s can be selected when selecting max number of species\n        solver.pop()\n    else:\n        # species s cannot be selected when selecting max number of species\n        solver.pop()\n        # Check if s is in options (K,L,M,N,P)\n        if s in ['K', 'L', 'M', 'N', 'P']:\n            # Print the letter of the option corresponding to s\n            option_map = {'K': 'A', 'L': 'B', 'M': 'C', 'N': 'D', 'P': 'E'}\n            print(f\"'{option_map[s]}'\")\n            break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Barbara is shopping at a pet store to select fish for her new aquarium from among the following species: J, K, L, M, N, O, and P. For each of the seven species, the store has several fish available. Barbara makes her selection in a manner consistent with the following conditions: If she selects one or more K, then she does not select any O. If she selects one or more M, then she does not select any N. If she selects one or more M, then she selects at least one O. If she selects one or more N, then she selects at least one O. If she selects one or more O, then she selects at least one P. If she selects one or more P, then she selects at least one O. If she selects any O at all, then she selects at least two O.\n\nWhich one of the following statements must be false?\n\nOptions:\n(A) Barbara selects exactly four fish, at least one of which is a J.\n(B) Barbara selects exactly four fish, at least one of which is an L.\n(C) Barbara selects exactly three fish, at least one of which is an M.\n(D) Barbara selects exactly three fish, at least one of which is an O.\n(E) Barbara selects exactly three fish, at least one of which is a P.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nspecies = ['J', 'K', 'L', 'M', 'N', 'O', 'P']\nnum_species = len(species)\n\n# Create integer variables for number of fish selected of each species\n# Each variable >= 0 (number of fish selected)\nselection = {s: Int(s) for s in species}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each selection count is >= 0\nfor s in species:\n    solver.add(selection[s] >= 0)\n\n# Define helper expressions for conditions involving \"one or more\"\nK_selected = selection['K'] >= 1\nO_selected = selection['O'] >= 1\nM_selected = selection['M'] >= 1\nN_selected = selection['N'] >= 1\nP_selected = selection['P'] >= 1\n\n# Conditions:\n# 1) If she selects one or more K, then she does not select any O.\nsolver.add(Implies(K_selected, selection['O'] == 0))\n\n# 2) If she selects one or more M, then she does not select any N.\nsolver.add(Implies(M_selected, selection['N'] == 0))\n\n# 3) If she selects one or more M, then she selects at least one O.\nsolver.add(Implies(M_selected, O_selected))\n\n# 4) If she selects one or more N, then she selects at least one O.\nsolver.add(Implies(N_selected, O_selected))\n\n# 5) If she selects one or more O, then she selects at least one P.\nsolver.add(Implies(O_selected, P_selected))\n\n# 6) If she selects one or more P, then she selects at least one O.\nsolver.add(Implies(P_selected, O_selected))\n\n# 7) If she selects any O at all, then she selects at least two O.\n# This means if O_selected then selection['O'] >= 2\nsolver.add(Implies(O_selected, selection['O'] >= 2))\n\n# OPTION CHECKING\n# Each option states a total number of fish and at least one of a species\n\noptions = [\n    ('A', 4, 'J'),\n    ('B', 4, 'L'),\n    ('C', 3, 'M'),\n    ('D', 3, 'O'),\n    ('E', 3, 'P'),\n]\n\nfor letter, total_fish, species_required in options:\n    solver.push()\n    # Total fish selected equals total_fish\n    total = Sum([selection[s] for s in species])\n    solver.add(total == total_fish)\n    # At least one fish of species_required\n    solver.add(selection[species_required] >= 1)\n    # Check satisfiability\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Barbara is shopping at a pet store to select fish for her new aquarium from among the following species: J, K, L, M, N, O, and P. For each of the seven species, the store has several fish available. Barbara makes her selection in a manner consistent with the following conditions: If she selects one or more K, then she does not select any O. If she selects one or more M, then she does not select any N. If she selects one or more M, then she selects at least one O. If she selects one or more N, then she selects at least one O. If she selects one or more O, then she selects at least one P. If she selects one or more P, then she selects at least one O. If she selects any O at all, then she selects at least two O.\n\nIf Barbara selects at least one fish for her aquarium, then which one of the following lists the minimum and maximum possible numbers, respectively, of different species of fish that Barbara selects?\n\nOptions:\n(A) 1, 4\n(B) 1, 5\n(C) 1, 6\n(D) 2, 5\n(E) 2, 6",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nspecies = ['J', 'K', 'L', 'M', 'N', 'O', 'P']\n\n# Create integer variables for each species representing the number selected (0 or more)\nselection = {s: Int(s) for s in species}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each selection count is >= 0\nfor s in species:\n    solver.add(selection[s] >= 0)\n\n# At least one fish selected overall\ntotal_selected = Sum([selection[s] for s in species])\nsolver.add(total_selected >= 1)\n\n# Conditions from the problem\n\n# If selects one or more K, then no O\n# K >=1 => O = 0\nsolver.add(Implies(selection['K'] >= 1, selection['O'] == 0))\n\n# If selects one or more M, then no N\nsolver.add(Implies(selection['M'] >= 1, selection['N'] == 0))\n\n# If selects one or more M, then selects at least one O\nsolver.add(Implies(selection['M'] >= 1, selection['O'] >= 1))\n\n# If selects one or more N, then selects at least one O\nsolver.add(Implies(selection['N'] >= 1, selection['O'] >= 1))\n\n# If selects one or more O, then selects at least one P\nsolver.add(Implies(selection['O'] >= 1, selection['P'] >= 1))\n\n# If selects one or more P, then selects at least one O\nsolver.add(Implies(selection['P'] >= 1, selection['O'] >= 1))\n\n# If selects any O at all, then selects at least two O\nsolver.add(Implies(selection['O'] >= 1, selection['O'] >= 2))\n\n# OPTION CHECKING\n\n# We want to find minimum and maximum number of different species selected (species with count >= 1)\n\n# Helper function to count number of species selected\ndef count_species_selected(sel):\n    return Sum([If(sel[s] >= 1, 1, 0) for s in species])\n\n# Find minimum number of species selected\nmin_solver = Solver()\nmin_solver.add(solver.assertions())\nmin_species = Int('min_species')\nmin_solver.add(min_species == count_species_selected(selection))\nmin_solver.minimize(min_species) if hasattr(min_solver, 'minimize') else None\n\n# Since Z3's Python API may not support minimize directly, do binary search for min\n\n# Binary search for min species count\nlow = 1\nhigh = len(species)\nmin_value = None\nwhile low <= high:\n    mid = (low + high) // 2\n    solver.push()\n    solver.add(count_species_selected(selection) <= mid)\n    if solver.check() == sat:\n        min_value = mid\n        high = mid - 1\n    else:\n        low = mid + 1\n    solver.pop()\n\n# Find maximum number of species selected\nlow = 1\nhigh = len(species)\nmax_value = None\nwhile low <= high:\n    mid = (low + high) // 2\n    solver.push()\n    solver.add(count_species_selected(selection) >= mid)\n    if solver.check() == sat:\n        max_value = mid\n        low = mid + 1\n    else:\n        high = mid - 1\n    solver.pop()\n\n# Now check which option matches min_value and max_value\noptions = [\n    (1,4),\n    (1,5),\n    (1,6),\n    (2,5),\n    (2,6)\n]\n\nfor i, (mn, mx) in enumerate(options):\n    if mn == min_value and mx == max_value:\n        print(f\"'{chr(65+i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Charlie makes a soup by adding exactly six kinds of foods—kale, lentils, mushrooms, onions, tomatoes, and zucchini—to a broth, one food at a time. No food is added more than once. The order in which Charlie adds the foods to the broth must be consistent with the following: If the mushrooms are added third, then the lentils are added last. If the zucchini is added first, then the lentils are added at some time before the onions. Neither the tomatoes nor the kale is added fifth. The mushrooms are added at some time before the tomatoes or the kale, but not before both.\n\nWhich one of the following could be the order in which the foods are added to the broth?\n\nOptions:\n(A) kale, mushrooms, onions, lentils, tomatoes, zucchini\n(B) kale, zucchini, mushrooms, tomatoes, lentils, onions\n(C) lentils, mushrooms, zucchini, kale, onions, tomatoes\n(D) zucchini, lentils, kale, mushrooms, onions, tomatoes\n(E) zucchini, tomatoes, onions, mushrooms, lentils, kale",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfoods = ['kale', 'lentils', 'mushrooms', 'onions', 'tomatoes', 'zucchini']\nfood_indices = {food: i for i, food in enumerate(foods)}\n\n# Create Int variables representing the position (1 to 6) of each food in the order\npositions = {food: Int(food) for food in foods}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each position is between 1 and 6\nfor food in foods:\n    solver.add(And(positions[food] >= 1, positions[food] <= 6))\n\n# All positions are distinct (no food added more than once)\nsolver.add(Distinct([positions[food] for food in foods]))\n\n# Constraint 1:\n# If mushrooms are added third, then lentils are added last (position 6)\nmushrooms_third = positions['mushrooms'] == 3\nlentils_last = positions['lentils'] == 6\nsolver.add(Implies(mushrooms_third, lentils_last))\n\n# Constraint 2:\n# If zucchini is added first, then lentils are added before onions\nzucchini_first = positions['zucchini'] == 1\nlentils_before_onions = positions['lentils'] < positions['onions']\nsolver.add(Implies(zucchini_first, lentils_before_onions))\n\n# Constraint 3:\n# Neither tomatoes nor kale is added fifth\nsolver.add(positions['tomatoes'] != 5)\nsolver.add(positions['kale'] != 5)\n\n# Constraint 4:\n# Mushrooms are added at some time before tomatoes or kale, but not before both\n# This means mushrooms < tomatoes or mushrooms < kale is true,\n# but mushrooms < tomatoes and mushrooms < kale is false.\nmush_before_tomatoes = positions['mushrooms'] < positions['tomatoes']\nmush_before_kale = positions['mushrooms'] < positions['kale']\n\n# mushrooms before tomatoes or kale:\nor_condition = Or([mush_before_tomatoes, mush_before_kale])\n# mushrooms before tomatoes and kale:\nand_condition = And(mush_before_tomatoes, mush_before_kale)\nsolver.add(or_condition)\nsolver.add(Not(and_condition))\n\n# OPTION CHECKING\noptions = [\n    ['kale', 'mushrooms', 'onions', 'lentils', 'tomatoes', 'zucchini'],      # A\n    ['kale', 'zucchini', 'mushrooms', 'tomatoes', 'lentils', 'onions'],      # B\n    ['lentils', 'mushrooms', 'zucchini', 'kale', 'onions', 'tomatoes'],      # C\n    ['zucchini', 'lentils', 'kale', 'mushrooms', 'onions', 'tomatoes'],      # D\n    ['zucchini', 'tomatoes', 'onions', 'mushrooms', 'lentils', 'kale']       # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add constraints for this option: the position of each food is its index + 1\n    for pos, food in enumerate(option, start=1):\n        solver.add(positions[food] == pos)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "Charlie makes a soup by adding exactly six kinds of foods—kale, lentils, mushrooms, onions, tomatoes, and zucchini—to a broth, one food at a time. No food is added more than once. The order in which Charlie adds the foods to the broth must be consistent with the following: If the mushrooms are added third, then the lentils are added last. If the zucchini is added first, then the lentils are added at some time before the onions. Neither the tomatoes nor the kale is added fifth. The mushrooms are added at some time before the tomatoes or the kale, but not before both.\n\nWhich one of the following foods CANNOT be added first?\n\nOptions:\n(A) kale\n(B) lentils\n(C) mushrooms\n(D) onions\n(E) tomatoes",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfoods = ['kale', 'lentils', 'mushrooms', 'onions', 'tomatoes', 'zucchini']\nfood_indices = {food: i for i, food in enumerate(foods)}\n\n# Positions: each food gets an integer variable representing its position (1 to 6)\npos = {food: Int(food) for food in foods}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Positions are between 1 and 6\nfor food in foods:\n    solver.add(And(pos[food] >= 1, pos[food] <= 6))\n\n# All positions are distinct (no food added more than once)\nsolver.add(Distinct([pos[food] for food in foods]))\n\n# If mushrooms are added third, then lentils are last (6)\nsolver.add(Implies(pos['mushrooms'] == 3, pos['lentils'] == 6))\n\n# If zucchini is first, then lentils before onions\nsolver.add(Implies(pos['zucchini'] == 1, pos['lentils'] < pos['onions']))\n\n# Neither tomatoes nor kale is added fifth\nsolver.add(pos['tomatoes'] != 5)\nsolver.add(pos['kale'] != 5)\n\n# Mushrooms are added before tomatoes or kale, but not before both\n# That means: mushrooms < tomatoes XOR mushrooms < kale\nm_before_tomatoes = pos['mushrooms'] < pos['tomatoes']\nm_before_kale = pos['mushrooms'] < pos['kale']\n# XOR can be expressed as (A and not B) or (not A and B)\nsolver.add(Or(And(m_before_tomatoes, Not(m_before_kale)),\n              And(Not(m_before_tomatoes), m_before_kale)))\n\n# OPTION CHECKING\noptions = ['kale', 'lentils', 'mushrooms', 'onions', 'tomatoes']\n\nfor i, food in enumerate(options):\n    solver.push()\n    # Add constraint that this food is first\n    solver.add(pos[food] == 1)\n    if solver.check() == unsat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "Charlie makes a soup by adding exactly six kinds of foods—kale, lentils, mushrooms, onions, tomatoes, and zucchini—to a broth, one food at a time. No food is added more than once. The order in which Charlie adds the foods to the broth must be consistent with the following: If the mushrooms are added third, then the lentils are added last. If the zucchini is added first, then the lentils are added at some time before the onions. Neither the tomatoes nor the kale is added fifth. The mushrooms are added at some time before the tomatoes or the kale, but not before both.\n\nIf the lentils are added last, then which one of the following must be true?\n\nOptions:\n(A) At least one of the foods is added at some time before the zucchini.\n(B) At least two of the foods are added at some time before the kale.\n(C) The mushrooms are added third.\n(D) The zucchini is added third.\n(E) The tomatoes are added fourth.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfoods = ['kale', 'lentils', 'mushrooms', 'onions', 'tomatoes', 'zucchini']\nfood_indices = {food: i for i, food in enumerate(foods)}\n\n# Create integer variables representing the position (1 to 6) each food is added\npositions = {food: Int(food) for food in foods}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each position is between 1 and 6\nfor food in foods:\n    solver.add(And(positions[food] >= 1, positions[food] <= 6))\n\n# All positions are distinct (no food added more than once)\nsolver.add(Distinct([positions[food] for food in foods]))\n\n# If mushrooms are added third, then lentils are added last (position 6)\nmushrooms_third = positions['mushrooms'] == 3\nlentils_last = positions['lentils'] == 6\nsolver.add(Implies(mushrooms_third, lentils_last))\n\n# If zucchini is added first, then lentils are added before onions\nzucchini_first = positions['zucchini'] == 1\nlentils_before_onions = positions['lentils'] < positions['onions']\nsolver.add(Implies(zucchini_first, lentils_before_onions))\n\n# Neither tomatoes nor kale is added fifth (position 5)\nsolver.add(positions['tomatoes'] != 5)\nsolver.add(positions['kale'] != 5)\n\n# Mushrooms are added before tomatoes or kale, but not before both\n# This means: mushrooms < tomatoes XOR mushrooms < kale\nm_before_tomatoes = positions['mushrooms'] < positions['tomatoes']\nm_before_kale = positions['mushrooms'] < positions['kale']\n# XOR can be expressed as (A or B) and not (A and B)\nmushrooms_before_one_only = And(Or(m_before_tomatoes, m_before_kale), Not(And(m_before_tomatoes, m_before_kale)))\nsolver.add(mushrooms_before_one_only)\n\n# We want to check the condition \"If the lentils are added last\"\n# So we add that as a constraint for checking options:\nsolver.add(lentils_last)\n\n# OPTION CHECKING\n\n# We will check each option by adding the negation of the option's statement,\n# and see if the solver is unsat (meaning the option must be true).\n\n# Option A: At least one of the foods is added at some time before the zucchini.\n# This means: Exists food with position < position of zucchini\n# Negation: For all foods, position >= position of zucchini (no food added before zucchini)\ndef option_A_negation():\n    return And([positions[food] >= positions['zucchini'] for food in foods])\n\n# Option B: At least two of the foods are added at some time before the kale.\n# Negation: At most one food added before kale\n# Count how many foods have position < kale, must be <= 1\ndef option_B_negation():\n    before_kale = [If(positions[food] < positions['kale'], 1, 0) for food in foods]\n    return Sum(before_kale) <= 1\n\n# Option C: The mushrooms are added third.\n# Negation: mushrooms not third\ndef option_C_negation():\n    return positions['mushrooms'] != 3\n\n# Option D: The zucchini is added third.\n# Negation: zucchini not third\ndef option_D_negation():\n    return positions['zucchini'] != 3\n\n# Option E: The tomatoes are added fourth.\n# Negation: tomatoes not fourth\ndef option_E_negation():\n    return positions['tomatoes'] != 4\n\noptions_negations = [\n    option_A_negation,\n    option_B_negation,\n    option_C_negation,\n    option_D_negation,\n    option_E_negation,\n]\n\nfor i, neg_func in enumerate(options_negations):\n    solver.push()\n    solver.add(neg_func())\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Charlie makes a soup by adding exactly six kinds of foods—kale, lentils, mushrooms, onions, tomatoes, and zucchini—to a broth, one food at a time. No food is added more than once. The order in which Charlie adds the foods to the broth must be consistent with the following: If the mushrooms are added third, then the lentils are added last. If the zucchini is added first, then the lentils are added at some time before the onions. Neither the tomatoes nor the kale is added fifth. The mushrooms are added at some time before the tomatoes or the kale, but not before both.\n\nWhich one of the following could be an accurate partial ordering of the foods added to the broth?\n\nOptions:\n(A) lentils: second; mushrooms: third\n(B) mushrooms: fourth; lentils: last\n(C) onions: second; mushrooms: fifth\n(D) zucchini: first; lentils: last\n(E) zucchini: first; mushrooms: second",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nfoods = ['kale', 'lentils', 'mushrooms', 'onions', 'tomatoes', 'zucchini']\npositions = range(1, 7)  # positions 1 through 6\n\n# Create Int variables for each food representing the position it is added\npos = {food: Int(food) for food in foods}\n\nsolver = Solver()\n\n# Each food position is between 1 and 6\nfor food in foods:\n    solver.add(And(pos[food] >= 1, pos[food] <= 6))\n\n# All foods have distinct positions\nsolver.add(Distinct([pos[food] for food in foods]))\n\n# CONSTRAINTS\n\n# If mushrooms are added third, then lentils are added last (position 6)\nmushrooms_third = pos['mushrooms'] == 3\nlentils_last = pos['lentils'] == 6\nsolver.add(Implies(mushrooms_third, lentils_last))\n\n# If zucchini is added first, then lentils are added before onions\nzucchini_first = pos['zucchini'] == 1\nlentils_before_onions = pos['lentils'] < pos['onions']\nsolver.add(Implies(zucchini_first, lentils_before_onions))\n\n# Neither tomatoes nor kale is added fifth\nsolver.add(pos['tomatoes'] != 5)\nsolver.add(pos['kale'] != 5)\n\n# Mushrooms are added before tomatoes or kale, but not before both\n# This means: mushrooms is before tomatoes or mushrooms is before kale, but not both\n# So: (mushrooms < tomatoes or mushrooms < kale) and not (mushrooms < tomatoes and mushrooms < kale)\nm_before_tomatoes = pos['mushrooms'] < pos['tomatoes']\nm_before_kale = pos['mushrooms'] < pos['kale']\nsolver.add(Or(m_before_tomatoes, m_before_kale))\nsolver.add(Not(And(m_before_tomatoes, m_before_kale)))\n\n# OPTION CHECKING\n\noptions = [\n    {'lentils': 2, 'mushrooms': 3},  # A\n    {'mushrooms': 4, 'lentils': 6},  # B\n    {'onions': 2, 'mushrooms': 5},   # C\n    {'zucchini': 1, 'lentils': 6},   # D\n    {'zucchini': 1, 'mushrooms': 2}  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Add the partial ordering constraints for this option\n    for food, position in option.items():\n        solver.add(pos[food] == position)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A study sponsored by a consumer group tests exactly five of seven cold medications—F, G, H, I, K, L, and M—and ranks the medications tested from first (best) to fifth (worst). There are no ties. The following conditions must apply: L ranks second. Either F or G ranks first. I is tested. H ranks better than G if both are tested. K ranks better than F if both are tested. If M is tested, both F and H are also tested.\n\nWhich one of the following could be the five cold medications that the study ranks, listed from first to fifth?\n\nOptions:\n(A) F, I, L, H, G\n(B) F, L, G, H, M\n(C) F, L, I, G, M\n(D) F, L, I, H, M\n(E) F, L, K, I, G",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmedications_all = ['F', 'G', 'H', 'I', 'K', 'L', 'M']\nmed_indices = {m: i for i, m in enumerate(medications_all)}\n\n# We have 5 ranks: 1 (best) to 5 (worst)\nranks = range(1, 6)\n\n# Variables:\n# For each medication, an Int variable representing its rank if tested, or 0 if not tested\nrank_vars = {m: Int(m) for m in medications_all}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank from 1 to 5 is assigned to exactly one medication tested\n# Medications not tested have rank 0\n# So ranks assigned are in {0} U {1..5}\nfor m in medications_all:\n    solver.add(Or(rank_vars[m] == 0, And(rank_vars[m] >= 1, rank_vars[m] <= 5)))\n\n# Exactly five medications are tested (rank != 0)\ntested = [If(rank_vars[m] != 0, 1, 0) for m in medications_all]\nsolver.add(Sum(tested) == 5)\n\n# The ranks assigned to tested medications are distinct (no ties)\ntested_ranks = [rank_vars[m] for m in medications_all]\n# Only consider ranks > 0 for distinctness\ntested_ranks_nonzero = [rank_vars[m] for m in medications_all]\n# We will enforce that the ranks of tested meds are distinct ignoring zeros by:\n# Extract ranks > 0 and assert distinctness\n# Since Z3 Distinct does not ignore zeros, we enforce by:\n# For any two different meds both tested, their ranks differ\nfor i in range(len(medications_all)):\n    for j in range(i + 1, len(medications_all)):\n        m1 = medications_all[i]\n        m2 = medications_all[j]\n        cond = And(rank_vars[m1] != 0, rank_vars[m2] != 0)\n        solver.add(Implies(cond, rank_vars[m1] != rank_vars[m2]))\n\n# Condition: L ranks second\nsolver.add(rank_vars['L'] == 2)\n\n# Condition: Either F or G ranks first\ncond_F_first = rank_vars['F'] == 1\ncond_G_first = rank_vars['G'] == 1\nsolver.add(Or(cond_F_first, cond_G_first))\n\n# Condition: I is tested (rank != 0)\nsolver.add(rank_vars['I'] != 0)\n\n# Condition: H ranks better than G if both are tested\n# \"Ranks better\" means smaller rank number\ncond_H_and_G_tested = And(rank_vars['H'] != 0, rank_vars['G'] != 0)\nsolver.add(Implies(cond_H_and_G_tested, rank_vars['H'] < rank_vars['G']))\n\n# Condition: K ranks better than F if both are tested\ncond_K_and_F_tested = And(rank_vars['K'] != 0, rank_vars['F'] != 0)\nsolver.add(Implies(cond_K_and_F_tested, rank_vars['K'] < rank_vars['F']))\n\n# Condition: If M is tested, both F and H are also tested\ncond_M_tested = rank_vars['M'] != 0\ncond_F_tested = rank_vars['F'] != 0\ncond_H_tested = rank_vars['H'] != 0\nsolver.add(Implies(cond_M_tested, And(cond_F_tested, cond_H_tested)))\n\n# OPTION CHECKING\noptions = [\n    ['F', 'I', 'L', 'H', 'G'],  # A\n    ['F', 'L', 'G', 'H', 'M'],  # B\n    ['F', 'L', 'I', 'G', 'M'],  # C\n    ['F', 'L', 'I', 'H', 'M'],  # D\n    ['F', 'L', 'K', 'I', 'G'],  # E\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Assign ranks according to option: position in list is rank (1-based)\n    # First, all meds not in option are not tested (rank 0)\n    for m in medications_all:\n        if m in opt:\n            rank = opt.index(m) + 1\n            solver.add(rank_vars[m] == rank)\n        else:\n            solver.add(rank_vars[m] == 0)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "A study sponsored by a consumer group tests exactly five of seven cold medications—F, G, H, I, K, L, and M—and ranks the medications tested from first (best) to fifth (worst). There are no ties. The following conditions must apply: L ranks second. Either F or G ranks first. I is tested. H ranks better than G if both are tested. K ranks better than F if both are tested. If M is tested, both F and H are also tested.\n\nWhich one of the following could be true of the study?\n\nOptions:\n(A) G ranks better than M.\n(B) H ranks better than F.\n(C) I ranks better than F.\n(D) K ranks better than G.\n(E) M ranks better than G.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmedications = ['F', 'G', 'H', 'I', 'K', 'L', 'M']\nnum_medications = len(medications)\nnum_tested = 5\n\n# Create Int variables for ranks: rank[med] = rank of medication med (1..5 if tested, 0 if not tested)\nrank = {m: Int(m) for m in medications}\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each medication rank is between 0 and 5 (0 means not tested)\nfor m in medications:\n    solver.add(And(rank[m] >= 0, rank[m] <= num_tested))\n\n# Exactly five medications are tested (rank > 0)\ntested = [If(rank[m] > 0, 1, 0) for m in medications]\nsolver.add(Sum(tested) == num_tested)\n\n# All ranks of tested medications are distinct and between 1 and 5\ntested_meds = [m for m in medications]\n# Collect ranks of tested meds\ntested_ranks = [rank[m] for m in medications]\n# For ranks > 0, they must be distinct and between 1 and 5\n# Since non-tested meds have rank 0, we only check distinctness of ranks > 0\n# So, define a helper list of ranks > 0:\n# We will add constraint that ranks > 0 are distinct\n# We'll do this by filtering ranks > 0 and then Distinct on those\n\n# Create a list of ranks that are > 0\n# Z3 does not allow filtering lists easily, so we create a list of Bool indicating tested:\ntested_bools = [rank[m] > 0 for m in medications]\n\n# We can encode distinctness by:\n# For all pairs of meds, if both tested, their ranks differ\nfor i in range(num_medications):\n    for j in range(i+1, num_medications):\n        m1 = medications[i]\n        m2 = medications[j]\n        both_tested = And(rank[m1] > 0, rank[m2] > 0)\n        ranks_different = rank[m1] != rank[m2]\n        solver.add(Implies(both_tested, ranks_different))\n\n# L ranks second\nsolver.add(rank['L'] == 2)\n\n# Either F or G ranks first\nsolver.add(Or(rank['F'] == 1, rank['G'] == 1))\n\n# I is tested (rank > 0)\nsolver.add(rank['I'] > 0)\n\n# H ranks better than G if both tested\nboth_H_G_tested = And(rank['H'] > 0, rank['G'] > 0)\nH_better_than_G = rank['H'] < rank['G']\nsolver.add(Implies(both_H_G_tested, H_better_than_G))\n\n# K ranks better than F if both tested\nboth_K_F_tested = And(rank['K'] > 0, rank['F'] > 0)\nK_better_than_F = rank['K'] < rank['F']\nsolver.add(Implies(both_K_F_tested, K_better_than_F))\n\n# If M is tested, both F and H are also tested\nM_tested = rank['M'] > 0\nF_tested = rank['F'] > 0\nH_tested = rank['H'] > 0\nsolver.add(Implies(M_tested, And(F_tested, H_tested)))\n\n# OPTION CHECKING\n\n# Helper function to check if rank[m1] < rank[m2] (m1 ranks better than m2)\ndef ranks_better(m1, m2):\n    return And(rank[m1] > 0, rank[m2] > 0, rank[m1] < rank[m2])\n\noptions = [\n    # (A) G ranks better than M.\n    ranks_better('G', 'M'),\n    # (B) H ranks better than F.\n    ranks_better('H', 'F'),\n    # (C) I ranks better than F.\n    ranks_better('I', 'F'),\n    # (D) K ranks better than G.\n    ranks_better('K', 'G'),\n    # (E) M ranks better than G.\n    ranks_better('M', 'G'),\n]\n\nfor i, opt in enumerate(options):\n    solver.push()\n    solver.add(opt)\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "A study sponsored by a consumer group tests exactly five of seven cold medications—F, G, H, I, K, L, and M—and ranks the medications tested from first (best) to fifth (worst). There are no ties. The following conditions must apply: L ranks second. Either F or G ranks first. I is tested. H ranks better than G if both are tested. K ranks better than F if both are tested. If M is tested, both F and H are also tested.\n\nWhich one of the following cold medications must be among those tested in the study?\n\nOptions:\n(A) F\n(B) G\n(C) H\n(D) K\n(E) M",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmedications = ['F', 'G', 'H', 'I', 'K', 'L', 'M']\nnum_medications = len(medications)\ntested_count = 5\n\n# Create Int variables for ranks: 1 (best) to 5 (worst), or 0 if not tested\nrank = {m: Int(m) for m in medications}  # 0 means not tested, else 1..5\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# Each rank is either 0 (not tested) or between 1 and 5\nfor m in medications:\n    solver.add(Or(rank[m] == 0, And(rank[m] >= 1, rank[m] <= 5)))\n\n# Exactly 5 medications are tested (rank != 0)\ntested = [If(rank[m] != 0, 1, 0) for m in medications]\nsolver.add(Sum(tested) == 5)\n\n# No ties among tested medications: ranks of tested meds are distinct and non-zero\ntested_ranks = [rank[m] for m in medications]\n# Collect ranks of tested meds only\n# We can enforce that all ranks > 0 are distinct\n# Distinct among ranks that are > 0\n# We do this by adding: For all pairs (m1,m2), if both ranks > 0, ranks differ\nfor i in range(num_medications):\n    for j in range(i+1, num_medications):\n        m1 = medications[i]\n        m2 = medications[j]\n        cond = And(rank[m1] != 0, rank[m2] != 0)\n        solver.add(Implies(cond, rank[m1] != rank[m2]))\n\n# L ranks second\nsolver.add(rank['L'] == 2)\n\n# Either F or G ranks first (and is tested)\nsolver.add(Or(rank['F'] == 1, rank['G'] == 1))\n\n# I is tested (rank[I] != 0)\nsolver.add(rank['I'] != 0)\n\n# H ranks better than G if both are tested\n# That means if rank[H]!=0 and rank[G]!=0 then rank[H] < rank[G]\nsolver.add(Implies(And(rank['H'] != 0, rank['G'] != 0), rank['H'] < rank['G']))\n\n# K ranks better than F if both are tested\nsolver.add(Implies(And(rank['K'] != 0, rank['F'] != 0), rank['K'] < rank['F']))\n\n# If M is tested, both F and H are also tested\nsolver.add(Implies(rank['M'] != 0, And(rank['F'] != 0, rank['H'] != 0)))\n\n# OPTION CHECKING\n\noptions = ['F', 'G', 'H', 'K', 'M']\n\nfor i, opt in enumerate(options):\n    solver.push()\n    # Add constraint that opt is NOT tested (rank == 0)\n    solver.add(rank[opt] == 0)\n    if solver.check() == sat:\n        # Option can be not tested, so opt is not necessarily tested\n        solver.pop()\n    else:\n        # If solver is unsat when opt is not tested, opt must be tested\n        print(f\"'{chr(65+i)}'\")\n        break\n    # No need to pop if break, but good practice\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "A study sponsored by a consumer group tests exactly five of seven cold medications—F, G, H, I, K, L, and M—and ranks the medications tested from first (best) to fifth (worst). There are no ties. The following conditions must apply: L ranks second. Either F or G ranks first. I is tested. H ranks better than G if both are tested. K ranks better than F if both are tested. If M is tested, both F and H are also tested.\n\nIf I ranks third, each of the following could also be true of the study EXCEPT:\n\nOptions:\n(A) M ranks better than H.\n(B) K ranks better than G.\n(C) I ranks better than F.\n(D) H ranks better than M.\n(E) G ranks better than K.",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\nmedications = ['F', 'G', 'H', 'I', 'K', 'L', 'M']\ntested_count = 5\n\n# Create Int variables for rank positions (1 to 5) or 0 if not tested\nrank = {m: Int(m) for m in medications}\n\nsolver = Solver()\n\n# Constraints: ranks are 0 (not tested) or 1..5 (tested)\nfor m in medications:\n    solver.add(Or(rank[m] == 0, And(rank[m] >= 1, rank[m] <= tested_count)))\n\n# Exactly 5 medications are tested (rank != 0)\ntested = [If(rank[m] != 0, 1, 0) for m in medications]\nsolver.add(Sum(tested) == tested_count)\n\n# L ranks second\nsolver.add(rank['L'] == 2)\n\n# Either F or G ranks first\nf_first = rank['F'] == 1\ng_first = rank['G'] == 1\nsolver.add(Or(f_first, g_first))\n\n# I is tested (rank != 0)\nsolver.add(rank['I'] != 0)\n\n# H ranks better than G if both are tested\nh_and_g_tested = And(rank['H'] != 0, rank['G'] != 0)\nh_better_than_g = rank['H'] < rank['G']\nsolver.add(Implies(h_and_g_tested, h_better_than_g))\n\n# K ranks better than F if both are tested\nk_and_f_tested = And(rank['K'] != 0, rank['F'] != 0)\nk_better_than_f = rank['K'] < rank['F']\nsolver.add(Implies(k_and_f_tested, k_better_than_f))\n\n# If M is tested, both F and H are also tested\nm_tested = rank['M'] != 0\nf_and_h_tested = And(rank['F'] != 0, rank['H'] != 0)\nsolver.add(Implies(m_tested, f_and_h_tested))\n\n# Additional given: I ranks third\nsolver.add(rank['I'] == 3)\n\n# OPTION CHECKING\n# Each option is a constraint; we check if it can be true with the above constraints\n# If option cannot be true, it is the EXCEPT answer\n\n# Helper function to check if a condition can be satisfied\ndef can_be_true(condition):\n    solver.push()\n    solver.add(condition)\n    result = solver.check()\n    solver.pop()\n    return result == sat\n\n# (A) M ranks better than H: M < H (both tested)\na_cond = And(rank['M'] != 0, rank['H'] != 0, rank['M'] < rank['H'])\n\n# (B) K ranks better than G: K < G (both tested)\nb_cond = And(rank['K'] != 0, rank['G'] != 0, rank['K'] < rank['G'])\n\n# (C) I ranks better than F: I < F (both tested)\nc_cond = And(rank['I'] != 0, rank['F'] != 0, rank['I'] < rank['F'])\n\n# (D) H ranks better than M: H < M (both tested)\nd_cond = And(rank['H'] != 0, rank['M'] != 0, rank['H'] < rank['M'])\n\n# (E) G ranks better than K: G < K (both tested)\ne_cond = And(rank['G'] != 0, rank['K'] != 0, rank['G'] < rank['K'])\n\noptions = [a_cond, b_cond, c_cond, d_cond, e_cond]\n\nfor i, cond in enumerate(options):\n    if not can_be_true(cond):\n        print(f\"'{chr(65 + i)}'\")\n        break",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.\n\nIf exactly three cities are each connected with Philadelphia, then which one of the following could be a pair of connected cities?\n\nOptions:\n(A) Honolulu and Montreal\n(B) Honolulu and Vancouver\n(C) Montreal and Toronto\n(D) Montreal and Vancouver\n(E) Philadelphia and Vancouver",
    "final_answer": "'B'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncities = ['Honolulu', 'Montreal', 'Philadelphia', 'Toronto', 'Vancouver']\ncity_indices = {c: i for i, c in enumerate(cities)}\n\n# Create variables for connections: connected[i][j] = 1 if city i connected to city j, else 0\n# Since connections are bidirectional, connected[i][j] == connected[j][i]\nconnected = [[Bool(f'conn_{i}_{j}') for j in range(len(cities))] for i in range(len(cities))]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# No city connected to itself\nfor i in range(len(cities)):\n    solver.add(connected[i][i] == False)\n\n# Connections are symmetric: connected[i][j] == connected[j][i]\nfor i in range(len(cities)):\n    for j in range(i+1, len(cities)):\n        solver.add(connected[i][j] == connected[j][i])\n\n# Each city connected to at least one other city\nfor i in range(len(cities)):\n    connections = [connected[i][j] for j in range(len(cities)) if j != i]\n    solver.add(Or(connections))\n\n# Montreal is connected with exactly one other city\nmontreal_idx = city_indices['Montreal']\nmontreal_connections = [connected[montreal_idx][j] for j in range(len(cities)) if j != montreal_idx]\nsolver.add(Sum([If(c, 1, 0) for c in montreal_connections]) == 1)\n\n# Honolulu is not connected with Toronto\nhonolulu_idx = city_indices['Honolulu']\ntoronto_idx = city_indices['Toronto']\nsolver.add(connected[honolulu_idx][toronto_idx] == False)\n\n# Any city connected with Honolulu is also connected with Toronto\nfor c in range(len(cities)):\n    if c != honolulu_idx and c != toronto_idx:\n        # If connected[c][Honolulu] then connected[c][Toronto]\n        solver.add(Implies(connected[c][honolulu_idx], connected[c][toronto_idx]))\n\n# If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver\nphiladelphia_idx = city_indices['Philadelphia']\nvancouver_idx = city_indices['Vancouver']\nsolver.add(Implies(connected[philadelphia_idx][toronto_idx], Not(connected[philadelphia_idx][vancouver_idx])))\n\n# Exactly three cities are each connected with Philadelphia\nphiladelphia_connections = [connected[philadelphia_idx][j] for j in range(len(cities)) if j != philadelphia_idx]\nsolver.add(Sum([If(c, 1, 0) for c in philadelphia_connections]) == 3)\n\n# OPTION CHECKING\noptions = [\n    (honolulu_idx, montreal_idx),    # A\n    (honolulu_idx, vancouver_idx),   # B\n    (montreal_idx, toronto_idx),     # C\n    (montreal_idx, vancouver_idx),   # D\n    (philadelphia_idx, vancouver_idx) # E\n]\n\nfor i, (c1, c2) in enumerate(options):\n    solver.push()\n    # Add that this pair is connected\n    solver.add(connected[c1][c2] == True)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'B'"
    }
  },
  {
    "question": "Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.\n\nWhich one of the following is a pair of cities that CANNOT be connected?\n\nOptions:\n(A) Honolulu and Montreal\n(B) Honolulu and Philadelphia\n(C) Montreal and Philadelphia\n(D) Montreal and Vancouver\n(E) Philadelphia and Toronto",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncities = ['Honolulu', 'Montreal', 'Philadelphia', 'Toronto', 'Vancouver']\nnum_cities = len(cities)\n\n# Create a dictionary for city indices for convenience\ncity_index = {city: i for i, city in enumerate(cities)}\n\n# Create variables for connections: connection[i][j] = 1 if city i connected to city j, else 0\n# Since flights are between two different cities, no self connections\nconnection = [[Bool(f'conn_{i}_{j}') for j in range(num_cities)] for i in range(num_cities)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. Connections are symmetric: if i connected to j then j connected to i\nfor i in range(num_cities):\n    for j in range(num_cities):\n        if i != j:\n            solver.add(connection[i][j] == connection[j][i])\n        else:\n            # no self connections\n            solver.add(connection[i][j] == False)\n\n# 2. Each city connected with at least one other city\nfor i in range(num_cities):\n    connected_cities = [connection[i][j] for j in range(num_cities) if j != i]\n    solver.add(Or(connected_cities))\n\n# 3. Montreal is connected with exactly one other city\nmontreal_idx = city_index['Montreal']\nmontreal_connections = [connection[montreal_idx][j] for j in range(num_cities) if j != montreal_idx]\n# Sum of True connections == 1\nsolver.add(Sum([If(c, 1, 0) for c in montreal_connections]) == 1)\n\n# 4. Honolulu is not connected with Toronto\nhonolulu_idx = city_index['Honolulu']\ntoronto_idx = city_index['Toronto']\nsolver.add(connection[honolulu_idx][toronto_idx] == False)\n\n# 5. Any city that is connected with Honolulu is also connected with Toronto\nfor city in range(num_cities):\n    if city != honolulu_idx and city != toronto_idx:\n        # If city connected to Honolulu then city connected to Toronto\n        solver.add(Implies(connection[city][honolulu_idx], connection[city][toronto_idx]))\n\n# 6. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver\nphiladelphia_idx = city_index['Philadelphia']\nvancouver_idx = city_index['Vancouver']\nsolver.add(Implies(connection[philadelphia_idx][toronto_idx], Not(connection[philadelphia_idx][vancouver_idx])))\n\n# OPTION CHECKING\noptions = [\n    ('A', honolulu_idx, montreal_idx),\n    ('B', honolulu_idx, philadelphia_idx),\n    ('C', montreal_idx, philadelphia_idx),\n    ('D', montreal_idx, vancouver_idx),\n    ('E', philadelphia_idx, toronto_idx),\n]\n\nfor letter, c1, c2 in options:\n    solver.push()\n    # Add constraint that these two cities ARE connected\n    solver.add(connection[c1][c2] == True)\n    # Check if model is still satisfiable\n    if solver.check() == unsat:\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.\n\nWhich one of the following could be true?\n\nOptions:\n(A) Montreal and Philadelphia are connected with each other, but neither is connected with any other city.\n(B) Montreal and Toronto are connected with each other, but neither is connected with any other city.\n(C) Philadelphia and Toronto are connected with each other, but neither is connected with any other city.\n(D) Philadelphia and Vancouver are connected with each other, but neither is connected with any other city.\n(E) Toronto and Vancouver are connected with each other, but neither is connected with any other city.",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncities = ['Honolulu', 'Montreal', 'Philadelphia', 'Toronto', 'Vancouver']\nn = len(cities)\n\n# Create a matrix of Bool variables: connected[i][j] means city i connected with city j\nconnected = [[Bool(f'conn_{i}_{j}') for j in range(n)] for i in range(n)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1. No city connected to itself\nfor i in range(n):\n    solver.add(connected[i][i] == False)\n\n# 2. Connections are symmetric: if i connected to j, then j connected to i\nfor i in range(n):\n    for j in range(i+1, n):\n        solver.add(connected[i][j] == connected[j][i])\n\n# 3. Each city is connected with at least one other city\nfor i in range(n):\n    solver.add(Or([connected[i][j] for j in range(n) if j != i]))\n\n# 4. Montreal is connected with exactly one other city\nmontreal_idx = cities.index('Montreal')\nmontreal_connections = [connected[montreal_idx][j] for j in range(n) if j != montreal_idx]\nsolver.add(Sum([If(c, 1, 0) for c in montreal_connections]) == 1)\n\n# 5. Honolulu is not connected with Toronto\nhonolulu_idx = cities.index('Honolulu')\ntoronto_idx = cities.index('Toronto')\nsolver.add(connected[honolulu_idx][toronto_idx] == False)\n\n# 6. Any city connected with Honolulu is also connected with Toronto\nfor city_idx in range(n):\n    if city_idx != honolulu_idx:\n        # connected[city][Honolulu] => connected[city][Toronto]\n        solver.add(Implies(connected[city_idx][honolulu_idx], connected[city_idx][toronto_idx]))\n\n# 7. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver\nphiladelphia_idx = cities.index('Philadelphia')\nvancouver_idx = cities.index('Vancouver')\nsolver.add(Implies(connected[philadelphia_idx][toronto_idx], Not(connected[philadelphia_idx][vancouver_idx])))\n\n# OPTION CHECKING\n\noptions = [\n    # (A) Montreal and Philadelphia are connected with each other, but neither is connected with any other city.\n    # Montreal connected only to Philadelphia; Philadelphia connected only to Montreal\n    lambda: And(\n        connected[montreal_idx][philadelphia_idx],\n        Sum([If(connected[montreal_idx][j], 1, 0) for j in range(n) if j != montreal_idx]) == 1,\n        Sum([If(connected[philadelphia_idx][j], 1, 0) for j in range(n) if j != philadelphia_idx]) == 1,\n        connected[philadelphia_idx][montreal_idx]\n    ),\n\n    # (B) Montreal and Toronto are connected with each other, but neither is connected with any other city.\n    lambda: And(\n        connected[montreal_idx][toronto_idx],\n        Sum([If(connected[montreal_idx][j], 1, 0) for j in range(n) if j != montreal_idx]) == 1,\n        Sum([If(connected[toronto_idx][j], 1, 0) for j in range(n) if j != toronto_idx]) == 1,\n        connected[toronto_idx][montreal_idx]\n    ),\n\n    # (C) Philadelphia and Toronto are connected with each other, but neither is connected with any other city.\n    lambda: And(\n        connected[philadelphia_idx][toronto_idx],\n        Sum([If(connected[philadelphia_idx][j], 1, 0) for j in range(n) if j != philadelphia_idx]) == 1,\n        Sum([If(connected[toronto_idx][j], 1, 0) for j in range(n) if j != toronto_idx]) == 1,\n        connected[toronto_idx][philadelphia_idx]\n    ),\n\n    # (D) Philadelphia and Vancouver are connected with each other, but neither is connected with any other city.\n    lambda: And(\n        connected[philadelphia_idx][vancouver_idx],\n        Sum([If(connected[philadelphia_idx][j], 1, 0) for j in range(n) if j != philadelphia_idx]) == 1,\n        Sum([If(connected[vancouver_idx][j], 1, 0) for j in range(n) if j != vancouver_idx]) == 1,\n        connected[vancouver_idx][philadelphia_idx]\n    ),\n\n    # (E) Toronto and Vancouver are connected with each other, but neither is connected with any other city.\n    lambda: And(\n        connected[toronto_idx][vancouver_idx],\n        Sum([If(connected[toronto_idx][j], 1, 0) for j in range(n) if j != toronto_idx]) == 1,\n        Sum([If(connected[vancouver_idx][j], 1, 0) for j in range(n) if j != vancouver_idx]) == 1,\n        connected[vancouver_idx][toronto_idx]\n    ),\n]\n\nfor i, option_constraint in enumerate(options):\n    solver.push()\n    solver.add(option_constraint())\n    if solver.check() == sat:\n        print(f\"'{chr(65 + i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  },
  {
    "question": "Each nonstop flight offered by Zephyr Airlines departs from one and arrives at another of five cities: Honolulu, Montreal, Philadelphia, Toronto, and Vancouver. Any two cities are said to be connected with each other if Zephyr offers nonstop flights between them. Each city is connected with at least one other city. The following conditions govern Zephyr's nonstop flights: Montreal is connected with exactly one other city. Honolulu is not connected with Toronto. Any city that is connected with Honolulu is also connected with Toronto. If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver.\n\nIf four of the cities are each connected with the remaining city, then the cities in which one of the following pairs must be connected with each other?\n\nOptions:\n(A) Honolulu and Montreal\n(B) Honolulu and Philadelphia\n(C) Honolulu and Vancouver\n(D) Montreal and Philadelphia\n(E) Montreal and Toronto",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\ncities = ['Honolulu', 'Montreal', 'Philadelphia', 'Toronto', 'Vancouver']\nn = len(cities)\n\n# Create a matrix of Bool variables: connected[i][j] = True if city i connected to city j\n# Since connections are between two different cities, and presumably undirected,\n# we model only upper triangle and mirror it.\nconnected = [[Bool(f\"conn_{i}_{j}\") if i < j else None for j in range(n)] for i in range(n)]\n\nsolver = Solver()\n\n# CONSTRAINTS\n\n# 1) Connections are symmetric: if i connected to j then j connected to i\nfor i in range(n):\n    for j in range(i+1, n):\n        # connected[i][j] == connected[j][i], but we only have one variable per pair\n        # so we only use connected[i][j] to represent connection between i and j\n        # no separate variable for connected[j][i]\n        pass  # symmetry implicit in model\n\n# 2) Each city connected with at least one other city\nfor i in range(n):\n    connected_vars = []\n    for j in range(n):\n        if i < j:\n            connected_vars.append(connected[i][j])\n        elif j < i:\n            connected_vars.append(connected[j][i])\n    solver.add(Or(connected_vars))\n\n# 3) Montreal is connected with exactly one other city\nmontreal_idx = cities.index('Montreal')\nmontreal_connections = []\nfor j in range(n):\n    if montreal_idx < j:\n        montreal_connections.append(connected[montreal_idx][j])\n    elif j < montreal_idx:\n        montreal_connections.append(connected[j][montreal_idx])\nsolver.add(PbEq([(c, 1) for c in montreal_connections], 1))  # exactly one connection\n\n# 4) Honolulu is not connected with Toronto\nhonolulu_idx = cities.index('Honolulu')\ntoronto_idx = cities.index('Toronto')\nif honolulu_idx < toronto_idx:\n    solver.add(Not(connected[honolulu_idx][toronto_idx]))\nelse:\n    solver.add(Not(connected[toronto_idx][honolulu_idx]))\n\n# 5) Any city connected with Honolulu is also connected with Toronto\nfor c in range(n):\n    if c == honolulu_idx or c == toronto_idx:\n        continue\n    # if city c connected with Honolulu then c connected with Toronto\n    # connected with Honolulu\n    if honolulu_idx < c:\n        honolulu_conn = connected[honolulu_idx][c]\n    else:\n        honolulu_conn = connected[c][honolulu_idx]\n    # connected with Toronto\n    if toronto_idx < c:\n        toronto_conn = connected[toronto_idx][c]\n    else:\n        toronto_conn = connected[c][toronto_idx]\n    solver.add(Implies(honolulu_conn, toronto_conn))\n\n# 6) If Philadelphia is connected with Toronto, then Philadelphia is not connected with Vancouver\nphiladelphia_idx = cities.index('Philadelphia')\nvancouver_idx = cities.index('Vancouver')\n# connected Philadelphia - Toronto\nif philadelphia_idx < toronto_idx:\n    phil_tor_conn = connected[philadelphia_idx][toronto_idx]\nelse:\n    phil_tor_conn = connected[toronto_idx][philadelphia_idx]\n# connected Philadelphia - Vancouver\nif philadelphia_idx < vancouver_idx:\n    phil_van_conn = connected[philadelphia_idx][vancouver_idx]\nelse:\n    phil_van_conn = connected[vancouver_idx][philadelphia_idx]\nsolver.add(Implies(phil_tor_conn, Not(phil_van_conn)))\n\n# 7) Four of the cities are each connected with the remaining city\n# This means there exists a city connected to all other 4 cities\n# So there is a city i such that connected[i][j] is True for all j != i\nfour_connected_city_found = False\nfour_connected_city = Int('four_connected_city')\nsolver.add(And(four_connected_city >= 0, four_connected_city < n))\nfor i in range(n):\n    # If four_connected_city == i then city i connected to all others\n    connections = []\n    for j in range(n):\n        if i == j:\n            continue\n        if i < j:\n            conn = connected[i][j]\n        else:\n            conn = connected[j][i]\n        connections.append(conn)\n    # all connections True\n    all_conn = And(connections)\n    solver.add(Implies(four_connected_city == i, all_conn))\n# Also ensure that such city exists by forcing that for some city i, the connections are all True\nsolver.add(Or([four_connected_city == i for i in range(n)]))\n\n# OPTION CHECKING\noptions = {\n    'A': ('Honolulu', 'Montreal'),\n    'B': ('Honolulu', 'Philadelphia'),\n    'C': ('Honolulu', 'Vancouver'),\n    'D': ('Montreal', 'Philadelphia'),\n    'E': ('Montreal', 'Toronto'),\n}\n\nfor letter, (c1, c2) in options.items():\n    solver.push()\n    idx1 = cities.index(c1)\n    idx2 = cities.index(c2)\n    if idx1 < idx2:\n        conn_var = connected[idx1][idx2]\n    else:\n        conn_var = connected[idx2][idx1]\n    # Add constraint that c1 and c2 are NOT connected, to check if possible\n    solver.add(Not(conn_var))\n    if solver.check() == unsat:\n        # Not connected leads to unsat, so they must be connected\n        print(f\"'{letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.\n\nWhich one of the following is an acceptable selection of animals for the study?\n\nOptions:\n(A) F, G, K, N, T, V\n(B) F, H, K, N, V, Z\n(C) G, H, K, L, V, Z\n(D) G, H, K, N, V, Z\n(E) G, H, L, N, V, Z",
    "final_answer": "'D'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Animals\nanimals = ['F', 'G', 'H', 'K', 'L', 'N', 'T', 'V', 'Z']\n\n# Create Bool variables for each animal: True if selected, False otherwise\nselected = {a: Bool(a) for a in animals}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly six animals are selected\nsolver.add(Sum([If(selected[a], 1, 0) for a in animals]) == 6)\n\n# F and H are not both selected: not (F and H)\nsolver.add(Not(And(selected['F'], selected['H'])))\n\n# N and T are not both selected: not (N and T)\nsolver.add(Not(And(selected['N'], selected['T'])))\n\n# If H is selected, K is also selected: H => K\nsolver.add(Implies(selected['H'], selected['K']))\n\n# If K is selected, N is also selected: K => N\nsolver.add(Implies(selected['K'], selected['N']))\n\n# OPTION CHECKING\noptions = [\n    ['F', 'G', 'K', 'N', 'T', 'V'],  # A\n    ['F', 'H', 'K', 'N', 'V', 'Z'],  # B\n    ['G', 'H', 'K', 'L', 'V', 'Z'],  # C\n    ['G', 'H', 'K', 'N', 'V', 'Z'],  # D\n    ['G', 'H', 'L', 'N', 'V', 'Z'],  # E\n]\n\nfor i, option in enumerate(options):\n    solver.push()\n    # Set selected animals to True\n    for a in animals:\n        if a in option:\n            solver.add(selected[a] == True)\n        else:\n            solver.add(selected[a] == False)\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'D'"
    }
  },
  {
    "question": "For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.\n\nIf H and L are among the animals selected, which one of the following could be true?\n\nOptions:\n(A) F is selected.\n(B) T is selected.\n(C) Z is selected.\n(D) Exactly one panda is selected.\n(E) Exactly two pandas are selected.",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Animals categorized by species\nmonkeys = ['F', 'G', 'H']\npandas = ['K', 'L', 'N']\nraccoons = ['T', 'V', 'Z']\nall_animals = monkeys + pandas + raccoons\n\n# Create a Bool variable for each animal indicating whether it is selected\nselected = {a: Bool(a) for a in all_animals}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly six animals are selected\nsolver.add(Sum([If(selected[a], 1, 0) for a in all_animals]) == 6)\n\n# F and H are not both selected\nsolver.add(Not(And(selected['F'], selected['H'])))\n\n# N and T are not both selected\nsolver.add(Not(And(selected['N'], selected['T'])))\n\n# If H is selected, then K is selected\nsolver.add(Implies(selected['H'], selected['K']))\n\n# If K is selected, then N is selected\nsolver.add(Implies(selected['K'], selected['N']))\n\n# Given: H and L are selected\nsolver.add(selected['H'])\nsolver.add(selected['L'])\n\n# OPTION CHECKING\noptions = ['F', 'T', 'Z', 'D', 'E']\n\nfor i, option in enumerate(options):\n    solver.push()\n    if option == 'F':\n        # (A) F is selected\n        solver.add(selected['F'])\n    elif option == 'T':\n        # (B) T is selected\n        solver.add(selected['T'])\n    elif option == 'Z':\n        # (C) Z is selected\n        solver.add(selected['Z'])\n    elif option == 'D':\n        # (D) Exactly one panda is selected\n        # Count pandas selected\n        panda_selected_count = Sum([If(selected[p], 1, 0) for p in pandas])\n        solver.add(panda_selected_count == 1)\n    elif option == 'E':\n        # (E) Exactly two pandas are selected\n        panda_selected_count = Sum([If(selected[p], 1, 0) for p in pandas])\n        solver.add(panda_selected_count == 2)\n    else:\n        solver.pop()\n        continue\n\n    if solver.check() == sat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.\n\nEach of the following is a pair of animals that could be selected together EXCEPT\n\nOptions:\n(A) F and G\n(B) H and K\n(C) K and T\n(D) L and N\n(E) T and V",
    "final_answer": "'C'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Animals\nanimals = ['F', 'G', 'H', 'K', 'L', 'N', 'T', 'V', 'Z']\n\n# Create selection variables: 1 if selected, 0 if not\nselection = {a: Int(a) for a in animals}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Each selection variable is 0 or 1\nfor a in animals:\n    solver.add(Or(selection[a] == 0, selection[a] == 1))\n\n# Exactly six animals selected\nsolver.add(Sum([selection[a] for a in animals]) == 6)\n\n# F and H are not both selected\nsolver.add(Not(And(selection['F'] == 1, selection['H'] == 1)))\n\n# N and T are not both selected\nsolver.add(Not(And(selection['N'] == 1, selection['T'] == 1)))\n\n# If H is selected, K is also selected: H => K\nsolver.add(Implies(selection['H'] == 1, selection['K'] == 1))\n\n# If K is selected, N is also selected: K => N\nsolver.add(Implies(selection['K'] == 1, selection['N'] == 1))\n\n# OPTION CHECKING\n# Each option is a pair of animals that could be selected together EXCEPT one\noptions = [\n    ('F', 'G'),  # A\n    ('H', 'K'),  # B\n    ('K', 'T'),  # C\n    ('L', 'N'),  # D\n    ('T', 'V'),  # E\n]\n\nfor i, (a1, a2) in enumerate(options):\n    solver.push()\n    # Add constraint that both animals are selected\n    solver.add(selection[a1] == 1)\n    solver.add(selection[a2] == 1)\n    # Check if the model is satisfiable with these two animals selected\n    if solver.check() == unsat:\n        print(f\"'{chr(65+i)}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'C'"
    }
  },
  {
    "question": "For a behavioral study, a researcher will select exactly six individual animals from among three monkeys—F, G, and H—three pandas—K, L, and N—and three raccoons—T, V, and Z. The selection of animals for the study must meet the following conditions: F and H are not both selected. N and T are not both selected. If H is selected, K is also selected. If K is selected, N is also selected.\n\nIf T is selected, which one of the following is a pair of animals that must be among the animals selected?\n\nOptions:\n(A) F and G\n(B) G and H\n(C) K and L\n(D) K and Z\n(E) L and N",
    "final_answer": "'A'",
    "rationale": "from z3 import *\n\n# DECLARATIONS\n# Animals\nmonkeys = ['F', 'G', 'H']\npandas = ['K', 'L', 'N']\nraccoons = ['T', 'V', 'Z']\nanimals = monkeys + pandas + raccoons\n\n# Create boolean variables for each animal indicating selection (True if selected)\nselection = {a: Bool(a) for a in animals}\n\n# CONSTRAINTS\nsolver = Solver()\n\n# Exactly six animals are selected\nsolver.add(Sum([If(selection[a], 1, 0) for a in animals]) == 6)\n\n# F and H are not both selected\nsolver.add(Not(And(selection['F'], selection['H'])))\n\n# N and T are not both selected\nsolver.add(Not(And(selection['N'], selection['T'])))\n\n# If H is selected, K is also selected\nsolver.add(Implies(selection['H'], selection['K']))\n\n# If K is selected, N is also selected\nsolver.add(Implies(selection['K'], selection['N']))\n\n# OPTION CHECKING\n# Given T is selected, check which pair must be selected\nsolver.add(selection['T'])\n\noptions = {\n    'A': ['F', 'G'],\n    'B': ['G', 'H'],\n    'C': ['K', 'L'],\n    'D': ['K', 'Z'],\n    'E': ['L', 'N']\n}\n\nfor opt_letter, pair in options.items():\n    solver.push()\n    # Negate that both animals in the pair are selected to test necessity\n    solver.add(Or(Not(selection[pair[0]]), Not(selection[pair[1]])))\n    if solver.check() == unsat:\n        print(f\"'{opt_letter}'\")\n        solver.pop()\n        break\n    solver.pop()",
    "metadata": {
      "license": "MIT",
      "source": "https://github.com/zhongwanjun/AR-LSAT",
      "domain": "Loong_Logic",
      "required_dependencies": [
        "z3-solver==4.12.2"
      ],
      "name": "Analytical Reasoning of Law School Admission Test (AR-LSAT)",
      "contributor": [
        "Xianglong Hu",
        "Yuan He"
      ],
      "date_created": "2025-05-11",
      "execution_result": "'A'"
    }
  }
]